import Combine
import CoreData
import CoreFoundation
import CoreGraphics
import CoreTransferable
import DeveloperToolsSupport
import Foundation
import OSLog
import Observation
import Spatial
import SwiftUICore
import Symbols
import TargetConditionals
import UIKit
import UniformTypeIdentifiers
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
import os
import os.log

/// Designates an accessibility action category that is provided and named
/// by the system.
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct AccessibilityActionCategory : Equatable, Sendable {

    /// An accessibility action category for the default actions of a view.
    /// This category replaces the system provided actions rotor
    /// for accessibility technologies like VoiceOver.
    public static let `default`: AccessibilityActionCategory

    /// An accessibility action category for associating actions related to
    /// editing text. This category replaces the system provided Edit actions
    /// for accessibility technologies like VoiceOver.
    public static let edit: AccessibilityActionCategory

    /// Creates a custom action category labeled by `name`.
    ///
    ///    extension AccessibilityActionCategory {
    ///        static let table = AccessibilityActionCategory("Table Options")
    ///    }
    ///
    ///    var body: some View {
    ///        TableCellView()
    ///             .accessibilityActions(category: .table) {
    ///                 ForEach(tableCellActions) { action in
    ///                     Button(action.title) {
    ///                         action()
    ///                     }
    ///                 }
    ///             }
    ///    }
    ///
    /// - Parameter:
    ///   - name: The name for the category of the accessibility actions.
    public init(_ name: Text)

    /// Creates a custom action category labeled by `nameKey`.
    ///
    ///    extension AccessibilityActionCategory {
    ///        static let table = AccessibilityActionCategory("Table Options")
    ///    }
    ///
    ///    var body: some View {
    ///        TableCellView()
    ///             .accessibilityActions(category: .table) {
    ///                 ForEach(tableCellActions) { action in
    ///                     Button(action.title) {
    ///                         action()
    ///                     }
    ///                 }
    ///             }
    ///    }
    ///
    /// - Parameter:
    ///   - nameKey: The name for the category of the accessibility actions.
    public init(_ nameKey: LocalizedStringKey)

    /// Creates a custom action category labeled by `name`.
    ///
    ///    extension AccessibilityActionCategory {
    ///        static let table = AccessibilityActionCategory("Table Options")
    ///    }
    ///
    ///    var body: some View {
    ///        TableCellView()
    ///             .accessibilityActions(category: .table) {
    ///                 ForEach(tableCellActions) { action in
    ///                     Button(action.title) {
    ///                         action()
    ///                     }
    ///                 }
    ///             }
    ///    }
    ///
    /// - Parameter:
    ///   - name: The name for the category of the accessibility actions.
    public init(_ name: some StringProtocol)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: AccessibilityActionCategory, b: AccessibilityActionCategory) -> Bool
}

/// The structure that defines the kinds of available accessibility actions.
///
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public struct AccessibilityActionKind : Equatable, Sendable {

    /// The value that represents the default accessibility action.
    public static let `default`: AccessibilityActionKind

    /// The value that represents an accessibility action that dismisses a
    /// modal view or cancels an operation.
    public static let escape: AccessibilityActionKind

    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    @available(macOS, unavailable)
    public static let magicTap: AccessibilityActionKind

    public init(named name: Text)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: AccessibilityActionKind, b: AccessibilityActionKind) -> Bool
}

/// A directional indicator you use when making an accessibility adjustment.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public enum AccessibilityAdjustmentDirection : Sendable {

    case increment

    case decrement

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: AccessibilityAdjustmentDirection, b: AccessibilityAdjustmentDirection) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension AccessibilityAdjustmentDirection : Equatable {
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension AccessibilityAdjustmentDirection : Hashable {
}

/// A view modifier that adds accessibility properties to the view
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public struct AccessibilityAttachmentModifier : ViewModifier {

    /// The type of view representing the body.
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    public typealias Body = Never
}

/// Defines the behavior for the child elements of the new parent element.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public struct AccessibilityChildBehavior : Hashable {

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: AccessibilityChildBehavior, rhs: AccessibilityChildBehavior) -> Bool

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension AccessibilityChildBehavior {

    /// Any child accessibility elements become hidden.
    ///
    /// Use this behavior when you want a view represented by
    /// a single accessibility element. The new accessibility element
    /// has no initial properties. So you will need to use other
    /// accessibility modifiers, such as ``View/accessibilityLabel(_:)``,
    /// to begin making it accessible.
    ///
    ///     var body: some View {
    ///         VStack {
    ///             Button("Previous Page", action: goBack)
    ///             Text("\(pageNumber)")
    ///             Button("Next Page", action: goForward)
    ///         }
    ///         .accessibilityElement(children: .ignore)
    ///         .accessibilityValue("Page \(pageNumber) of \(pages.count)")
    ///         .accessibilityAdjustableAction { action in
    ///             if action == .increment {
    ///                 goForward()
    ///             } else {
    ///                 goBack()
    ///             }
    ///         }
    ///     }
    ///
    /// Before using the  ``AccessibilityChildBehavior/ignore``behavior, consider
    /// using the ``AccessibilityChildBehavior/combine`` behavior.
    ///
    /// - Note: A new accessibility element is always created.
    public static let ignore: AccessibilityChildBehavior

    /// Any child accessibility elements become children of the new
    /// accessibility element.
    ///
    /// Use this behavior when you want a view to be an accessibility
    /// container. An accessibility container groups child accessibility
    /// elements which improves navigation. For example, all children
    /// of an accessibility container are navigated in order before
    /// navigating through the next accessibility container.
    ///
    ///     var body: some View {
    ///         ScrollView {
    ///             VStack {
    ///                 HStack {
    ///                     ForEach(users) { user in
    ///                         UserCell(user)
    ///                     }
    ///                 }
    ///                 .accessibilityElement(children: .contain)
    ///                 .accessibilityLabel("Users")
    ///
    ///                 VStack {
    ///                     ForEach(messages) { message in
    ///                         MessageCell(message)
    ///                     }
    ///                 }
    ///                 .accessibilityElement(children: .contain)
    ///                 .accessibilityLabel("Messages")
    ///             }
    ///         }
    ///     }
    ///
    /// A new accessibility element is created when:
    /// * The view contains multiple or zero accessibility elements
    /// * The view contains a single accessibility element with no children
    ///
    /// - Note: If an accessibility element is not created, the
    ///         ``AccessibilityChildBehavior`` of the existing
    ///         accessibility element is modified.
    public static let contain: AccessibilityChildBehavior

    /// Any child accessibility element's properties are merged
    /// into the new accessibility element.
    ///
    /// Use this behavior when you want a view represented by
    /// a single accessibility element. The new accessibility element
    /// merges properties from all non-hidden children. Some
    /// properties may be transformed or ignored to achieve the
    /// ideal combined result. For example, not all of ``AccessibilityTraits``
    /// are merged and a ``AccessibilityActionKind/default`` action
    /// may become a named action (``AccessibilityActionKind/init(named:)``).
    ///
    ///     struct UserCell: View {
    ///         var user: User
    ///
    ///         var body: some View {
    ///             VStack {
    ///                 Image(user.image)
    ///                 Text(user.name)
    ///                 Button("Options", action: showOptions)
    ///             }
    ///             .accessibilityElement(children: .combine)
    ///         }
    ///     }
    ///
    /// A new accessibility element is created when:
    /// * The view contains multiple or zero accessibility elements
    /// * The view wraps a ``UIViewRepresentable``/``NSViewRepresentable``.
    ///
    /// - Note: If an accessibility element is not created, the
    ///         ``AccessibilityChildBehavior`` of the existing
    ///         accessibility element is modified.
    public static let combine: AccessibilityChildBehavior
}

/// An option set that defines the functionality of a view's direct touch area.
@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
public struct AccessibilityDirectTouchOptions : OptionSet, Sendable {

    /// The raw type that can be used to represent all values of the conforming
    /// type.
    ///
    /// Every distinct value of the conforming type has a corresponding unique
    /// value of the `RawValue` type, but there may be values of the `RawValue`
    /// type that don't have a corresponding value of the conforming type.
    public typealias RawValue = UInt

    /// The corresponding value of the raw type.
    ///
    /// A new instance initialized with `rawValue` will be equivalent to this
    /// instance. For example:
    ///
    ///     enum PaperSize: String {
    ///         case A4, A5, Letter, Legal
    ///     }
    ///
    ///     let selectedSize = PaperSize.Letter
    ///     print(selectedSize.rawValue)
    ///     // Prints "Letter"
    ///
    ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
    ///     // Prints "true"
    public let rawValue: AccessibilityDirectTouchOptions.RawValue

    /// Create a set of direct touch options
    public init(rawValue: AccessibilityDirectTouchOptions.RawValue)

    /// Allows a direct touch area to immediately receive touch events without
    /// an assitive technology, such as VoiceOver, speaking. Appropriate for
    /// apps that provide direct audio feedback on touch that would conflict
    /// with speech feedback.
    public static let silentOnTouch: AccessibilityDirectTouchOptions

    /// Prevents touch passthrough with the direct touch area until an
    /// assistive technology, such as VoiceOver, has activated the direct
    /// touch area through a user action, for example a double tap.
    public static let requiresActivation: AccessibilityDirectTouchOptions

    /// The type of the elements of an array literal.
    @available(iOS 17.0, tvOS 17.0, watchOS 10.0, macOS 14.0, *)
    public typealias ArrayLiteralElement = AccessibilityDirectTouchOptions

    /// The element type of the option set.
    ///
    /// To inherit all the default implementations from the `OptionSet` protocol,
    /// the `Element` type must be `Self`, the default.
    @available(iOS 17.0, tvOS 17.0, watchOS 10.0, macOS 14.0, *)
    public typealias Element = AccessibilityDirectTouchOptions
}

/// A property wrapper type that can read and write a value that SwiftUI updates
/// as the focus of any active accessibility technology, such as VoiceOver,
/// changes.
///
/// Use this capability to request that VoiceOver or other accessibility
/// technologies programmatically focus on a specific element, or to determine
/// whether VoiceOver or other accessibility technologies are focused on
/// particular elements. Use ``View/accessibilityFocused(_:equals:)`` or
/// ``View/accessibilityFocused(_:)`` in conjunction with this property
/// wrapper to identify accessibility elements for which you want to get
/// or set accessibility focus. When accessibility focus enters the modified accessibility element,
/// the framework updates the wrapped value of this property to match a given
/// prototype value. When accessibility focus leaves, SwiftUI resets the wrapped value
/// of an optional property to `nil` or the wrapped value of a Boolean property to `false`.
/// Setting the property's value programmatically has the reverse effect, causing
/// accessibility focus to move to whichever accessibility element is associated with the updated value.
///
///  In the example below, when `notification` changes, and its  `isPriority` property
///  is `true`, the accessibility focus moves to the notification `Text` element above the rest of the
///  view's content:
///
///     struct CustomNotification: Equatable {
///         var text: String
///         var isPriority: Bool
///     }
///
///     struct ContentView: View {
///         @Binding var notification: CustomNotification?
///         @AccessibilityFocusState var isNotificationFocused: Bool
///
///         var body: some View {
///             VStack {
///                 if let notification = self.notification {
///                     Text(notification.text)
///                         .accessibilityFocused($isNotificationFocused)
///                 }
///                 Text("The main content for this view.")
///             }
///             .onChange(of: notification) { notification in
///                 if (notification?.isPriority == true)  {
///                     isNotificationFocused = true
///                 }
///             }
///
///         }
///     }
///
/// To allow for cases where accessibility focus is completely absent from the
/// tree of accessibility elements, or accessibility technologies are not
/// active, the wrapped value must be either optional or Boolean.
///
/// Some initializers of `AccessibilityFocusState` also allow specifying
/// accessibility technologies, determining to which types of accessibility
/// focus this binding applies. If you specify no accessibility technologies,
/// SwiftUI uses an aggregate of any and all active accessibility technologies.
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
@propertyWrapper @frozen public struct AccessibilityFocusState<Value> : DynamicProperty where Value : Hashable {

    @propertyWrapper @frozen public struct Binding {

        /// The underlying value referenced by the bound property.
        public var wrappedValue: Value { get nonmutating set }

        /// The currently focused element.
        public var projectedValue: AccessibilityFocusState<Value>.Binding { get }
    }

    /// The current state value, taking into account whatever bindings might be
    /// in effect due to the current location of focus.
    ///
    /// When focus is not in any view that is bound to this state, the wrapped
    /// value will be `nil` (for optional-typed state) or `false` (for `Bool`-
    /// typed state).
    public var wrappedValue: Value { get nonmutating set }

    /// A projection of the state value that can be used to establish bindings between view content
    /// and accessibility focus placement.
    ///
    /// Use `projectedValue` in conjunction with
    /// ``SwiftUI/View/accessibilityFocused(_:equals:)`` to establish
    /// bindings between view content and accessibility focus placement.
    public var projectedValue: AccessibilityFocusState<Value>.Binding { get }

    /// Creates a new accessibility focus state for a Boolean value.
    public init() where Value == Bool

    /// Creates a new accessibility focus state for a Boolean value, using the accessibility
    /// technologies you specify.
    ///
    /// - Parameters:
    ///   - technologies: One of the available ``AccessibilityTechnologies``.
    public init(for technologies: AccessibilityTechnologies) where Value == Bool

    /// Creates a new accessibility focus state of the type you provide.
    public init<T>() where Value == T?, T : Hashable

    /// Creates a new accessibility focus state of the type and
    /// using the accessibility technologies you specify.
    ///
    /// - Parameter technologies: One or more of the available
    ///  ``AccessibilityTechnologies``.
    public init<T>(for technologies: AccessibilityTechnologies) where Value == T?, T : Hashable
}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension AccessibilityFocusState : Sendable where Value : Sendable {
}

/// The role of an accessibility element in a label / content pair.
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
@frozen public enum AccessibilityLabeledPairRole {

    /// This element represents the label part of the label / content pair.
    ///
    /// For example, it might be the explanatory text to the left of a control,
    /// describing what the control does.
    case label

    /// This element represents the content part of the label / content pair.
    ///
    /// For example, it might be the custom control itself.
    case content

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: AccessibilityLabeledPairRole, b: AccessibilityLabeledPairRole) -> Bool
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension AccessibilityLabeledPairRole : Hashable {

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension AccessibilityLabeledPairRole : Sendable {
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension AccessibilityLabeledPairRole : BitwiseCopyable {
}

/// Content within an accessibility rotor.
///
/// Generally generated from control flow constructs like `ForEach` and `if`, and
/// `AccessibilityRotorEntry`.
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
@MainActor @preconcurrency public protocol AccessibilityRotorContent {

    /// The type for the internal content of this `AccessibilityRotorContent`.
    associatedtype Body : AccessibilityRotorContent

    /// The internal content of this `AccessibilityRotorContent`.
    @AccessibilityRotorContentBuilder @MainActor @preconcurrency var body: Self.Body { get }
}

/// Result builder you use to generate rotor entry content.
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
@resultBuilder public struct AccessibilityRotorContentBuilder {

    /// Builds an expression within the builder.
    public static func buildExpression<Content>(_ content: Content) -> Content where Content : AccessibilityRotorContent

    public static func buildBlock<Content>(_ content: Content) -> some AccessibilityRotorContent where Content : AccessibilityRotorContent


    public static func buildIf<Content>(_ content: Content?) -> some AccessibilityRotorContent where Content : AccessibilityRotorContent

}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension AccessibilityRotorContentBuilder {

    public static func buildBlock<C0, C1>(_ c0: C0, _ c1: C1) -> some AccessibilityRotorContent where C0 : AccessibilityRotorContent, C1 : AccessibilityRotorContent

}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension AccessibilityRotorContentBuilder {

    public static func buildBlock<C0, C1, C2>(_ c0: C0, _ c1: C1, _ c2: C2) -> some AccessibilityRotorContent where C0 : AccessibilityRotorContent, C1 : AccessibilityRotorContent, C2 : AccessibilityRotorContent

}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension AccessibilityRotorContentBuilder {

    public static func buildBlock<C0, C1, C2, C3>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3) -> some AccessibilityRotorContent where C0 : AccessibilityRotorContent, C1 : AccessibilityRotorContent, C2 : AccessibilityRotorContent, C3 : AccessibilityRotorContent

}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension AccessibilityRotorContentBuilder {

    public static func buildBlock<C0, C1, C2, C3, C4>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4) -> some AccessibilityRotorContent where C0 : AccessibilityRotorContent, C1 : AccessibilityRotorContent, C2 : AccessibilityRotorContent, C3 : AccessibilityRotorContent, C4 : AccessibilityRotorContent

}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension AccessibilityRotorContentBuilder {

    public static func buildBlock<C0, C1, C2, C3, C4, C5>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5) -> some AccessibilityRotorContent where C0 : AccessibilityRotorContent, C1 : AccessibilityRotorContent, C2 : AccessibilityRotorContent, C3 : AccessibilityRotorContent, C4 : AccessibilityRotorContent, C5 : AccessibilityRotorContent

}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension AccessibilityRotorContentBuilder {

    public static func buildBlock<C0, C1, C2, C3, C4, C5, C6>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5, _ c6: C6) -> some AccessibilityRotorContent where C0 : AccessibilityRotorContent, C1 : AccessibilityRotorContent, C2 : AccessibilityRotorContent, C3 : AccessibilityRotorContent, C4 : AccessibilityRotorContent, C5 : AccessibilityRotorContent, C6 : AccessibilityRotorContent

}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension AccessibilityRotorContentBuilder {

    public static func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5, _ c6: C6, _ c7: C7) -> some AccessibilityRotorContent where C0 : AccessibilityRotorContent, C1 : AccessibilityRotorContent, C2 : AccessibilityRotorContent, C3 : AccessibilityRotorContent, C4 : AccessibilityRotorContent, C5 : AccessibilityRotorContent, C6 : AccessibilityRotorContent, C7 : AccessibilityRotorContent

}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension AccessibilityRotorContentBuilder {

    public static func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7, C8>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5, _ c6: C6, _ c7: C7, _ c8: C8) -> some AccessibilityRotorContent where C0 : AccessibilityRotorContent, C1 : AccessibilityRotorContent, C2 : AccessibilityRotorContent, C3 : AccessibilityRotorContent, C4 : AccessibilityRotorContent, C5 : AccessibilityRotorContent, C6 : AccessibilityRotorContent, C7 : AccessibilityRotorContent, C8 : AccessibilityRotorContent

}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension AccessibilityRotorContentBuilder {

    public static func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7, C8, C9>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5, _ c6: C6, _ c7: C7, _ c8: C8, _ c9: C9) -> some AccessibilityRotorContent where C0 : AccessibilityRotorContent, C1 : AccessibilityRotorContent, C2 : AccessibilityRotorContent, C3 : AccessibilityRotorContent, C4 : AccessibilityRotorContent, C5 : AccessibilityRotorContent, C6 : AccessibilityRotorContent, C7 : AccessibilityRotorContent, C8 : AccessibilityRotorContent, C9 : AccessibilityRotorContent

}

/// A struct representing an entry in an Accessibility Rotor.
///
/// An Accessibility Rotor is a shortcut for Accessibility users to
/// quickly navigate to specific elements of the user interface,
/// and optionally specific ranges of text within those elements.
///
/// An entry in a Rotor may contain a label to identify the entry to the user,
/// and identifier used to determine which Accessibility element the Rotor entry
/// should navigate to, as well as an optional range used for entries that
/// navigate to a specific position in the text of their associated
/// Accessibility element. An entry can also specify a handler to be
/// called before the entry is navigated to, to do any manual work needed to
/// bring the Accessibility element on-screen.
///
/// In the following example, a Message application creates a Rotor
/// allowing users to navigate to specifically the messages originating from
/// VIPs.
///
///     // `messages` is a list of `Identifiable` `Message`s.
///
///     ScrollView {
///         LazyVStack {
///             ForEach(messages) { message in
///                 MessageView(message)
///             }
///         }
///     }
///     .accessibilityElement(children: .contain)
///     .accessibilityRotor("VIPs") {
///         // Not all the `MessageView`s are generated at once, but the model
///         // knows about all the messages.
///         ForEach(messages) { message in
///             // If the Message is from a VIP, make a Rotor entry for it.
///             if message.isVIP {
///                 AccessibilityRotorEntry(message.subject, id: message.id)
///             }
///         }
///     }
///
/// An entry may also be created using an optional namespace, for situations
/// where there are multiple Accessibility elements within a ForEach iteration
/// or where a `ScrollView` is not present. In this case, the `prepare` closure
/// may be needed in order to scroll the element into position using
/// `ScrollViewReader`. The same namespace should be passed to calls to
/// `accessibilityRotorEntry(id:in:)` to tag the Accessibility elements
/// associated with this entry.
///
/// In the following example, a Message application creates a Rotor
/// allowing users to navigate to specifically the messages originating from
/// VIPs. The Rotor entries are associated with the content text of the message,
/// which is one of the two views within the ForEach that generate Accessibility
/// elements. That view is tagged with `accessibilityRotorEntry(id:in:)` so that
/// it can be found by the `AccessibilityRotorEntry`, and `ScrollViewReader` is
/// used with the `prepare` closure to scroll it into position.
///
///     struct MessageListView: View {
///         @Namespace var namespace
///
///         var body: some View {
///             ScrollViewReader { scroller in
///                  ScrollView {
///                     LazyVStack {
///                         ForEach(allMessages) { message in
///                             VStack {
///                                 Text(message.subject)
///                                 // Tag this `Text` as an element associated
///                                 // with a Rotor entry.
///                                 Text(message.content)
///                                     .accessibilityRotorEntry(
///                                         "\(message.id)_content",
///                                         in: namespace
///                                     )
///                             }
///                         }
///                     }
///                 }
///                 .accessibilityElement(children: .contain)
///                 .accessibilityRotor("VIP Messages") {
///                     ForEach(vipMessages) { vipMessage in
///                         // The Rotor entry points to a specific ID we
///                         // defined within a given `ForEach` iteration,
///                         // not to the entire `ForEach` iteration.
///                         AccessibilityRotorEntry(vipMessage.subject,
///                             id: "\(vipMessage.id)_content", in: namespace)
///                         {
///                             // But the ID we give to `ScrollViewReader`
///                             // matches the one used in the `ForEach`, which
///                             // is the identifier for the whole iteration
///                             // and what `ScrollViewReader` requires.
///                             scroller.scrollTo(vipMessage.id)
///                         }
///                     }
///                 }
///             }
///         }
///     }
///
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public struct AccessibilityRotorEntry<ID> where ID : Hashable {

    /// Create a Rotor entry with a specific label and identifier, with an
    /// optional range.
    /// - Parameters:
    ///   - label: Localized string used to show this Rotor entry
    ///     to users.
    ///   - id: Used to find the UI element associated with this
    ///     Rotor entry. This identifier should be used within a `scrollView`,
    ///     either in a `ForEach` or using an `id` call.
    ///   - textRange: Optional range of text associated with this Rotor
    ///     entry. This should be a range within text that is set as the
    ///     either label or accessibility value of the associated element.
    ///   - prepare: Optional closure to run before a Rotor entry
    ///     is navigated to, to prepare the UI as needed. This can be used to
    ///     bring the UI element on-screen if it isn't already, and SwiftUI
    ///     is not able to automatically scroll to it.
    public init(_ label: Text, id: ID, textRange: Range<String.Index>? = nil, prepare: @escaping (() -> Void) = {})

    /// Create a Rotor entry with a specific label, identifier and namespace,
    /// and with an optional range.
    /// - Parameters:
    ///   - label: Localized string used to show this Rotor entry
    ///     to users.
    ///   - id: Used to find the UI element associated with this
    ///     Rotor entry. This identifier and namespace should match a call to
    ///     `accessibilityRotorEntry(id:in)`.
    ///   - namespace: Namespace for this identifier. Should match a call
    ///     to `accessibilityRotorEntry(id:in)`.
    ///   - textRange: Optional range of text associated with this Rotor
    ///     entry. This should be a range within text that is set as the
    ///     accessibility label or accessibility value of the associated
    ///     element.
    ///   - prepare: Optional closure to run before a Rotor entry
    ///     is navigated to, to prepare the UI as needed. This should be used to
    ///     bring the Accessibility element on-screen, if scrolling is needed to
    ///     get to it.
    public init(_ label: Text, id: ID, in namespace: Namespace.ID, textRange: Range<String.Index>? = nil, prepare: @escaping (() -> Void) = {})

    /// Create a Rotor entry with a specific label and range. This Rotor entry
    /// will be associated with the Accessibility element that owns the Rotor.
    /// - Parameters:
    ///   - label: Optional localized string used to show this Rotor entry
    ///     to users. If no label is specified, the Rotor entry will be labeled
    ///     based on the text at that range.
    ///   - range: Range of text associated with this Rotor
    ///     entry.
    ///   - prepare: Optional closure to run before a Rotor entry
    ///     is navigated to, to prepare the UI as needed. This can be used to
    ///     bring the UI element or text on-screen if it isn't already,
    ///     and SwiftUI not able to automatically scroll to it.
    public init(_ label: Text? = nil, textRange: Range<String.Index>, prepare: @escaping (() -> Void) = {}) where ID == Never

    /// Create a Rotor entry with a specific label and identifier, with an
    /// optional range.
    /// - Parameters:
    ///   - id: Used to find the UI element associated with this
    ///     Rotor entry. This identifier should be used within a `scrollView`,
    ///     either in a `ForEach` or using an `id` call.
    ///   - label: Localized string used to show this Rotor entry
    ///     to users.
    ///   - textRange: Optional range of text associated with this Rotor
    ///     entry. This should be a range within text that is set as the
    ///     accessibility label or accessibility value of the associated
    ///     element.
    ///   - prepare: Optional closure to run before a Rotor entry
    ///     is navigated to, to prepare the UI as needed. This can be used to
    ///     bring the UI element on-screen if it isn't already, and SwiftUI
    ///     is not able to automatically scroll to it.
    public init(_ labelKey: LocalizedStringKey, id: ID, textRange: Range<String.Index>? = nil, prepare: @escaping (() -> Void) = {})

    /// Create a Rotor entry with a specific label and identifier, with an
    /// optional range.
    /// - Parameters:
    ///   - label: Localized string used to show this Rotor entry
    ///     to users.
    ///   - id: Used to find the UI element associated with this
    ///     Rotor entry. This identifier should be used within a `scrollView`,
    ///     either in a `ForEach` or using an `id` call.
    ///   - textRange: Optional range of text associated with this Rotor
    ///     entry. This should be a range within text that is set as the
    ///     accessibility label or accessibility value of the associated
    ///     element.
    ///   - prepare: Optional closure to run before a Rotor entry
    ///     is navigated to, to prepare the UI as needed. This can be used to
    ///     bring the UI element on-screen if it isn't already, and SwiftUI
    ///     is not able to automatically scroll to it.
    public init<L>(_ label: L, id: ID, textRange: Range<String.Index>? = nil, prepare: @escaping (() -> Void) = {}) where L : StringProtocol

    /// Create a Rotor entry with a specific label, identifier and namespace,
    /// and with an optional range.
    /// - Parameters:
    ///   - labelKey: Localized string used to show this Rotor entry
    ///     to users.
    ///   - id: Used to find the UI element associated with this
    ///     Rotor entry. This identifier and namespace should match a call to
    ///     `accessibilityRotorEntry(id:in)`.
    ///   - namespace: Namespace for this identifier. Should match a call
    ///     to `accessibilityRotorEntry(id:in)`.
    ///   - textRange: Optional range of text associated with this Rotor
    ///     entry. This should be a range within text that is set as the
    ///     accessibility label or accessibility value of the associated
    ///     element.
    ///   - prepare: Optional closure to run before a Rotor entry
    ///     is navigated to, to prepare the UI as needed. This should be used to
    ///     bring the Accessibility element on-screen, if scrolling is needed to
    ///     get to it.
    public init(_ labelKey: LocalizedStringKey, id: ID, in namespace: Namespace.ID, textRange: Range<String.Index>? = nil, prepare: @escaping (() -> Void) = {})

    /// Create a Rotor entry with a specific label, identifier and namespace,
    /// and with an optional range.
    /// - Parameters:
    ///   - label: Localized string used to show this Rotor entry
    ///     to users.
    ///   - id: Used to find the UI element associated with this
    ///     Rotor entry. This identifier and namespace should match a call to
    ///     `accessibilityRotorEntry(id:in)`.
    ///   - namespace: Namespace for this identifier. Should match a call
    ///     to `accessibilityRotorEntry(id:in)`.
    ///   - textRange: Optional range of text associated with this Rotor
    ///     entry. This should be a range within text that is set as the
    ///     accessibility label or accessibility value of the associated
    ///     element.
    ///   - prepare: Optional closure to run before a Rotor entry
    ///     is navigated to, to prepare the UI as needed. This should be used to
    ///     bring the Accessibility element on-screen, if scrolling is needed to
    ///     get to it.
    public init<L>(_ label: L, _ id: ID, in namespace: Namespace.ID, textRange: Range<String.Index>? = nil, prepare: @escaping (() -> Void) = {}) where L : StringProtocol

    /// Create a Rotor entry with a specific label and range. This Rotor entry
    /// will be associated with the Accessibility element that owns the Rotor.
    /// - Parameters:
    ///   - labelKey: Localized string used to show this Rotor entry
    ///     to users. If no label is specified, the Rotor entry will be labeled
    ///     based on the text at that range.
    ///   - range: Range of text associated with this Rotor
    ///     entry.
    ///   - prepare: Optional closure to run before a Rotor entry
    ///     is navigated to, to prepare the UI as needed. This can be used to
    ///     bring the UI element or text on-screen if it isn't already,
    ///     and SwiftUI not able to automatically scroll to it.
    public init(_ labelKey: LocalizedStringKey, textRange: Range<String.Index>, prepare: @escaping (() -> Void) = {})

    /// Create a Rotor entry with a specific label and range. This Rotor entry
    /// will be associated with the Accessibility element that owns the Rotor.
    /// - Parameters:
    ///   - label: Localized string used to show this Rotor entry
    ///     to users. If no label is specified, the Rotor entry will be labeled
    ///     based on the text at that range.
    ///   - range: Range of text associated with this Rotor
    ///     entry.
    ///   - prepare: Optional closure to run before a Rotor entry
    ///     is navigated to, to prepare the UI as needed. This can be used to
    ///     bring the UI element or text on-screen if it isn't already,
    ///     and SwiftUI not able to automatically scroll to it.
    public init<L>(_ label: L, textRange: Range<String.Index>, prepare: @escaping (() -> Void) = {}) where ID == Never, L : StringProtocol
}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension AccessibilityRotorEntry : AccessibilityRotorContent {

    /// The internal content of this `AccessibilityRotorContent`.
    @MainActor @preconcurrency public var body: Never { get }

    /// The type for the internal content of this `AccessibilityRotorContent`.
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias Body = Never
}

/// Designates a Rotor that replaces one of the automatic, system-provided
/// Rotors with a developer-provided Rotor.
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public struct AccessibilitySystemRotor : Sendable {

    /// System Rotors allowing users to iterate through links or visited links.
    public static func links(visited: Bool) -> AccessibilitySystemRotor

    /// System Rotor allowing users to iterate through all links.
    public static var links: AccessibilitySystemRotor { get }

    /// System Rotors allowing users to iterate through all headings, of various
    /// heading levels.
    public static func headings(level: AccessibilityHeadingLevel) -> AccessibilitySystemRotor

    /// System Rotor allowing users to iterate through all headings.
    public static var headings: AccessibilitySystemRotor { get }

    /// System Rotor allowing users to iterate through all the ranges of
    /// bolded text.
    public static var boldText: AccessibilitySystemRotor { get }

    /// System Rotor allowing users to iterate through all the ranges of
    /// italicized text.
    public static var italicText: AccessibilitySystemRotor { get }

    /// System Rotor allowing users to iterate through all the ranges of
    /// underlined text.
    public static var underlineText: AccessibilitySystemRotor { get }

    /// System Rotor allowing users to iterate through all the ranges of
    /// mis-spelled words.
    public static var misspelledWords: AccessibilitySystemRotor { get }

    /// System Rotor allowing users to iterate through all images.
    public static var images: AccessibilitySystemRotor { get }

    /// System Rotor allowing users to iterate through all text fields.
    public static var textFields: AccessibilitySystemRotor { get }

    /// System Rotor allowing users to iterate through all tables.
    public static var tables: AccessibilitySystemRotor { get }

    /// System Rotor allowing users to iterate through all lists.
    public static var lists: AccessibilitySystemRotor { get }

    /// System Rotor allowing users to iterate through all landmarks.
    public static var landmarks: AccessibilitySystemRotor { get }
}

/// Accessibility technologies available to the system.
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public struct AccessibilityTechnologies : SetAlgebra, Sendable {

    /// The value that represents the VoiceOver screen reader, allowing use
    /// of the system without seeing the screen visually.
    public static let voiceOver: AccessibilityTechnologies

    /// The value that represents a Switch Control, allowing the use of the
    /// entire system using controller buttons, a breath-controlled switch or similar hardware.
    public static let switchControl: AccessibilityTechnologies

    /// Creates a new accessibility technologies structure with an empy accessibility technology set.
    public init()

    /// Returns a new set with the elements of both this and the given set.
    ///
    /// In the following example, the `attendeesAndVisitors` set is made up
    /// of the elements of the `attendees` and `visitors` sets:
    ///
    ///     let attendees: Set = ["Alicia", "Bethany", "Diana"]
    ///     let visitors = ["Marcia", "Nathaniel"]
    ///     let attendeesAndVisitors = attendees.union(visitors)
    ///     print(attendeesAndVisitors)
    ///     // Prints "["Diana", "Nathaniel", "Bethany", "Alicia", "Marcia"]"
    ///
    /// If the set already contains one or more elements that are also in
    /// `other`, the existing members are kept.
    ///
    ///     let initialIndices = Set(0..<5)
    ///     let expandedIndices = initialIndices.union([2, 3, 6, 7])
    ///     print(expandedIndices)
    ///     // Prints "[2, 4, 6, 7, 0, 1, 3]"
    ///
    /// - Parameter other: A set of the same type as the current set.
    /// - Returns: A new set with the unique elements of this set and `other`.
    ///
    /// - Note: if this set and `other` contain elements that are equal but
    ///   distinguishable (e.g. via `===`), which of these elements is present
    ///   in the result is unspecified.
    public func union(_ other: AccessibilityTechnologies) -> AccessibilityTechnologies

    /// Adds the elements of the given set to the set.
    ///
    /// In the following example, the elements of the `visitors` set are added to
    /// the `attendees` set:
    ///
    ///     var attendees: Set = ["Alicia", "Bethany", "Diana"]
    ///     let visitors: Set = ["Diana", "Marcia", "Nathaniel"]
    ///     attendees.formUnion(visitors)
    ///     print(attendees)
    ///     // Prints "["Diana", "Nathaniel", "Bethany", "Alicia", "Marcia"]"
    ///
    /// If the set already contains one or more elements that are also in
    /// `other`, the existing members are kept.
    ///
    ///     var initialIndices = Set(0..<5)
    ///     initialIndices.formUnion([2, 3, 6, 7])
    ///     print(initialIndices)
    ///     // Prints "[2, 4, 6, 7, 0, 1, 3]"
    ///
    /// - Parameter other: A set of the same type as the current set.
    public mutating func formUnion(_ other: AccessibilityTechnologies)

    /// Returns a new set with the elements that are common to both this set and
    /// the given set.
    ///
    /// In the following example, the `bothNeighborsAndEmployees` set is made up
    /// of the elements that are in *both* the `employees` and `neighbors` sets.
    /// Elements that are in only one or the other are left out of the result of
    /// the intersection.
    ///
    ///     let employees: Set = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    ///     let neighbors: Set = ["Bethany", "Eric", "Forlani", "Greta"]
    ///     let bothNeighborsAndEmployees = employees.intersection(neighbors)
    ///     print(bothNeighborsAndEmployees)
    ///     // Prints "["Bethany", "Eric"]"
    ///
    /// - Parameter other: A set of the same type as the current set.
    /// - Returns: A new set.
    ///
    /// - Note: if this set and `other` contain elements that are equal but
    ///   distinguishable (e.g. via `===`), which of these elements is present
    ///   in the result is unspecified.
    public func intersection(_ other: AccessibilityTechnologies) -> AccessibilityTechnologies

    /// Removes the elements of this set that aren't also in the given set.
    ///
    /// In the following example, the elements of the `employees` set that are
    /// not also members of the `neighbors` set are removed. In particular, the
    /// names `"Alicia"`, `"Chris"`, and `"Diana"` are removed.
    ///
    ///     var employees: Set = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    ///     let neighbors: Set = ["Bethany", "Eric", "Forlani", "Greta"]
    ///     employees.formIntersection(neighbors)
    ///     print(employees)
    ///     // Prints "["Bethany", "Eric"]"
    ///
    /// - Parameter other: A set of the same type as the current set.
    public mutating func formIntersection(_ other: AccessibilityTechnologies)

    /// Returns a new set with the elements that are either in this set or in the
    /// given set, but not in both.
    ///
    /// In the following example, the `eitherNeighborsOrEmployees` set is made up
    /// of the elements of the `employees` and `neighbors` sets that are not in
    /// both `employees` *and* `neighbors`. In particular, the names `"Bethany"`
    /// and `"Eric"` do not appear in `eitherNeighborsOrEmployees`.
    ///
    ///     let employees: Set = ["Alicia", "Bethany", "Diana", "Eric"]
    ///     let neighbors: Set = ["Bethany", "Eric", "Forlani"]
    ///     let eitherNeighborsOrEmployees = employees.symmetricDifference(neighbors)
    ///     print(eitherNeighborsOrEmployees)
    ///     // Prints "["Diana", "Forlani", "Alicia"]"
    ///
    /// - Parameter other: A set of the same type as the current set.
    /// - Returns: A new set.
    public func symmetricDifference(_ other: AccessibilityTechnologies) -> AccessibilityTechnologies

    /// Removes the elements of the set that are also in the given set and adds
    /// the members of the given set that are not already in the set.
    ///
    /// In the following example, the elements of the `employees` set that are
    /// also members of `neighbors` are removed from `employees`, while the
    /// elements of `neighbors` that are not members of `employees` are added to
    /// `employees`. In particular, the names `"Bethany"` and `"Eric"` are
    /// removed from `employees` while the name `"Forlani"` is added.
    ///
    ///     var employees: Set = ["Alicia", "Bethany", "Diana", "Eric"]
    ///     let neighbors: Set = ["Bethany", "Eric", "Forlani"]
    ///     employees.formSymmetricDifference(neighbors)
    ///     print(employees)
    ///     // Prints "["Diana", "Forlani", "Alicia"]"
    ///
    /// - Parameter other: A set of the same type.
    public mutating func formSymmetricDifference(_ other: AccessibilityTechnologies)

    /// Returns a Boolean value that indicates whether the given element exists
    /// in the set.
    ///
    /// This example uses the `contains(_:)` method to test whether an integer is
    /// a member of a set of prime numbers.
    ///
    ///     let primes: Set = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]
    ///     let x = 5
    ///     if primes.contains(x) {
    ///         print("\(x) is prime!")
    ///     } else {
    ///         print("\(x). Not prime.")
    ///     }
    ///     // Prints "5 is prime!"
    ///
    /// - Parameter member: An element to look for in the set.
    /// - Returns: `true` if `member` exists in the set; otherwise, `false`.
    public func contains(_ member: AccessibilityTechnologies) -> Bool

    /// Inserts the given element in the set if it is not already present.
    ///
    /// If an element equal to `newMember` is already contained in the set, this
    /// method has no effect. In this example, a new element is inserted into
    /// `classDays`, a set of days of the week. When an existing element is
    /// inserted, the `classDays` set does not change.
    ///
    ///     enum DayOfTheWeek: Int {
    ///         case sunday, monday, tuesday, wednesday, thursday,
    ///             friday, saturday
    ///     }
    ///
    ///     var classDays: Set<DayOfTheWeek> = [.wednesday, .friday]
    ///     print(classDays.insert(.monday))
    ///     // Prints "(true, .monday)"
    ///     print(classDays)
    ///     // Prints "[.friday, .wednesday, .monday]"
    ///
    ///     print(classDays.insert(.friday))
    ///     // Prints "(false, .friday)"
    ///     print(classDays)
    ///     // Prints "[.friday, .wednesday, .monday]"
    ///
    /// - Parameter newMember: An element to insert into the set.
    /// - Returns: `(true, newMember)` if `newMember` was not contained in the
    ///   set. If an element equal to `newMember` was already contained in the
    ///   set, the method returns `(false, oldMember)`, where `oldMember` is the
    ///   element that was equal to `newMember`. In some cases, `oldMember` may
    ///   be distinguishable from `newMember` by identity comparison or some
    ///   other means.
    public mutating func insert(_ newMember: AccessibilityTechnologies) -> (inserted: Bool, memberAfterInsert: AccessibilityTechnologies)

    /// Removes the given element and any elements subsumed by the given element.
    ///
    /// - Parameter member: The element of the set to remove.
    /// - Returns: For ordinary sets, an element equal to `member` if `member` is
    ///   contained in the set; otherwise, `nil`. In some cases, a returned
    ///   element may be distinguishable from `member` by identity comparison
    ///   or some other means.
    ///
    ///   For sets where the set type and element type are the same, like
    ///   `OptionSet` types, this method returns any intersection between the set
    ///   and `[member]`, or `nil` if the intersection is empty.
    public mutating func remove(_ member: AccessibilityTechnologies) -> AccessibilityTechnologies?

    /// Inserts the given element into the set unconditionally.
    ///
    /// If an element equal to `newMember` is already contained in the set,
    /// `newMember` replaces the existing element. In this example, an existing
    /// element is inserted into `classDays`, a set of days of the week.
    ///
    ///     enum DayOfTheWeek: Int {
    ///         case sunday, monday, tuesday, wednesday, thursday,
    ///             friday, saturday
    ///     }
    ///
    ///     var classDays: Set<DayOfTheWeek> = [.monday, .wednesday, .friday]
    ///     print(classDays.update(with: .monday))
    ///     // Prints "Optional(.monday)"
    ///
    /// - Parameter newMember: An element to insert into the set.
    /// - Returns: For ordinary sets, an element equal to `newMember` if the set
    ///   already contained such a member; otherwise, `nil`. In some cases, the
    ///   returned element may be distinguishable from `newMember` by identity
    ///   comparison or some other means.
    ///
    ///   For sets where the set type and element type are the same, like
    ///   `OptionSet` types, this method returns any intersection between the 
    ///   set and `[newMember]`, or `nil` if the intersection is empty.
    public mutating func update(with newMember: AccessibilityTechnologies) -> AccessibilityTechnologies?

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: AccessibilityTechnologies, b: AccessibilityTechnologies) -> Bool

    /// The type of the elements of an array literal.
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias ArrayLiteralElement = AccessibilityTechnologies

    /// A type for which the conforming type provides a containment test.
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias Element = AccessibilityTechnologies
}

/// Position and direction information of a zoom gesture that someone performs
/// with an assistive technology like VoiceOver.
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
public struct AccessibilityZoomGestureAction {

    /// A direction that matches the movement of a zoom gesture performed
    /// by an assistive technology, such as a swipe up and down in Voiceover's
    /// zoom rotor.
    @frozen public enum Direction {

        /// The gesture direction that represents zooming in.
        case zoomIn

        /// The gesture direction that represents zooming out.
        case zoomOut

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: AccessibilityZoomGestureAction.Direction, b: AccessibilityZoomGestureAction.Direction) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// The zoom gesture's direction.
    public let direction: AccessibilityZoomGestureAction.Direction

    /// The zoom gesture's activation point, normalized to the accessibility
    /// element's frame.
    public let location: UnitPoint

    /// The zoom gesture's activation point within the window's coordinate
    /// space.
    public let point: CGPoint
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension AccessibilityZoomGestureAction.Direction : Equatable {
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension AccessibilityZoomGestureAction.Direction : Hashable {
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension AccessibilityZoomGestureAction.Direction : Sendable {
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension AccessibilityZoomGestureAction.Direction : BitwiseCopyable {
}

/// A gauge style that displays a closed ring that's partially filled in to
/// indicate the gauge's current value.
///
/// Use ``GaugeStyle/accessoryCircularCapacity`` to construct this style.
@available(iOS 16.0, macOS 13.0, watchOS 9.0, *)
@available(tvOS, unavailable)
@MainActor @preconcurrency public struct AccessoryCircularCapacityGaugeStyle : GaugeStyle {

    /// Creates an accessory circular capacity gauge style.
    @MainActor @preconcurrency public init()

    /// Creates a view representing the body of a gauge.
    ///
    /// The system calls this modifier on each instance of gauge within a view
    /// hierarchy where this style is the current gauge style.
    ///
    /// - Parameter configuration: The properties to apply to the gauge instance.
    @MainActor @preconcurrency public func makeBody(configuration: AccessoryCircularCapacityGaugeStyle.Configuration) -> some View


    /// A view representing the body of a gauge.
    @available(iOS 16.0, watchOS 9.0, macOS 13.0, *)
    @available(tvOS, unavailable)
    public typealias Body = some View
}

/// A gauge style that displays an open ring with a marker that appears at a
/// point along the ring to indicate the gauge's current value.
///
/// Use ``GaugeStyle/accessoryCircular`` to construct this style.
@available(iOS 16.0, macOS 13.0, watchOS 9.0, *)
@available(tvOS, unavailable)
@MainActor @preconcurrency public struct AccessoryCircularGaugeStyle : GaugeStyle {

    /// Creates an accessory circular gauge style.
    @MainActor @preconcurrency public init()

    /// Creates a view representing the body of a gauge.
    ///
    /// The system calls this modifier on each instance of gauge within a view
    /// hierarchy where this style is the current gauge style.
    ///
    /// - Parameter configuration: The properties to apply to the gauge instance.
    @MainActor @preconcurrency public func makeBody(configuration: AccessoryCircularGaugeStyle.Configuration) -> some View


    /// A view representing the body of a gauge.
    @available(iOS 16.0, watchOS 9.0, macOS 13.0, *)
    @available(tvOS, unavailable)
    public typealias Body = some View
}

/// A gauge style that displays bar that fills from leading to trailing
/// edges as the gauge's current value increases.
///
/// Use ``GaugeStyle/accessoryLinearCapacity`` to construct this style.
@available(iOS 16.0, macOS 13.0, watchOS 9.0, *)
@available(tvOS, unavailable)
@MainActor @preconcurrency public struct AccessoryLinearCapacityGaugeStyle : GaugeStyle {

    /// Creates an accessory linear capacity gauge style.
    @MainActor @preconcurrency public init()

    /// Creates a view representing the body of a gauge.
    ///
    /// The system calls this modifier on each instance of gauge within a view
    /// hierarchy where this style is the current gauge style.
    ///
    /// - Parameter configuration: The properties to apply to the gauge instance.
    @MainActor @preconcurrency public func makeBody(configuration: AccessoryLinearCapacityGaugeStyle.Configuration) -> some View


    /// A view representing the body of a gauge.
    @available(iOS 16.0, watchOS 9.0, macOS 13.0, *)
    @available(tvOS, unavailable)
    public typealias Body = some View
}

/// A gauge style that displays bar with a marker that appears at a
/// point along the bar to indicate the gauge's current value.
///
/// Use ``GaugeStyle/accessoryLinear`` to construct this style.
@available(iOS 16.0, macOS 13.0, watchOS 9.0, *)
@available(tvOS, unavailable)
@MainActor @preconcurrency public struct AccessoryLinearGaugeStyle : GaugeStyle {

    /// Creates an accessory linear gauge style.
    @MainActor @preconcurrency public init()

    /// Creates a view representing the body of a gauge.
    ///
    /// The system calls this modifier on each instance of gauge within a view
    /// hierarchy where this style is the current gauge style.
    ///
    /// - Parameter configuration: The properties to apply to the gauge instance.
    @MainActor @preconcurrency public func makeBody(configuration: AccessoryLinearGaugeStyle.Configuration) -> some View


    /// A view representing the body of a gauge.
    @available(iOS 16.0, watchOS 9.0, macOS 13.0, *)
    @available(tvOS, unavailable)
    public typealias Body = some View
}

/// A representation of an action sheet presentation.
///
/// Use an action sheet when you want the user to make a choice between two
/// or more options, in response to their own action. If you want the user to
/// act in response to the state of the app or the system, rather than a user
/// action, use an ``Alert`` instead.
///
/// You show an action sheet by using the
/// ``View/actionSheet(isPresented:content:)`` view modifier to create an
/// action sheet, which then appears whenever the bound `isPresented` value is
/// `true`. The `content` closure you provide to this modifier produces a
/// customized instance of the `ActionSheet` type. To supply the options, create
/// instances of ``ActionSheet/Button`` to distinguish between ordinary options,
/// destructive options, and cancellation of the user's original action.
///
/// The action sheet handles its own dismissal by setting the bound
/// `isPresented` value back to `false` when the user taps a button in the
/// action sheet.
///
/// The following example creates an action sheet with three options: a Cancel
/// button, a destructive button, and a default button. The second and third of
/// these call methods are named `overwriteWorkout` and `appendWorkout`,
/// respectively.
///
///     @State private var showActionSheet = false
///     var body: some View {
///         Button("Tap to show action sheet") {
///             showActionSheet = true
///         }
///         .actionSheet(isPresented: $showActionSheet) {
///             ActionSheet(title: Text("Resume Workout Recording"),
///                         message: Text("Choose a destination for workout data"),
///                         buttons: [
///                             .cancel(),
///                             .destructive(
///                                 Text("Overwrite Current Workout"),
///                                 action: overwriteWorkout
///                             ),
///                             .default(
///                                 Text("Append to Current Workout"),
///                                 action: appendWorkout
///                             )
///                         ]
///             )
///         }
///     }
///
/// The system may interpret the order of items as they appear in the `buttons`
/// array to accommodate platform conventions. In this example, the Cancel
/// button is the first member of the array, but the action sheet puts it in its
/// standard position at the bottom of the sheet.
///
/// ![An action sheet with the title Resume Workout Recording in bold text and
/// the message Choose a destination for workout data in smaller text. Below
/// the text, three buttons: a destructive Overwrite Current Workout button in
/// red, a default-styled Overwrite Current Workout button, and a Cancel button,
/// farther below and set off in its own button
/// group.](SwiftUI-ActionSheet-cancel-and-destructive.png)
@available(iOS, introduced: 13.0, deprecated: 100000.0, message: "use `View.confirmationDialog(title:isPresented:titleVisibility:presenting::actions:)`instead.")
@available(macOS, unavailable)
@available(tvOS, introduced: 13.0, deprecated: 100000.0, message: "use `View.confirmationDialog(title:isPresented:titleVisibility:presenting:actions:)`instead.")
@available(watchOS, introduced: 6.0, deprecated: 100000.0, message: "use `View.confirmationDialog(title:isPresented:titleVisibility:presenting:actions:)`instead.")
@available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "use `View.confirmationDialog(title:isPresented:titleVisibility:presenting:actions:)`instead.")
public struct ActionSheet {

    /// Creates an action sheet with the provided buttons.
    /// - Parameters:
    ///   - title: The title of the action sheet.
    ///   - message: The message to display in the body of the action sheet.
    ///   - buttons: The buttons to show in the action sheet.
    public init(title: Text, message: Text? = nil, buttons: [ActionSheet.Button] = [.cancel()])

    /// A button representing an operation of an action sheet presentation.
    ///
    /// The ``ActionSheet`` button is type-aliased to the ``Alert`` button type,
    /// which provides default, cancel, and destructive styles.
    public typealias Button = Alert.Button
}

/// A placement for tabs in a tab view using the adaptable sidebar style.
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct AdaptableTabBarPlacement : Hashable {

    /// The automatic placement.
    public static let automatic: AdaptableTabBarPlacement

    /// The tab bar of a tab view.
    public static let tabBar: AdaptableTabBarPlacement

    /// The sidebar of a tab view.
    ///
    /// A tab view can appear as a sidebar
    /// in ``TabViewStyle/sidebarAdaptable``. Sidebar tabs represent all of
    /// the tabs in a tab view.
    @available(macOS, unavailable)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public static let sidebar: AdaptableTabBarPlacement

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: AdaptableTabBarPlacement, b: AdaptableTabBarPlacement) -> Bool

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

/// A representation of an alert presentation.
///
/// Use an alert when you want the user to act in response to the state of the
/// app or the system. If you want the user to make a choice in response to
/// their own action, use an ``ActionSheet`` instead.
///
/// You show an alert by using the ``View/alert(isPresented:content:)`` view
/// modifier to create an alert, which then appears whenever the bound
/// `isPresented` value is `true`. The `content` closure you provide to this
/// modifer produces a customized instance of the `Alert` type.
///
/// In the following example, a button presents a simple alert when
/// tapped, by updating a local `showAlert` property that binds to the alert.
///
///     @State private var showAlert = false
///     var body: some View {
///         Button("Tap to show alert") {
///             showAlert = true
///         }
///         .alert(isPresented: $showAlert) {
///             Alert(
///                 title: Text("Current Location Not Available"),
///                 message: Text("Your current location cant be " +
///                                 "determined at this time.")
///             )
///         }
///     }
///
/// ![A default alert dialog with the title Current Location Not Available in bold
/// text, the message your current location cant be determined at this time in
/// smaller text, and a default OK button.](SwiftUI-Alert-OK.png)
///
/// To customize the alert, add instances of the ``Alert/Button`` type, which
/// provides standardized buttons for common tasks like canceling and performing
/// destructive actions. The following example uses two buttons: a default
/// button labeled "Try Again" that calls a `saveWorkoutData` method,
/// and a "destructive" button that calls a `deleteWorkoutData` method.
///
///     @State private var showAlert = false
///     var body: some View {
///         Button("Tap to show alert") {
///             showAlert = true
///         }
///         .alert(isPresented: $showAlert) {
///             Alert(
///                 title: Text("Unable to Save Workout Data"),
///                 message: Text("The connection to the server was lost."),
///                 primaryButton: .default(
///                     Text("Try Again"),
///                     action: saveWorkoutData
///                 ),
///                 secondaryButton: .destructive(
///                     Text("Delete"),
///                     action: deleteWorkoutData
///                 )
///             )
///         }
///     }
///
/// ![An alert dialog with the title, Unable to Save Workout Data in bold text, and
/// the message, The connection to the server was lost, in smaller text. Below
/// the text, two buttons: a default button with Try Again in blue text, and a
/// button with Delete in red text.](SwiftUI-Alert-default-and-destructive.png)
///
/// The alert handles its own dismissal when the user taps one of the buttons in the alert, by setting
/// the bound `isPresented` value back to `false`.
@available(iOS, introduced: 13.0, deprecated: 100000.0, message: "Use View.alert(_:isPresented:presenting:actions:) instead.")
@available(macOS, introduced: 10.15, deprecated: 100000.0, message: "Use View.alert(_:isPresented:presenting:actions:) instead.")
@available(tvOS, introduced: 13.0, deprecated: 100000.0, message: "Use View.alert(_:isPresented:presenting:actions:) instead.")
@available(watchOS, introduced: 6.0, deprecated: 100000.0, message: "Use View.alert(_:isPresented:presenting:actions:) instead.")
@available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Use View.alert(_:isPresented:presenting:actions:) instead.")
public struct Alert {

    /// Creates an alert with one button.
    /// - Parameters:
    ///   - title: The title of the alert.
    ///   - message: The message to display in the body of the alert.
    ///   - dismissButton: The button that dismisses the alert.
    public init(title: Text, message: Text? = nil, dismissButton: Alert.Button? = nil)

    /// Creates an alert with two buttons.
    ///
    /// The system determines the visual ordering of the buttons.
    /// - Parameters:
    ///   - title: The title of the alert.
    ///   - message: The message to display in the body of the alert.
    ///   - primaryButton: The first button to show in the alert.
    ///   - secondaryButton: The second button to show in the alert.
    public init(title: Text, message: Text? = nil, primaryButton: Alert.Button, secondaryButton: Alert.Button)

    /// A button representing an operation of an alert presentation.
    public struct Button {

        /// Creates an alert button with the default style.
        /// - Parameters:
        ///   - label: The text to display on the button.
        ///   - action: A closure to execute when the user taps or presses the
        ///   button.
        /// - Returns: An alert button with the default style.
        public static func `default`(_ label: Text, action: (() -> Void)? = {}) -> Alert.Button

        /// Creates an alert button that indicates cancellation, with a custom
        /// label.
        /// - Parameters:
        ///   - label: The text to display on the button.
        ///   - action: A closure to execute when the user taps or presses the
        ///   button.
        /// - Returns: An alert button that indicates cancellation.
        public static func cancel(_ label: Text, action: (() -> Void)? = {}) -> Alert.Button

        /// Creates an alert button that indicates cancellation, with a
        /// system-provided label.
        ///
        /// The system automatically chooses locale-appropriate text for the
        /// button's label.
        /// - Parameter action: A closure to execute when the user taps or presses the
        ///   button.
        /// - Returns: An alert button that indicates cancellation.
        public static func cancel(_ action: (() -> Void)? = {}) -> Alert.Button

        /// Creates an alert button with a style that indicates a destructive
        /// action.
        /// - Parameters:
        ///   - label: The text to display on the button.
        ///   - action: A closure to execute when the user taps or presses the
        ///   button.
        /// - Returns: An alert button that indicates a destructive action.
        public static func destructive(_ label: Text, action: (() -> Void)? = {}) -> Alert.Button
    }
}

/// A modifier that can create another modifier with animation.
@available(iOS, introduced: 13.0, deprecated: 100000.0, message: "use Animatable directly")
@available(macOS, introduced: 10.15, deprecated: 100000.0, message: "use Animatable directly")
@available(tvOS, introduced: 13.0, deprecated: 100000.0, message: "use Animatable directly")
@available(watchOS, introduced: 6.0, deprecated: 100000.0, message: "use Animatable directly")
@available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "use Animatable directly")
public protocol AnimatableModifier : Animatable, ViewModifier {
}

/// The criteria that determines when an animation is considered finished.
@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
public struct AnimationCompletionCriteria : Hashable, Sendable {

    /// The animation has logically completed, but may still be in its long
    /// tail.
    ///
    /// If a subsequent change occurs that creates additional animations on
    /// properties with `logicallyComplete` completion callbacks registered,
    /// then those callbacks will fire when the animations from the change that
    /// they were registered with logically complete, ignoring the new
    /// animations.
    public static let logicallyComplete: AnimationCompletionCriteria

    /// The entire animation is finished and will now be removed.
    ///
    /// If a subsequent change occurs that creates additional animations on
    /// properties with `removed` completion callbacks registered, then those
    /// callbacks will only fire when *all* of the created animations are
    /// complete.
    public static let removed: AnimationCompletionCriteria

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: AnimationCompletionCriteria, b: AnimationCompletionCriteria) -> Bool

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

/// A pausable schedule of dates updating at a frequency no more quickly than
/// the provided interval.
///
/// You can also use ``TimelineSchedule/animation(minimumInterval:paused:)`` to
/// construct this schedule.
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public struct AnimationTimelineSchedule : TimelineSchedule, Sendable {

    /// Create a pausable schedule of dates updating at a frequency no more
    /// quickly than the provided interval.
    ///
    /// - Parameters:
    ///     - minimumInterval: The minimum interval to update the schedule at.
    ///     Pass nil to let the system pick an appropriate update interval.
    ///     - paused: If the schedule should stop generating updates.
    public init(minimumInterval: Double? = nil, paused: Bool = false)

    /// Returns entries at the frequency of the animation schedule.
    ///
    /// When in `.lowFrequency` mode, return no entries, effectively pausing the animation.
    public func entries(from start: Date, mode: TimelineScheduleMode) -> AnimationTimelineSchedule.Entries

    /// The sequence of dates within a schedule.
    ///
    /// The ``TimelineSchedule/entries(from:mode:)`` method returns a value
    /// of this type, which is a
    /// <doc://com.apple.documentation/documentation/Swift/Sequence>
    /// of dates in ascending order. A ``TimelineView`` that you create with a
    /// schedule updates its content at the moments in time corresponding to
    /// the dates included in the sequence.
    public struct Entries : Sequence, IteratorProtocol, Sendable {

        /// Advances to the next element and returns it, or `nil` if no next element
        /// exists.
        ///
        /// Repeatedly calling this method returns, in order, all the elements of the
        /// underlying sequence. As soon as the sequence has run out of elements, all
        /// subsequent calls return `nil`.
        ///
        /// You must not call this method if any other copy of this iterator has been
        /// advanced with a call to its `next()` method.
        ///
        /// The following example shows how an iterator can be used explicitly to
        /// emulate a `for`-`in` loop. First, retrieve a sequence's iterator, and
        /// then call the iterator's `next()` method until it returns `nil`.
        ///
        ///     let numbers = [2, 3, 5, 7]
        ///     var numbersIterator = numbers.makeIterator()
        ///
        ///     while let num = numbersIterator.next() {
        ///         print(num)
        ///     }
        ///     // Prints "2"
        ///     // Prints "3"
        ///     // Prints "5"
        ///     // Prints "7"
        ///
        /// - Returns: The next element in the underlying sequence, if a next element
        ///   exists; otherwise, `nil`.
        public mutating func next() -> Date?

        /// A type representing the sequence's elements.
        @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
        public typealias Element = Date

        /// A type that provides the sequence's iteration interface and
        /// encapsulates its iteration state.
        @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
        public typealias Iterator = AnimationTimelineSchedule.Entries
    }
}

/// A type-erased scroll target behavior.
///
/// Provide this to the ``View/scrollTargetBehavior(_:)`` modifier. When the
/// underlying behavior changes, the scroll view to which this behavior applies
/// will be updated.
///
/// Use this to dynamically control the scroll target behavior at runtime.
/// For example, you could provide a paging behavior in compact size classes
/// and a view aligned behavior otherwise.
///
///     @Environment(\.horizontalSizeClass) var sizeClass
///
///     var body: some View {
///         ScrollView { ... }
///             .scrollTargetBehavior(scrollTargetBehavior)
///     }
///
///      var scrollTargetBehavior: some ScrollTargetBehavior {
///         sizeClass == .compact
///             ? AnyScrollTargetBehavior(.paging)
///             : AnyScrollTargetBehavior(.viewAligned)
///     }
///
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
@frozen public struct AnyScrollTargetBehavior : ScrollTargetBehavior {

    /// The type-erased scroll target behavior.
    public var base: (any ScrollTargetBehavior)

    /// Creates a new type-erase scroll target behavior.
    @inlinable public init(_ base: some ScrollTargetBehavior)

    /// Updates the proposed target that a scrollable view should scroll to.
    ///
    /// The system calls this method in two main cases:
    /// - When a scroll gesture ends, it calculates where it would naturally
    ///   scroll to using its deceleration rate. The system
    ///   provides this calculated value as the target of this method.
    /// - When a scrollable view's size changes, it calculates where it should
    ///   be scrolled given the new size and provides this calculates value
    ///   as the target of this method.
    ///
    /// You can implement this method to override the calculated target
    /// which will have the scrollable view scroll to a different position
    /// than it would otherwise.
    @inlinable public func updateTarget(_ target: inout ScrollTarget, context: AnyScrollTargetBehavior.TargetContext)
}

/// Type erased tab content.
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct AnyTabContent<SelectionValue> : TabContent where SelectionValue : Hashable {

    /// The type used to drive selection for the containing tab view.
    public typealias TabValue = SelectionValue

    /// Create an instance that type-erases `tabContent`.
    public init<T>(_ tabContent: T) where SelectionValue == T.TabValue, T : TabContent

    /// The type of content representing the body of this content type.
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias Body = AnyTabContent<SelectionValue>
}

/// A type that represents the structure and behavior of an app.
///
/// Create an app by declaring a structure that conforms to the `App` protocol.
/// Implement the required ``SwiftUI/App/body-swift.property`` computed property
/// to define the app's content:
///
///     @main
///     struct MyApp: App {
///         var body: some Scene {
///             WindowGroup {
///                 Text("Hello, world!")
///             }
///         }
///     }
///
/// Precede the structure's declaration with the
/// [@main](https://docs.swift.org/swift-book/ReferenceManual/Attributes.html#ID626)
/// attribute to indicate that your custom `App` protocol conformer provides the
/// entry point into your app. The protocol provides a default implementation of
/// the ``SwiftUI/App/main()`` method that the system calls to launch your app.
/// You can have exactly one entry point among all of your app's files.
///
/// Compose the app's body from instances that conform to the ``SwiftUI/Scene``
/// protocol. Each scene contains the root view of a view hierarchy and has a
/// life cycle managed by the system. SwiftUI provides some concrete scene types
/// to handle common scenarios, like for displaying documents or settings. You
/// can also create custom scenes.
///
///     @main
///     struct Mail: App {
///         var body: some Scene {
///             WindowGroup {
///                 MailViewer()
///             }
///             Settings {
///                 SettingsView()
///             }
///         }
///     }
///
/// You can declare state in your app to share across all of its scenes. For
/// example, you can use the ``SwiftUI/StateObject`` attribute to initialize a
/// data model, and then provide that model on a view input as an
/// ``SwiftUI/ObservedObject`` or through the environment as an
/// ``SwiftUI/EnvironmentObject`` to scenes in the app:
///
///     @main
///     struct Mail: App {
///         @StateObject private var model = MailModel()
///
///         var body: some Scene {
///             WindowGroup {
///                 MailViewer()
///                     .environmentObject(model) // Passed through the environment.
///             }
///             Settings {
///                 SettingsView(model: model) // Passed as an observed object.
///             }
///         }
///     }
///
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
@MainActor @preconcurrency public protocol App {

    /// The type of scene representing the content of the app.
    ///
    /// When you create a custom app, Swift infers this type from your
    /// implementation of the required ``SwiftUI/App/body-swift.property``
    /// property.
    associatedtype Body : Scene

    /// The content and behavior of the app.
    ///
    /// For any app that you create, provide a computed `body` property that
    /// defines your app's scenes, which are instances that conform to the
    /// ``SwiftUI/Scene`` protocol. For example, you can create a simple app
    /// with a single scene containing a single view:
    ///
    ///     @main
    ///     struct MyApp: App {
    ///         var body: some Scene {
    ///             WindowGroup {
    ///                 Text("Hello, world!")
    ///             }
    ///         }
    ///     }
    ///
    /// Swift infers the app's ``SwiftUI/App/Body-swift.associatedtype``
    /// associated type based on the scene provided by the `body` property.
    @SceneBuilder @MainActor @preconcurrency var body: Self.Body { get }

    /// Creates an instance of the app using the body that you define for its
    /// content.
    ///
    /// Swift synthesizes a default initializer for structures that don't
    /// provide one. You typically rely on the default initializer for
    /// your app.
    @MainActor @preconcurrency init()
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension App {

    /// Initializes and runs the app.
    ///
    /// If you precede your ``SwiftUI/App`` conformer's declaration with the
    /// [@main](https://docs.swift.org/swift-book/ReferenceManual/Attributes.html#ID626)
    /// attribute, the system calls the conformer's `main()` method to launch
    /// the app. SwiftUI provides a
    /// default implementation of the method that manages the launch process in
    /// a platform-appropriate way.
    @MainActor @preconcurrency public static func main()
}

/// A property wrapper type that reflects a value from `UserDefaults` and
/// invalidates a view on a change in value in that user default.
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
@frozen @propertyWrapper public struct AppStorage<Value> : DynamicProperty {

    public var wrappedValue: Value { get nonmutating set }

    public var projectedValue: Binding<Value> { get }
}

@available(iOS 17.0, macOS 14.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension AppStorage {

    /// Creates a property that can save and restore table column state.
    ///
    /// Table column state is typically not bound from a table directly to
    /// `AppStorage`, but instead indirecting through `State` or `SceneStorage`,
    /// and using the app storage value as its initial value kept up to date
    /// on changes to the direct backing.
    ///
    /// - Parameters:
    ///   - wrappedValue: The default value if table column state is not
    ///   available for the given key.
    ///   - key: The key to read and write the value to in the user defaults
    ///     store.
    ///   - store: The user defaults store to read and write to. A value
    ///     of `nil` will use the user default store from the environment.
    public init<RowValue>(wrappedValue: Value = TableColumnCustomization<RowValue>(), _ key: String, store: UserDefaults? = nil) where Value == TableColumnCustomization<RowValue>, RowValue : Identifiable
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension AppStorage : Sendable where Value : Sendable {
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension AppStorage {

    /// Creates a property that can read and write to a boolean user default.
    ///
    /// - Parameters:
    ///   - wrappedValue: The default value if a boolean value is not specified
    ///     for the given key.
    ///   - key: The key to read and write the value to in the user defaults
    ///     store.
    ///   - store: The user defaults store to read and write to. A value
    ///     of `nil` will use the user default store from the environment.
    public init(wrappedValue: Value, _ key: String, store: UserDefaults? = nil) where Value == Bool

    /// Creates a property that can read and write to an integer user default.
    ///
    /// - Parameters:
    ///   - wrappedValue: The default value if an integer value is not specified
    ///     for the given key.
    ///   - key: The key to read and write the value to in the user defaults
    ///     store.
    ///   - store: The user defaults store to read and write to. A value
    ///     of `nil` will use the user default store from the environment.
    public init(wrappedValue: Value, _ key: String, store: UserDefaults? = nil) where Value == Int

    /// Creates a property that can read and write to a double user default.
    ///
    /// - Parameters:
    ///   - wrappedValue: The default value if a double value is not specified
    ///     for the given key.
    ///   - key: The key to read and write the value to in the user defaults
    ///     store.
    ///   - store: The user defaults store to read and write to. A value
    ///     of `nil` will use the user default store from the environment.
    public init(wrappedValue: Value, _ key: String, store: UserDefaults? = nil) where Value == Double

    /// Creates a property that can read and write to a string user default.
    ///
    /// - Parameters:
    ///   - wrappedValue: The default value if a string value is not specified
    ///     for the given key.
    ///   - key: The key to read and write the value to in the user defaults
    ///     store.
    ///   - store: The user defaults store to read and write to. A value
    ///     of `nil` will use the user default store from the environment.
    public init(wrappedValue: Value, _ key: String, store: UserDefaults? = nil) where Value == String

    /// Creates a property that can read and write to a url user default.
    ///
    /// - Parameters:
    ///   - wrappedValue: The default value if a url value is not specified for
    ///     the given key.
    ///   - key: The key to read and write the value to in the user defaults
    ///     store.
    ///   - store: The user defaults store to read and write to. A value
    ///     of `nil` will use the user default store from the environment.
    public init(wrappedValue: Value, _ key: String, store: UserDefaults? = nil) where Value == URL

    /// Creates a property that can read and write to a date user default.
    ///
    /// - Parameters:
    ///   - wrappedValue: The default value if a date value is not specified for
    ///     the given key.
    ///   - key: The key to read and write the value to in the user defaults
    ///     store.
    ///   - store: The user defaults store to read and write to. A value
    ///     of `nil` will use the user default store from the environment.
    @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
    public init(wrappedValue: Value, _ key: String, store: UserDefaults? = nil) where Value == Date

    /// Creates a property that can read and write to a user default as data.
    ///
    /// Avoid storing large data blobs in user defaults, such as image data,
    /// as it can negatively affect performance of your app. On tvOS, a
    /// `NSUserDefaultsSizeLimitExceededNotification` notification is posted
    /// if the total user default size reaches 512kB.
    ///
    /// - Parameters:
    ///   - wrappedValue: The default value if a data value is not specified for
    ///    the given key.
    ///   - key: The key to read and write the value to in the user defaults
    ///     store.
    ///   - store: The user defaults store to read and write to. A value
    ///     of `nil` will use the user default store from the environment.
    public init(wrappedValue: Value, _ key: String, store: UserDefaults? = nil) where Value == Data

    /// Creates a property that can read and write to an integer user default,
    /// transforming that to `RawRepresentable` data type.
    ///
    /// A common usage is with enumerations:
    ///
    ///     enum MyEnum: Int {
    ///         case a
    ///         case b
    ///         case c
    ///     }
    ///     struct MyView: View {
    ///         @AppStorage("MyEnumValue") private var value = MyEnum.a
    ///         var body: some View { ... }
    ///     }
    ///
    /// - Parameters:
    ///   - wrappedValue: The default value if an integer value
    ///     is not specified for the given key.
    ///   - key: The key to read and write the value to in the user defaults
    ///     store.
    ///   - store: The user defaults store to read and write to. A value
    ///     of `nil` will use the user default store from the environment.
    public init(wrappedValue: Value, _ key: String, store: UserDefaults? = nil) where Value : RawRepresentable, Value.RawValue == Int

    /// Creates a property that can read and write to a string user default,
    /// transforming that to `RawRepresentable` data type.
    ///
    /// A common usage is with enumerations:
    ///
    ///     enum MyEnum: String {
    ///         case a
    ///         case b
    ///         case c
    ///     }
    ///     struct MyView: View {
    ///         @AppStorage("MyEnumValue") private var value = MyEnum.a
    ///         var body: some View { ... }
    ///     }
    ///
    /// - Parameters:
    ///   - wrappedValue: The default value if a string value
    ///     is not specified for the given key.
    ///   - key: The key to read and write the value to in the user defaults
    ///     store.
    ///   - store: The user defaults store to read and write to. A value
    ///     of `nil` will use the user default store from the environment.
    public init(wrappedValue: Value, _ key: String, store: UserDefaults? = nil) where Value : RawRepresentable, Value.RawValue == String
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension AppStorage where Value : ExpressibleByNilLiteral {

    /// Creates a property that can read and write an Optional boolean user
    /// default.
    ///
    /// Defaults to nil if there is no restored value.
    ///
    /// - Parameters:
    ///   - key: The key to read and write the value to in the user defaults
    ///     store.
    ///   - store: The user defaults store to read and write to. A value
    ///     of `nil` will use the user default store from the environment.
    public init(_ key: String, store: UserDefaults? = nil) where Value == Bool?

    /// Creates a property that can read and write an Optional integer user
    /// default.
    ///
    /// Defaults to nil if there is no restored value.
    ///
    /// - Parameters:
    ///   - key: The key to read and write the value to in the user defaults
    ///     store.
    ///   - store: The user defaults store to read and write to. A value
    ///     of `nil` will use the user default store from the environment.
    public init(_ key: String, store: UserDefaults? = nil) where Value == Int?

    /// Creates a property that can read and write an Optional double user
    /// default.
    ///
    /// Defaults to nil if there is no restored value.
    ///
    /// - Parameters:
    ///   - key: The key to read and write the value to in the user defaults
    ///     store.
    ///   - store: The user defaults store to read and write to. A value
    ///     of `nil` will use the user default store from the environment.
    public init(_ key: String, store: UserDefaults? = nil) where Value == Double?

    /// Creates a property that can read and write an Optional string user
    /// default.
    ///
    /// Defaults to nil if there is no restored value.
    ///
    /// - Parameters:
    ///   - key: The key to read and write the value to in the user defaults
    ///     store.
    ///   - store: The user defaults store to read and write to. A value
    ///     of `nil` will use the user default store from the environment.
    public init(_ key: String, store: UserDefaults? = nil) where Value == String?

    /// Creates a property that can read and write an Optional URL user
    /// default.
    ///
    /// Defaults to nil if there is no restored value.
    ///
    /// - Parameters:
    ///   - key: The key to read and write the value to in the user defaults
    ///     store.
    ///   - store: The user defaults store to read and write to. A value
    ///     of `nil` will use the user default store from the environment.
    public init(_ key: String, store: UserDefaults? = nil) where Value == URL?

    /// Creates a property that can read and write an Optional Date user
    /// default.
    ///
    /// Defaults to nil if there is no restored value.
    ///
    /// - Parameters:
    ///   - key: The key to read and write the value to in the user defaults
    ///     store.
    ///   - store: The user defaults store to read and write to. A value
    ///     of `nil` will use the user default store from the environment.
    @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
    public init(_ key: String, store: UserDefaults? = nil) where Value == Date?

    /// Creates a property that can read and write an Optional data user
    /// default.
    ///
    /// Defaults to nil if there is no restored value.
    ///
    /// - Parameters:
    ///   - key: The key to read and write the value to in the user defaults
    ///     store.
    ///   - store: The user defaults store to read and write to. A value
    ///     of `nil` will use the user default store from the environment.
    public init(_ key: String, store: UserDefaults? = nil) where Value == Data?
}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension AppStorage {

    /// Creates a property that can save and restore an Optional string,
    /// transforming it to an Optional `RawRepresentable` data type.
    ///
    /// Defaults to nil if there is no restored value
    ///
    /// A common usage is with enumerations:
    ///
    ///     enum MyEnum: String {
    ///         case a
    ///         case b
    ///         case c
    ///     }
    ///     struct MyView: View {
    ///         @AppStorage("MyEnumValue") private var value: MyEnum?
    ///         var body: some View { ... }
    ///     }
    ///
    /// - Parameters:
    ///   - key: The key to read and write the value to in the user defaults
    ///     store.
    ///   - store: The user defaults store to read and write to. A value
    ///     of `nil` will use the user default store from the environment.
    public init<R>(_ key: String, store: UserDefaults? = nil) where Value == R?, R : RawRepresentable, R.RawValue == String

    /// Creates a property that can save and restore an Optional integer,
    /// transforming it to an Optional `RawRepresentable` data type.
    ///
    /// Defaults to nil if there is no restored value
    ///
    /// A common usage is with enumerations:
    ///
    ///     enum MyEnum: Int {
    ///         case a
    ///         case b
    ///         case c
    ///     }
    ///     struct MyView: View {
    ///         @AppStorage("MyEnumValue") private var value: MyEnum?
    ///         var body: some View { ... }
    ///     }
    ///
    /// - Parameters:
    ///   - key: The key to read and write the value to in the user defaults
    ///     store.
    ///   - store: The user defaults store to read and write to. A value
    ///     of `nil` will use the user default store from the environment.
    public init<R>(_ key: String, store: UserDefaults? = nil) where Value == R?, R : RawRepresentable, R.RawValue == Int
}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension AppStorage {

    /// Creates a property that can save and restore a toolbarLabelStyle state.
    ///
    /// - Parameters:
    ///   - wrappedValue: The default value if toolbarLabelStyle state is not
    ///   available for the given key.
    ///   - key: The key to read and write the value to in the user defaults
    ///     store.
    ///   - store: The user defaults store to read and write to. A value
    ///     of `nil` will use the user default store from the environment.
    public init(wrappedValue: Value = ToolbarLabelStyle.automatic, _ key: String, store: UserDefaults? = nil) where Value == ToolbarLabelStyle
}

@available(iOS 18.0, macOS 15.0, visionOS 2.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension AppStorage {

    /// Creates a property that can save and restore tab sidebar customizations.
    ///
    /// You can set this customization on the TabView using
    /// ``View/tabViewCustomization(_:)``.
    ///
    /// - Parameters:
    ///   - wrappedValue: The default value if the customization is not
    ///   available for the given key.
    ///   - key: The key to read and write the value to in the user defaults
    ///     store.
    ///   - store: The user defaults store to read and write to. A value
    ///     of `nil` will use the user default store from the environment.
    public init(wrappedValue: Value = TabViewCustomization(), _ key: String, store: UserDefaults? = nil) where Value == TabViewCustomization
}

/// A view that asynchronously loads and displays an image.
///
/// This view uses the shared
/// <doc://com.apple.documentation/documentation/Foundation/URLSession>
/// instance to load an image from the specified URL, and then display it.
/// For example, you can display an icon that's stored on a server:
///
///     AsyncImage(url: URL(string: "https://example.com/icon.png"))
///         .frame(width: 200, height: 200)
///
/// Until the image loads, the view displays a standard placeholder that
/// fills the available space. After the load completes successfully, the view
/// updates to display the image. In the example above, the icon is smaller
/// than the frame, and so appears smaller than the placeholder.
///
/// ![A diagram that shows a grey box on the left, the SwiftUI icon on the
/// right, and an arrow pointing from the first to the second. The icon
/// is about half the size of the grey box.](AsyncImage-1)
///
/// You can specify a custom placeholder using
/// ``init(url:scale:content:placeholder:)``. With this initializer, you can
/// also use the `content` parameter to manipulate the loaded image.
/// For example, you can add a modifier to make the loaded image resizable:
///
///     AsyncImage(url: URL(string: "https://example.com/icon.png")) { image in
///         image.resizable()
///     } placeholder: {
///         ProgressView()
///     }
///     .frame(width: 50, height: 50)
///
/// For this example, SwiftUI shows a ``ProgressView`` first, and then the
/// image scaled to fit in the specified frame:
///
/// ![A diagram that shows a progress view on the left, the SwiftUI icon on the
/// right, and an arrow pointing from the first to the second.](AsyncImage-2)
///
/// > Important: You can't apply image-specific modifiers, like
/// ``Image/resizable(capInsets:resizingMode:)``, directly to an `AsyncImage`.
/// Instead, apply them to the ``Image`` instance that your `content`
/// closure gets when defining the view's appearance.
///
/// To gain more control over the loading process, use the
/// ``init(url:scale:transaction:content:)`` initializer, which takes a
/// `content` closure that receives an ``AsyncImagePhase`` to indicate
/// the state of the loading operation. Return a view that's appropriate
/// for the current phase:
///
///     AsyncImage(url: URL(string: "https://example.com/icon.png")) { phase in
///         if let image = phase.image {
///             image // Displays the loaded image.
///         } else if phase.error != nil {
///             Color.red // Indicates an error.
///         } else {
///             Color.blue // Acts as a placeholder.
///         }
///     }
///
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public struct AsyncImage<Content> : View where Content : View {

    /// Loads and displays an image from the specified URL.
    ///
    /// Until the image loads, SwiftUI displays a default placeholder. When
    /// the load operation completes successfully, SwiftUI updates the
    /// view to show the loaded image. If the operation fails, SwiftUI
    /// continues to display the placeholder. The following example loads
    /// and displays an icon from an example server:
    ///
    ///     AsyncImage(url: URL(string: "https://example.com/icon.png"))
    ///
    /// If you want to customize the placeholder or apply image-specific
    /// modifiers --- like ``Image/resizable(capInsets:resizingMode:)`` ---
    /// to the loaded image, use the ``init(url:scale:content:placeholder:)``
    /// initializer instead.
    ///
    /// - Parameters:
    ///   - url: The URL of the image to display.
    ///   - scale: The scale to use for the image. The default is `1`. Set a
    ///     different value when loading images designed for higher resolution
    ///     displays. For example, set a value of `2` for an image that you
    ///     would name with the `@2x` suffix if stored in a file on disk.
    public init(url: URL?, scale: CGFloat = 1) where Content == Image

    /// Loads and displays a modifiable image from the specified URL using
    /// a custom placeholder until the image loads.
    ///
    /// Until the image loads, SwiftUI displays the placeholder view that
    /// you specify. When the load operation completes successfully, SwiftUI
    /// updates the view to show content that you specify, which you
    /// create using the loaded image. For example, you can show a green
    /// placeholder, followed by a tiled version of the loaded image:
    ///
    ///     AsyncImage(url: URL(string: "https://example.com/icon.png")) { image in
    ///         image.resizable(resizingMode: .tile)
    ///     } placeholder: {
    ///         Color.green
    ///     }
    ///
    /// If the load operation fails, SwiftUI continues to display the
    /// placeholder. To be able to display a different view on a load error,
    /// use the ``init(url:scale:transaction:content:)`` initializer instead.
    ///
    /// - Parameters:
    ///   - url: The URL of the image to display.
    ///   - scale: The scale to use for the image. The default is `1`. Set a
    ///     different value when loading images designed for higher resolution
    ///     displays. For example, set a value of `2` for an image that you
    ///     would name with the `@2x` suffix if stored in a file on disk.
    ///   - content: A closure that takes the loaded image as an input, and
    ///     returns the view to show. You can return the image directly, or
    ///     modify it as needed before returning it.
    ///   - placeholder: A closure that returns the view to show until the
    ///     load operation completes successfully.
    public init<I, P>(url: URL?, scale: CGFloat = 1, @ViewBuilder content: @escaping (Image) -> I, @ViewBuilder placeholder: @escaping () -> P) where Content == _ConditionalContent<I, P>, I : View, P : View

    /// Loads and displays a modifiable image from the specified URL in phases.
    ///
    /// If you set the asynchronous image's URL to `nil`, or after you set the
    /// URL to a value but before the load operation completes, the phase is
    /// ``AsyncImagePhase/empty``. After the operation completes, the phase
    /// becomes either ``AsyncImagePhase/failure(_:)`` or
    /// ``AsyncImagePhase/success(_:)``. In the first case, the phase's
    /// ``AsyncImagePhase/error`` value indicates the reason for failure.
    /// In the second case, the phase's ``AsyncImagePhase/image`` property
    /// contains the loaded image. Use the phase to drive the output of the
    /// `content` closure, which defines the view's appearance:
    ///
    ///     AsyncImage(url: URL(string: "https://example.com/icon.png")) { phase in
    ///         if let image = phase.image {
    ///             image // Displays the loaded image.
    ///         } else if phase.error != nil {
    ///             Color.red // Indicates an error.
    ///         } else {
    ///             Color.blue // Acts as a placeholder.
    ///         }
    ///     }
    ///
    /// To add transitions when you change the URL, apply an identifier to the
    /// ``AsyncImage``.
    ///
    /// - Parameters:
    ///   - url: The URL of the image to display.
    ///   - scale: The scale to use for the image. The default is `1`. Set a
    ///     different value when loading images designed for higher resolution
    ///     displays. For example, set a value of `2` for an image that you
    ///     would name with the `@2x` suffix if stored in a file on disk.
    ///   - transaction: The transaction to use when the phase changes.
    ///   - content: A closure that takes the load phase as an input, and
    ///     returns the view to display for the specified phase.
    public init(url: URL?, scale: CGFloat = 1, transaction: Transaction = Transaction(), @ViewBuilder content: @escaping (AsyncImagePhase) -> Content)

    /// The content and behavior of the view.
    ///
    /// When you implement a custom view, you must implement a computed
    /// `body` property to provide the content for your view. Return a view
    /// that's composed of built-in views that SwiftUI provides, plus other
    /// composite views that you've already defined:
    ///
    ///     struct MyView: View {
    ///         var body: some View {
    ///             Text("Hello, World!")
    ///         }
    ///     }
    ///
    /// For more information about composing views and a view hierarchy,
    /// see <doc:Declaring-a-Custom-View>.
    @MainActor @preconcurrency public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias Body = some View
}

/// The current phase of the asynchronous image loading operation.
///
/// When you create an ``AsyncImage`` instance with the
/// ``AsyncImage/init(url:scale:transaction:content:)`` initializer, you define
/// the appearance of the view using a `content` closure. SwiftUI calls the
/// closure with a phase value at different points during the load operation
/// to indicate the current state. Use the phase to decide what to draw.
/// For example, you can draw the loaded image if it exists, a view that
/// indicates an error, or a placeholder:
///
///     AsyncImage(url: URL(string: "https://example.com/icon.png")) { phase in
///         if let image = phase.image {
///             image // Displays the loaded image.
///         } else if phase.error != nil {
///             Color.red // Indicates an error.
///         } else {
///             Color.blue // Acts as a placeholder.
///         }
///     }
///
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public enum AsyncImagePhase : Sendable {

    /// No image is loaded.
    case empty

    /// An image succesfully loaded.
    case success(Image)

    /// An image failed to load with an error.
    case failure(any Error)

    /// The loaded image, if any.
    ///
    /// If this value isn't `nil`, the image load operation has finished,
    /// and you can use the image to update the view. You can use the image
    /// directly, or you can modify it in some way. For example, you can add
    /// a ``Image/resizable(capInsets:resizingMode:)`` modifier to make the
    /// image resizable.
    public var image: Image? { get }

    /// The error that occurred when attempting to load an image, if any.
    public var error: (any Error)? { get }
}

/// The default control group style.
///
/// You can also use ``ControlGroupStyle/automatic`` to construct this style.
@available(iOS 15.0, macOS 12.0, tvOS 17.0, *)
@available(watchOS, unavailable)
public struct AutomaticControlGroupStyle : ControlGroupStyle {

    /// Creates a view representing the body of a control group.
    ///
    /// - Parameter configuration: The properties of the control group instance
    ///   being created.
    ///
    /// This method will be called for each instance of ``ControlGroup`` created
    /// within a view hierarchy where this style is the current
    /// `ControlGroupStyle`.
    @MainActor @preconcurrency public func makeBody(configuration: AutomaticControlGroupStyle.Configuration) -> some View


    /// A view representing the body of a control group.
    @available(iOS 15.0, tvOS 17.0, macOS 12.0, *)
    @available(watchOS, unavailable)
    public typealias Body = some View
}

/// A disclosure group style that resolves its appearance automatically
/// based on the current context.
///
/// Use ``DisclosureGroupStyle/automatic`` to construct this style.
@available(iOS 16.0, macOS 13.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@MainActor @preconcurrency public struct AutomaticDisclosureGroupStyle : DisclosureGroupStyle {

    /// Creates an automatic disclosure group style.
    @MainActor @preconcurrency public init()

    /// Creates a view that represents the body of a disclosure group.
    ///
    /// SwiftUI calls this method for each instance of ``DisclosureGroup``
    /// that you create within a view hierarchy where this style is the current
    /// ``DisclosureGroupStyle``.
    ///
    /// - Parameter configuration: The properties of the instance being created.
    @MainActor @preconcurrency public func makeBody(configuration: AutomaticDisclosureGroupStyle.Configuration) -> some View


    /// A view that represents the body of a disclosure group.
    @available(iOS 16.0, macOS 13.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias Body = some View
}

/// The default form style.
///
/// Use the ``FormStyle/automatic`` static variable to create this style:
///
///     Form {
///        ...
///     }
///     .formStyle(.automatic)
///
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct AutomaticFormStyle : FormStyle {

    /// Creates a default form style.
    ///
    /// Don't call this initializer directly. Instead, use the
    /// ``FormStyle/automatic`` static variable to create this style:
    ///
    ///     Form {
    ///        ...
    ///     }
    ///     .formStyle(.automatic)
    ///
    public init()

    /// Creates a view that represents the body of a form.
    ///
    /// - Parameter configuration: The properties of the form.
    /// - Returns: A view that has behavior and appearance that enables it
    ///   to function as a ``Form``.
    @MainActor @preconcurrency public func makeBody(configuration: AutomaticFormStyle.Configuration) -> some View


    /// A view that represents the appearance and interaction of a form.
    @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
    public typealias Body = some View
}

/// The default hover effect based on the surrounding context.
///
/// The automatic effect will resolve to any ``View/defaultHoverEffect(_:)``
/// applied to the current View hierarchy, or a system-defined effect if
/// no default effect has been defined.
///
/// You can also use ``CustomHoverEffect/automatic`` to construct this hover
/// effect.
@available(iOS 18.0, tvOS 18.0, visionOS 2.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
public struct AutomaticHoverEffect : CustomHoverEffect {

    /// Creates an automatic hover effect.
    public init()

    /// Defines the effect produced by this effect.
    ///
    /// You implement this method to describe a custom effect to apply to a
    /// view. `content` is an empty effect you use to build your effect, which
    /// will later be applied to a View, or combined with other
    /// `CustomHoverEffect`s.
    ///
    /// - Parameter content: An empty effect you use to compose the custom
    ///   effect.
    /// - Returns: A custom effect.
    public func body(content: AutomaticHoverEffect.Content) -> some CustomHoverEffect


    /// The type of effect representing the body of this effect. When you create
    /// a custom effect, Swift infers this type from your implementation of the
    /// required ``CustomHoverEffect/body(content:)`` method.
    @available(iOS 18.0, tvOS 18.0, visionOS 2.0, *)
    @available(watchOS, unavailable)
    @available(macOS, unavailable)
    public typealias Body = some CustomHoverEffect
}

/// The default labeled content style.
///
/// Use ``LabeledContentStyle/automatic`` to construct this style.
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct AutomaticLabeledContentStyle : LabeledContentStyle {

    /// Creates an automatic labeled content style.
    public init()

    /// Creates a view that represents the body of labeled content.
    @MainActor @preconcurrency public func makeBody(configuration: AutomaticLabeledContentStyle.Configuration) -> some View


    /// A view that represents the appearance and behavior of labeled content.
    @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
    public typealias Body = some View
}

/// A navigation split style that resolves its appearance automatically
/// based on the current context.
///
/// Use ``NavigationSplitViewStyle/automatic`` to construct this style.
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
@MainActor @preconcurrency public struct AutomaticNavigationSplitViewStyle : NavigationSplitViewStyle {

    /// Creates an instance of the automatic navigation split view style.
    ///
    /// Use ``NavigationSplitViewStyle/automatic`` to construct this style.
    @MainActor @preconcurrency public init()

    /// Creates a view that represents the body of a navigation split view.
    ///
    /// SwiftUI calls this method for each instance of ``NavigationSplitView``,
    /// where this style is the current ``NavigationSplitViewStyle``.
    ///
    /// - Parameter configuration: The properties of the instance to create.
    @MainActor @preconcurrency public func makeBody(configuration: AutomaticNavigationSplitViewStyle.Configuration) -> some View


    /// A view that represents the body of a navigation split view.
    @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
    public typealias Body = some View
}

/// A style that automatically chooses the appropriate presentation
/// transition for the current context.
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct AutomaticNavigationTransition : NavigationTransition {
}

/// The default presentation sizing, appropriate for the platform.
///
/// - Seealso: ``PresentationSizing/automatic``
@available(iOS 18.0, macOS 15.0, tvOS 18.0, visionOS 2.0, watchOS 11.0, *)
public struct AutomaticPresentationSizing : PresentationSizing, Sendable {

    public func proposedSize(for root: PresentationSizingRoot, context: PresentationSizingContext) -> ProposedViewSize
}

/// The default table style in the current context.
///
/// You can also use ``TableStyle/automatic`` to construct this style.
@available(iOS 16.0, macOS 12.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct AutomaticTableStyle : TableStyle {

    /// Creates a view that represents the body of a table.
    ///
    /// The system calls this method for each ``Table`` instance in a view
    /// hierarchy where this style is the current table style.
    ///
    /// - Parameter configuration: The properties of the table.
    @MainActor @preconcurrency public func makeBody(configuration: AutomaticTableStyle.Configuration) -> some View


    /// A view that represents the body of a table.
    @available(iOS 16.0, macOS 12.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias Body = some View
}

/// The default text editor style, based on the text editor's context.
///
/// You can also use ``TextEditorStyle/automatic`` to construct this style.
@available(iOS 17.0, macOS 14.0, visionOS 1.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@MainActor @preconcurrency public struct AutomaticTextEditorStyle : TextEditorStyle {

    /// Creates a view that represents the body of a text editor.
    ///
    /// The system calls this method for each ``TextEditor`` instance in a view
    /// hierarchy where this style is the current text editor style.
    ///
    /// - Parameter configuration: The properties of the text editor.
    @MainActor @preconcurrency public func makeBody(configuration: AutomaticTextEditorStyle.Configuration) -> AutomaticTextEditorStyle.Body

    /// Creates an instance of the default text editor style.
    @MainActor @preconcurrency public init()

    /// A view that represents the body of a text editor.
    @MainActor @preconcurrency public struct Body : View {

        /// The content and behavior of the view.
        ///
        /// When you implement a custom view, you must implement a computed
        /// `body` property to provide the content for your view. Return a view
        /// that's composed of built-in views that SwiftUI provides, plus other
        /// composite views that you've already defined:
        ///
        ///     struct MyView: View {
        ///         var body: some View {
        ///             Text("Hello, World!")
        ///         }
        ///     }
        ///
        /// For more information about composing views and a view hierarchy,
        /// see <doc:Declaring-a-Custom-View>.
        @MainActor @preconcurrency public var body: some View { get }

        /// The type of view representing the body of this view.
        ///
        /// When you create a custom view, Swift infers this type from your
        /// implementation of the required ``View/body-swift.property`` property.
        @available(iOS 17.0, visionOS 1.0, macOS 14.0, *)
        @available(tvOS, unavailable)
        @available(watchOS, unavailable)
        public typealias Body = some View
    }
}

/// The kinds of background tasks that your app or extension can handle.
///
/// Use a value of this type with the ``Scene/backgroundTask(_:action:)`` scene
/// modifier to create a handler for background tasks that the system sends
/// to your app or extension. For example, you can use ``urlSession`` to define
/// an asynchronous closure that the system calls when it launches your app or
/// extension to handle a response from a background
/// <doc://com.apple.documentation/documentation/Foundation/URLSession>.
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct BackgroundTask<Request, Response> : Sendable {
}

@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension BackgroundTask {

    /// A task that responds to background URL sessions.
    public static var urlSession: BackgroundTask<String, Void> { get }

    /// A task that responds to background URL sessions matching the given
    /// identifier.
    ///
    /// - Parameter identifier: The identifier to match.
    ///
    /// - Returns: A background task that you can handle with your app or
    ///   extension.
    public static func urlSession(_ identifier: String) -> BackgroundTask<Void, Void>

    /// A task that responds to background URL sessions matching the given
    /// predicate.
    ///
    /// - Parameter matching: The predicate to match.
    ///
    /// - Returns: A background task that you can handle with your app or
    ///   extension.
    public static func urlSession(matching: @escaping @Sendable (String) -> Bool) -> BackgroundTask<String, Void>

    /// A task that updates your apps state in the background for a
    /// matching identifier.
    ///
    /// - Parameter matching: The identifier to match.
    ///
    /// - Returns: A background task that you can handle with your app or
    ///   extension.
    @available(macOS, unavailable)
    public static func appRefresh(_ identifier: String) -> BackgroundTask<Void, Void>
}

/// The visual prominence of a badge.
///
/// Badges can be used for different kinds of information, from the
/// passive number of items in a container to the number of required
/// actions. The prominence of badges in Lists can be adjusted to reflect
/// this and be made to draw more or less attention to themselves.
///
/// Badges will default to `standard` prominence unless specified.
///
/// The following example shows a ``List`` displaying a list of folders
/// with an informational badge with lower prominence, showing the number
/// of items in the folder.
///
///     List(folders) { folder in
///         Text(folder.name)
///             .badge(folder.numberOfItems)
///     }
///     .badgeProminence(.decreased)
///
@available(iOS 17.0, macOS 14.0, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
public struct BadgeProminence : Hashable, Sendable {

    /// The lowest level of prominence for a badge.
    ///
    /// This level or prominence should be used for badges that display a value
    /// of passive information that requires no user action, such as total
    /// number of messages or content.
    ///
    /// In lists on iOS and macOS, this results in badge labels being
    /// displayed without any extra decoration. On iOS, this looks the same as
    /// `.standard`.
    ///
    ///     List(folders) { folder in
    ///         Text(folder.name)
    ///             .badge(folder.numberOfItems)
    ///     }
    ///     .badgeProminence(.decreased)
    ///
    public static let decreased: BadgeProminence

    /// The standard level of prominence for a badge.
    ///
    /// This level of prominence should be used for badges that display a value
    /// that suggests user action, such as a count of unread messages or new
    /// invitations.
    ///
    /// In lists on macOS, this results in a badge label on a grayscale platter;
    /// and in lists on iOS, this prominence of badge has no platter.
    ///
    ///     List(mailboxes) { mailbox in
    ///         Text(mailbox.name)
    ///             .badge(mailbox.numberOfUnreadMessages)
    ///     }
    ///     .badgeProminence(.standard)
    ///
    public static let standard: BadgeProminence

    /// The highest level of prominence for a badge.
    ///
    /// This level of prominence should be used for badges that display a value
    /// that requires user action, such as number of updates or account errors.
    ///
    /// In lists on iOS and macOS, this results in badge labels being displayed
    /// on a red platter.
    ///
    ///     ForEach(accounts) { account in
    ///         Text(account.userName)
    ///             .badge(account.setupErrors)
    ///             .badgeProminence(.increased)
    ///     }
    ///
    public static let increased: BadgeProminence

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: BadgeProminence, b: BadgeProminence) -> Bool

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

/// A navigation split style that reduces the size of the detail content
/// to make room when showing the leading column or columns.
///
/// Use ``NavigationSplitViewStyle/balanced`` to construct this style.
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
@MainActor @preconcurrency public struct BalancedNavigationSplitViewStyle : NavigationSplitViewStyle {

    /// Creates an instance of ``BalancedNavigationSplitViewStyle``.
    ///
    /// You can also use ``NavigationSplitViewStyle/balanced`` to construct this
    /// style.
    @MainActor @preconcurrency public init()

    /// Creates a view that represents the body of a navigation split view.
    ///
    /// SwiftUI calls this method for each instance of ``NavigationSplitView``,
    /// where this style is the current ``NavigationSplitViewStyle``.
    ///
    /// - Parameter configuration: The properties of the instance to create.
    @MainActor @preconcurrency public func makeBody(configuration: BalancedNavigationSplitViewStyle.Configuration) -> some View


    /// A view that represents the body of a navigation split view.
    @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
    public typealias Body = some View
}

/// A button style that applies standard border artwork based on the button's
/// context.
///
/// You can also use ``PrimitiveButtonStyle/bordered`` to construct this style.
@available(iOS 15.0, macOS 10.15, tvOS 13.0, watchOS 7.0, *)
public struct BorderedButtonStyle : PrimitiveButtonStyle {

    /// Creates a bordered button style.
    public init()

    /// Creates a view that represents the body of a button.
    ///
    /// The system calls this method for each ``Button`` instance in a view
    /// hierarchy where this style is the current button style.
    ///
    /// - Parameter configuration: The properties of the button.
    @MainActor @preconcurrency public func makeBody(configuration: BorderedButtonStyle.Configuration) -> some View


    /// A view that represents the body of a button.
    @available(iOS 15.0, tvOS 13.0, watchOS 7.0, macOS 10.15, *)
    public typealias Body = some View
}

/// A button style that applies standard border prominent artwork based
/// on the button's context.
///
/// Use ``PrimitiveButtonStyle/borderedProminent`` to construct this style.
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public struct BorderedProminentButtonStyle : PrimitiveButtonStyle {

    /// Creates a bordered prominent button style.
    public init()

    /// Creates a view that represents the body of a button.
    ///
    /// The system calls this method for each ``Button`` instance in a view
    /// hierarchy where this style is the current button style.
    ///
    /// - Parameter configuration : The properties of the button.
    @MainActor @preconcurrency public func makeBody(configuration: BorderedProminentButtonStyle.Configuration) -> some View


    /// A view that represents the body of a button.
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias Body = some View
}

/// A menu style that displays a borderless button that toggles the display of
/// the menu's contents when pressed.
///
/// Use ``MenuStyle/borderlessButton`` to construct this style.
@available(iOS, introduced: 14.0, deprecated: 100000.0, message: "Use .menuStyle(.button) and .buttonStyle(.borderless).")
@available(macOS, introduced: 11.0, deprecated: 100000.0, message: "Use .menuStyle(.button) and .buttonStyle(.borderless).")
@available(tvOS, introduced: 17.0, deprecated: 100000.0, message: "Use .menuStyle(.button) and .buttonStyle(.borderless).")
@available(watchOS, unavailable)
@available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Use .menuStyle(.button) and .buttonStyle(.borderless).")
public struct BorderlessButtonMenuStyle : MenuStyle {

    /// Creates a borderless button menu style.
    public init()

    /// Creates a view that represents the body of a menu.
    ///
    /// - Parameter configuration: The properties of the menu.
    ///
    /// The system calls this method for each ``Menu`` instance in a view
    /// hierarchy where this style is the current menu style.
    @MainActor @preconcurrency public func makeBody(configuration: BorderlessButtonMenuStyle.Configuration) -> some View


    /// A view that represents the body of a menu.
    @available(iOS, introduced: 14.0, deprecated: 100000.0, message: "Use .menuStyle(.button) and .buttonStyle(.borderless).")
    @available(tvOS, introduced: 17.0, deprecated: 100000.0, message: "Use .menuStyle(.button) and .buttonStyle(.borderless).")
    @available(watchOS, unavailable, message: "Use .menuStyle(.button) and .buttonStyle(.borderless).")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Use .menuStyle(.button) and .buttonStyle(.borderless).")
    @available(macOS, introduced: 11.0, deprecated: 100000.0, message: "Use .menuStyle(.button) and .buttonStyle(.borderless).")
    public typealias Body = some View
}

/// A button style that doesn't apply a border.
///
/// You can also use ``PrimitiveButtonStyle/borderless`` to construct this
/// style.
@available(iOS 13.0, macOS 10.15, tvOS 17.0, watchOS 8.0, *)
public struct BorderlessButtonStyle : PrimitiveButtonStyle {

    /// Creates a borderless button style.
    public init()

    /// Creates a view that represents the body of a button.
    ///
    /// The system calls this method for each ``Button`` instance in a view
    /// hierarchy where this style is the current button style.
    ///
    /// - Parameter configuration : The properties of the button.
    @MainActor @preconcurrency public func makeBody(configuration: BorderlessButtonStyle.Configuration) -> some View


    /// A view that represents the body of a button.
    @available(iOS 13.0, tvOS 17.0, watchOS 8.0, macOS 10.15, *)
    public typealias Body = some View
}

/// A control that initiates an action.
///
/// You create a button by providing an action and a label. The action is either
/// a method or closure property that does something when a user clicks or taps
/// the button. The label is a view that describes the button's action --- for
/// example, by showing text, an icon, or both.
///
/// The label of a button can be any kind of view, such as a ``Text`` view for
/// text-only labels:
///
///     Button(action: signIn) {
///         Text("Sign In")
///     }
///
/// Or a ``Label`` view, for buttons with both a title and an icon:
///
///     Button(action: signIn) {
///         Label("Sign In", systemImage: "arrow.up")
///     }
///
/// For those common cases, you can also use the convenience initializers that
/// take a title string or ``LocalizedStringKey`` as their first parameter, and
/// optionally a system image name or `ImageResource` as their second parameter,
/// instead of a trailing closure:
///
///     Button("Sign In", systemImage: "arrow.up", action: signIn)
///
/// Prefer to use these convenience initializers, or a ``Label`` view, when
/// providing both a title and an icon. This allows the button to dynamically
/// adapt its appearance to render its title and icon correctly in containers
/// such as toolbars and menus. For example, on iOS, buttons only display their
/// icons by default when placed in toolbars, but show both a leading title and
/// trailing icon in menus. Defining labels this way also helps with
/// accessibility --- for example, applying the ``View/labelStyle(_:)`` modifier
/// with an ``LabelStyle/iconOnly`` style to the button will cause it to only
/// visually display its icon, but still use its title to describe the button in
/// accessibility modes like VoiceOver:
///
///     Button("Sign In", systemImage: "arrow.up", action: signIn)
///         .labelStyle(.iconOnly)
///
/// Avoid labels that only use images or exclusively visual components without
/// an accessibility label.
///
/// How the user activates the button varies by platform:
/// - In iOS and watchOS, the user taps the button.
/// - In macOS, the user clicks the button.
/// - In tvOS, the user presses "select" on an
///   external remote, like the Siri Remote, while focusing on the button.
///
/// The appearance of the button depends on factors like where you
/// place it, whether you assign it a role, and how you style it.
///
/// ### Adding buttons to containers
///
/// Use buttons for any user interface element that initiates an action.
/// Buttons automatically adapt their visual style to match the expected style
/// within these different containers and contexts. For example, to create a
/// ``List`` cell that initiates an action when selected by the user, add a
/// button to the list's content:
///
///     List {
///         // Cells that show all the current folders.
///         ForEach(folders) { folder in
///             Text(folder.title)
///         }
///
///         // A cell that, when selected, adds a new folder.
///         Button(action: addItem) {
///             Label("Add Folder", systemImage: "folder.badge.plus")
///         }
///     }
///
/// ![A screenshot of a list of four items. The first three items use a
/// grayscale foreground color and have the text Documents, Downloads,
/// and Recents. The last item has a blue foreground color and shows
/// a folder icon with the text Add Folder.](Button-1)
///
/// Similarly, to create a context menu item that initiates an action, add a
/// button to the ``View/contextMenu(_:)`` modifier's content closure:
///
///     .contextMenu {
///         Button("Cut", action: cut)
///         Button("Copy", action: copy)
///         Button("Paste", action: paste)
///     }
///
/// ![A screenshot of a context menu that contains the three items Cut, Copy,
/// and Paste.](Button-2)
///
/// This pattern extends to most other container views in SwiftUI that have
/// customizable, interactive content, like ``Form`` instances.
///
/// ### Assigning a role
///
/// You can optionally initialize a button with a ``ButtonRole`` that
/// characterizes the button's purpose. For example, you can create a
/// ``ButtonRole/destructive`` button for a deletion action:
///
///      Button("Delete", role: .destructive, action: delete)
///
/// The system uses the button's role to style the button appropriately
/// in every context. For example, a destructive button in a contextual menu
/// appears with a red foreground color:
///
/// ![A screenshot of a context menu that contains the four items Cut, Copy,
/// Paste, and Delete. The last item uses a foreground color of red.](Button-3)
///
/// If you don't specify a role for a button, the system applies an
/// appropriate default appearance.
///
/// ### Styling buttons
///
/// You can customize a button's appearance using one of the standard button
/// styles, like ``PrimitiveButtonStyle/bordered``, and apply the style with the
/// ``View/buttonStyle(_:)`` modifier:
///
///     HStack {
///         Button("Sign In", action: signIn)
///         Button("Register", action: register)
///     }
///     .buttonStyle(.bordered)
///
/// If you apply the style to a container view, as in the example above,
/// all the buttons in the container use the style:
///
/// ![A screenshot of two buttons, side by side, each with a capsule shaped
/// background. The label for the first button is Sign In; the right button is
/// Register.](Button-4)
///
/// You can also create custom styles. To add a custom appearance with
/// standard interaction behavior, create a style that conforms to the
/// ``ButtonStyle`` protocol. To customize both appearance and interaction
/// behavior, create a style that conforms to the ``PrimitiveButtonStyle``
/// protocol. Custom styles can also read the button's role and use it to
/// adjust the button's appearance.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public struct Button<Label> : View where Label : View {

    /// Creates a button that displays a custom label.
    ///
    /// - Parameters:
    ///   - action: The action to perform when the user triggers the button.
    ///   - label: A view that describes the purpose of the button's `action`.
    @preconcurrency public init(action: @escaping @MainActor () -> Void, @ViewBuilder label: () -> Label)

    /// The content and behavior of the view.
    ///
    /// When you implement a custom view, you must implement a computed
    /// `body` property to provide the content for your view. Return a view
    /// that's composed of built-in views that SwiftUI provides, plus other
    /// composite views that you've already defined:
    ///
    ///     struct MyView: View {
    ///         var body: some View {
    ///             Text("Hello, World!")
    ///         }
    ///     }
    ///
    /// For more information about composing views and a view hierarchy,
    /// see <doc:Declaring-a-Custom-View>.
    @MainActor @preconcurrency public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    public typealias Body = some View
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Button where Label == Text {

    /// Creates a button that generates its label from a localized string key.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the button's localized title, that describes
    ///     the purpose of the button's `action`.
    ///   - action: The action to perform when the user triggers the button.
    @preconcurrency nonisolated public init(_ titleKey: LocalizedStringKey, action: @escaping @MainActor () -> Void)

    /// Creates a button that generates its label from a string.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// title similar to ``Text/init(_:)``. See ``Text`` for more
    /// information about localizing strings.
    ///
    /// - Parameters:
    ///   - title: A string that describes the purpose of the button's `action`.
    ///   - action: The action to perform when the user triggers the button.
    @preconcurrency nonisolated public init<S>(_ title: S, action: @escaping @MainActor () -> Void) where S : StringProtocol
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension Button where Label == Label<Text, Image> {

    /// Creates a button that generates its label from a localized string key
    /// and system image name.
    ///
    /// This initializer creates a ``Label`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the button's localized title, that describes
    ///     the purpose of the button's `action`.
    ///   - systemImage: The name of the image resource to lookup.
    ///   - action: The action to perform when the user triggers the button.
    nonisolated public init(_ titleKey: LocalizedStringKey, systemImage: String, action: @escaping @MainActor () -> Void)

    /// Creates a button that generates its label from a string and
    /// system image name.
    ///
    /// This initializer creates a ``Label`` view on your behalf, and treats the
    /// title similar to ``Text/init(_:)``. See ``Text`` for more
    /// information about localizing strings.
    ///
    /// - Parameters:
    ///   - title: A string that describes the purpose of the button's `action`.
    ///   - systemImage: The name of the image resource to lookup.
    ///   - action: The action to perform when the user triggers the button.
    nonisolated public init<S>(_ title: S, systemImage: String, action: @escaping @MainActor () -> Void) where S : StringProtocol
}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension Button where Label == Label<Text, Image> {

    /// Creates a button that generates its label from a localized string key
    /// and image resource.
    ///
    /// This initializer creates a ``Label`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the button's localized title, that describes
    ///     the purpose of the button's `action`.
    ///   - image: The image resource to lookup.
    ///   - action: The action to perform when the user triggers the button.
    @preconcurrency nonisolated public init(_ titleKey: LocalizedStringKey, image: ImageResource, action: @escaping @MainActor () -> Void)

    /// Creates a button that generates its label from a string and
    /// image resource.
    ///
    /// This initializer creates a ``Label`` view on your behalf, and treats the
    /// title similar to ``Text/init(_:)``. See ``Text`` for more
    /// information about localizing strings.
    ///
    /// - Parameters:
    ///   - title: A string that describes the purpose of the button's `action`.
    ///   - image: The image resource to lookup.
    ///   - action: The action to perform when the user triggers the button.
    @preconcurrency nonisolated public init<S>(_ title: S, image: ImageResource, action: @escaping @MainActor () -> Void) where S : StringProtocol
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Button where Label == PrimitiveButtonStyleConfiguration.Label {

    /// Creates a button based on a configuration for a style with a custom
    /// appearance and custom interaction behavior.
    ///
    /// Use this initializer within the
    /// ``PrimitiveButtonStyle/makeBody(configuration:)`` method of a
    /// ``PrimitiveButtonStyle`` to create an instance of the button that you
    /// want to style. This is useful for custom button styles that modify the
    /// current button style, rather than implementing a brand new style.
    ///
    /// For example, the following style adds a red border around the button,
    /// but otherwise preserves the button's current style:
    ///
    ///     struct RedBorderedButtonStyle: PrimitiveButtonStyle {
    ///         func makeBody(configuration: Configuration) -> some View {
    ///             Button(configuration)
    ///                 .border(Color.red)
    ///         }
    ///     }
    ///
    /// - Parameter configuration: A configuration for a style with a custom
    ///   appearance and custom interaction behavior.
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    nonisolated public init(_ configuration: PrimitiveButtonStyleConfiguration)
}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension Button {

    /// Creates a button with a specified role that displays a custom label.
    ///
    /// - Parameters:
    ///   - role: An optional semantic role that describes the button. A value of
    ///     `nil` means that the button doesn't have an assigned role.
    ///   - action: The action to perform when the user interacts with the button.
    ///   - label: A view that describes the purpose of the button's `action`.
    @preconcurrency nonisolated public init(role: ButtonRole?, action: @escaping @MainActor () -> Void, @ViewBuilder label: () -> Label)
}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension Button where Label == Text {

    /// Creates a button with a specified role that generates its label from a
    /// localized string key.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the button's localized title, that describes
    ///     the purpose of the button's `action`.
    ///   - role: An optional semantic role describing the button. A value of
    ///     `nil` means that the button doesn't have an assigned role.
    ///   - action: The action to perform when the user triggers the button.
    @preconcurrency nonisolated public init(_ titleKey: LocalizedStringKey, role: ButtonRole?, action: @escaping @MainActor () -> Void)

    /// Creates a button with a specified role that generates its label from a
    /// string.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// title similar to ``Text/init(_:)``. See ``Text`` for more
    /// information about localizing strings.
    ///
    /// - Parameters:
    ///   - title: A string that describes the purpose of the button's `action`.
    ///   - role: An optional semantic role describing the button. A value of
    ///     `nil` means that the button doesn't have an assigned role.
    ///   - action: The action to perform when the user interacts with the button.
    @preconcurrency nonisolated public init<S>(_ title: S, role: ButtonRole?, action: @escaping @MainActor () -> Void) where S : StringProtocol
}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension Button where Label == Label<Text, Image> {

    /// Creates a button with a specified role that generates its label from a
    /// localized string key and a system image.
    ///
    /// This initializer creates a ``Label`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the button's localized title, that describes
    ///     the purpose of the button's `action`.
    ///   - systemImage: The name of the image resource to lookup.
    ///   - role: An optional semantic role describing the button. A value of
    ///     `nil` means that the button doesn't have an assigned role.
    ///   - action: The action to perform when the user triggers the button.
    nonisolated public init(_ titleKey: LocalizedStringKey, systemImage: String, role: ButtonRole?, action: @escaping @MainActor () -> Void)

    /// Creates a button with a specified role that generates its label from a
    /// string and a system image and an image resource.
    ///
    /// This initializer creates a ``Label`` view on your behalf, and treats the
    /// title similar to ``Text/init(_:)``. See ``Text`` for more
    /// information about localizing strings.
    ///
    /// - Parameters:
    ///   - title: A string that describes the purpose of the button's `action`.
    ///   - systemImage: The name of the image resource to lookup.
    ///   - role: An optional semantic role describing the button. A value of
    ///     `nil` means that the button doesn't have an assigned role.
    ///   - action: The action to perform when the user interacts with the button.
    nonisolated public init<S>(_ title: S, systemImage: String, role: ButtonRole?, action: @escaping @MainActor () -> Void) where S : StringProtocol
}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension Button where Label == Label<Text, Image> {

    /// Creates a button with a specified role that generates its label from a
    /// localized string key and an image resource.
    ///
    /// This initializer creates a ``Label`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the button's localized title, that describes
    ///     the purpose of the button's `action`.
    ///   - image: The image resource to lookup.
    ///   - role: An optional semantic role describing the button. A value of
    ///     `nil` means that the button doesn't have an assigned role.
    ///   - action: The action to perform when the user triggers the button.
    @preconcurrency nonisolated public init(_ titleKey: LocalizedStringKey, image: ImageResource, role: ButtonRole?, action: @escaping @MainActor () -> Void)

    /// Creates a button with a specified role that generates its label from a
    /// string and an image resource.
    ///
    /// This initializer creates a ``Label`` view on your behalf, and treats the
    /// title similar to ``Text/init(_:)``. See ``Text`` for more
    /// information about localizing strings.
    ///
    /// - Parameters:
    ///   - title: A string that describes the purpose of the button's `action`.
    ///   - image: The image resource to lookup.
    ///   - role: An optional semantic role describing the button. A value of
    ///     `nil` means that the button doesn't have an assigned role.
    ///   - action: The action to perform when the user interacts with the button.
    @preconcurrency nonisolated public init<S>(_ title: S, image: ImageResource, role: ButtonRole?, action: @escaping @MainActor () -> Void) where S : StringProtocol
}

/// A shape used to draw a button's border.
///
/// Use the ``View/buttonBorderShape(_:)`` view modifier to apply the shape to
/// bordered buttons within a view hierarchy.
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public struct ButtonBorderShape : Equatable, Sendable {

    /// A shape that defers to the system to determine an appropriate shape
    /// for the given context and platform.
    ///
    /// Use the ``View/buttonBorderShape(_:)`` view modifier to apply the shape
    /// to bordered buttons within a view hierarchy.
    public static let automatic: ButtonBorderShape

    /// A capsule shape.
    ///
    /// Use the ``View/buttonBorderShape(_:)`` view modifier to apply the shape
    /// to bordered buttons within a view hierarchy.
    ///
    /// - Note: This has no effect on non-widget system buttons in macOS.
    @available(macOS 14.0, tvOS 17.0, *)
    public static let capsule: ButtonBorderShape

    /// A rounded rectangle shape.
    ///
    /// Use the ``View/buttonBorderShape(_:)`` view modifier to apply the shape
    /// to bordered buttons within a view hierarchy.
    public static let roundedRectangle: ButtonBorderShape

    /// A rounded rectangle shape.
    ///
    /// Use the ``View/buttonBorderShape(_:)`` view modifier to apply the shape
    /// to bordered buttons within a view hierarchy.
    ///
    /// - Parameter radius: The corner radius of the rectangle.
    /// - Note: This has no effect on non-widget system buttons in macOS.
    @available(macOS 14.0, tvOS 17.0, *)
    public static func roundedRectangle(radius: CGFloat) -> ButtonBorderShape

    /// A circular shape.
    ///
    /// Use the ``View/buttonBorderShape(_:)`` view modifier to apply the shape
    /// to bordered buttons within a view hierarchy.
    @available(iOS 17.0, macOS 14.0, tvOS 16.4, watchOS 10.0, *)
    public static let circle: ButtonBorderShape

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ButtonBorderShape, b: ButtonBorderShape) -> Bool
}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension ButtonBorderShape : Shape {

    /// Describes this shape as a path within a rectangular frame of reference.
    ///
    /// - Parameter rect: The frame of reference for describing this shape.
    ///
    /// - Returns: A path that describes this shape.
    nonisolated public func path(in rect: CGRect) -> Path

    /// The type defining the data to animate.
    @available(iOS 17.0, tvOS 17.0, watchOS 10.0, macOS 14.0, *)
    public typealias AnimatableData = EmptyAnimatableData

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    @available(iOS 17.0, tvOS 17.0, watchOS 10.0, macOS 14.0, *)
    public typealias Body
}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension ButtonBorderShape : InsettableShape {

    /// Returns `self` inset by `amount`.
    @inlinable nonisolated public func inset(by amount: CGFloat) -> some InsettableShape


    /// The type of the inset shape.
    @available(iOS 17.0, tvOS 17.0, watchOS 10.0, macOS 14.0, *)
    public typealias InsetShape = some InsettableShape
}

/// A menu style that displays a button that toggles the display of the
/// menu's contents when pressed.
///
/// Use ``MenuStyle/button`` to construct this style.
@available(iOS 16.0, macOS 13.0, tvOS 17.0, *)
@available(watchOS, unavailable)
public struct ButtonMenuStyle : MenuStyle {

    /// Creates a button menu style.
    public init()

    /// Creates a view that represents the body of a menu.
    ///
    /// - Parameter configuration: The properties of the menu.
    ///
    /// The system calls this method for each ``Menu`` instance in a view
    /// hierarchy where this style is the current menu style.
    @MainActor @preconcurrency public func makeBody(configuration: ButtonMenuStyle.Configuration) -> some View


    /// A view that represents the body of a menu.
    @available(iOS 16.0, tvOS 17.0, macOS 13.0, *)
    @available(watchOS, unavailable)
    public typealias Body = some View
}

/// The options for controlling the repeatability of button actions.
///
/// Use values of this type with the ``View/buttonRepeatBehavior(_:)``
/// modifier.
@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
public struct ButtonRepeatBehavior : Hashable, Sendable {

    /// The automatic repeat behavior.
    public static let automatic: ButtonRepeatBehavior

    /// Repeating button actions will be enabled.
    public static let enabled: ButtonRepeatBehavior

    /// Repeating button actions will be disabled.
    public static let disabled: ButtonRepeatBehavior

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ButtonRepeatBehavior, b: ButtonRepeatBehavior) -> Bool

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

/// A value that describes the purpose of a button.
///
/// A button role provides a description of a button's purpose.  For example,
/// the ``ButtonRole/destructive`` role indicates that a button performs
/// a destructive action, like delete user data:
///
///     Button("Delete", role: .destructive) { delete() }
///
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public struct ButtonRole : Equatable, Sendable {

    /// A role that indicates a destructive button.
    ///
    /// Use this role for a button that deletes user data, or performs an
    /// irreversible operation. A destructive button signals by its appearance
    /// that the user should carefully consider whether to tap or click the
    /// button. For example, SwiftUI presents a destructive button that you add
    /// with the ``View/swipeActions(edge:allowsFullSwipe:content:)``
    /// modifier using a red background:
    ///
    ///     List {
    ///         ForEach(items) { item in
    ///             Text(item.title)
    ///                 .swipeActions {
    ///                     Button(role: .destructive) { delete() } label: {
    ///                         Label("Delete", systemImage: "trash")
    ///                     }
    ///                 }
    ///         }
    ///     }
    ///     .navigationTitle("Shopping List")
    ///
    /// ![A screenshot of a list of three items, where the second item is
    /// shifted to the left, and the row displays a red button with a trash
    /// icon on the right side.](ButtonRole-destructive-1)
    public static let destructive: ButtonRole

    /// A role that indicates a button that cancels an operation.
    ///
    /// Use this role for a button that cancels the current operation.
    public static let cancel: ButtonRole

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ButtonRole, b: ButtonRole) -> Bool
}

/// A type that applies standard interaction behavior and a custom appearance to
/// all buttons within a view hierarchy.
///
/// To configure the current button style for a view hierarchy, use the
/// ``View/buttonStyle(_:)`` modifier. Specify a style that conforms to
/// `ButtonStyle` when creating a button that uses the standard button
/// interaction behavior defined for each platform. To create a button with
/// custom interaction behavior, use ``PrimitiveButtonStyle`` instead.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@MainActor @preconcurrency public protocol ButtonStyle {

    /// A view that represents the body of a button.
    associatedtype Body : View

    /// Creates a view that represents the body of a button.
    ///
    /// The system calls this method for each ``Button`` instance in a view
    /// hierarchy where this style is the current button style.
    ///
    /// - Parameter configuration : The properties of the button.
    @ViewBuilder @MainActor @preconcurrency func makeBody(configuration: Self.Configuration) -> Self.Body

    /// The properties of a button.
    typealias Configuration = ButtonStyleConfiguration
}

/// The properties of a button.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public struct ButtonStyleConfiguration {

    /// A type-erased label of a button.
    @MainActor @preconcurrency public struct Label : View {

        /// The type of view representing the body of this view.
        ///
        /// When you create a custom view, Swift infers this type from your
        /// implementation of the required ``View/body-swift.property`` property.
        @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
        public typealias Body = Never
    }

    /// An optional semantic role that describes the button's purpose.
    ///
    /// A value of `nil` means that the Button doesn't have an assigned role. If
    /// the button does have a role, use it to make adjustments to the button's
    /// appearance. The following example shows a custom style that uses
    /// bold text when the role is ``ButtonRole/cancel``,
    /// ``ShapeStyle/red`` text when the role is ``ButtonRole/destructive``,
    /// and adds no special styling otherwise:
    ///
    ///     struct MyButtonStyle: ButtonStyle {
    ///         func makeBody(configuration: Configuration) -> some View {
    ///             configuration.label
    ///                 .font(
    ///                     configuration.role == .cancel ? .title2.bold() : .title2)
    ///                 .foregroundColor(
    ///                     configuration.role == .destructive ? Color.red : nil)
    ///         }
    ///     }
    ///
    /// You can create one of each button using this style to see the effect:
    ///
    ///     VStack(spacing: 20) {
    ///         Button("Cancel", role: .cancel) {}
    ///         Button("Delete", role: .destructive) {}
    ///         Button("Continue") {}
    ///     }
    ///     .buttonStyle(MyButtonStyle())
    ///
    /// ![A screenshot of three buttons stacked vertically. The first says
    /// Cancel in black, bold letters. The second says Delete in red, regular
    /// weight letters. The third says Continue in black, regular weight
    /// letters.](ButtonStyleConfiguration-role-1)
    @available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
    public let role: ButtonRole?

    /// A view that describes the effect of pressing the button.
    public let label: ButtonStyleConfiguration.Label

    /// A Boolean that indicates whether the user is currently pressing the
    /// button.
    public let isPressed: Bool
}

/// A toggle style that displays as a button with its label as the title.
///
/// You can also use ``ToggleStyle/button`` to construct this style.
///
///     Toggle(isOn: $isFlagged) {
///         Label("Flag", systemImage: "flag.fill")
///     }
///     .toggleStyle(.button)
///
@available(iOS 15.0, macOS 12.0, watchOS 9.0, *)
@available(tvOS, unavailable)
public struct ButtonToggleStyle : ToggleStyle {

    /// Creates a button toggle style.
    ///
    /// Don't call this initializer directly. Instead, use the
    /// ``ToggleStyle/button`` static variable to create this style:
    ///
    ///     Toggle(isOn: $isFlagged) {
    ///         Label("Flag", systemImage: "flag.fill")
    ///     }
    ///     .toggleStyle(.button)
    ///
    public init()

    /// Creates a view that represents the body of a toggle button.
    ///
    /// SwiftUI implements this required method of the ``ToggleStyle``
    /// protocol to define the behavior and appearance of the
    /// ``ToggleStyle/button`` toggle style. Don't call this method
    /// directly; the system calls this method for each
    /// ``Toggle`` instance in a view hierarchy that's styled as
    /// a button.
    ///
    /// - Parameter configuration: The properties of the toggle, including a
    ///   label and a binding to the toggle's state.
    /// - Returns: A view that acts as a button that controls a Boolean state.
    @MainActor @preconcurrency public func makeBody(configuration: ButtonToggleStyle.Configuration) -> some View


    /// A view that represents the appearance and interaction of a toggle.
    ///
    /// SwiftUI infers this type automatically based on the ``View``
    /// instance that you return from your implementation of the
    /// ``makeBody(configuration:)`` method.
    @available(iOS 15.0, watchOS 9.0, macOS 12.0, *)
    @available(tvOS, unavailable)
    public typealias Body = some View
}

/// A progress view that uses a circular gauge to indicate the partial
/// completion of an activity.
///
/// On watchOS, and in widgets and complications, a circular progress view
/// appears as a gauge with the ``GaugeStyle/accessoryCircularCapacity``
/// style. If the progress view is indeterminate, the gauge is empty.
///
/// In cases where no determinate circular progress view style is available,
/// circular progress views use an indeterminate style.
///
/// Use ``ProgressViewStyle/circular`` to construct the circular progress view
/// style.
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public struct CircularProgressViewStyle : ProgressViewStyle {

    /// Creates a circular progress view style.
    public init()

    /// Creates a circular progress view style with a tint color.
    @available(iOS, introduced: 14.0, deprecated: 100000.0, message: "Use ``View/tint(_)`` instead.")
    @available(macOS, introduced: 11.0, deprecated: 100000.0, message: "Use ``View/tint(_)`` instead.")
    @available(tvOS, introduced: 14.0, deprecated: 100000.0, message: "Use ``View/tint(_)`` instead.")
    @available(watchOS, introduced: 7.0, deprecated: 100000.0, message: "Use ``View/tint(_)`` instead.")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Use ``View/tint(_)`` instead.")
    public init(tint: Color)

    /// Creates a view representing the body of a progress view.
    ///
    /// - Parameter configuration: The properties of the progress view being
    ///   created.
    ///
    /// The view hierarchy calls this method for each progress view where this
    /// style is the current progress view style.
    ///
    /// - Parameter configuration: The properties of the progress view, such as
    ///  its preferred progress type.
    @MainActor @preconcurrency public func makeBody(configuration: CircularProgressViewStyle.Configuration) -> some View


    /// A view representing the body of a progress view.
    @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
    public typealias Body = some View
}

/// A control used to select a color from the system color picker UI.
///
/// The color picker provides a color well that shows the currently selected
/// color, and displays the larger system color picker that allows users to
/// select a new color.
///
/// By default color picker supports colors with opacity; to disable opacity
/// support, set the `supportsOpacity` parameter to `false`.
/// In this mode the color picker won't show controls for adjusting the opacity
/// of the selected color, and strips out opacity from any color set
/// programmatically or selected from the user's system favorites.
///
/// You use `ColorPicker` by embedding it inside a view hierarchy and
/// initializing it with a title string and a ``Binding`` to a ``Color``:
///
///     struct FormattingControls: View {
///         @State private var bgColor =
///             Color(.sRGB, red: 0.98, green: 0.9, blue: 0.2)
///
///         var body: some View {
///             VStack {
///                 ColorPicker("Alignment Guides", selection: $bgColor)
///             }
///         }
///     }
///
@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct ColorPicker<Label> : View where Label : View {

    /// Creates an instance that selects a color.
    ///
    /// - Parameters:
    ///     - selection: A ``Binding`` to the variable that displays the
    ///       selected ``Color``.
    ///     - supportsOpacity: A Boolean value that indicates whether the color
    ///       picker allows adjusting the selected color's opacity; the default
    ///       is `true`.
    ///     - label: A view that describes the use of the selected color.
    ///        The system color picker UI sets it's title using the text from
    ///        this view.
    ///
    public init(selection: Binding<Color>, supportsOpacity: Bool = true, @ViewBuilder label: () -> Label)

    /// Creates an instance that selects a color.
    ///
    /// - Parameters:
    ///     - selection: A ``Binding`` to the variable that displays the
    ///       selected ``CGColor``.
    ///     - supportsOpacity: A Boolean value that indicates whether the color
    ///       picker allows adjusting the selected color's opacity; the default
    ///       is `true`.
    ///     - label: A view that describes the use of the selected color.
    ///        The system color picker UI sets it's title using the text from
    ///        this view.
    ///
    public init(selection: Binding<CGColor>, supportsOpacity: Bool = true, @ViewBuilder label: () -> Label)

    /// The content and behavior of the view.
    ///
    /// When you implement a custom view, you must implement a computed
    /// `body` property to provide the content for your view. Return a view
    /// that's composed of built-in views that SwiftUI provides, plus other
    /// composite views that you've already defined:
    ///
    ///     struct MyView: View {
    ///         var body: some View {
    ///             Text("Hello, World!")
    ///         }
    ///     }
    ///
    /// For more information about composing views and a view hierarchy,
    /// see <doc:Declaring-a-Custom-View>.
    @MainActor @preconcurrency public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    @available(iOS 14.0, macOS 11.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias Body = some View
}

@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension ColorPicker where Label == Text {

    /// Creates a color picker with a text label generated from a title string key.
    ///
    /// Use ``ColorPicker`` to create a color well that your app uses to allow
    /// the selection of a ``Color``. The example below creates a color well
    /// using a ``Binding`` to a property stored in a settings object and title
    /// you provide:
    ///
    ///     final class Settings: ObservableObject {
    ///         @Published var alignmentGuideColor =
    ///             Color(.sRGB, red: 0.98, green: 0.9, blue: 0.2)
    ///     }
    ///
    ///     struct FormattingControls: View {
    ///         @State private var settings = Settings()
    ///
    ///         var body: some View {
    ///             VStack {
    ///                 // Other formatting controls.
    ///                 ColorPicker("Alignment Guides",
    ///                     selection: $settings.alignmentGuideColor
    ///                 )
    ///             }
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - titleKey: The key for the localized title of the picker.
    ///   - selection: A ``Binding`` to the variable that displays the
    ///     selected ``Color``.
    ///   - supportsOpacity: A Boolean value that indicates whether the color
    ///     picker allows adjustments to the selected color's opacity; the
    ///     default is `true`.
    nonisolated public init(_ titleKey: LocalizedStringKey, selection: Binding<Color>, supportsOpacity: Bool = true)

    /// Creates a color picker with a text label generated from a title string.
    ///
    /// Use ``ColorPicker`` to create a color well that your app uses to allow
    /// the selection of a ``Color``. The example below creates a color well
    /// using a ``Binding`` and title you provide:
    ///
    ///     func showColorPicker(_ title: String, color: Binding<Color>) {
    ///         ColorPicker(title, selection: color)
    ///     }
    ///
    /// - Parameters:
    ///   - title: The title displayed by the color picker.
    ///   - selection: A ``Binding`` to the variable containing a ``Color``.
    ///   - supportsOpacity: A Boolean value that indicates whether the color
    ///     picker allows adjustments to the selected color's opacity; the
    ///     default is `true`.
    nonisolated public init<S>(_ title: S, selection: Binding<Color>, supportsOpacity: Bool = true) where S : StringProtocol

    /// Creates a color picker with a text label generated from a title string key.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the localized title of the picker.
    ///   - selection: A ``Binding`` to the variable that displays the
    ///     selected ``CGColor``.
    ///   - supportsOpacity: A Boolean value that indicates whether the color
    ///     picker allows adjustments to the selected color's opacity; the
    ///     default is `true`.
    nonisolated public init(_ titleKey: LocalizedStringKey, selection: Binding<CGColor>, supportsOpacity: Bool = true)

    /// Creates a color picker with a text label generated from a title string.
    ///
    /// - Parameters:
    ///   - title: The title displayed by the color picker.
    ///   - selection: A ``Binding`` to the variable containing a ``CGColor``.
    ///   - supportsOpacity: A Boolean value that indicates whether the color
    ///     picker allows adjustments to the selected color's opacity; the
    ///     default is `true`.
    nonisolated public init<S>(_ title: S, selection: Binding<CGColor>, supportsOpacity: Bool = true) where S : StringProtocol
}

/// A navigation view style represented by a series of views in columns.
///
/// You can also use ``NavigationViewStyle/columns`` to construct this style.
@available(iOS, introduced: 15.0, deprecated: 100000.0, message: "replace styled NavigationView with NavigationSplitView")
@available(macOS, introduced: 12.0, deprecated: 100000.0, message: "replace styled NavigationView with NavigationSplitView")
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "replace styled NavigationView with NavigationSplitView")
public struct ColumnNavigationViewStyle : NavigationViewStyle {
}

/// A non-scrolling form style with a trailing aligned column of labels
/// next to a leading aligned column of values.
///
/// Use the ``FormStyle/columns`` static variable to create this style:
///
///     Form {
///        ...
///     }
///     .formStyle(.columns)
///
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct ColumnsFormStyle : FormStyle {

    /// A non-scrolling form style with a trailing aligned column of labels
    /// next to a leading aligned column of values.
    ///
    /// Don't call this initializer directly. Instead, use the
    /// ``FormStyle/columns`` static variable to create this style:
    ///
    ///     Form {
    ///        ...
    ///     }
    ///     .formStyle(.columns)
    ///
    public init()

    /// Creates a view that represents the body of a form.
    ///
    /// - Parameter configuration: The properties of the form.
    /// - Returns: A view that has behavior and appearance that enables it
    ///   to function as a ``Form``.
    @MainActor @preconcurrency public func makeBody(configuration: ColumnsFormStyle.Configuration) -> some View


    /// A view that represents the appearance and interaction of a form.
    @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
    public typealias Body = some View
}

/// Groups of controls that you can add to existing command menus.
///
/// In macOS, SwiftUI realizes command groups as collections of menu items in a
/// menu bar menu. In iOS, iPadOS, and tvOS, SwiftUI creates key commands for
/// each of a group's commands that has a keyboard shortcut.
@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct CommandGroup<Content> : Commands where Content : View {

    /// A value describing the addition of the given views to the beginning of
    /// the indicated group.
    public init(before group: CommandGroupPlacement, @ViewBuilder addition: () -> Content)

    /// A value describing the addition of the given views to the end of the
    /// indicated group.
    public init(after group: CommandGroupPlacement, @ViewBuilder addition: () -> Content)

    /// A value describing the complete replacement of the contents of the
    /// indicated group with the given views.
    public init(replacing group: CommandGroupPlacement, @ViewBuilder addition: () -> Content)

    /// The contents of the command hierarchy.
    ///
    /// For any commands that you create, provide a computed `body` property
    /// that defines the scene as a composition of other scenes. You can
    /// assemble a command hierarchy from built-in commands that SwiftUI
    /// provides, as well as other commands that you've defined.
    @MainActor @preconcurrency public var body: some Commands { get }

    /// The type of commands that represents the body of this command hierarchy.
    ///
    /// When you create custom commands, Swift infers this type from your
    /// implementation of the required ``SwiftUI/Commands/body-swift.property``
    /// property.
    @available(iOS 14.0, macOS 11.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias Body = some Commands
}

/// The standard locations that you can place new command groups relative to.
///
/// The names of these placements aren't visible in the user interface, but
/// the discussion for each placement lists the items that it includes.
@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct CommandGroupPlacement {

    /// Placement for commands that provide information about the app,
    /// the terms of the user's license agreement, and so on.
    ///
    /// By default, this group includes the following command in macOS:
    /// * About App
    public static let appInfo: CommandGroupPlacement

    /// Placement for commands that expose app settings and
    /// preferences.
    ///
    /// By default, this group includes the following command in macOS:
    /// * Preferences
    public static let appSettings: CommandGroupPlacement

    /// Placement for commands that expose services other apps provide.
    ///
    /// By default, this group includes the following command in macOS:
    /// * Services submenu (managed automatically)
    public static let systemServices: CommandGroupPlacement

    /// Placement for commands that control the visibility of running
    /// apps.
    ///
    /// By default, this group includes the following commands in macOS:
    /// * Hide App
    /// * Hide Others
    /// * Show All
    public static let appVisibility: CommandGroupPlacement

    /// Placement for commands that result in app termination.
    ///
    /// By default, this group includes the following command in macOS:
    /// * Quit App
    public static let appTermination: CommandGroupPlacement

    /// Placement for commands that create and open different kinds of
    /// documents.
    ///
    /// By default, this group includes the following commands in macOS:
    /// * New
    /// * Open
    /// * Open Recent submenu (managed automatically)
    public static let newItem: CommandGroupPlacement

    /// Placement for commands that save open documents and close
    /// windows.
    ///
    /// By default, this group includes the following commands in macOS:
    /// * Close
    /// * Save
    /// * Save As/Duplicate
    /// * Revert to Saved
    public static let saveItem: CommandGroupPlacement

    /// Placement for commands that relate to importing and exporting
    /// data using formats that the app doesn't natively support.
    ///
    /// Empty by default in macOS.
    public static let importExport: CommandGroupPlacement

    /// Placement for commands related to printing app content.
    ///
    /// By default, this group includes the following commands in macOS:
    /// * Page Setup
    /// * Print
    public static let printItem: CommandGroupPlacement

    /// Placement for commands that control the Undo Manager.
    ///
    /// By default, this group includes the following commands in macOS:
    /// * Undo
    /// * Redo
    public static let undoRedo: CommandGroupPlacement

    /// Placement for commands that interact with the Clipboard and
    /// manipulate content that is currently selected in the app's view
    /// hierarchy.
    ///
    /// By default, this group includes the following commands in macOS:
    /// * Cut
    /// * Copy
    /// * Paste
    /// * Paste and Match Style
    /// * Delete
    /// * Select All
    public static let pasteboard: CommandGroupPlacement

    /// Placement for commands that manipulate and transform text
    /// selections.
    ///
    /// By default, this group includes the following commands in macOS:
    /// * Find submenu
    /// * Spelling and Grammar submenu
    /// * Substitutions submenu
    /// * Transformations submenu
    /// * Speech submenu
    public static let textEditing: CommandGroupPlacement

    /// Placement for commands that manipulate and transform the styles
    /// applied to text selections.
    ///
    /// By default, this group includes the following commands in macOS:
    /// * Font submenu
    /// * Text submenu
    public static let textFormatting: CommandGroupPlacement

    /// Placement for commands that manipulate the toolbar.
    ///
    /// By default, this group includes the following commands in macOS:
    /// * Show/Hide Toolbar
    /// * Customize Toolbar
    public static let toolbar: CommandGroupPlacement

    /// Placement for commands that control the app's sidebar and full-screen
    /// modes.
    ///
    /// By default, this group includes the following commands in macOS:
    /// * Show/Hide Sidebar
    /// * Enter/Exit Full Screen
    public static let sidebar: CommandGroupPlacement

    /// Placement for commands that control the size of the window.
    ///
    /// By default, this group includes the following commands in macOS:
    /// * Minimize
    /// * Zoom
    public static let windowSize: CommandGroupPlacement

    /// Placement for commands that arrange all of an app's windows.
    ///
    /// By default, this group includes the following command in macOS:
    /// * Bring All to Front
    public static let windowArrangement: CommandGroupPlacement

    /// Placement for commands that present documentation and helpful
    /// information to people.
    ///
    /// By default, this group includes the following command in macOS:
    /// * App Help
    public static let help: CommandGroupPlacement
}

/// Command menus are stand-alone, top-level containers for controls that
/// perform related, app-specific commands.
///
/// Command menus are realized as menu bar menus on macOS, inserted between the
/// built-in View and Window menus in order of declaration. On iOS, iPadOS, and
/// tvOS, SwiftUI creates key commands for each of a menu's commands that has a
/// keyboard shortcut.
@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct CommandMenu<Content> : Commands where Content : View {

    /// Creates a new menu with a localized name for a collection of app-
    /// specific commands, inserted in the standard location for app menus
    /// (after the View menu, in order with other menus declared without an
    /// explicit location).
    public init(_ nameKey: LocalizedStringKey, @ViewBuilder content: () -> Content)

    /// Creates a new menu for a collection of app-specific commands, inserted
    /// in the standard location for app menus (after the View menu, in order
    /// with other menus declared without an explicit location).
    public init(_ name: Text, @ViewBuilder content: () -> Content)

    /// Creates a new menu for a collection of app-specific commands, inserted
    /// in the standard location for app menus (after the View menu, in order
    /// with other menus declared without an explicit location).
    public init<S>(_ name: S, @ViewBuilder content: () -> Content) where S : StringProtocol

    /// The contents of the command hierarchy.
    ///
    /// For any commands that you create, provide a computed `body` property
    /// that defines the scene as a composition of other scenes. You can
    /// assemble a command hierarchy from built-in commands that SwiftUI
    /// provides, as well as other commands that you've defined.
    @MainActor @preconcurrency public var body: some Commands { get }

    /// The type of commands that represents the body of this command hierarchy.
    ///
    /// When you create custom commands, Swift infers this type from your
    /// implementation of the required ``SwiftUI/Commands/body-swift.property``
    /// property.
    @available(iOS 14.0, macOS 11.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias Body = some Commands
}

/// Conforming types represent a group of related commands that can be exposed
/// to the user via the main menu on macOS and key commands on iOS.
@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@MainActor @preconcurrency public protocol Commands {

    /// The type of commands that represents the body of this command hierarchy.
    ///
    /// When you create custom commands, Swift infers this type from your
    /// implementation of the required ``SwiftUI/Commands/body-swift.property``
    /// property.
    associatedtype Body : Commands

    /// The contents of the command hierarchy.
    ///
    /// For any commands that you create, provide a computed `body` property
    /// that defines the scene as a composition of other scenes. You can
    /// assemble a command hierarchy from built-in commands that SwiftUI
    /// provides, as well as other commands that you've defined.
    @CommandsBuilder @MainActor @preconcurrency var body: Self.Body { get }
}

/// Constructs command sets from multi-expression closures. Like `ViewBuilder`,
/// it supports up to ten expressions in the closure body.
@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@resultBuilder public struct CommandsBuilder {

    /// Builds an expression within the builder.
    public static func buildExpression<Content>(_ content: Content) -> Content where Content : Commands

    /// Builds an empty command set from a block containing no statements.
    public static func buildBlock() -> EmptyCommands

    /// Passes a single command group written as a child group through
    /// modified.
    public static func buildBlock<C>(_ content: C) -> C where C : Commands
}

@available(iOS 16.0, macOS 13.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension CommandsBuilder {

    /// Produces an optional widget for conditional statements in multi-statement
    /// closures that's only visible when the condition evaluates to true.
    public static func buildIf<C>(_ content: C?) -> C? where C : Commands

    /// Produces content for a conditional statement in a multi-statement closure
    /// when the condition is true.
    public static func buildEither<T, F>(first: T) -> _ConditionalContent<T, F> where T : Commands, F : Commands

    /// Produces content for a conditional statement in a multi-statement closure
    /// when the condition is false.
    public static func buildEither<T, F>(second: F) -> _ConditionalContent<T, F> where T : Commands, F : Commands

    /// Processes commands for a conditional compiler-control statement that
    /// performs an availability check.
    @available(iOS 17.5, macOS 14.5, *)
    public static func buildLimitedAvailability(_ content: any Commands) -> some Commands

}

@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension CommandsBuilder {

    public static func buildBlock<C0, C1>(_ c0: C0, _ c1: C1) -> some Commands where C0 : Commands, C1 : Commands

}

@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension CommandsBuilder {

    public static func buildBlock<C0, C1, C2>(_ c0: C0, _ c1: C1, _ c2: C2) -> some Commands where C0 : Commands, C1 : Commands, C2 : Commands

}

@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension CommandsBuilder {

    public static func buildBlock<C0, C1, C2, C3>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3) -> some Commands where C0 : Commands, C1 : Commands, C2 : Commands, C3 : Commands

}

@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension CommandsBuilder {

    public static func buildBlock<C0, C1, C2, C3, C4>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4) -> some Commands where C0 : Commands, C1 : Commands, C2 : Commands, C3 : Commands, C4 : Commands

}

@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension CommandsBuilder {

    public static func buildBlock<C0, C1, C2, C3, C4, C5>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5) -> some Commands where C0 : Commands, C1 : Commands, C2 : Commands, C3 : Commands, C4 : Commands, C5 : Commands

}

@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension CommandsBuilder {

    public static func buildBlock<C0, C1, C2, C3, C4, C5, C6>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5, _ c6: C6) -> some Commands where C0 : Commands, C1 : Commands, C2 : Commands, C3 : Commands, C4 : Commands, C5 : Commands, C6 : Commands

}

@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension CommandsBuilder {

    public static func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5, _ c6: C6, _ c7: C7) -> some Commands where C0 : Commands, C1 : Commands, C2 : Commands, C3 : Commands, C4 : Commands, C5 : Commands, C6 : Commands, C7 : Commands

}

@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension CommandsBuilder {

    public static func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7, C8>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5, _ c6: C6, _ c7: C7, _ c8: C8) -> some Commands where C0 : Commands, C1 : Commands, C2 : Commands, C3 : Commands, C4 : Commands, C5 : Commands, C6 : Commands, C7 : Commands, C8 : Commands

}

@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension CommandsBuilder {

    public static func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7, C8, C9>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5, _ c6: C6, _ c7: C7, _ c8: C8, _ c9: C9) -> some Commands where C0 : Commands, C1 : Commands, C2 : Commands, C3 : Commands, C4 : Commands, C5 : Commands, C6 : Commands, C7 : Commands, C8 : Commands, C9 : Commands

}

/// A date picker style that displays the components in a compact, textual
/// format.
///
/// You can also use ``DatePickerStyle/compact`` to construct this style.
@available(iOS 14.0, macCatalyst 13.4, macOS 10.15.4, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct CompactDatePickerStyle : DatePickerStyle {

    /// Creates an instance of the compact date picker style.
    public init()

    /// Returns the appearance and interaction content for a `DatePicker`.
    ///
    /// The system calls this method for each ``DatePicker`` instance in a view
    /// hierarchy where this style is the current date picker style.
    ///
    /// - Parameter configuration : The properties of the date picker.
    @available(iOS 16.0, macOS 13.0, *)
    @MainActor @preconcurrency public func makeBody(configuration: CompactDatePickerStyle.Configuration) -> some View


    /// A view representing the appearance and interaction of a `DatePicker`.
    @available(iOS 14.0, macOS 10.15.4, macCatalyst 13.4, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias Body = some View
}

/// A control group style that presents its content as a compact menu when the user
/// presses the control, or as a submenu when nested within a larger menu.
///
/// Use ``ControlGroupStyle/compactMenu`` to construct this style.
@available(iOS 16.4, macOS 13.3, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct CompactMenuControlGroupStyle : ControlGroupStyle {

    /// Creates a compact menu control group style.
    public init()

    /// Creates a view representing the body of a control group.
    ///
    /// - Parameter configuration: The properties of the control group instance
    ///   being created.
    ///
    /// This method will be called for each instance of ``ControlGroup`` created
    /// within a view hierarchy where this style is the current
    /// `ControlGroupStyle`.
    @MainActor @preconcurrency public func makeBody(configuration: CompactMenuControlGroupStyle.Configuration) -> some View


    /// A view representing the body of a control group.
    @available(iOS 16.4, macOS 13.3, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias Body = some View
}

/// The placement of a container background.
///
/// This method controls where to place a background that you specify with the
/// ``View/containerBackground(_:for:)`` or
/// ``View/containerBackground(for:alignment:content:)`` modifier.
@available(iOS 17.0, tvOS 17.0, macOS 14.0, watchOS 10.0, *)
public struct ContainerBackgroundPlacement : Sendable, Hashable {

    /// A background placement inside a ``NavigationStack``
    /// or ``NavigationSplitView``.
    ///
    /// For translucent backgrounds in a navigation split view, combine this
    /// placement with ``ContainerBackgroundPlacement/navigationSplitView``.
    ///
    ///     NavigationSplitView {
    ///           sidebar 
    ///         .containerBackground(.thinMaterial, for: .navigation)
    ///         .containerBackground(Color.green, for: .navigationSplitView)
    ///     } detail: {
    ///         //  detail 
    ///         .containerBackground(.thickMaterial, for: .navigation)
    ///     }
    @available(watchOS 10.0, iOS 18.0, *)
    @available(macOS, unavailable)
    @available(tvOS, unavailable)
    @available(visionOS, unavailable)
    public static let navigation: ContainerBackgroundPlacement

    /// A background placement behind the content of a ``NavigationSplitView``.
    ///
    /// This is visible behind columns that are made translucent using the
    /// ``ContentBackgroundPlacement/navigation`` placement. For expanded split
    /// views, this container background is also visible between the columns as
    /// the divider color.
    @available(watchOS 11.0, iOS 18.0, *)
    @available(macOS, unavailable)
    @available(tvOS, unavailable)
    @available(visionOS, unavailable)
    public static let navigationSplitView: ContainerBackgroundPlacement

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ContainerBackgroundPlacement, b: ContainerBackgroundPlacement) -> Bool

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

/// A key for accessing container values.
///
/// You can create custom container values by extending the
/// ``ContainerValues`` structure with new properties.
/// First declare a new container value key type and specify a value for the
/// required ``defaultValue`` property:
///
///     private struct MyContainerValueKey: ContainerValueKey {
///         static let defaultValue: String = "Default value"
///     }
///
/// The Swift compiler automatically infers the associated ``Value`` type as the
/// type you specify for the default value. Then use the key to define a new
/// container value property:
///
///     extension ContainerValues {
///         var myCustomValue: String {
///             get { self[MyContainerValueKey.self] }
///             set { self[MyContainerValueKey.self] = newValue }
///         }
///     }
///
/// Clients of your container value never use the key directly.
/// Instead, they use the key path of your custom container value property.
/// To set the container value for a view, add the
/// ``View/containerValue(_:_:)`` view modifier to that view:
///
///     MyView()
///         .containerValue(\.myCustomValue, "Another string")
///
/// As a convenience, you can also define a dedicated view modifier to
/// apply this container value:
///
///     extension View {
///         func myCustomValue(_ myCustomValue: String) -> some View {
///             containerValue(\.myCustomValue, myCustomValue)
///     }
///
/// This improves clarity at the call site:
///
///     MyView()
///         .myCustomValue("Another string")
///
/// To read the container value, use `Group(subviews:)` on a containing
/// view, and then access the container value on members of that
/// collection.
///
///     @ViewBuilder var content: some View {
///         Text("A").myCustomValue("Hello")
///         Text("B").myCustomValue("World")
///     }
///
///     Group(subviews: content) { subviews in
///         ForEach(subviews) { subview in
///             Text(subview.containerValues.myCustomValue)
///         }
///     }
///
/// In practice, this will mostly be used by views that contain multiple other
/// views to extract information from their subviews. You could turn the example
/// above into such a container view as follows:
///
///     struct MyContainer<Content: View>: View {
///         var content: Content
///
///         init(@ViewBuilder content: () -> Content) {
///             self.content = content()
///         }
///
///         var body: some View {
///             Group(subviews: content) { subviews in
///                 ForEach(subviews) { subview in
///                     // Display each view side-by-side with its custom value.
///                     HStack {
///                         subview
///                         Text(subview.containerValues.myCustomValue)
///                     }
///                 }
///             }
///         }
///     }
///
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public protocol ContainerValueKey {

    /// The type of value produced by the container value.
    associatedtype Value

    /// The default value of the container value.
    static var defaultValue: Self.Value { get }
}

/// A collection of container values associated with a given view.
///
/// SwiftUI exposes a collection of values associated with each view in the
/// `ContainerValues` structure.
///
/// Container values you set on a given view affect only that view.
/// Like preferences, container values can be read by views above the view
/// they're set on. Unlike preferences, however, container values don't have
/// merging behavior because they don't escape their closest container.
/// The following example shows the container value set on the contained view,
/// and then dropped when it reaches the containing ``VStack``.
///
///     VStack {
///         Text("A").containerValue(\.myCustomValue, 1) // myCustomValue = 1
///         Text("B").containerValue(\.myCustomValue, 2) // myCustomValue = 2
///         // Container values are unaffected by views that aren't containers:
///         Text("C")
///             .containerValue(\.myCustomValue, 3)
///             .padding() // myCustomValue = 3
///     } // myCustomValue = it's default value, values do not escape the container
///
/// Even if a stack has only one child, container values still wouldn't
/// be lifted to the `VStack`. Container values don't escape a container
/// even if the container has only one child.
///
/// Create a custom container value by declaring a new property
/// in an extension to the container values structure and applying
/// the ``Entry()`` macro to the variable declaration:
///
///     extension ContainerValues {
///         @Entry var myCustomValue: String = "Default value"
///     }
///
/// Clients of your value then access the value by reading it from the container
/// values collection of a ``Subview``.
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct ContainerValues {

    /// Accesses the particular container value associated with a custom key.
    ///
    /// Create a custom container value by declaring a new property
    /// in an extension to the container values structure and applying
    /// the ``Entry()`` macro to the variable declaration:
    ///
    ///     extension ContainerValues {
    ///         @Entry var myCustomValue: String = "Default value"
    ///     }
    ///
    /// You use custom container values the same way you use system-provided
    /// values, setting a value with the ``View/containerValue(_:_:)`` view
    /// modifier, and reading values from a ``Subview`` provided by the
    /// `subviews` modifier. You can also provide a dedicated view modifier as a
    /// convenience for setting the value:
    ///
    ///     extension View {
    ///         func myCustomValue(_ myCustomValue: String) -> some View {
    ///             containerValue(\.myCustomValue, myCustomValue)
    ///         }
    ///     }
    ///
    public subscript<Key>(key: Key.Type) -> Key.Value where Key : ContainerValueKey

    /// The tag value for the given type if the container values contains one.
    ///
    /// Tag values are set using the ``View/tag`` modifier.
    ///
    /// - Parameter type: The type to get the tag value for.
    /// - Returns: The tag value for the given type if the subview has one,
    ///   otherwise `nil`.
    public func tag<V>(for type: V.Type) -> V? where V : Hashable

    /// Returns true if the container values contain a tag matching a given
    /// value.
    ///
    /// Tag values are set using the ``View/tag`` modifier.
    ///
    /// - Parameter tag: The tag value to check for.
    /// - Returns: If the container values has a tag matching the given value.
    public func hasTag<V>(_ tag: V) -> Bool where V : Hashable
}

/// The placement of margins.
///
/// Different views can support customizating margins that appear in
/// different parts of that view. Use values of this type to customize
/// those margins of a particular placement.
///
/// For example, use a ``ContentMarginPlacement/scrollIndicators``
/// placement to customize the margins of scrollable view's scroll
/// indicators separately from the margins of a scrollable view's
/// content.
///
/// Use this type with the ``View/contentMargins(_:for:)`` modifier.
@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
public struct ContentMarginPlacement {

    /// The automatic placement.
    ///
    /// Views that support margin customization can automatically use
    /// margins with this placement. For example, a ``ScrollView`` will
    /// use this placement to automatically inset both its content and
    /// scroll indicators by the specified amount.
    public static var automatic: ContentMarginPlacement { get }

    /// The scroll content placement.
    ///
    /// Scrollable views like ``ScrollView`` will use this placement to
    /// inset their content, but not their scroll indicators.
    public static var scrollContent: ContentMarginPlacement { get }

    /// The scroll indicators placement.
    ///
    /// Scrollable views like ``ScrollView`` will use this placement to
    /// inset their scroll indicators, but not their content.
    public static var scrollIndicators: ContentMarginPlacement { get }
}

/// An interface, consisting of a label and additional content, that you
/// display when the content of your app is unavailable to users.
///
/// It is recommended to use `ContentUnavailableView` in situations where a view's
/// content cannot be displayed. That could be caused by a network error, a
/// list without items, a search that returns no results etc.
///
/// You create an `ContentUnavailableView` in its simplest form, by providing a
/// label and some additional content such as a description or a call to action:
///
///     ContentUnavailableView {
///         Label("No Mail", systemImage: "tray.fill")
///     } description: {
///         Text("New mails you receive will appear here.")
///     }
///
/// The system provides default `ContentUnavailableView`s that you can use in
/// specific situations. The example below illustrates the usage of the
/// ``ContentUnavailableView/search`` view:
///
///     struct ContentView: View {
///         @ObservedObject private var viewModel = ContactsViewModel()
///
///         var body: some View {
///             NavigationStack {
///                 List {
///                     ForEach(viewModel.searchResults) { contact in
///                         NavigationLink {
///                             ContactsView(contact)
///                         } label: {
///                             Text(contact.name)
///                         }
///                     }
///                 }
///                 .navigationTitle("Contacts")
///                 .searchable(text: $viewModel.searchText)
///                 .overlay {
///                     if searchResults.isEmpty {
///                         ContentUnavailableView.search
///                     }
///                 }
///             }
///         }
///     }
///
@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
public struct ContentUnavailableView<Label, Description, Actions> : View where Label : View, Description : View, Actions : View {

    /// Creates an interface, consisting of a label and additional content, that you
    /// display when the content of your app is unavailable to users.
    ///
    /// - Parameters:
    ///   - label: The label that describes the view.
    ///   - description: The view that describes the interface.
    ///   - actions: The content of the interface actions.
    public init(@ViewBuilder label: () -> Label, @ViewBuilder description: () -> Description = { EmptyView() }, @ViewBuilder actions: () -> Actions = { EmptyView() })

    /// The content and behavior of the view.
    ///
    /// When you implement a custom view, you must implement a computed
    /// `body` property to provide the content for your view. Return a view
    /// that's composed of built-in views that SwiftUI provides, plus other
    /// composite views that you've already defined:
    ///
    ///     struct MyView: View {
    ///         var body: some View {
    ///             Text("Hello, World!")
    ///         }
    ///     }
    ///
    /// For more information about composing views and a view hierarchy,
    /// see <doc:Declaring-a-Custom-View>.
    @MainActor @preconcurrency public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    @available(iOS 17.0, tvOS 17.0, watchOS 10.0, macOS 14.0, *)
    public typealias Body = some View
}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension ContentUnavailableView where Label == Label<Text, Image>, Description == Text?, Actions == EmptyView {

    /// Creates an interface, consisting of a title generated from a localized
    /// string, an image and additional content, that you display when the
    /// content of your app is unavailable to users.
    ///
    /// - Parameters:
    ///    - title: A title generated from a localized string.
    ///    - image: The name of the image resource to lookup.
    ///    - description: The view that describes the interface.
    nonisolated public init(_ title: LocalizedStringKey, image name: String, description: Text? = nil)

    /// Creates an interface, consisting of a title generated from a localized
    /// string, a system icon image and additional content, that you display when the
    /// content of your app is unavailable to users.
    ///
    /// - Parameters:
    ///    - title: A title generated from a localized string.
    ///    - systemImage: The name of the system symbol image resource to lookup.
    ///      Use the SF Symbols app to look up the names of system symbol images.
    ///    - description: The view that describes the interface.
    nonisolated public init(_ title: LocalizedStringKey, systemImage name: String, description: Text? = nil)

    /// Creates an interface, consisting of a title generated from a string,
    /// an image and additional content, that you display when the content of
    /// your app is unavailable to users.
    ///
    /// - Parameters:
    ///    - title: A string used as the title.
    ///    - image: The name of the image resource to lookup.
    ///    - description: The view that describes the interface.
    nonisolated public init<S>(_ title: S, image name: String, description: Text? = nil) where S : StringProtocol

    /// Creates an interface, consisting of a title generated from a string,
    /// a system icon image and additional content, that you display when the
    /// content of your app is unavailable to users.
    ///
    /// - Parameters:
    ///    - title: A string used as the title.
    ///    - systemImage: The name of the system symbol image resource to lookup.
    ///      Use the SF Symbols app to look up the names of system symbol images.
    ///    - description: The view that describes the interface.
    nonisolated public init<S>(_ title: S, systemImage name: String, description: Text? = nil) where S : StringProtocol
}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension ContentUnavailableView where Label == SearchUnavailableContent.Label, Description == SearchUnavailableContent.Description, Actions == SearchUnavailableContent.Actions {

    /// Creates a `ContentUnavailableView` instance that conveys a search state.
    ///
    /// A `ContentUnavailableView` initialized with this static member is expected to
    /// be contained within a searchable view hierarchy. Such a configuration
    /// enables the search query to be parsed into the view's description.
    ///
    /// For example, consider the usage of this static member in *ContactsListView*:
    ///
    ///     struct ContactsListView: View {
    ///         @ObservedObject private var viewModel = ContactsViewModel()
    ///
    ///         var body: some View {
    ///             NavigationStack {
    ///                 List {
    ///                     ForEach(viewModel.searchResults) { contact in
    ///                         NavigationLink {
    ///                             ContactsView(contact)
    ///                         } label: {
    ///                             Text(contact.name)
    ///                         }
    ///                     }
    ///                 }
    ///                 .navigationTitle("Contacts")
    ///                 .searchable(text: $viewModel.searchText)
    ///                 .overlay {
    ///                     if searchResults.isEmpty {
    ///                         ContentUnavailableView.search
    ///                     }
    ///                 }
    ///             }
    ///         }
    ///     }
    ///
    public static var search: ContentUnavailableView<SearchUnavailableContent.Label, SearchUnavailableContent.Description, SearchUnavailableContent.Actions> { get }

    /// Creates a `ContentUnavailableView` instance that conveys a search state.
    ///
    /// For example, consider the usage of this static member in *ContactsListView*:
    ///
    ///     struct ContactsListView: View {
    ///         @ObservedObject private var viewModel = ContactsViewModel()
    ///
    ///         var body: some View {
    ///             NavigationStack {
    ///                 CustomSearchBar(query: $viewModel.searchText)
    ///                 List {
    ///                     ForEach(viewModel.searchResults) { contact in
    ///                         NavigationLink {
    ///                             ContactsView(contact)
    ///                         } label: {
    ///                             Text(contact.name)
    ///                         }
    ///                     }
    ///                 }
    ///                 .navigationTitle("Contacts")
    ///                 .overlay {
    ///                     if viewModel.searchResults.isEmpty {
    ///                         ContentUnavailableView
    ///                             .search(text: viewModel.searchText)
    ///                     }
    ///                 }
    ///             }
    ///         }
    ///     }
    ///
    /// - Parameter text: The search text query.
    public static func search(text: String) -> ContentUnavailableView<Label, Description, Actions>
}

/// A container for views that you present as menu items in a context menu.
///
/// A context menu view allows you to present a situationally specific menu
/// that enables taking actions relevant to the current task.
///
/// You can create a context menu by first defining a `ContextMenu` container
/// with the controls that represent the actions that people can take,
/// and then using the ``View/contextMenu(_:)`` view modifier to apply the
/// menu to a view.
///
/// The example below creates and applies a two item context menu container
/// to a ``Text`` view. The Boolean value `shouldShowMenu`, which defaults to
/// true, controls the availability of context menu:
///
///     private let menuItems = ContextMenu {
///         Button {
///             // Add this item to a list of favorites.
///         } label: {
///             Label("Add to Favorites", systemImage: "heart")
///         }
///         Button {
///             // Open Maps and center it on this item.
///         } label: {
///             Label("Show in Maps", systemImage: "mappin")
///         }
///     }
///
///     private struct ContextMenuMenuItems: View {
///         @State private var shouldShowMenu = true
///
///         var body: some View {
///             Text("Turtle Rock")
///                 .contextMenu(shouldShowMenu ? menuItems : nil)
///         }
///     }
///
/// ![A screenshot of a context menu showing two menu items: Add to
/// Favorites, and Show in Maps.](View-contextMenu-1-iOS)
@available(iOS, introduced: 13.0, deprecated: 100000.0, message: "Use `contextMenu(menuItems:)` instead.")
@available(macOS, introduced: 10.15, deprecated: 100000.0, message: "Use `contextMenu(menuItems:)` instead.")
@available(tvOS, unavailable)
@available(watchOS, introduced: 6.0, deprecated: 7.0)
@available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Use `contextMenu(menuItems:)` instead.")
public struct ContextMenu<MenuItems> where MenuItems : View {

    public init(@ViewBuilder menuItems: () -> MenuItems)
}

/// A container view that displays semantically-related controls
/// in a visually-appropriate manner for the context
///
/// You can provide an optional label to this view that describes its children.
/// This view may be used in different ways depending on the surrounding
/// context. For example, when you place the control group in a
/// toolbar item, SwiftUI uses the label when the group is moved to the
/// toolbar's overflow menu.
///
///     ContentView()
///         .toolbar(id: "items") {
///             ToolbarItem(id: "media") {
///                 ControlGroup {
///                     MediaButton()
///                     ChartButton()
///                     GraphButton()
///                 } label: {
///                     Label("Plus", systemImage: "plus")
///                 }
///             }
///         }
///
@available(iOS 15.0, macOS 12.0, tvOS 17.0, *)
@available(watchOS, unavailable)
public struct ControlGroup<Content> : View where Content : View {

    /// Creates a new ControlGroup with the specified children
    ///
    /// - Parameters:
    ///   - content: the children to display
    public init(@ViewBuilder content: () -> Content)

    /// The content and behavior of the view.
    ///
    /// When you implement a custom view, you must implement a computed
    /// `body` property to provide the content for your view. Return a view
    /// that's composed of built-in views that SwiftUI provides, plus other
    /// composite views that you've already defined:
    ///
    ///     struct MyView: View {
    ///         var body: some View {
    ///             Text("Hello, World!")
    ///         }
    ///     }
    ///
    /// For more information about composing views and a view hierarchy,
    /// see <doc:Declaring-a-Custom-View>.
    @MainActor @preconcurrency public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    @available(iOS 15.0, tvOS 17.0, macOS 12.0, *)
    @available(watchOS, unavailable)
    public typealias Body = some View
}

@available(iOS 15.0, macOS 12.0, tvOS 17.0, *)
@available(watchOS, unavailable)
extension ControlGroup where Content == ControlGroupStyleConfiguration.Content {

    /// Creates a control group based on a style configuration.
    ///
    /// Use this initializer within the
    /// ``ControlGroupStyle/makeBody(configuration:)`` method of a
    /// ``ControlGroupStyle`` instance to create an instance of the control group
    /// being styled. This is useful for custom control group styles that modify
    /// the current control group style.
    ///
    /// For example, the following code creates a new, custom style that places a
    /// red border around the current control group:
    ///
    ///     struct RedBorderControlGroupStyle: ControlGroupStyle {
    ///         func makeBody(configuration: Configuration) -> some View {
    ///             ControlGroup(configuration)
    ///                 .border(Color.red)
    ///         }
    ///     }
    ///
    nonisolated public init(_ configuration: ControlGroupStyleConfiguration)
}

@available(iOS 16.0, macOS 13.0, tvOS 17.0, *)
@available(watchOS, unavailable)
extension ControlGroup {

    /// Creates a new control group with the specified content and a label.
    ///
    /// - Parameters:
    ///   - content: The content to display.
    ///   - label: A view that describes the purpose of the group.
    nonisolated public init<C, L>(@ViewBuilder content: () -> C, @ViewBuilder label: () -> L) where Content == LabeledControlGroupContent<C, L>, C : View, L : View
}

@available(iOS 16.0, macOS 13.0, tvOS 17.0, *)
@available(watchOS, unavailable)
extension ControlGroup {

    /// Creates a new control group with the specified content that generates
    /// its label from a localized string key.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the group's localized title, that describes
    ///     the contents of the group.
    ///   - label: A view that describes the purpose of the group.
    nonisolated public init<C>(_ titleKey: LocalizedStringKey, @ViewBuilder content: () -> C) where Content == LabeledControlGroupContent<C, Text>, C : View

    /// Creates a new control group with the specified content that generates
    /// its label from a string.
    ///
    /// - Parameters:
    ///   - title: A string that describes the contents of the group.
    ///   - label: A view that describes the purpose of the group.
    nonisolated public init<C, S>(_ title: S, @ViewBuilder content: () -> C) where Content == LabeledControlGroupContent<C, Text>, C : View, S : StringProtocol
}

@available(iOS 16.0, macOS 13.0, tvOS 17.0, *)
@available(watchOS, unavailable)
extension ControlGroup {

    /// Creates a new control group with the specified content that generates
    /// its label from a localized string key and image name.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the group's localized title, that describes
    ///     the contents of the group.
    ///   - systemImage: The name of the image resource to lookup.
    ///   - label: A view that describes the purpose of the group.
    nonisolated public init<C>(_ titleKey: LocalizedStringKey, systemImage: String, @ViewBuilder content: () -> C) where Content == LabeledControlGroupContent<C, Label<Text, Image>>, C : View

    /// Creates a new control group with the specified content that generates
    /// its label from a string and image name.
    ///
    /// - Parameters:
    ///   - title: A string that describes the contents of the group.
    ///   - systemImage: The name of the image resource to lookup.
    ///   - label: A view that describes the purpose of the group.
    nonisolated public init<C, S>(_ title: S, systemImage: String, @ViewBuilder content: () -> C) where Content == LabeledControlGroupContent<C, Label<Text, Image>>, C : View, S : StringProtocol
}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, *)
@available(watchOS, unavailable)
extension ControlGroup {

    /// Creates a new control group with the specified content that generates
    /// its label from a localized string key and image resource.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the group's localized title, that describes
    ///     the contents of the group.
    ///   - systemImage: The name of the image resource to lookup.
    ///   - label: A view that describes the purpose of the group.
    nonisolated public init<C>(_ titleKey: LocalizedStringKey, image: ImageResource, @ViewBuilder content: () -> C) where Content == LabeledControlGroupContent<C, Label<Text, Image>>, C : View

    /// Creates a new control group with the specified content that generates
    /// its label from a string and image name.
    ///
    /// - Parameters:
    ///   - title: A string that describes the contents of the group.
    ///   - systemImage: The name of the image resource to lookup.
    ///   - label: A view that describes the purpose of the group.
    nonisolated public init<C, S>(_ title: S, image: ImageResource, @ViewBuilder content: () -> C) where Content == LabeledControlGroupContent<C, Label<Text, Image>>, C : View, S : StringProtocol
}

/// Defines the implementation of all control groups within a view
/// hierarchy.
///
/// To configure the current `ControlGroupStyle` for a view hierarchy, use the
/// ``View/controlGroupStyle(_:)`` modifier.
@available(iOS 15.0, macOS 12.0, tvOS 17.0, *)
@available(watchOS, unavailable)
@MainActor @preconcurrency public protocol ControlGroupStyle {

    /// A view representing the body of a control group.
    associatedtype Body : View

    /// Creates a view representing the body of a control group.
    ///
    /// - Parameter configuration: The properties of the control group instance
    ///   being created.
    ///
    /// This method will be called for each instance of ``ControlGroup`` created
    /// within a view hierarchy where this style is the current
    /// `ControlGroupStyle`.
    @ViewBuilder @MainActor @preconcurrency func makeBody(configuration: Self.Configuration) -> Self.Body

    /// The properties of a `ControlGroup` instance being created.
    typealias Configuration = ControlGroupStyleConfiguration
}

@available(iOS 17.0, macOS 14.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension ControlGroupStyle where Self == PaletteControlGroupStyle {

    /// A control group style that presents its content as a palette.
    ///
    /// - Note: When used outside of menus, this style is rendered as a
    /// segmented control.
    ///
    /// Use this style to render a multi-select or a stateless palette.
    /// The following example creates a control group that contains both type of shelves:
    ///
    ///     Menu {
    ///         // A multi select palette
    ///         ControlGroup {
    ///             ForEach(ColorTags.allCases) { colorTag in
    ///                 Toggle(isOn: $selectedColorTags[colorTag]) {
    ///                     Label(colorTag.name, systemImage: "circle")
    ///                 }
    ///                 .tint(colorTag.color)
    ///             }
    ///         }
    ///         .controlGroupStyle(.palette)
    ///         .paletteSelectionEffect(.symbolVariant(.fill))
    ///
    ///         // A momentary / stateless palette
    ///         ControlGroup {
    ///             ForEach(Emotes.allCases) { emote in
    ///                 Button {
    ///                     sendEmote(emote)
    ///                 } label: {
    ///                     Label(emote.name, systemImage: emote.systemImage)
    ///                 }
    ///             }
    ///         }
    ///         .controlGroupStyle(.palette)
    ///     }
    ///
    /// To apply this style to a control group, or to a view that contains
    /// control groups, use the ``View/controlGroupStyle(_:)`` modifier.
    @MainActor @preconcurrency public static var palette: PaletteControlGroupStyle { get }
}

@available(iOS 15.0, macOS 12.0, tvOS 17.0, *)
@available(watchOS, unavailable)
extension ControlGroupStyle where Self == AutomaticControlGroupStyle {

    /// The default control group style.
    ///
    /// The default control group style can vary by platform. By default, both
    /// platforms use a momentary segmented control style that's appropriate for
    /// the environment in which it is rendered.
    ///
    /// You can override a control group's style. To apply the default style to
    /// a control group or to a view that contains a control group, use
    /// the ``View/controlGroupStyle(_:)`` modifier.
    @MainActor @preconcurrency public static var automatic: AutomaticControlGroupStyle { get }
}

@available(iOS 15.0, macOS 12.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension ControlGroupStyle where Self == NavigationControlGroupStyle {

    /// The navigation control group style.
    ///
    /// Use this style to group controls related to navigation, such as
    /// back/forward buttons or timeline navigation controls.
    ///
    /// The navigation control group style can vary by platform. On iOS, it
    /// renders as individual borderless buttons, while on macOS, it displays as
    /// a separated momentary segmented control.
    ///
    /// To apply this style to a control group or to a view that contains a
    /// control group, use the ``View/controlGroupStyle(_:)`` modifier.
    @MainActor @preconcurrency public static var navigation: NavigationControlGroupStyle { get }
}

@available(iOS 16.4, macOS 13.3, tvOS 17.0, *)
@available(watchOS, unavailable)
extension ControlGroupStyle where Self == MenuControlGroupStyle {

    /// A control group style that presents its content as a menu when the user
    /// presses the control, or as a submenu when nested within a larger menu.
    ///
    /// To apply this style to a control group, or to a view that contains
    /// control groups, use the ``View/controlGroupStyle(_:)`` modifier.
    @MainActor @preconcurrency public static var menu: MenuControlGroupStyle { get }
}

@available(iOS 16.4, macOS 13.3, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension ControlGroupStyle where Self == CompactMenuControlGroupStyle {

    /// A control group style that presents its content as a compact menu when the user
    /// presses the control, or as a submenu when nested within a larger menu.
    ///
    /// To apply this style to a control group, or to a view that contains
    /// control groups, use the ``View/controlGroupStyle(_:)`` modifier.
    @MainActor @preconcurrency public static var compactMenu: CompactMenuControlGroupStyle { get }
}

/// The properties of a control group.
@available(iOS 15.0, macOS 12.0, tvOS 17.0, *)
@available(watchOS, unavailable)
public struct ControlGroupStyleConfiguration {

    /// A type-erased content of a `ControlGroup`.
    @MainActor @preconcurrency public struct Content : View {

        /// The type of view representing the body of this view.
        ///
        /// When you create a custom view, Swift infers this type from your
        /// implementation of the required ``View/body-swift.property`` property.
        @available(iOS 15.0, tvOS 17.0, macOS 12.0, *)
        @available(watchOS, unavailable)
        public typealias Body = Never
    }

    /// A view that represents the content of the `ControlGroup`.
    public let content: ControlGroupStyleConfiguration.Content

    /// A type-erased label of a ``ControlGroup``.
    @available(iOS 16.0, macOS 13.0, *)
    @MainActor @preconcurrency public struct Label : View {

        /// The type of view representing the body of this view.
        ///
        /// When you create a custom view, Swift infers this type from your
        /// implementation of the required ``View/body-swift.property`` property.
        @available(iOS 16.0, tvOS 17.0, macOS 13.0, *)
        @available(watchOS, unavailable)
        public typealias Body = Never
    }

    /// A view that provides the optional label of the ``ControlGroup``.
    @available(iOS 16.0, macOS 13.0, *)
    public let label: ControlGroupStyleConfiguration.Label
}

/// The configuration and content of a control widget to display in system spaces
///  such as Control Center, the Lock Screen, and the Action Button.
///
/// Controls allow users to quickly read the state of your app or its
/// accessories, and take quick actions, without having to open your app. Users
/// can add, configure, and arrange controls to suit their individual needs. You
/// can provide multiple types of controls, each representing a specific kind of
/// action.
///
/// There are three key components to a control:
///
/// * A configuration that determines whether the control is configurable,
///   identifies the control, and defines the SwiftUI template that provides the
///   control's content.
/// * A value provider that defines the value of the control when being
///   previewed and when being actually rendered
/// * The template used by WidgetKit to display the control.
///
/// Controls are defined using templates in order to ensure that they control
/// will work at all sizes and in all system spaces in which they might be
/// displayed. These templates define images (specifically, symbol images) and
/// text using simple SwiftUI views like ``Label``, ``Text``, and ``Image``; and
/// tint colors using the ``ControlWidgetTemplate/tint(_:)`` modifier.
@available(iOS 18.0, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@available(visionOS, unavailable)
@MainActor @preconcurrency public protocol ControlWidget {

    /// Creates a control using `body` as its content.
    @MainActor @preconcurrency init()

    /// The type of configuration representing the content of this control.
    ///
    /// When you create a custom control, Swift infers this type from your
    /// implementation of the required ``ControlWidget/body-swift.property``
    /// property.
    associatedtype Body : ControlWidgetConfiguration

    /// The content and behavior of the control.
    ///
    /// For any controls that you create, provide a computed `body` property
    /// that defines the control using some control widget configuration.
    ///
    /// Swift infers the control's ``SwiftUI/ControlWidget/Body-swift.associatedtype``
    /// associated type based on the contents of the `body` property.
    @ControlWidgetConfigurationBuilder @MainActor @preconcurrency var body: Self.Body { get }
}

/// A type that describes a control widget's content.
@available(iOS 18.0, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@available(visionOS, unavailable)
@MainActor @preconcurrency public protocol ControlWidgetConfiguration {

    /// The type of control widget configuration representing the body of this
    /// configuration.
    associatedtype Body : ControlWidgetConfiguration

    /// The content and behavior of the control.
    @ControlWidgetConfigurationBuilder @MainActor @preconcurrency var body: Self.Body { get }
}

/// A custom attribute that constructs a control widget's body.
///
/// The `@ControlWidgetConfigurationBuilder` attribute allows your control
/// widget's body closure to produce a control widget configuration after zero
/// or more other statements:
///
///     struct GarageDoorOpener: ControlWidget {
///         var body: some ControlWidgetConfiguration {
///             let kind = "com.yourcompany.GarageDoorOpener"
///
///             StaticControlConfiguration(
///                 kind: kind
///             ) {
///                 ...
///             }
///         }
///     }
///
@available(iOS 18.0, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@available(visionOS, unavailable)
@resultBuilder public struct ControlWidgetConfigurationBuilder {

    /// Builds an expression within the builder.
    public static func buildExpression<Content>(_ content: Content) -> Content where Content : ControlWidgetConfiguration

    /// Passes a single control widget configuration written as a child control
    /// through unmodified.
    ///
    /// An example of a single control widget configuration written as a child
    /// view is `{ StaticControlConfiguration(...) }`.
    public static func buildBlock<Content>(_ content: Content) -> some ControlWidgetConfiguration where Content : ControlWidgetConfiguration

}

/// A type that describes a control widget's content.
///
/// Controls are defined using templates in order to ensure that they control
/// will work at all sizes and in all system spaces in which they might be
/// displayed. These templates define images (specifically, symbol images) and
/// text using simple SwiftUI views like ``Label``, ``Text``, and ``Image``; and
/// tint colors using the ``ControlWidgetTemplate/tint(_:)`` modifier.
@available(iOS 18.0, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@available(visionOS, unavailable)
@MainActor @preconcurrency public protocol ControlWidgetTemplate {

    /// The type of control widget template representing the body of this template.
    ///
    /// When you create a custom control widget, Swift infers this type from your
    /// implementation of the required ``ControlWidgetTemplate/body-swift.property``
    /// property.
    associatedtype Body : ControlWidgetTemplate

    /// The content and behavior of this control widget.
    @ControlWidgetTemplateBuilder @MainActor @preconcurrency var body: Self.Body { get }
}

/// A custom attribute that constructs a control widget template's body.
///
/// The `@ControlWidgetTemplateBuilder` attribute allows your control
/// template's body closure to produce a control template after zero or more
/// other statements:
///
///     struct GarageDoorOpener: ControlWidget {
///         var body: some ControlWidgetConfiguration {
///             let kind = "com.yourcompany.GarageDoorOpener"
///
///             StaticControlConfiguration(
///                 kind: kind
///             ) {
///                 let isOpen = ...
///
///                 ControlWidgetToggle(
///                     "Garage Door",
///                     isOn: isOpen,
///                     action: ToggleGarageDoor()
///                 ) {
///                     Label(
///                         $0 ? "Open" : "Closed",
///                         systemImage: $0 ?
///                             "door.garage.open" : "door.garage.closed"
///                     )
///                 }
///             }
///         }
///     }
///
@available(iOS 18.0, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@available(visionOS, unavailable)
@resultBuilder public struct ControlWidgetTemplateBuilder {

    /// Builds an expression within the builder.
    public static func buildExpression<Content>(_ content: Content) -> Content where Content : ControlWidgetTemplate

    /// Passes a single control widget template written as a child view
    /// through unmodified.
    ///
    /// An example of a single control widget template written as a child
    /// view is `{ ControlWidgetToggle(...) }`.
    public static func buildBlock<Content>(_ content: Content) -> some ControlWidgetTemplate where Content : ControlWidgetTemplate

}

/// The definition of a custom detent with a calculated height.
///
/// You can create and use a custom detent with built-in detents.
///
///     extension PresentationDetent {
///         static let bar = Self.custom(BarDetent.self)
///         static let small = Self.height(100)
///         static let extraLarge = Self.fraction(0.75)
///     }
///
///     private struct BarDetent: CustomPresentationDetent {
///         static func height(in context: Context) -> CGFloat? {
///             max(44, context.maxDetentValue * 0.1)
///         }
///     }
///
///     struct ContentView: View {
///         @State private var showSettings = false
///         @State private var selectedDetent = PresentationDetent.bar
///
///         var body: some View {
///             Button("View Settings") {
///                 showSettings = true
///             }
///             .sheet(isPresented: $showSettings) {
///                 SettingsView(selectedDetent: $selectedDetent)
///                     .presentationDetents(
///                         [.bar, .small, .medium, .large, .extraLarge],
///                         selection: $selectedDetent)
///             }
///         }
///     }
///
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public protocol CustomPresentationDetent {

    /// Calculates and returns a height based on the context.
    ///
    /// - Parameter context: Information that can help to determine the
    ///   height of the detent.
    ///
    /// - Returns: The height of the detent, or `nil` if the detent should be
    ///   inactive based on the `contenxt` input.
    static func height(in context: Self.Context) -> CGFloat?
}

@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension CustomPresentationDetent {

    /// Information that you can use to calculate the height of a custom detent.
    public typealias Context = PresentationDetent.Context
}

/// Conforming types represent items that can be placed in various locations
/// in a customizable toolbar.
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public protocol CustomizableToolbarContent : ToolbarContent where Self.Body : CustomizableToolbarContent {
}

extension CustomizableToolbarContent {

    /// Configures the customization behavior of customizable toolbar content.
    ///
    /// Customizable toolbar items support different kinds of customization:
    /// * A user can add an an item that is not in the toolbar.
    /// * A user can remove an item that is in the toolbar.
    /// * A user can move an item within the toolbar.
    ///
    /// Based on the customization behavior of the toolbar items, different
    /// edits will be supported.
    ///
    /// Use this modifier to the customization behavior a user can
    /// perform on your toolbar items. In the following example, the
    /// customizable toolbar item supports all of the different kinds of
    /// toolbar customizations and starts in the toolbar.
    ///
    ///     ContentView()
    ///         .toolbar(id: "main") {
    ///             ToolbarItem(id: "new") {
    ///                 // new button here
    ///             }
    ///         }
    ///
    /// You can create an item that can not be removed from the toolbar
    /// or moved within the toolbar  by passing a value of
    /// ``ToolbarCustomizationBehavior/disabled`` to this modifier.
    ///
    ///     ContentView()
    ///         .toolbar(id: "main") {
    ///             ToolbarItem(id: "new") {
    ///                 // new button here
    ///             }
    ///             .customizationBehavior(.disabled)
    ///         }
    ///
    /// You can create an item that can not be removed from the toolbar, but
    /// can be moved by passing a value of
    /// ``ToolbarCustomizationBehavior/reorderable``.
    ///
    ///     ContentView()
    ///         .toolbar(id: "main") {
    ///             ToolbarItem(id: "new") {
    ///                 // new button here
    ///             }
    ///             .customizationBehavior(.reorderable)
    ///         }
    ///
    /// - Parameter behavior: The customization behavior of the customizable
    ///   toolbar content.
    @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
    nonisolated public func customizationBehavior(_ behavior: ToolbarCustomizationBehavior) -> some CustomizableToolbarContent

}

extension CustomizableToolbarContent {

    /// Configures the way customizable toolbar items with the default
    /// behavior behave.
    ///
    /// Default customizable items support a variety of edits by the user.
    /// * A user can add an an item that is not in the toolbar.
    /// * A user can remove an item that is in the toolbar.
    /// * A user can move an item within the toolbar.
    ///
    /// By default, all default customizable items will be initially
    /// present in the toolbar. Provide a value of
    /// ``Visibility/hidden`` to this modifier to specify that items should
    /// initially be hidden from the user, and require them to add those items
    /// to the toolbar if desired.
    ///
    ///     ContentView()
    ///         .toolbar(id: "main") {
    ///             ToolbarItem(id: "new") {
    ///                 // new button here
    ///             }
    ///             .defaultCustomization(.hidden)
    ///         }
    ///
    /// You can ensure that the user can always use an item with default
    /// customizability, even if it's removed from the customizable toolbar. To
    /// do this, provide the ``ToolbarCustomizationOptions/alwaysAvailable``
    /// option. These items will remain in the overflow if the user removes them
    /// from the toolbar.
    ///
    /// Provide a value of ``ToolbarCustomizationOptions/alwaysAvailable`` to
    /// the options parameter of this modifier to receive this behavior.
    ///
    ///     ContentView()
    ///         .toolbar(id: "main") {
    ///             ToolbarItem(id: "new") {
    ///                 // new button here
    ///             }
    ///             .defaultCustomization(options: .alwaysAvailable)
    ///         }
    ///
    /// - Parameters:
    ///   - defaultVisibility: The default visibility of toolbar content
    ///     with the default customization behavior.
    ///   - options: The customization options to configure the behavior
    ///     of toolbar content with the default customization behavior.
    @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
    public func defaultCustomization(_ defaultVisibility: Visibility = .automatic, options: ToolbarCustomizationOptions = []) -> some CustomizableToolbarContent


    /// Configures customizable toolbar content with the default visibility
    /// and options.
    ///
    /// Use the ``CustomizableToolbarContent/defaultCustomization(_:options:)``
    /// modifier providing either a `defaultVisibility` or `options` instead.
    @available(iOS, introduced: 16.0, deprecated: 16.0, message: "Please provide either a visibility or customization options")
    @available(macOS, introduced: 13.0, deprecated: 13.0, message: "Please provide either a visibility or customization options")
    @available(tvOS, introduced: 16.0, deprecated: 16.0, message: "Please provide either a visibility or customization options")
    @available(watchOS, introduced: 9.0, deprecated: 9.0, message: "Please provide either a visibility or customization options")
    public func defaultCustomization() -> some CustomizableToolbarContent

}

/// A control for selecting an absolute date.
///
/// Use a `DatePicker` when you want to provide a view that allows the user to
/// select a calendar date, and optionally a time. The view binds to a
/// <doc://com.apple.documentation/documentation/Foundation/Date> instance.
///
/// The following example creates a basic `DatePicker`, which appears on iOS as
/// text representing the date. This example limits the display to only the
/// calendar date, not the time. When the user taps or clicks the text, a
/// calendar view animates in, from which the user can select a date. When the
/// user dismisses the calendar view, the view updates the bound
/// <doc://com.apple.documentation/documentation/Foundation/Date>.
///
///     @State private var date = Date()
///
///     var body: some View {
///         DatePicker(
///             "Start Date",
///             selection: $date,
///             displayedComponents: [.date]
///         )
///     }
///
/// ![An iOS date picker, consisting of a label that says Start Date, and a
/// label showing the date Apr 1, 1976.](SwiftUI-DatePicker-basic.png)
///
/// For cases where adding a subtitle to the label is desired, use a view
/// builder that creates multiple `Text` views where the first text represents
/// the title and the second text represents the subtitle:
///
///     @State private var date = Date()
///
///     var body: some View {
///         DatePicker(selection: $date) {
///             Text("Start Date")
///             Text("Select the starting date for the event")
///         }
///     }
///
/// You can limit the `DatePicker` to specific ranges of dates, allowing
/// selections only before or after a certain date, or between two dates. The
/// following example shows a date-and-time picker that only permits selections
/// within the year 2021 (in the `UTC` time zone).
///
///     @State private var date = Date()
///     let dateRange: ClosedRange<Date> = {
///         let calendar = Calendar.current
///         let startComponents = DateComponents(year: 2021, month: 1, day: 1)
///         let endComponents = DateComponents(year: 2021, month: 12, day: 31, hour: 23, minute: 59, second: 59)
///         return calendar.date(from:startComponents)!
///             ...
///             calendar.date(from:endComponents)!
///     }()
///
///     var body: some View {
///         DatePicker(
///             "Start Date",
///              selection: $date,
///              in: dateRange,
///              displayedComponents: [.date, .hourAndMinute]
///         )
///     }
///
/// ![A SwiftUI standard date picker on iOS, with the label Start Date, and
/// buttons for the time 5:15 PM and the date Jul 31,
/// 2021.](SwiftUI-DatePicker-selectFromRange.png)
///
/// ### Styling date pickers
///
/// To use a different style of date picker, use the
/// ``View/datePickerStyle(_:)`` view modifier. The following example shows the
/// graphical date picker style.
///
///     @State private var date = Date()
///
///     var body: some View {
///         DatePicker(
///             "Start Date",
///             selection: $date,
///             displayedComponents: [.date]
///         )
///         .datePickerStyle(.graphical)
///     }
///
/// ![A SwiftUI date picker using the graphical style, with the label Start Date
/// and wheels for the month, day, and year, showing the selection
/// October 22, 2021.](SwiftUI-DatePicker-graphicalStyle.png)
///
@available(iOS 13.0, macOS 10.15, watchOS 10.0, *)
@available(tvOS, unavailable)
public struct DatePicker<Label> : View where Label : View {

    public typealias Components = DatePickerComponents

    /// The content and behavior of the view.
    ///
    /// When you implement a custom view, you must implement a computed
    /// `body` property to provide the content for your view. Return a view
    /// that's composed of built-in views that SwiftUI provides, plus other
    /// composite views that you've already defined:
    ///
    ///     struct MyView: View {
    ///         var body: some View {
    ///             Text("Hello, World!")
    ///         }
    ///     }
    ///
    /// For more information about composing views and a view hierarchy,
    /// see <doc:Declaring-a-Custom-View>.
    @MainActor @preconcurrency public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    @available(iOS 13.0, watchOS 10.0, macOS 10.15, *)
    @available(tvOS, unavailable)
    public typealias Body = some View
}

@available(iOS 13.0, macOS 10.15, watchOS 10.0, *)
@available(tvOS, unavailable)
extension DatePicker {

    /// Creates an instance that selects a `Date` with an unbounded range.
    ///
    /// - Parameters:
    ///   - selection: The date value being displayed and selected.
    ///   - displayedComponents: The date components that user is able to
    ///     view and edit. Defaults to `[.hourAndMinute, .date]`. On watchOS,
    ///     if `.hourAndMinute` or `.hourMinuteAndSecond` are included with
    ///     `.date`, only `.date` is displayed.
    ///   - label: A view that describes the use of the date.
    nonisolated public init(selection: Binding<Date>, displayedComponents: DatePicker<Label>.Components = [.hourAndMinute, .date], @ViewBuilder label: () -> Label)

    /// Creates an instance that selects a `Date` in a closed range.
    ///
    /// - Parameters:
    ///   - selection: The date value being displayed and selected.
    ///   - range: The inclusive range of selectable dates.
    ///   - displayedComponents: The date components that user is able to
    ///     view and edit. Defaults to `[.hourAndMinute, .date]`. On watchOS,
    ///     if `.hourAndMinute` or `.hourMinuteAndSecond` are included with
    ///     `.date`, only `.date` is displayed.
    ///   - label: A view that describes the use of the date.
    nonisolated public init(selection: Binding<Date>, in range: ClosedRange<Date>, displayedComponents: DatePicker<Label>.Components = [.hourAndMinute, .date], @ViewBuilder label: () -> Label)

    /// Creates an instance that selects a `Date` on or after some start date.
    ///
    /// - Parameters:
    ///   - selection: The date value being displayed and selected.
    ///   - range: The open range from some selectable start date.
    ///   - displayedComponents: The date components that user is able to
    ///     view and edit. Defaults to `[.hourAndMinute, .date]`. On watchOS,
    ///     if `.hourAndMinute` or `.hourMinuteAndSecond` are included with
    ///     `.date`, only `.date` is displayed.
    ///   - label: A view that describes the use of the date.
    nonisolated public init(selection: Binding<Date>, in range: PartialRangeFrom<Date>, displayedComponents: DatePicker<Label>.Components = [.hourAndMinute, .date], @ViewBuilder label: () -> Label)

    /// Creates an instance that selects a `Date` on or before some end date.
    ///
    /// - Parameters:
    ///   - selection: The date value being displayed and selected.
    ///   - range: The open range before some selectable end date.
    ///   - displayedComponents: The date components that user is able to
    ///     view and edit. Defaults to `[.hourAndMinute, .date]`. On watchOS,
    ///     if `.hourAndMinute` or `.hourMinuteAndSecond` are included with
    ///     `.date`, only `.date` is displayed.
    ///   - label: A view that describes the use of the date.
    nonisolated public init(selection: Binding<Date>, in range: PartialRangeThrough<Date>, displayedComponents: DatePicker<Label>.Components = [.hourAndMinute, .date], @ViewBuilder label: () -> Label)
}

@available(iOS 13.0, macOS 10.15, watchOS 10.0, *)
@available(tvOS, unavailable)
extension DatePicker where Label == Text {

    /// Creates an instance that selects a `Date` with an unbounded range.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the localized title of `self`, describing
    ///     its purpose.
    ///   - selection: The date value being displayed and selected.
    ///   - displayedComponents: The date components that user is able to
    ///     view and edit. Defaults to `[.hourAndMinute, .date]`. On watchOS,
    ///     if `.hourAndMinute` or `.hourMinuteAndSecond` are included with
    ///     `.date`, only `.date` is displayed.
    nonisolated public init(_ titleKey: LocalizedStringKey, selection: Binding<Date>, displayedComponents: DatePicker<Label>.Components = [.hourAndMinute, .date])

    /// Creates an instance that selects a `Date` in a closed range.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the localized title of `self`, describing
    ///     its purpose.
    ///   - selection: The date value being displayed and selected.
    ///   - range: The inclusive range of selectable dates.
    ///   - displayedComponents: The date components that user is able to
    ///     view and edit. Defaults to `[.hourAndMinute, .date]`. On watchOS,
    ///     if `.hourAndMinute` or `.hourMinuteAndSecond` are included with
    ///     `.date`, only `.date` is displayed.
    nonisolated public init(_ titleKey: LocalizedStringKey, selection: Binding<Date>, in range: ClosedRange<Date>, displayedComponents: DatePicker<Label>.Components = [.hourAndMinute, .date])

    /// Creates an instance that selects a `Date` on or after some start date.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the localized title of `self`, describing
    ///     its purpose.
    ///   - selection: The date value being displayed and selected.
    ///   - range: The open range from some selectable start date.
    ///   - displayedComponents: The date components that user is able to
    ///     view and edit. Defaults to `[.hourAndMinute, .date]`. On watchOS,
    ///     if `.hourAndMinute` or `.hourMinuteAndSecond` are included with
    ///     `.date`, only `.date` is displayed.
    nonisolated public init(_ titleKey: LocalizedStringKey, selection: Binding<Date>, in range: PartialRangeFrom<Date>, displayedComponents: DatePicker<Label>.Components = [.hourAndMinute, .date])

    /// Creates an instance that selects a `Date` on or before some end date.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the localized title of `self`, describing
    ///     its purpose.
    ///   - selection: The date value being displayed and selected.
    ///   - range: The open range before some selectable end date.
    ///   - displayedComponents: The date components that user is able to
    ///     view and edit. Defaults to `[.hourAndMinute, .date]`. On watchOS,
    ///     if `.hourAndMinute` or `.hourMinuteAndSecond` are included with
    ///     `.date`, only `.date` is displayed.
    nonisolated public init(_ titleKey: LocalizedStringKey, selection: Binding<Date>, in range: PartialRangeThrough<Date>, displayedComponents: DatePicker<Label>.Components = [.hourAndMinute, .date])

    /// Creates an instance that selects a `Date` within the given range.
    ///
    /// - Parameters:
    ///   - title: The title of `self`, describing its purpose.
    ///   - selection: The date value being displayed and selected.
    ///   - displayedComponents: The date components that user is able to
    ///     view and edit. Defaults to `[.hourAndMinute, .date]`. On watchOS,
    ///     if `.hourAndMinute` or `.hourMinuteAndSecond` are included with
    ///     `.date`, only `.date` is displayed.
    nonisolated public init<S>(_ title: S, selection: Binding<Date>, displayedComponents: DatePicker<Label>.Components = [.hourAndMinute, .date]) where S : StringProtocol

    /// Creates an instance that selects a `Date` in a closed range.
    ///
    /// - Parameters:
    ///   - title: The title of `self`, describing its purpose.
    ///   - selection: The date value being displayed and selected.
    ///   - range: The inclusive range of selectable dates.
    ///   - displayedComponents: The date components that user is able to
    ///     view and edit. Defaults to `[.hourAndMinute, .date]`. On watchOS,
    ///     if `.hourAndMinute` or `.hourMinuteAndSecond` are included with
    ///     `.date`, only `.date` is displayed.
    nonisolated public init<S>(_ title: S, selection: Binding<Date>, in range: ClosedRange<Date>, displayedComponents: DatePicker<Label>.Components = [.hourAndMinute, .date]) where S : StringProtocol

    /// Creates an instance that selects a `Date` on or after some start date.
    ///
    /// - Parameters:
    ///   - title: The title of `self`, describing its purpose.
    ///   - selection: The date value being displayed and selected.
    ///   - range: The open range from some selectable start date.
    ///   - displayedComponents: The date components that user is able to
    ///     view and edit. Defaults to `[.hourAndMinute, .date]`. On watchOS,
    ///     if `.hourAndMinute` or `.hourMinuteAndSecond` are included with
    ///     `.date`, only `.date` is displayed.
    nonisolated public init<S>(_ title: S, selection: Binding<Date>, in range: PartialRangeFrom<Date>, displayedComponents: DatePicker<Label>.Components = [.hourAndMinute, .date]) where S : StringProtocol

    /// Creates an instance that selects a `Date` on or before some end date.
    ///
    /// - Parameters:
    ///   - title: The title of `self`, describing its purpose.
    ///   - selection: The date value being displayed and selected.
    ///   - range: The open range before some selectable end date.
    ///   - displayedComponents: The date components that user is able to
    ///     view and edit. Defaults to `[.hourAndMinute, .date]`. On watchOS,
    ///     if `.hourAndMinute` or `.hourMinuteAndSecond` are included with
    ///     `.date`, only `.date` is displayed.
    nonisolated public init<S>(_ title: S, selection: Binding<Date>, in range: PartialRangeThrough<Date>, displayedComponents: DatePicker<Label>.Components = [.hourAndMinute, .date]) where S : StringProtocol
}

@available(iOS 13.0, macOS 10.15, watchOS 10.0, *)
@available(tvOS, unavailable)
public struct DatePickerComponents : OptionSet, Sendable {

    /// The corresponding value of the raw type.
    ///
    /// A new instance initialized with `rawValue` will be equivalent to this
    /// instance. For example:
    ///
    ///     enum PaperSize: String {
    ///         case A4, A5, Letter, Legal
    ///     }
    ///
    ///     let selectedSize = PaperSize.Letter
    ///     print(selectedSize.rawValue)
    ///     // Prints "Letter"
    ///
    ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
    ///     // Prints "true"
    public let rawValue: UInt

    /// Creates a new option set from the given raw value.
    ///
    /// This initializer always succeeds, even if the value passed as `rawValue`
    /// exceeds the static properties declared as part of the option set. This
    /// example creates an instance of `ShippingOptions` with a raw value beyond
    /// the highest element, with a bit mask that effectively contains all the
    /// declared static members.
    ///
    ///     let extraOptions = ShippingOptions(rawValue: 255)
    ///     print(extraOptions.isStrictSuperset(of: .all))
    ///     // Prints "true"
    ///
    /// - Parameter rawValue: The raw value of the option set to create. Each bit
    ///   of `rawValue` potentially represents an element of the option set,
    ///   though raw values may include bits that are not defined as distinct
    ///   values of the `OptionSet` type.
    public init(rawValue: UInt)

    /// Displays hour and minute components based on the locale
    public static let hourAndMinute: DatePickerComponents

    /// Displays day, month, and year based on the locale
    public static let date: DatePickerComponents

    /// The type of the elements of an array literal.
    @available(iOS 13.0, watchOS 10.0, macOS 10.15, *)
    @available(tvOS, unavailable)
    public typealias ArrayLiteralElement = DatePickerComponents

    /// The element type of the option set.
    ///
    /// To inherit all the default implementations from the `OptionSet` protocol,
    /// the `Element` type must be `Self`, the default.
    @available(iOS 13.0, watchOS 10.0, macOS 10.15, *)
    @available(tvOS, unavailable)
    public typealias Element = DatePickerComponents

    /// The raw type that can be used to represent all values of the conforming
    /// type.
    ///
    /// Every distinct value of the conforming type has a corresponding unique
    /// value of the `RawValue` type, but there may be values of the `RawValue`
    /// type that don't have a corresponding value of the conforming type.
    @available(iOS 13.0, watchOS 10.0, macOS 10.15, *)
    @available(tvOS, unavailable)
    public typealias RawValue = UInt
}

/// A type that specifies the appearance and interaction of all date pickers
/// within a view hierarchy.
///
/// To configure the current date picker style for a view hierarchy, use the
/// ``View/datePickerStyle(_:)`` modifier.
@available(iOS 13.0, macOS 10.15, watchOS 10.0, *)
@available(tvOS, unavailable)
@MainActor @preconcurrency public protocol DatePickerStyle {

    /// A view representing the appearance and interaction of a `DatePicker`.
    associatedtype Body : View

    /// Returns the appearance and interaction content for a `DatePicker`.
    ///
    /// The system calls this method for each ``DatePicker`` instance in a view
    /// hierarchy where this style is the current date picker style.
    ///
    /// - Parameter configuration : The properties of the date picker.
    @available(iOS 16.0, macOS 13.0, *)
    @ViewBuilder @MainActor @preconcurrency func makeBody(configuration: Self.Configuration) -> Self.Body

    /// A type alias for the properties of a `DatePicker`.
    @available(iOS 16.0, macOS 13.0, *)
    typealias Configuration = DatePickerStyleConfiguration
}

@available(iOS 13.0, watchOS 10.0, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
extension DatePickerStyle where Self == WheelDatePickerStyle {

    /// A date picker style that displays each component as columns in a
    /// scrollable wheel.
    @MainActor @preconcurrency public static var wheel: WheelDatePickerStyle { get }
}

@available(iOS 13.0, macOS 10.15, watchOS 10.0, *)
@available(tvOS, unavailable)
extension DatePickerStyle where Self == DefaultDatePickerStyle {

    /// The default style for date pickers.
    @MainActor @preconcurrency public static var automatic: DefaultDatePickerStyle { get }
}

@available(iOS 14.0, macOS 10.15, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension DatePickerStyle where Self == GraphicalDatePickerStyle {

    /// A date picker style that displays an interactive calendar or clock.
    ///
    /// This style is useful when you want to allow browsing through days in a
    /// calendar, or when the look of a clock face is appropriate.
    @MainActor @preconcurrency public static var graphical: GraphicalDatePickerStyle { get }
}

@available(iOS 14.0, macCatalyst 13.4, macOS 10.15.4, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension DatePickerStyle where Self == CompactDatePickerStyle {

    /// A date picker style that displays the components in a compact, textual
    /// format.
    ///
    /// Use this style when space is constrained and users expect to make
    /// specific date and time selections. Some variants may include rich
    /// editing controls in a pop up.
    @MainActor @preconcurrency public static var compact: CompactDatePickerStyle { get }
}

/// The properties of a `DatePicker`.
@available(iOS 16.0, macOS 13.0, watchOS 10.0, *)
@available(tvOS, unavailable)
public struct DatePickerStyleConfiguration {

    /// A type-erased label of a `DatePicker`.
    @MainActor @preconcurrency public struct Label : View {

        /// The type of view representing the body of this view.
        ///
        /// When you create a custom view, Swift infers this type from your
        /// implementation of the required ``View/body-swift.property`` property.
        @available(iOS 16.0, watchOS 10.0, macOS 13.0, *)
        @available(tvOS, unavailable)
        public typealias Body = Never
    }

    /// A description of the `DatePicker`.
    public let label: DatePickerStyleConfiguration.Label

    /// The date value being displayed and selected.
    @Binding public var selection: Date { get nonmutating set }

    public var $selection: Binding<Date> { get }

    /// The oldest selectable date.
    public var minimumDate: Date?

    /// The most recent selectable date.
    public var maximumDate: Date?

    /// The date components that the user is able to view and edit.
    public var displayedComponents: DatePickerComponents
}

/// The default button style, based on the button's context.
///
/// You can also use ``PrimitiveButtonStyle/automatic`` to construct this style.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public struct DefaultButtonStyle : PrimitiveButtonStyle {

    /// Creates a default button style.
    public init()

    /// Creates a view that represents the body of a button.
    ///
    /// The system calls this method for each ``Button`` instance in a view
    /// hierarchy where this style is the current button style.
    ///
    /// - Parameter configuration : The properties of the button.
    @MainActor @preconcurrency public func makeBody(configuration: DefaultButtonStyle.Configuration) -> some View


    /// A view that represents the body of a button.
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    public typealias Body = some View
}

/// The default style for date pickers.
///
/// You can also use ``DatePickerStyle/automatic`` to construct this style.
@available(iOS 13.0, macOS 10.15, watchOS 10.0, *)
@available(tvOS, unavailable)
@MainActor @preconcurrency public struct DefaultDatePickerStyle : DatePickerStyle {

    /// Creates an instance of the default date picker style.
    @MainActor @preconcurrency public init()

    /// Returns the appearance and interaction content for a `DatePicker`.
    ///
    /// The system calls this method for each ``DatePicker`` instance in a view
    /// hierarchy where this style is the current date picker style.
    ///
    /// - Parameter configuration : The properties of the date picker.
    @available(iOS 16.0, macOS 13.0, *)
    @MainActor @preconcurrency public func makeBody(configuration: DefaultDatePickerStyle.Configuration) -> some View


    /// A view representing the appearance and interaction of a `DatePicker`.
    @available(iOS 13.0, watchOS 10.0, macOS 10.15, *)
    @available(tvOS, unavailable)
    public typealias Body = some View
}

/// The default type of the current value label when used by a date-relative
/// progress view.
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct DefaultDateProgressLabel : View {

    /// The content and behavior of the view.
    ///
    /// When you implement a custom view, you must implement a computed
    /// `body` property to provide the content for your view. Return a view
    /// that's composed of built-in views that SwiftUI provides, plus other
    /// composite views that you've already defined:
    ///
    ///     struct MyView: View {
    ///         var body: some View {
    ///             Text("Hello, World!")
    ///         }
    ///     }
    ///
    /// For more information about composing views and a view hierarchy,
    /// see <doc:Declaring-a-Custom-View>.
    @MainActor @preconcurrency public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
    public typealias Body = some View
}

/// The default actions for the document group launch scene and the document launch view.
///
/// This `View` populates ``DocumentGroupLaunchScene`` and ``DocumentLaunchView``
/// with the default actions.
@available(iOS 18.0, macOS 15.0, visionOS 2.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct DefaultDocumentGroupLaunchActions : View {

    /// The content and behavior of the view.
    ///
    /// When you implement a custom view, you must implement a computed
    /// `body` property to provide the content for your view. Return a view
    /// that's composed of built-in views that SwiftUI provides, plus other
    /// composite views that you've already defined:
    ///
    ///     struct MyView: View {
    ///         var body: some View {
    ///             Text("Hello, World!")
    ///         }
    ///     }
    ///
    /// For more information about composing views and a view hierarchy,
    /// see <doc:Declaring-a-Custom-View>.
    @MainActor @preconcurrency public var body: some View { get }

    public init()

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias Body = some View
}

/// Prioritizations for default focus preferences when evaluating where
/// to move focus in different circumstances.
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct DefaultFocusEvaluationPriority : Sendable {

    /// Use the default focus preference when focus moves into the affected
    /// branch automatically, but ignore it when the movement is driven by a
    /// user-initiated navigation command.
    public static let automatic: DefaultFocusEvaluationPriority

    /// Always use the default focus preference when focus moves into the
    /// affected branch.
    public static let userInitiated: DefaultFocusEvaluationPriority
}

/// The default gauge view style in the current context of the view being
/// styled.
///
/// You can also use ``GaugeStyle/automatic`` to construct this style.
@available(iOS 16.0, macOS 13.0, watchOS 7.0, *)
@available(tvOS, unavailable)
@MainActor @preconcurrency public struct DefaultGaugeStyle : GaugeStyle {

    /// Creates a default gauge style.
    @MainActor @preconcurrency public init()

    /// Creates a view representing the body of a gauge.
    ///
    /// The system calls this modifier on each instance of gauge within a view
    /// hierarchy where this style is the current gauge style.
    ///
    /// - Parameter configuration: The properties to apply to the gauge instance.
    @MainActor @preconcurrency public func makeBody(configuration: DefaultGaugeStyle.Configuration) -> some View


    /// A view representing the body of a gauge.
    @available(iOS 16.0, watchOS 7.0, macOS 13.0, *)
    @available(tvOS, unavailable)
    public typealias Body = some View
}

/// The default style for group box views.
///
/// You can also use ``GroupBoxStyle/automatic`` to construct this style.
@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct DefaultGroupBoxStyle : GroupBoxStyle {

    public init()

    /// Creates a view representing the body of a group box.
    ///
    /// SwiftUI calls this method for each instance of ``SwiftUI/GroupBox``
    /// created within a view hierarchy where this style is the current
    /// group box style.
    ///
    /// - Parameter configuration: The properties of the group box instance being
    ///   created.
    @MainActor @preconcurrency public func makeBody(configuration: DefaultGroupBoxStyle.Configuration) -> some View


    /// A view that represents the body of a group box.
    @available(iOS 14.0, macOS 11.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias Body = some View
}

/// The default label style in the current context.
///
/// You can also use ``LabelStyle/automatic`` to construct this style.
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public struct DefaultLabelStyle : LabelStyle {

    /// Creates an automatic label style.
    public init()

    /// Creates a view that represents the body of a label.
    ///
    /// The system calls this method for each ``Label`` instance in a view
    /// hierarchy where this style is the current label style.
    ///
    /// - Parameter configuration: The properties of the label.
    @MainActor @preconcurrency public func makeBody(configuration: DefaultLabelStyle.Configuration) -> some View


    /// A view that represents the body of a label.
    @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
    public typealias Body = some View
}

/// The list style that describes a platform's default behavior and appearance
/// for a list.
///
/// You can also use ``ListStyle/automatic`` to construct this style.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public struct DefaultListStyle : ListStyle {

    /// Creates a default list style.
    public init()
}

/// The default menu style, based on the menu's context.
///
/// You can also use ``MenuStyle/automatic`` to construct this style.
@available(iOS 14.0, macOS 11.0, tvOS 17.0, *)
@available(watchOS, unavailable)
public struct DefaultMenuStyle : MenuStyle {

    /// Creates a default menu style.
    public init()

    /// Creates a view that represents the body of a menu.
    ///
    /// - Parameter configuration: The properties of the menu.
    ///
    /// The system calls this method for each ``Menu`` instance in a view
    /// hierarchy where this style is the current menu style.
    @MainActor @preconcurrency public func makeBody(configuration: DefaultMenuStyle.Configuration) -> some View


    /// A view that represents the body of a menu.
    @available(iOS 14.0, tvOS 17.0, macOS 11.0, *)
    @available(watchOS, unavailable)
    public typealias Body = some View
}

/// The default navigation view style.
///
/// You can also use ``NavigationViewStyle/automatic`` to construct this style.
@available(iOS, introduced: 13.0, deprecated: 100000.0, message: "replace styled NavigationView with NavigationStack or NavigationSplitView instead")
@available(macOS, introduced: 10.15, deprecated: 100000.0, message: "replace styled NavigationView with NavigationSplitView instead")
@available(tvOS, introduced: 13.0, deprecated: 100000.0, message: "replace styled NavigationView with NavigationStack or NavigationSplitView instead")
@available(watchOS, introduced: 7.0, deprecated: 100000.0, message: "replace styled NavigationView with NavigationStack or NavigationSplitView instead")
@available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "replace styled NavigationView with NavigationStack or NavigationSplitView instead")
public struct DefaultNavigationViewStyle : NavigationViewStyle {

    public init()
}

/// The default picker style, based on the picker's context.
///
/// You can also use ``PickerStyle/automatic`` to construct this style.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public struct DefaultPickerStyle : PickerStyle {

    /// Creates a default picker style.
    public init()
}

/// The default progress view style in the current context of the view being
/// styled.
///
/// Use ``ProgressViewStyle/automatic`` to construct this style.
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public struct DefaultProgressViewStyle : ProgressViewStyle {

    /// Creates a default progress view style.
    public init()

    /// Creates a view representing the body of a progress view.
    ///
    /// - Parameter configuration: The properties of the progress view being
    ///   created.
    ///
    /// The view hierarchy calls this method for each progress view where this
    /// style is the current progress view style.
    ///
    /// - Parameter configuration: The properties of the progress view, such as
    ///  its preferred progress type.
    @MainActor @preconcurrency public func makeBody(configuration: DefaultProgressViewStyle.Configuration) -> some View


    /// A view representing the body of a progress view.
    @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
    public typealias Body = some View
}

/// The default label used for a share link.
///
/// You don't use this type directly. Instead, ``ShareLink`` uses it
/// automatically depending on how you create a share link.
@available(iOS 16.0, macOS 13.0, watchOS 9.0, *)
@available(tvOS, unavailable)
public struct DefaultShareLinkLabel : View {

    /// The content and behavior of the view.
    ///
    /// When you implement a custom view, you must implement a computed
    /// `body` property to provide the content for your view. Return a view
    /// that's composed of built-in views that SwiftUI provides, plus other
    /// composite views that you've already defined:
    ///
    ///     struct MyView: View {
    ///         var body: some View {
    ///             Text("Hello, World!")
    ///         }
    ///     }
    ///
    /// For more information about composing views and a view hierarchy,
    /// see <doc:Declaring-a-Custom-View>.
    @MainActor @preconcurrency public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    @available(iOS 16.0, watchOS 9.0, macOS 13.0, *)
    @available(tvOS, unavailable)
    public typealias Body = some View
}

/// The default label to use for a tab or tab section.
///
/// You don't use this type directly. Instead, the system creates it
/// automatically when you construct a `Tab` or `TabSection`.
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct DefaultTabLabel : View {

    /// The content and behavior of the view.
    ///
    /// When you implement a custom view, you must implement a computed
    /// `body` property to provide the content for your view. Return a view
    /// that's composed of built-in views that SwiftUI provides, plus other
    /// composite views that you've already defined:
    ///
    ///     struct MyView: View {
    ///         var body: some View {
    ///             Text("Hello, World!")
    ///         }
    ///     }
    ///
    /// For more information about composing views and a view hierarchy,
    /// see <doc:Declaring-a-Custom-View>.
    @MainActor @preconcurrency public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias Body = some View
}

/// The default tab view style.
///
/// Use ``TabViewStyle/automatic`` to construct this style.
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public struct DefaultTabViewStyle : TabViewStyle {

    public init()
}

/// The default text field style, based on the text field's context.
///
/// You can also use ``TextFieldStyle/automatic`` to construct this style.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public struct DefaultTextFieldStyle : TextFieldStyle {

    public init()
}

/// The default toggle style.
///
/// Use the ``ToggleStyle/automatic`` static variable to create this style:
///
///     Toggle("Enhance Sound", isOn: $isEnhanced)
///         .toggleStyle(.automatic)
///
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public struct DefaultToggleStyle : ToggleStyle {

    /// Creates a default toggle style.
    ///
    /// Don't call this initializer directly. Instead, use the
    /// ``ToggleStyle/automatic`` static variable to create this style:
    ///
    ///     Toggle("Enhance Sound", isOn: $isEnhanced)
    ///         .toggleStyle(.automatic)
    ///
    public init()

    /// Creates a view that represents the body of a toggle.
    ///
    /// SwiftUI implements this required method of the ``ToggleStyle``
    /// protocol to define the behavior and appearance of the
    /// ``ToggleStyle/automatic`` toggle style. Don't call this method
    /// directly. Rather, the system calls this method for each
    /// ``Toggle`` instance in a view hierarchy that needs the default
    /// style.
    ///
    /// - Parameter configuration: The properties of the toggle, including a
    ///   label and a binding to the toggle's state.
    /// - Returns: A view that acts as a toggle.
    @MainActor @preconcurrency public func makeBody(configuration: DefaultToggleStyle.Configuration) -> some View


    /// A view that represents the appearance and interaction of a toggle.
    ///
    /// SwiftUI infers this type automatically based on the ``View``
    /// instance that you return from your implementation of the
    /// ``makeBody(configuration:)`` method.
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    public typealias Body = some View
}

/// The severity of an alert or confirmation dialog.
///
/// You can use dialog severity to indicate that people need to take extra
/// care when interacting with the dialog, like when an action taken from
/// the dialog permanently deletes data.
@available(iOS 17.0, macOS 13.0, tvOS 17.0, watchOS 10.0, *)
public struct DialogSeverity : Equatable {

    /// The default dialog severity. Alerts that present an error will use `.critical`
    /// and all others will use `.standard`.
    public static let automatic: DialogSeverity

    /// A severity that indicates extra attention should be given to the dialog,
    /// for example when unexpected data loss may occur as a result of the
    /// action taken.
    ///
    /// On macOS, a dialog with critical severity will display a large caution
    /// symbol with the app icon as an overlay.
    public static let critical: DialogSeverity

    /// A severity that indicates the dialog is being displayed for the purpose
    /// of presenting information to the user.
    @available(macOS 14.0, *)
    public static let standard: DialogSeverity

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: DialogSeverity, b: DialogSeverity) -> Bool
}

/// A view that shows or hides another content view, based on the state of a
/// disclosure control.
///
/// A disclosure group view consists of a label to identify the contents, and a
/// control to show and hide the contents. Showing the contents puts the
/// disclosure group into the "expanded" state, and hiding them makes the
/// disclosure group "collapsed".
///
/// In the following example, a disclosure group contains two toggles and
/// an embedded disclosure group. The top level disclosure group exposes its
/// expanded state with the bound property, `topLevelExpanded`. By expanding
/// the disclosure group, the user can use the toggles to update the state of
/// the `toggleStates` structure.
///
///     struct ToggleStates {
///         var oneIsOn: Bool = false
///         var twoIsOn: Bool = true
///     }
///     @State private var toggleStates = ToggleStates()
///     @State private var topExpanded: Bool = true
///
///     var body: some View {
///         DisclosureGroup("Items", isExpanded: $topExpanded) {
///             Toggle("Toggle 1", isOn: $toggleStates.oneIsOn)
///             Toggle("Toggle 2", isOn: $toggleStates.twoIsOn)
///             DisclosureGroup("Sub-items") {
///                 Text("Sub-item 1")
///             }
///         }
///     }
@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct DisclosureGroup<Label, Content> : View where Label : View, Content : View {

    /// Creates a disclosure group with the given label and content views.
    ///
    /// - Parameters:
    ///   - content: The content shown when the disclosure group expands.
    ///   - label: A view that describes the content of the disclosure group.
    public init(@ViewBuilder content: @escaping () -> Content, @ViewBuilder label: () -> Label)

    /// Creates a disclosure group with the given label and content views, and
    /// a binding to the expansion state (expanded or collapsed).
    ///
    /// - Parameters:
    ///   - isExpanded: A binding to a Boolean value that determines the group's
    ///    expansion state (expanded or collapsed).
    ///   - content: The content shown when the disclosure group expands.
    ///   - label: A view that describes the content of the disclosure group.
    public init(isExpanded: Binding<Bool>, @ViewBuilder content: @escaping () -> Content, @ViewBuilder label: () -> Label)

    /// The content and behavior of the view.
    ///
    /// When you implement a custom view, you must implement a computed
    /// `body` property to provide the content for your view. Return a view
    /// that's composed of built-in views that SwiftUI provides, plus other
    /// composite views that you've already defined:
    ///
    ///     struct MyView: View {
    ///         var body: some View {
    ///             Text("Hello, World!")
    ///         }
    ///     }
    ///
    /// For more information about composing views and a view hierarchy,
    /// see <doc:Declaring-a-Custom-View>.
    @MainActor @preconcurrency public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    @available(iOS 14.0, macOS 11.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias Body = some View
}

@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension DisclosureGroup where Label == Text {

    /// Creates a disclosure group, using a provided localized string key to
    /// create a text view for the label.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the localized label of `self` that describes
    ///     the content of the disclosure group.
    ///   - content: The content shown when the disclosure group expands.
    nonisolated public init(_ titleKey: LocalizedStringKey, @ViewBuilder content: @escaping () -> Content)

    /// Creates a disclosure group, using a provided localized string key to
    /// create a text view for the label, and a binding to the expansion state
    /// (expanded or collapsed).
    ///
    /// - Parameters:
    ///   - titleKey: The key for the localized label of `self` that describes
    ///     the content of the disclosure group.
    ///   - isExpanded: A binding to a Boolean value that determines the group's
    ///    expansion state (expanded or collapsed).
    ///   - content: The content shown when the disclosure group expands.
    nonisolated public init(_ titleKey: LocalizedStringKey, isExpanded: Binding<Bool>, @ViewBuilder content: @escaping () -> Content)

    /// Creates a disclosure group, using a provided string to create a
    /// text view for the label.
    ///
    /// - Parameters:
    ///   - label: A description of the content of the disclosure group.
    ///   - content: The content shown when the disclosure group expands.
    nonisolated public init<S>(_ label: S, @ViewBuilder content: @escaping () -> Content) where S : StringProtocol

    /// Creates a disclosure group, using a provided string to create a
    /// text view for the label, and a binding to the expansion state (expanded
    /// or collapsed).
    ///
    /// - Parameters:
    ///   - label: A description of the content of the disclosure group.
    ///   - isExpanded: A binding to a Boolean value that determines the group's
    ///    expansion state (expanded or collapsed).
    ///   - content: The content shown when the disclosure group expands.
    nonisolated public init<S>(_ label: S, isExpanded: Binding<Bool>, @ViewBuilder content: @escaping () -> Content) where S : StringProtocol
}

/// A type that specifies the appearance and interaction of disclosure groups
/// within a view hierarchy.
///
/// To configure the disclosure group style for a view hierarchy, use the
/// ``View/disclosureGroupStyle(_:)`` modifier.
///
/// To create a custom disclosure group style, declare a type that conforms
/// to `DisclosureGroupStyle`. Implement the
/// ``DisclosureGroupStyle/makeBody(configuration:)`` method to return a view
/// that composes the elements of the `configuration` that SwiftUI provides to
/// your method.
///
///     struct MyDisclosureStyle: DisclosureGroupStyle {
///         func makeBody(configuration: Configuration) -> some View {
///             VStack {
///                 Button {
///                     withAnimation {
///                         configuration.isExpanded.toggle()
///                     }
///                 } label: {
///                     HStack(alignment: .firstTextBaseline) {
///                         configuration.label
///                         Spacer()
///                         Text(configuration.isExpanded ? "hide" : "show")
///                             .foregroundColor(.accentColor)
///                             .font(.caption.lowercaseSmallCaps())
///                             .animation(nil, value: configuration.isExpanded)
///                     }
///                     .contentShape(Rectangle())
///                 }
///                 .buttonStyle(.plain)
///                 if configuration.isExpanded {
///                     configuration.content
///                 }
///             }
///         }
///     }
///
@available(iOS 16.0, macOS 13.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@MainActor @preconcurrency public protocol DisclosureGroupStyle {

    /// A view that represents the body of a disclosure group.
    associatedtype Body : View

    /// Creates a view that represents the body of a disclosure group.
    ///
    /// SwiftUI calls this method for each instance of ``DisclosureGroup``
    /// that you create within a view hierarchy where this style is the current
    /// ``DisclosureGroupStyle``.
    ///
    /// - Parameter configuration: The properties of the instance being created.
    @ViewBuilder @MainActor @preconcurrency func makeBody(configuration: Self.Configuration) -> Self.Body

    /// The properties of a disclosure group instance.
    typealias Configuration = DisclosureGroupStyleConfiguration
}

@available(iOS 16.0, macOS 13.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension DisclosureGroupStyle where Self == AutomaticDisclosureGroupStyle {

    /// A disclosure group style that resolves its appearance automatically
    /// based on the current context.
    @MainActor @preconcurrency public static var automatic: AutomaticDisclosureGroupStyle { get }
}

/// The properties of a disclosure group instance.
@available(iOS 16.0, macOS 13.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct DisclosureGroupStyleConfiguration {

    /// A type-erased label of a disclosure group.
    @MainActor @preconcurrency public struct Label : View {

        /// The type of view representing the body of this view.
        ///
        /// When you create a custom view, Swift infers this type from your
        /// implementation of the required ``View/body-swift.property`` property.
        @available(iOS 16.0, macOS 13.0, *)
        @available(tvOS, unavailable)
        @available(watchOS, unavailable)
        public typealias Body = Never
    }

    /// The label for the disclosure group.
    public let label: DisclosureGroupStyleConfiguration.Label

    /// A type-erased content of a disclosure group.
    @MainActor @preconcurrency public struct Content : View {

        /// The type of view representing the body of this view.
        ///
        /// When you create a custom view, Swift infers this type from your
        /// implementation of the required ``View/body-swift.property`` property.
        @available(iOS 16.0, macOS 13.0, *)
        @available(tvOS, unavailable)
        @available(watchOS, unavailable)
        public typealias Body = Never
    }

    /// The content of the disclosure group.
    public let content: DisclosureGroupStyleConfiguration.Content

    /// A binding to a Boolean that indicates whether the disclosure
    /// group is expanded.
    @Binding public var isExpanded: Bool { get nonmutating set }

    public var $isExpanded: Binding<Bool> { get }
}

/// A kind of table row that shows or hides additional rows based on the state
/// of a disclosure control.
///
/// A disclosure group row consists of a label row that is always visible, and
/// some content rows that are conditionally visible depending on the state.
/// Toggling the control will flip the state between "expanded" and "collapsed".
///
/// In the following example, a disclosure group has `allDevices` as the label
/// row, and exposes its expanded state with the bound property, `expanded`.
/// Upon toggling the disclosure control, the user can update the expanded state
/// which will in turn show or hide the three content rows for `iPhone`, `iPad`,
/// and `Mac`.
///
///     private struct DeviceStats: Identifiable {
///         // ...
///     }
///     @State private var expanded: Bool = true
///     @State private var allDevices: DeviceStats = /* ... */
///     @State private var iPhone: DeviceStats = /* ... */
///     @State private var iPad: DeviceStats = /* ... */
///     @State private var Mac: DeviceStats = /* ... */
///
///     var body: some View {
///         Table(of: DeviceStats.self) {
///             // ...
///         } rows: {
///             DisclosureTableRow(allDevices, isExpanded: $expanded) {
///                 TableRow(iPhone)
///                 TableRow(iPad)
///                 TableRow(Mac)
///             }
///         }
///     }
@available(iOS 17.0, macOS 14.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct DisclosureTableRow<Label, Content> : TableRowContent where Label : TableRowContent, Content : TableRowContent, Label.TableRowValue == Content.TableRowValue {

    /// The type of value represented by this table row content.
    public typealias TableRowValue = Label.TableRowValue

    /// Creates a disclosure group with the given value and table rows, and a
    /// binding to the expansion state (expanded or collapsed).
    ///
    /// - Parameters:
    ///   - value: The value of the disclosable table row.
    ///   - isExpanded: A binding to a Boolean value that determines the group's
    ///    expansion state (expanded or collapsed).
    ///   - content: The table row shown when the disclosure group expands.
    public init<Value>(_ value: Value, isExpanded: Binding<Bool>? = nil, @TableRowBuilder<Value> content: @escaping () -> Content) where Label == TableRow<Value>, Value == Content.TableRowValue

    /// The composition of content that comprise the table row content.
    @MainActor @preconcurrency public var tableRowBody: some TableRowContent { get }

    /// The type of content representing the body of this table row content.
    @available(iOS 17.0, macOS 14.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias TableRowBody = some TableRowContent
}

/// An action that dismisses a presentation.
///
/// Use the ``EnvironmentValues/dismiss`` environment value to get the instance
/// of this structure for a given ``Environment``. Then call the instance
/// to perform the dismissal. You call the instance directly because
/// it defines a ``DismissAction/callAsFunction()``
/// method that Swift calls when you call the instance.
///
/// You can use this action to:
///  * Dismiss a modal presentation, like a sheet or a popover.
///  * Pop the current view from a ``NavigationStack``.
///
///  On apps targeting iOS 18 and aligned releases, you also use the dismiss
///  action to pop the implicit stack of a collapsed ``NavigationSplitView``, or
///  clear the equivalent state in an expanded split view.
///
/// The specific behavior of the action depends on where you call it from.
/// For example, you can create a button that calls the ``DismissAction``
/// inside a view that acts as a sheet:
///
///     private struct SheetContents: View {
///         @Environment(\.dismiss) private var dismiss
///
///         var body: some View {
///             Button("Done") {
///                 dismiss()
///             }
///         }
///     }
///
/// When you present the `SheetContents` view, someone can dismiss
/// the sheet by tapping or clicking the sheet's button:
///
///     private struct DetailView: View {
///         @State private var isSheetPresented = false
///
///         var body: some View {
///             Button("Show Sheet") {
///                 isSheetPresented = true
///             }
///             .sheet(isPresented: $isSheetPresented) {
///                 SheetContents()
///             }
///         }
///     }
///
/// Be sure that you define the action in the appropriate environment.
/// For example, don't reorganize the `DetailView` in the example above
/// so that it creates the `dismiss` property and calls it from the
/// ``View/sheet(item:onDismiss:content:)`` view modifier's `content`
/// closure:
///
///     private struct DetailView: View {
///         @State private var isSheetPresented = false
///         @Environment(\.dismiss) private var dismiss // Applies to DetailView.
///
///         var body: some View {
///             Button("Show Sheet") {
///                 isSheetPresented = true
///             }
///             .sheet(isPresented: $isSheetPresented) {
///                 Button("Done") {
///                     dismiss() // Fails to dismiss the sheet.
///                 }
///             }
///         }
///     }
///
/// If you do this, the sheet fails to dismiss because the action applies
/// to the environment where you declared it, which is that of the detail
/// view, rather than the sheet. In fact, in macOS and iPadOS, if the
/// `DetailView` is the root view of a window, the dismiss action closes
/// the window instead.
///
/// The dismiss action has no effect on a view that isn't currently
/// presented. If you need to query whether SwiftUI is currently presenting
/// a view, read the ``EnvironmentValues/isPresented`` environment value.
///
/// - Note: While the dismiss action can be used to a close window that you
///   create with ``WindowGroup`` or ``Window``, prefer ``DismissWindowAction``
///   for that use case instead.
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
@MainActor @preconcurrency public struct DismissAction {

    /// Dismisses the view if it is currently presented.
    ///
    /// Don't call this method directly. SwiftUI calls it for you when you
    /// call the ``DismissAction`` structure that you get from the
    /// ``Environment``:
    ///
    ///     private struct SheetContents: View {
    ///         @Environment(\.dismiss) private var dismiss
    ///
    ///         var body: some View {
    ///             Button("Done") {
    ///                 dismiss() // Implicitly calls dismiss.callAsFunction()
    ///             }
    ///         }
    ///     }
    ///
    /// For information about how Swift uses the `callAsFunction()` method to
    /// simplify call site syntax, see
    /// [Methods with Special Names](https://docs.swift.org/swift-book/ReferenceManual/Declarations.html#ID622)
    /// in *The Swift Programming Language*.
    @MainActor @preconcurrency public func callAsFunction()
}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension DismissAction : Sendable {
}

/// Programmatic window dismissal behaviors.
///
/// Use values of this type to control window dismissal during the
/// current transaction.
///
/// For example, to dismiss windows showing a modal presentation
/// that would otherwise prohibit dismissal, use the ``destructive``
/// behavior:
///
///     struct DismissWindowButton: View {
///         @Environment(\.dismissWindow) private var dismissWindow
///
///         var body: some View {
///             Button("Close Auxiliary Window") {
///                 withTransaction(\.dismissBehavior, .destructive) {
///                     dismissWindow(id: "auxiliary")
///                 }
///             }
///         }
///     }
///
@available(iOS 17.0, macOS 14.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct DismissBehavior : Sendable {

    /// The interactive dismiss behavior.
    ///
    /// Use this behavior when you want to dismiss a window in a manner that is
    /// similar to the standard system affordances for window dismissal - for
    /// example, when a user clicks the close button.
    ///
    /// This is the default behavior on macOS and iOS.
    ///
    /// On macOS, dismissing a window using this behavior will not dismiss a
    /// window which is currently showing a modal presentation, such as a sheet
    /// or alert. Additionally, a document window that is dismissed with this
    /// behavior will show the save dialog if there are unsaved changes to the
    /// document.
    ///
    /// On iOS, dismissing a window using this behavior will dismiss it
    /// regardless of any modal presentations being shown.
    public static let interactive: DismissBehavior

    /// The destructive dismiss behavior.
    ///
    /// Use this behavior when you want to dismiss a window regardless of
    /// any conditions that would normally prevent the dismissal. Dismissing
    /// windows in this matter may result in loss of state.
    ///
    /// On macOS, this behavior will cause windows to dismiss even when they are
    /// currently showing a modal presentation, such as a sheet or alert.
    /// Additionally, a document window will not show the save dialog when
    /// there are unsaved changes and the window is dismissed with this
    /// behavior.
    ///
    /// On iOS, this behavior behaves the same as `interactive`.
    public static let destructive: DismissBehavior
}

/// An action that can end a search interaction.
///
/// Use the ``EnvironmentValues/dismissSearch`` environment value to get the
/// instance of this structure for a given ``Environment``. Then call the
/// instance to dismiss the current search interaction. You call the instance
/// directly because it defines a ``DismissSearchAction/callAsFunction()``
/// method that Swift calls when you call the instance.
///
/// When you dismiss search, SwiftUI:
///
/// * Sets ``EnvironmentValues/isSearching`` to `false`.
/// * Clears any text from the search field.
/// * Removes focus from the search field.
///
/// > Note: Calling this instance has no effect if the user isn't
/// interacting with a search field.
///
/// Use this action to dismiss a search operation based on
/// another user interaction. For example, consider a searchable
/// view with a ``Button`` that presents more information about the first
/// matching item from a collection:
///
///     struct ContentView: View {
///         @State private var searchText = ""
///
///         var body: some View {
///             NavigationStack {
///                 SearchedView(searchText: searchText)
///                     .searchable(text: $searchText)
///             }
///         }
///     }
///
///     struct SearchedView: View {
///         var searchText: String
///
///         let items = ["a", "b", "c"]
///         var filteredItems: [String] { items.filter { $0 == searchText.lowercased() } }
///
///         @State private var isPresented = false
///         @Environment(\.dismissSearch) private var dismissSearch
///
///         var body: some View {
///             if let item = filteredItems.first {
///                 Button("Details about \(item)") {
///                     isPresented = true
///                 }
///                 .sheet(isPresented: $isPresented) {
///                     NavigationStack {
///                         DetailView(item: item, dismissSearch: dismissSearch)
///                     }
///                 }
///             }
///         }
///     }
///
/// The button becomes visible only after the user enters search text
/// that produces a match. When the user taps the button, SwiftUI shows
/// a sheet that provides more information about the item, including
/// an Add button for adding the item to a stored list of items:
///
///     private struct DetailView: View {
///         var item: String
///         var dismissSearch: DismissSearchAction
///
///         @Environment(\.dismiss) private var dismiss
///
///         var body: some View {
///             Text("Information about \(item).")
///                 .toolbar {
///                     Button("Add") {
///                         // Store the item here...
///
///                         dismiss()
///                         dismissSearch()
///                     }
///                 }
///         }
///     }
///
/// People can dismiss the sheet by dragging it down, effectively
/// canceling the operation, leaving the in-progress search interaction
/// intact. Alternatively, people can tap the Add button to store the item.
/// Because the person using your app is likely to be done with both the
/// detail view and the search interaction at this point, the button's
/// closure also uses the ``EnvironmentValues/dismiss`` property to dismiss
/// the sheet, and the ``EnvironmentValues/dismissSearch`` property to
/// reset the search field.
///
/// > Important: Access the action from inside the searched view, as the
///   example above demonstrates, rather than from the searched views
///   parent, or another hierarchy, like that of a sheet. SwiftUI sets the
///   value in the environment of the view that you apply the searchable
///   modifier to, and doesnt propagate the value up the view hierarchy.
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
@MainActor @preconcurrency public struct DismissSearchAction {

    /// Dismisses the current search operation, if any.
    ///
    /// Don't call this method directly. SwiftUI calls it for you when you
    /// call the ``DismissSearchAction`` structure that you get from the
    /// ``Environment``:
    ///
    ///     struct SearchedView: View {
    ///         @Environment(\.dismissSearch) private var dismissSearch
    ///
    ///         var body: some View {
    ///             Button("Cancel") {
    ///                 dismissSearch() // Implicitly calls dismissSearch.callAsFunction()
    ///             }
    ///         }
    ///     }
    ///
    /// For information about how Swift uses the `callAsFunction()` method to
    /// simplify call site syntax, see
    /// [Methods with Special Names](https://docs.swift.org/swift-book/ReferenceManual/Declarations.html#ID622)
    /// in *The Swift Programming Language*.
    @MainActor @preconcurrency public func callAsFunction()
}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension DismissSearchAction : Sendable {
}

/// An action that dismisses a window associated to a particular scene.
///
/// Use the ``EnvironmentValues/dismissWindow`` environment value to get the
/// instance of this structure for a given ``Environment``. Then call the
/// instance to dismiss a window. You call the instance directly because it
/// defines a ``DismissWindowAction/callAsFunction(id:)`` method that Swift
/// calls when you call the instance.
///
/// For example, you can define a button that closes an auxiliary window:
///
///     @main
///     struct MyApp: App {
///         var body: some Scene {
///             WindowGroup {
///                 ContentView()
///             }
///             #if os(macOS)
///             Window("Auxiliary", id: "auxiliary") {
///                 AuxiliaryContentView()
///             }
///             #endif
///         }
///     }
///
///     struct DismissWindowButton: View {
///         @Environment(\.dismissWindow) private var dismissWindow
///
///         var body: some View {
///             Button("Close Auxiliary Window") {
///                 dismissWindow(id: "auxiliary")
///             }
///         }
///     }
///
/// If the window was opened with ``EnvironmentValues/pushWindow``, the original
/// presenting will reappear when this action is performed.
@available(iOS 17.0, macOS 14.0, visionOS 1.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@MainActor @preconcurrency public struct DismissWindowAction {

    /// Dismisses the current window.
    ///
    /// Don't call this method directly. SwiftUI calls it when you
    /// call the ``EnvironmentValues/dismissWindow`` action:
    ///
    ///     dismissWindow()
    ///
    /// For information about how Swift uses the `callAsFunction()` method to
    /// simplify call site syntax, see
    /// [Methods with Special Names](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/declarations#Methods-with-Special-Names)
    /// in *The Swift Programming Language*.
    @MainActor @preconcurrency public func callAsFunction()

    /// Dismisses the window that's associated with the specified identifier.
    ///
    /// When the specified identifier represents a ``WindowGroup``, all of the
    /// open windows in that group will be dismissed. For dismissing a single
    /// window associated to a `WindowGroup` scene, use
    /// ``dismissWindow(value:)`` or ``dismissWindow(id:value:)``.
    ///
    /// Don't call this method directly. SwiftUI calls it when you
    /// call the ``EnvironmentValues/dismissWindow`` action with an identifier:
    ///
    ///     dismissWindow(id: "message")
    ///
    /// For information about how Swift uses the `callAsFunction()` method to
    /// simplify call site syntax, see
    /// [Methods with Special Names](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/declarations#Methods-with-Special-Names)
    /// in *The Swift Programming Language*.
    ///
    /// - Parameter id: The identifier of the scene to dismiss.
    @MainActor @preconcurrency public func callAsFunction(id: String)

    /// Dismisses the window defined by the window group that is presenting the
    /// specified value type.
    ///
    /// If multiple windows match the provided value, then they all will be
    /// dismissed. For dismissing a specific window in a specific group, use
    /// ``dismissWindow(id:value:)``.
    ///
    /// Don't call this method directly. SwiftUI calls it when you
    /// call the ``EnvironmentValues/dismissWindow`` action with an identifier
    /// and a value:
    ///
    ///     dismissWindow(value: message.id)
    ///
    /// For information about how Swift uses the `callAsFunction()` method to
    /// simplify call site syntax, see
    /// [Methods with Special Names](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/declarations#Methods-with-Special-Names)
    /// in *The Swift Programming Language*.
    ///
    /// - Parameters:
    ///   - value: The value which is currently presented.
    @MainActor @preconcurrency public func callAsFunction<D>(value: D) where D : Decodable, D : Encodable, D : Hashable

    /// Dismisses the window defined by the window group that is presenting the
    /// specified value type and that's associated with the specified identifier.
    ///
    /// Don't call this method directly. SwiftUI calls it when you
    /// call the ``EnvironmentValues/dismissWindow`` action with an identifier
    /// and a value:
    ///
    ///     dismissWindow(id: "message", value: message.id)
    ///
    /// For information about how Swift uses the `callAsFunction()` method to
    /// simplify call site syntax, see
    /// [Methods with Special Names](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/declarations#Methods-with-Special-Names)
    /// in *The Swift Programming Language*.
    ///
    /// - Parameters:
    ///   - id: The identifier of the scene to dismiss.
    ///   - value: The value which is currently presented.
    @MainActor @preconcurrency public func callAsFunction<D>(id: String, value: D) where D : Decodable, D : Encodable, D : Hashable
}

@available(iOS 17.0, macOS 14.0, visionOS 1.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension DismissWindowAction : Sendable {
}

/// A visual element that can be used to separate other content.
///
/// When contained in a stack, the divider extends across the minor axis of the
/// stack, or horizontally when not in a stack.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public struct Divider : View {

    public init()

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    public typealias Body = Never
}

/// A Box that allows setting its Document base
/// not requiring the caller to know the exact types of the box and its base.
@available(iOS 17.0, macOS 14.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public protocol DocumentBaseBox<Document> : AnyObject {

    /// The underlying document type.
    associatedtype Document

    /// Updates the underlying document to a new value.
    var base: Self.Document! { get set }
}

@available(iOS 17.0, macOS 14.0, visionOS 1.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct DocumentConfiguration {

    /// A Boolean value that indicates whether you can edit the document.
    ///
    /// On macOS, the document could be non-editable if the user lacks write permissions,
    /// the parent directory or volume is read-only,
    /// or the document couldn't be autosaved.
    ///
    /// On iOS, the document is not editable if there was
    /// an error reading or saving it, there's an unresolved conflict,
    /// the document is being uploaded or downloaded,
    /// or otherwise, it is currently busy and unsafe for user edits.
    public var isEditable: Bool { get }

    /// A URL of an open document.
    ///
    /// If the document has never been saved, returns `nil`.
    public var fileURL: URL? { get }
}

@available(iOS 17.0, macOS 14.0, visionOS 1.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension DocumentConfiguration : Sendable {
}

/// A scene that enables support for opening, creating, and saving documents.
///
/// Use a `DocumentGroup` scene to tell SwiftUI what kinds of documents your
/// app can open when you declare your app using the ``App`` protocol.
///
/// Initialize a document group scene by passing in the document model and a
/// view capable of displaying the document type. The document types you supply
/// to `DocumentGroup` must conform to ``FileDocument`` or
/// ``ReferenceFileDocument``. SwiftUI uses the model to add document support
/// to your app. In macOS this includes document-based menu support, including
/// the ability to open multiple documents. On iOS this includes a document
/// browser that can navigate to the documents stored on the file system
/// and multiwindow support:
///
///     @main
///     struct MyApp: App {
///         var body: some Scene {
///             DocumentGroup(newDocument: TextFile()) { configuration in
///                 ContentView(document: configuration.$document)
///             }
///         }
///     }
///
/// Any time the configuration changes, SwiftUI updates the contents
/// with that new configuration, similar to other parameterized builders.
///
/// ### Viewing documents
///
/// If your app only needs to display but not modify a specific
/// document type, you can use the file viewer document group scene. You
/// supply the file type of the document, and a view that displays the
/// document type that you provide:
///
///     @main
///     struct MyApp: App {
///         var body: some Scene {
///             DocumentGroup(viewing: MyImageFormatDocument.self) {
///                 MyImageFormatViewer(image: $0.document)
///             }
///         }
///     }
///
/// ### Supporting multiple document types
///
/// Your app can support multiple document types by adding additional
/// document group scenes:
///
///     @main
///     struct MyApp: App {
///         var body: some Scene {
///             DocumentGroup(newDocument: TextFile()) { group in
///                 ContentView(document: group.$document)
///             }
///             DocumentGroup(viewing: MyImageFormatDocument.self) { group in
///                 MyImageFormatViewer(image: group.document)
///             }
///         }
///     }
///
/// ### Accessing the document's URL
///
/// If your app needs to know the document's URL, you can read it from the `editor`
/// closure's `configuration` parameter, along with the binding to the document.
/// When you create a new document, the configuration's `fileURL` property is `nil`.
/// Every time it changes, it is passed over to the `DocumentGroup` builder
/// in the updated `configuration`.
/// This ensures that the view you define in the closure always knows
/// the URL of the document it hosts.
///
///     @main
///     struct MyApp: App {
///         var body: some Scene {
///             DocumentGroup(newDocument: TextFile()) { configuration in
///                 ContentView(
///                     document: configuration.$document,
///                     fileURL: configuration.fileURL
///                 )
///             }
///         }
///     }
///
/// The URL can be used, for example, to present the file path of the file name
/// in the user interface.
/// Don't access the document's contents or metadata using the URL because that
/// can conflict with the management of the file that SwiftUI performs.
/// Instead, use the methods that ``FileDocument`` and ``ReferenceFileDocument``
/// provide to perform read and write operations.
@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct DocumentGroup<Document, Content> : Scene where Content : View {

    /// The content and behavior of the scene.
    ///
    /// For any scene that you create, provide a computed `body` property that
    /// defines the scene as a composition of other scenes. You can assemble a
    /// scene from built-in scenes that SwiftUI provides, as well as other
    /// scenes that you've defined.
    ///
    /// Swift infers the scene's ``SwiftUI/Scene/Body-swift.associatedtype``
    /// associated type based on the contents of the `body` property.
    @MainActor @preconcurrency public var body: some Scene { get }

    /// The type of scene that represents the body of this scene.
    ///
    /// When you create a custom scene, Swift infers this type from your
    /// implementation of the required ``SwiftUI/Scene/body-swift.property``
    /// property.
    @available(iOS 14.0, macOS 11.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias Body = some Scene
}

@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension DocumentGroup where Document : ReferenceFileDocument {

    /// Creates a document group that is able to create and edit reference file
    /// documents.
    ///
    /// - Parameters:
    ///   - newDocument: The initial document used when the user creates
    ///     a new document. The argument should create a new instance, such that
    ///     a new document is created on each invocation of the closure.
    ///   - editor: The editing UI for the provided document.
    ///
    /// The current document for a given editor instance is also provided as an
    /// environment object for its subhierarchy.
    ///
    /// Undo support is not automatically provided for this construction of
    /// a `DocumentGroup`, and any updates to the document by the editor view
    /// hierarchy are expected to register undo operations when appropriate.
    @preconcurrency nonisolated public init(newDocument: @escaping @Sendable () -> Document, @ViewBuilder editor: @escaping (ReferenceFileDocumentConfiguration<Document>) -> Content)

    /// Creates a document group that is able to view reference file documents.
    ///
    /// - Parameters:
    ///   - documentType: The type of document being viewed.
    ///   - viewer: The viewing UI for the provided document.
    ///
    /// The current document for a given editor instance is also provided as an
    /// environment object for its subhierarchy.
    ///
    /// - See Also: `CFBundleTypeRole` with a value of "Viewer"
    nonisolated public init(viewing documentType: Document.Type, @ViewBuilder viewer: @escaping (ReferenceFileDocumentConfiguration<Document>) -> Content)
}

@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension DocumentGroup where Document : FileDocument {

    /// Creates a document group for creating and editing file documents.
    ///
    /// Use a ``DocumentGroup`` scene to tell SwiftUI what kinds of documents
    /// your app can open when you declare your app using the ``App`` protocol.
    /// You initialize a document group scene by passing in the document model
    /// and a view capable of displaying the document's contents. The document
    /// types you supply to ``DocumentGroup`` must conform to ``FileDocument``
    /// or ``ReferenceFileDocument``. SwiftUI uses the model to add document
    /// support to your app. In macOS this includes document-based menu support
    /// including the ability to open multiple documents. On iOS this includes
    /// a document browser that can navigate to the documents stored on the
    /// file system and multiwindow support:
    ///
    ///     @main
    ///     struct MyApp: App {
    ///         var body: some Scene {
    ///             DocumentGroup(newDocument: TextFile()) { file in
    ///                 ContentView(document: file.$document)
    ///             }
    ///         }
    ///     }
    ///
    /// The document types you supply to ``DocumentGroup`` must conform to
    /// ``FileDocument`` or ``ReferenceFileDocument``. Your app can support
    ///  multiple document types by adding additional ``DocumentGroup`` scenes.
    ///
    /// - Parameters:
    ///   - newDocument: The initial document to use when a user creates
    ///     a new document.
    ///   - editor: The editing UI for the provided document.
    @preconcurrency nonisolated public init(newDocument: @autoclosure @escaping @Sendable () -> Document, @ViewBuilder editor: @escaping (FileDocumentConfiguration<Document>) -> Content)

    /// Creates a document group capable of viewing file documents.
    ///
    /// Use this method to create a document group that can view files of a
    /// specific type. The example below creates a new document viewer for
    /// `MyImageFormatDocument` and displays them with `MyImageFormatViewer`:
    ///
    ///     @main
    ///     struct MyApp: App {
    ///         var body: some Scene {
    ///             DocumentGroup(viewing: MyImageFormatDocument.self) { file in
    ///                 MyImageFormatViewer(image: file.document)
    ///             }
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - documentType: The type of document your app can view.
    ///   - viewer: The viewing UI for the provided document.
    ///
    /// You tell the system about the app's role with respect to the document
    /// type by setting the
    ///  <doc://com.apple.documentation/documentation/BundleResources/Information_Property_List/CFBundleDocumentTypes/CFBundleTypeRole>
    ///   `Info.plist` key with a value of `Viewer`.
    ///
    nonisolated public init(viewing documentType: Document.Type, @ViewBuilder viewer: @escaping (FileDocumentConfiguration<Document>) -> Content)
}

/// A launch scene for document-based applications.
///
/// You can use this launch scene alongside ``DocumentGroup`` scenes.
/// If you don't implement a `DocumentGroup` in the app declaration, you can get
///  the same design by implementing a ``DocumentLaunchView``.
///
/// If you don't provide the title of the scene, it displays the application
/// name. If you don't provide the actions builder, the scene has the default
/// "Create Document" action that creates new documents. To customize the
/// document launch experience, you can replace the standard screen background
/// and title, add decorative views, and add custom actions.
///
/// A `DocumentGroupLaunchScene` configures the document browser on the bottom
/// sheet to open content types from all the document groups in the app
/// definition. A `DocumentGroupLaunchScene` also configures the document groups
/// to create documents of the first content type that your application can
/// create and write.
///
/// For more information, see ``FileDocument.writableContentTypes`` and
/// ``ReferenceFileDocument.writableContentTypes``.
@available(iOS 18.0, visionOS 2.0, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct DocumentGroupLaunchScene<Actions> : Scene where Actions : View {

    /// The content and behavior of the scene.
    ///
    /// For any scene that you create, provide a computed `body` property that
    /// defines the scene as a composition of other scenes. You can assemble a
    /// scene from built-in scenes that SwiftUI provides, as well as other
    /// scenes that you've defined.
    ///
    /// Swift infers the scene's ``SwiftUI/Scene/Body-swift.associatedtype``
    /// associated type based on the contents of the `body` property.
    @MainActor @preconcurrency public var body: some Scene { get }

    /// The type of scene that represents the body of this scene.
    ///
    /// When you create a custom scene, Swift infers this type from your
    /// implementation of the required ``SwiftUI/Scene/body-swift.property``
    /// property.
    @available(iOS 18.0, visionOS 2.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    @available(macOS, unavailable)
    public typealias Body = some Scene
}

@available(iOS 18.0, visionOS 2.0, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension DocumentGroupLaunchScene {

    /// Creates a launch scene for document-based applications with a title, a set of actions, and a background.
    ///
    /// Use a `DocumentGroupLaunchScene` alongside any ``DocumentGroup`` scenes.
    /// If you don't implement a `DocumentGroup` in the app declaration, you can get the same design by implementing a ``DocumentLaunchView``.
    ///
    /// - Parameters:
    ///   - title: A key to use for the view title.
    ///   - actions: A view builder for returning the view's actions.
    ///   - background: The background of the scene.
    nonisolated public init(_ title: LocalizedStringKey, @ViewBuilder _ actions: () -> Actions, @ViewBuilder background: () -> some View, @ViewBuilder backgroundAccessoryView: @escaping (DocumentLaunchGeometryProxy) -> some View, @ViewBuilder overlayAccessoryView: @escaping (DocumentLaunchGeometryProxy) -> some View)

    /// Creates a launch scene for document-based applications with a title, a set of actions, a background, and a background accessory view.
    ///
    /// Use a `DocumentGroupLaunchScene` alongside any ``DocumentGroup`` scenes.
    /// If you don't implement a `DocumentGroup` in the app declaration, you can get the same design by implementing a ``DocumentLaunchView``.
    ///
    /// - Parameters:
    ///   - title: A key to use for the view title.
    ///   - actions: A view builder for returning the view's actions.
    ///   - background: The background of the scene.
    ///   - backgroundAccessoryView: A view builder for returning the view's background accessory view.
    nonisolated public init(_ title: LocalizedStringKey, @ViewBuilder _ actions: () -> Actions, @ViewBuilder background: () -> some View, @ViewBuilder backgroundAccessoryView: @escaping (DocumentLaunchGeometryProxy) -> some View)

    /// Creates a launch scene for document-based applications with a title, a set of actions, a background, and an overlay accessory view.
    ///
    /// Use a `DocumentGroupLaunchScene` alongside any ``DocumentGroup`` scenes.
    /// If you don't implement a `DocumentGroup` in the app declaration, you can get the same design by implementing a ``DocumentLaunchView``.
    ///
    /// - Parameters:
    ///   - title: A key to use for the view title.
    ///   - actions: A view builder for returning the view's actions.
    ///   - background: The background of the scene.
    ///   - overlayAccessoryView: A view builder for returning the view's overlay accessory view.
    nonisolated public init(_ title: LocalizedStringKey, @ViewBuilder _ actions: () -> Actions, @ViewBuilder background: () -> some View, @ViewBuilder overlayAccessoryView: @escaping (DocumentLaunchGeometryProxy) -> some View)

    /// Creates a launch scene for document-based applications with a title, a set of actions, and a background.
    ///
    /// Use a `DocumentGroupLaunchScene` alongside any ``DocumentGroup`` scenes.
    /// If you don't implement a `DocumentGroup` in the app declaration, you can get the same design by implementing a ``DocumentLaunchView``.
    ///
    /// - Parameters:
    ///   - title: A key to use for the view title.
    ///   - actions: A view builder for returning the view's actions.
    ///   - background: The background of the scene.
    nonisolated public init(_ title: LocalizedStringKey, @ViewBuilder _ actions: () -> Actions, @ViewBuilder background: () -> some View)

    /// Creates a launch scene for document-based applications with a title, a set of actions, and a background.
    ///
    /// Use a `DocumentGroupLaunchScene` alongside any ``DocumentGroup`` scenes.
    /// If you don't implement a `DocumentGroup` in the app declaration, you can get the same design by implementing a ``DocumentLaunchView``.
    ///
    /// - Parameters:
    ///   - title: A string to use for the view title.
    ///   - actions: A view builder for returning the view's actions.
    ///   - background: The background of the scene.
    nonisolated public init(_ title: some StringProtocol, @ViewBuilder _ actions: () -> Actions, @ViewBuilder background: () -> some View, @ViewBuilder backgroundAccessoryView: @escaping (DocumentLaunchGeometryProxy) -> some View, @ViewBuilder overlayAccessoryView: @escaping (DocumentLaunchGeometryProxy) -> some View)

    /// Creates a launch scene for document-based applications with a title, a set of actions, a background, and a background accessory view.
    ///
    /// Use a `DocumentGroupLaunchScene` alongside any ``DocumentGroup`` scenes.
    /// If you don't implement a `DocumentGroup` in the app declaration, you can get the same design by implementing a ``DocumentLaunchView``.
    ///
    /// - Parameters:
    ///   - title: A string to use for the view title.
    ///   - actions: A view builder for returning the view's actions.
    ///   - background: The background of the scene.
    ///   - backgroundAccessoryView: A view builder for returning the view's background accessory view.
    nonisolated public init(_ title: some StringProtocol, @ViewBuilder _ actions: () -> Actions, @ViewBuilder background: () -> some View, @ViewBuilder backgroundAccessoryView: @escaping (DocumentLaunchGeometryProxy) -> some View)

    /// Creates a launch scene for document-based applications with a title, a set of actions, a background, and an overlay accessory view.
    ///
    /// Use a `DocumentGroupLaunchScene` alongside any ``DocumentGroup`` scenes.
    /// If you don't implement a `DocumentGroup` in the app declaration, you can get the same design by implementing a ``DocumentLaunchView``.
    ///
    /// - Parameters:
    ///   - title: A string to use for the view title.
    ///   - actions: A view builder for returning the view's actions.
    ///   - background: The background of the scene.
    ///   - overlayAccessoryView: A view builder for returning the view's overlay accessory view.
    nonisolated public init(_ title: some StringProtocol, @ViewBuilder _ actions: () -> Actions, @ViewBuilder background: () -> some View, @ViewBuilder overlayAccessoryView: @escaping (DocumentLaunchGeometryProxy) -> some View)

    /// Creates a launch scene for document-based applications with a title, a set of actions, and a background.
    ///
    /// Use a `DocumentGroupLaunchScene` alongside any ``DocumentGroup`` scenes.
    /// If you don't implement a `DocumentGroup` in the app declaration, you can get the same design by implementing a ``DocumentLaunchView``.
    ///
    /// - Parameters:
    ///   - title: A string to use for the view title.
    ///   - actions: A view builder for returning the view's actions.
    ///   - background: The background of the scene.
    nonisolated public init(_ title: some StringProtocol, @ViewBuilder _ actions: () -> Actions, @ViewBuilder background: () -> some View)

    /// Creates a launch scene for document-based applications with a title, a set of actions, a background, and background and overlay accessory views.
    ///
    /// Use a `DocumentGroupLaunchScene` alongside any ``DocumentGroup`` scenes.
    /// If you don't implement a `DocumentGroup` in the app declaration, you can get the same design by implementing a ``DocumentLaunchView``.
    ///
    /// - Parameters:
    ///   - title: A text value to use for the view title.
    ///   - actions: A view builder for returning the view's actions
    ///   - background: A background of the view.
    ///   - backgroundAccessoryView: A view builder for returning the view's background accessory view.
    ///   - overlayAccessoryView: A view builder for returning the view's overlay accessory view.
    nonisolated public init(_ title: Text? = nil, @ViewBuilder _ actions: () -> Actions, @ViewBuilder background: () -> some View, @ViewBuilder backgroundAccessoryView: @escaping (DocumentLaunchGeometryProxy) -> some View, @ViewBuilder overlayAccessoryView: @escaping (DocumentLaunchGeometryProxy) -> some View)

    /// Creates a launch scene for document-based applications with a title, a set of actions, a background, and a background accessory view.
    ///
    /// Use a `DocumentGroupLaunchScene` alongside any ``DocumentGroup`` scenes.
    /// If you don't implement a `DocumentGroup` in the app declaration, you can get the same design by implementing a ``DocumentLaunchView``.
    ///
    /// - Parameters:
    ///   - title: A text value to use for the view title.
    ///   - actions: A view builder for returning the view's actions
    ///   - background: A background of the view.
    ///   - backgroundAccessoryView: A view builder for returning the view's background accessory view.
    nonisolated public init(_ title: Text? = nil, @ViewBuilder _ actions: () -> Actions, @ViewBuilder background: () -> some View, @ViewBuilder backgroundAccessoryView: @escaping (DocumentLaunchGeometryProxy) -> some View)

    /// Creates a launch scene for document-based applications with a title, a set of actions, a background, and an overlay accessory view.
    ///
    /// Use a `DocumentGroupLaunchScene` alongside any ``DocumentGroup`` scenes.
    /// If you don't implement a `DocumentGroup` in the app declaration, you can get the same design by implementing a ``DocumentLaunchView``.
    ///
    /// - Parameters:
    ///   - title: A text value to use for the view title.
    ///   - actions: A view builder for returning the view's actions
    ///   - background: A background of the view.
    ///   - overlayAccessoryView: A view builder for returning the view's overlay accessory view.
    nonisolated public init(_ title: Text? = nil, @ViewBuilder _ actions: () -> Actions, @ViewBuilder background: () -> some View, @ViewBuilder overlayAccessoryView: @escaping (DocumentLaunchGeometryProxy) -> some View)

    /// Creates a launch scene for document-based applications with a title, a set of actions, and a background.
    ///
    /// Use a `DocumentGroupLaunchScene` alongside any ``DocumentGroup`` scenes.
    /// If you don't implement a `DocumentGroup` in the app declaration, you can get the same design by implementing a ``DocumentLaunchView``.
    ///
    /// - Parameters:
    ///   - title: A text value to use for the view title.
    ///   - actions: A view builder for returning the view's actions
    ///   - background: A background of the view.
    nonisolated public init(_ title: Text? = nil, @ViewBuilder _ actions: () -> Actions, @ViewBuilder background: () -> some View)
}

@available(iOS 18.0, visionOS 2.0, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension DocumentGroupLaunchScene {

    /// Creates a launch scene for document-based applications with a title, a background style, a set of actions, and background and overlay accessory views.
    ///
    /// Use a `DocumentGroupLaunchScene` alongside any ``DocumentGroup`` scenes.
    /// If you don't implement a `DocumentGroup` in the app declaration, you can get the same design by implementing a ``DocumentLaunchView``.
    ///
    /// - Parameters:
    ///   - title: A key to use for the view title.
    ///   - backgroundStyle: A background style of the view.
    ///   - actions: A view builder for returning the view's actions.
    ///   - backgroundAccessoryView: A view builder for returning the view's background accessory view.
    ///   - overlayAccessoryView: A view builder for returning the view's overlay accessory view.
    nonisolated public init<B>(_ title: LocalizedStringKey, backgroundStyle: B = BackgroundStyle(), @ViewBuilder _ actions: () -> Actions = { DefaultDocumentGroupLaunchActions() }, @ViewBuilder backgroundAccessoryView: @escaping (DocumentLaunchGeometryProxy) -> some View, @ViewBuilder overlayAccessoryView: @escaping (DocumentLaunchGeometryProxy) -> some View) where B : ShapeStyle

    /// Creates a launch scene for document-based applications with a title, a background style, a set of actions, and a background accessory view.
    ///
    /// Use a `DocumentGroupLaunchScene` alongside any ``DocumentGroup`` scenes.
    /// If you don't implement a `DocumentGroup` in the app declaration, you can get the same design by implementing a ``DocumentLaunchView``.
    ///
    /// - Parameters:
    ///   - title: A key to use for the view title.
    ///   - backgroundStyle: A background style of the view.
    ///   - actions: A view builder for returning the view's actions.
    ///   - backgroundAccessoryView: A view builder for returning the view's background accessory view.
    nonisolated public init<B>(_ title: LocalizedStringKey, backgroundStyle: B = BackgroundStyle(), @ViewBuilder _ actions: () -> Actions = { DefaultDocumentGroupLaunchActions() }, @ViewBuilder backgroundAccessoryView: @escaping (DocumentLaunchGeometryProxy) -> some View) where B : ShapeStyle

    /// Creates a launch scene for document-based applications with a title, a background style, a set of actions, and an overlay accessory view.
    ///
    /// Use a `DocumentGroupLaunchScene` alongside any ``DocumentGroup`` scenes.
    /// If you don't implement a `DocumentGroup` in the app declaration, you can get the same design by implementing a ``DocumentLaunchView``.
    ///
    /// - Parameters:
    ///   - title: A key to use for the view title.
    ///   - backgroundStyle: A background style of the view.
    ///   - actions: A view builder for returning the view's actions.
    ///   - overlayAccessoryView: A view builder for returning the view's overlay accessory view.
    nonisolated public init<B>(_ title: LocalizedStringKey, backgroundStyle: B = BackgroundStyle(), @ViewBuilder _ actions: () -> Actions = { DefaultDocumentGroupLaunchActions() }, @ViewBuilder overlayAccessoryView: @escaping (DocumentLaunchGeometryProxy) -> some View) where B : ShapeStyle

    /// Creates a launch scene for document-based applications with a title, a background style, and a set of actions.
    ///
    /// Use a `DocumentGroupLaunchScene` alongside any ``DocumentGroup`` scenes.
    /// If you don't implement a `DocumentGroup` in the app declaration, you can get the same design by implementing a ``DocumentLaunchView``.
    ///
    /// - Parameters:
    ///   - title: A key to use for the view title.
    ///   - backgroundStyle: A background style of the view.
    ///   - actions: A view builder for returning the view's actions.
    nonisolated public init<B>(_ title: LocalizedStringKey, backgroundStyle: B = BackgroundStyle(), @ViewBuilder _ actions: () -> Actions = { DefaultDocumentGroupLaunchActions() }) where B : ShapeStyle

    /// Creates a launch scene for document-based applications with a title, a background style, a set of actions, and background and overlay accessory views.
    ///
    /// Use a `DocumentGroupLaunchScene` alongside any ``DocumentGroup`` scenes.
    /// If you don't implement a `DocumentGroup` in the app declaration, you can get the same design by implementing a ``DocumentLaunchView``.
    ///
    /// - Parameters:
    ///   - title: A string to use for the view title.
    ///   - backgroundStyle: A background style of the view.
    ///   - actions: A view builder for returning the view's actions.
    ///   - backgroundAccessoryView: A view builder for returning the view's background accessory view.
    ///   - overlayAccessoryView: A view builder for returning the view's overlay accessory view.
    nonisolated public init<B>(_ title: some StringProtocol, backgroundStyle: B = BackgroundStyle(), @ViewBuilder _ actions: () -> Actions = { DefaultDocumentGroupLaunchActions() }, @ViewBuilder backgroundAccessoryView: @escaping (DocumentLaunchGeometryProxy) -> some View, @ViewBuilder overlayAccessoryView: @escaping (DocumentLaunchGeometryProxy) -> some View) where B : ShapeStyle

    /// Creates a launch scene for document-based applications with a title, a background style, a set of actions, and a background accessory view.
    ///
    /// Use a `DocumentGroupLaunchScene` alongside any ``DocumentGroup`` scenes.
    /// If you don't implement a `DocumentGroup` in the app declaration, you can get the same design by implementing a ``DocumentLaunchView``.
    ///
    /// - Parameters:
    ///   - title: A string to use for the view title.
    ///   - backgroundStyle: A background style of the view.
    ///   - actions: A view builder for returning the view's actions.
    ///   - backgroundAccessoryView: A view builder for returning the view's background accessory view.
    nonisolated public init<B>(_ title: some StringProtocol, backgroundStyle: B = BackgroundStyle(), @ViewBuilder _ actions: () -> Actions = { DefaultDocumentGroupLaunchActions() }, @ViewBuilder backgroundAccessoryView: @escaping (DocumentLaunchGeometryProxy) -> some View) where B : ShapeStyle

    /// Creates a launch scene for document-based applications with a title, a background style, a set of actions, and an overlay accessory view.
    ///
    /// Use a `DocumentGroupLaunchScene` alongside any ``DocumentGroup`` scenes.
    /// If you don't implement a `DocumentGroup` in the app declaration, you can get the same design by implementing a ``DocumentLaunchView``.
    ///
    /// - Parameters:
    ///   - title: A string to use for the view title.
    ///   - backgroundStyle: A background style of the view.
    ///   - actions: A view builder for returning the view's actions.
    ///   - overlayAccessoryView: A view builder for returning the view's overlay accessory view.
    nonisolated public init<B>(_ title: some StringProtocol, backgroundStyle: B = BackgroundStyle(), @ViewBuilder _ actions: () -> Actions = { DefaultDocumentGroupLaunchActions() }, @ViewBuilder overlayAccessoryView: @escaping (DocumentLaunchGeometryProxy) -> some View) where B : ShapeStyle

    /// Creates a launch scene for document-based applications with a title, a background style, and a set of actions.
    ///
    /// Use a `DocumentGroupLaunchScene` alongside any ``DocumentGroup`` scenes.
    /// If you don't implement a `DocumentGroup` in the app declaration, you can get the same design by implementing a ``DocumentLaunchView``.
    ///
    /// - Parameters:
    ///   - title: A string to use for the view title.
    ///   - backgroundStyle: A background style of the view.
    ///   - actions: A view builder for returning the view's actions.
    nonisolated public init<B>(_ title: some StringProtocol, backgroundStyle: B = BackgroundStyle(), @ViewBuilder _ actions: () -> Actions = { DefaultDocumentGroupLaunchActions() }) where B : ShapeStyle

    /// Creates a launch scene for document-based applications with a title, a background style, a set of actions, and background and overlay accessory views.
    ///
    /// Use a `DocumentGroupLaunchScene` alongside any ``DocumentGroup`` scenes.
    /// If you don't implement a `DocumentGroup` in the app declaration, you can get the same design by implementing a ``DocumentLaunchView``.
    ///
    /// - Parameters:
    ///   - title: A text value to use for the title.
    ///   - backgroundStyle: A background style of the view.
    ///   - actions: A view builder for returning the view's actions.
    ///   - backgroundAccessoryView: A view builder for returning the view's background accessory view.
    ///   - overlayAccessoryView: A view builder for returning the view's overlay accessory view.
    nonisolated public init<B>(_ title: Text? = nil, backgroundStyle: B = BackgroundStyle(), @ViewBuilder _ actions: () -> Actions = { DefaultDocumentGroupLaunchActions() }, @ViewBuilder backgroundAccessoryView: @escaping (DocumentLaunchGeometryProxy) -> some View, @ViewBuilder overlayAccessoryView: @escaping (DocumentLaunchGeometryProxy) -> some View) where B : ShapeStyle

    /// Creates a launch scene for document-based applications with a title, a background style, a set of actions, and a background accessory view.
    ///
    /// Use a `DocumentGroupLaunchScene` alongside any ``DocumentGroup`` scenes.
    /// If you don't implement a `DocumentGroup` in the app declaration, you can get the same design by implementing a ``DocumentLaunchView``.
    ///
    /// - Parameters:
    ///   - title: A text value to use for the title.
    ///   - backgroundStyle: A background style of the view.
    ///   - actions: A view builder for returning the view's actions.
    ///   - backgroundAccessoryView: A view builder for returning the view's background accessory view.
    nonisolated public init<B>(_ title: Text? = nil, backgroundStyle: B = BackgroundStyle(), @ViewBuilder _ actions: () -> Actions = { DefaultDocumentGroupLaunchActions() }, @ViewBuilder backgroundAccessoryView: @escaping (DocumentLaunchGeometryProxy) -> some View) where B : ShapeStyle

    /// Creates a launch scene for document-based applications with a title, a background style, a set of actions, and an overlay accessory view.
    ///
    /// Use a `DocumentGroupLaunchScene` alongside any ``DocumentGroup`` scenes.
    /// If you don't implement a `DocumentGroup` in the app declaration, you can get the same design by implementing a ``DocumentLaunchView``.
    ///
    /// - Parameters:
    ///   - title: A text value to use for the title.
    ///   - backgroundStyle: A background style of the view.
    ///   - actions: A view builder for returning the view's actions.
    ///   - overlayAccessoryView: A view builder for returning the view's overlay accessory view.
    nonisolated public init<B>(_ title: Text? = nil, backgroundStyle: B = BackgroundStyle(), @ViewBuilder _ actions: () -> Actions = { DefaultDocumentGroupLaunchActions() }, @ViewBuilder overlayAccessoryView: @escaping (DocumentLaunchGeometryProxy) -> some View) where B : ShapeStyle

    /// Creates a launch scene for document-based applications with a title, a background style, and a set of actions.
    ///
    /// Use a `DocumentGroupLaunchScene` alongside any ``DocumentGroup`` scenes.
    /// If you don't implement a `DocumentGroup` in the app declaration, you can get the same design by implementing a ``DocumentLaunchView``.
    ///
    /// - Parameters:
    ///   - title: A text value to use for the title.
    ///   - backgroundStyle: A background style of the view.
    ///   - actions: A view builder for returning the view's actions.
    nonisolated public init<B>(_ title: Text? = nil, backgroundStyle: B = BackgroundStyle(), @ViewBuilder _ actions: () -> Actions = { DefaultDocumentGroupLaunchActions() }) where B : ShapeStyle
}

/// A proxy for access to the frame of the scene and its title view.
@available(iOS 18.0, visionOS 2.0, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct DocumentLaunchGeometryProxy {

    /// Frame of the document launch interface.
    public var frame: CGRect

    /// Frame of the title view within the interface.
    public var titleViewFrame: CGRect
}

/// A view to present when launching document-related user experience.
///
/// > Note:
/// > An alternative to `DocumentLaunchView` is a scene variant
/// of this API: ``DocumentGroupLaunchScene``.
/// > If the app definition contains `DocumentGroup` scenes, consider using
/// > a `DocumentGroupLaunchScene` instead of this view.
///
/// Configure `DocumentLaunchView` to open and display files and trigger custom
/// actions.
///
/// For example, an application that offers writing books can present
/// the `DocumentLaunchView` as its launch view:
///
///     public import UniformTypeIdentifiers
///
///     struct BookEditorLaunchView: View {
///
///         var body: some View {
///             DocumentLaunchView(for: [.book]) {
///                 NewDocumentButton("Start New Book")
///             } onDocumentOpen: { url in
///                 BookEditor(url)
///             }
///         }
///     }
///
///     struct BookEditor: View {
///         init(_ url: URL) { }
///     }
///
///     extension UTType {
///         static var book = UTType(exportedAs: "com.example.bookEditor")
///     }
///
@available(iOS 18.0, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@available(macCatalyst, unavailable)
@available(visionOS, unavailable)
@available(macCatalyst, unavailable)
public struct DocumentLaunchView<Actions, DocumentView> : View where Actions : View, DocumentView : View {

    /// The body of the view.
    @MainActor @preconcurrency public var body: some View { get }

    /// Creates a view to present when launching document-related user experiences
    /// using a localized title, custom actions, a background view, and accessory views.
    ///
    /// > Note:
    /// > An alternative to `DocumentLaunchView` is a scene variant
    /// > of this API: ``DocumentGroupLaunchScene``.
    /// > If the app definition contains `DocumentGroup` scenes, consider using
    /// > a `DocumentGroupLaunchScene` instead of this view.
    ///
    /// - Parameters:
    ///   - title: A title key to use for the view title.
    ///   - contentTypes: Content types that the view can open.
    ///   - actions: A view builder returning the view's actions
    ///   - onDocumentOpen: A closure that handles an open file.
    ///   - background: A background of the view.
    ///   - backgroundAccessoryView: A view builder for returning the view's
    ///   background accessory view.
    ///   - overlayAccessoryView: A view builder for returning the view's
    ///    overlay accessory view.
    public init(_ title: LocalizedStringKey, for contentTypes: [UTType], @ViewBuilder _ actions: () -> Actions, @ViewBuilder onDocumentOpen: @escaping (URL) -> DocumentView, @ViewBuilder background: () -> some View, @ViewBuilder backgroundAccessoryView: @escaping (DocumentLaunchGeometryProxy) -> some View, @ViewBuilder overlayAccessoryView: @escaping (DocumentLaunchGeometryProxy) -> some View)

    /// Creates a view to present when launching document-related user experiences
    /// using a localized title, custom actions, a background view, and a background accessory view.
    ///
    /// > Note:
    /// > An alternative to `DocumentLaunchView` is a scene variant
    /// > of this API: ``DocumentGroupLaunchScene``.
    /// > If the app definition contains `DocumentGroup` scenes, consider using
    /// > a `DocumentGroupLaunchScene` instead of this view.
    ///
    /// - Parameters:
    ///   - title: A title key to use for the view title.
    ///   - contentTypes: Content types that the view can open.
    ///   - actions: A view builder returning the view's actions
    ///   - onDocumentOpen: A closure that handles an open file.
    ///   - background: A background of the view.
    ///   - backgroundAccessoryView: A view builder for returning the view's
    ///   background accessory view.
    public init(_ title: LocalizedStringKey, for contentTypes: [UTType], @ViewBuilder _ actions: () -> Actions, @ViewBuilder onDocumentOpen: @escaping (URL) -> DocumentView, @ViewBuilder background: () -> some View, @ViewBuilder backgroundAccessoryView: @escaping (DocumentLaunchGeometryProxy) -> some View)

    /// Creates a view to present when launching document-related user experiences
    /// using a localized title, custom actions, a background view, and an overlay accessory view.
    ///
    /// > Note:
    /// > An alternative to `DocumentLaunchView` is a scene variant
    /// > of this API: ``DocumentGroupLaunchScene``.
    /// > If the app definition contains `DocumentGroup` scenes, consider using
    /// > a `DocumentGroupLaunchScene` instead of this view.
    ///
    /// - Parameters:
    ///   - title: A title key to use for the view title.
    ///   - contentTypes: Content types that the view can open.
    ///   - actions: A view builder returning the view's actions
    ///   - onDocumentOpen: A closure that handles an open file.
    ///   - background: A background of the view.
    ///   - overlayAccessoryView: A view builder for returning the view's
    ///   overlay accessory view.
    public init(_ title: LocalizedStringKey, for contentTypes: [UTType], @ViewBuilder _ actions: () -> Actions, @ViewBuilder onDocumentOpen: @escaping (URL) -> DocumentView, @ViewBuilder background: () -> some View, @ViewBuilder overlayAccessoryView: @escaping (DocumentLaunchGeometryProxy) -> some View)

    /// Creates a view to present when launching document-related user experiences
    /// using a localized title, custom actions, and a background view.
    ///
    /// > Note:
    /// > An alternative to `DocumentLaunchView` is a scene variant
    /// > of this API: ``DocumentGroupLaunchScene``.
    /// > If the app definition contains `DocumentGroup` scenes, consider using
    /// > a `DocumentGroupLaunchScene` instead of this view.
    ///
    /// - Parameters:
    ///   - title: A title key to use for the view title.
    ///   - contentTypes: Content types that the view can open.
    ///   - actions: A view builder returning the view's actions
    ///   - onDocumentOpen: A closure that handles an open file.
    ///   - background: A background of the view.
    public init(_ title: LocalizedStringKey, for contentTypes: [UTType], @ViewBuilder _ actions: () -> Actions, @ViewBuilder onDocumentOpen: @escaping (URL) -> DocumentView, @ViewBuilder background: () -> some View)

    /// Creates a view to present when launching document-related user experiences
    /// using a title, custom actions, a background view, and accessory views.
    ///
    /// > Note:
    /// > An alternative to `DocumentLaunchView` is a scene variant
    /// > of this API: ``DocumentGroupLaunchScene``.
    /// > If the app definition contains `DocumentGroup` scenes, consider using
    /// > a `DocumentGroupLaunchScene` instead of this view.
    ///
    /// - Parameters:
    ///   - title: A title to use for the view title.
    ///   - contentTypes: Content types that the view can open.
    ///   - actions: A view builder returning the view's actions
    ///   - onDocumentOpen: A closure that handles an open file.
    ///   - background: A background of the view.
    ///   - backgroundAccessoryView: A view builder for returning the view's
    ///   background accessory view.
    ///   - overlayAccessoryView: A view builder for returning the view's
    ///   overlay accessory view.
    public init(_ title: some StringProtocol, for contentTypes: [UTType], @ViewBuilder _ actions: () -> Actions, @ViewBuilder onDocumentOpen: @escaping (URL) -> DocumentView, @ViewBuilder background: () -> some View, @ViewBuilder backgroundAccessoryView: @escaping (DocumentLaunchGeometryProxy) -> some View, @ViewBuilder overlayAccessoryView: @escaping (DocumentLaunchGeometryProxy) -> some View)

    /// Creates a view to present when launching document-related user experiences
    /// using a title, custom actions, a background view, and background accessory view.
    ///
    /// > Note:
    /// > An alternative to `DocumentLaunchView` is a scene variant
    /// > of this API: ``DocumentGroupLaunchScene``.
    /// > If the app definition contains `DocumentGroup` scenes, consider using
    /// > a `DocumentGroupLaunchScene` instead of this view.
    ///
    /// - Parameters:
    ///   - title: A title to use for the view title.
    ///   - contentTypes: Content types that the view can open.
    ///   - actions: A view builder returning the view's actions
    ///   - onDocumentOpen: A closure that handles an open file.
    ///   - background: A background of the view.
    ///   - backgroundAccessoryView: A view builder for returning the view's
    ///   background accessory view.
    public init(_ title: some StringProtocol, for contentTypes: [UTType], @ViewBuilder _ actions: () -> Actions, @ViewBuilder onDocumentOpen: @escaping (URL) -> DocumentView, @ViewBuilder background: () -> some View, @ViewBuilder backgroundAccessoryView: @escaping (DocumentLaunchGeometryProxy) -> some View)

    /// Creates a view to present when launching document-related user experiences
    /// using a title, custom actions, a background view, and an overlay accessory view.
    ///
    /// > Note:
    /// > An alternative to `DocumentLaunchView` is a scene variant
    /// > of this API: ``DocumentGroupLaunchScene``.
    /// > If the app definition contains `DocumentGroup` scenes, consider using
    /// > a `DocumentGroupLaunchScene` instead of this view.
    ///
    /// - Parameters:
    ///   - title: A title to use for the view title.
    ///   - contentTypes: Content types that the view can open.
    ///   - actions: A view builder returning the view's actions
    ///   - onDocumentOpen: A closure that handles an open file.
    ///   - background: A background of the view.
    ///   - overlayAccessoryView: A view builder for returning the view's
    ///   overlay accessory view.
    public init(_ title: some StringProtocol, for contentTypes: [UTType], @ViewBuilder _ actions: () -> Actions, @ViewBuilder onDocumentOpen: @escaping (URL) -> DocumentView, @ViewBuilder background: () -> some View, @ViewBuilder overlayAccessoryView: @escaping (DocumentLaunchGeometryProxy) -> some View)

    /// Creates a view to present when launching document-related user experiences
    /// using a title, custom actions, and a background view .
    ///
    /// > Note:
    /// > An alternative to `DocumentLaunchView` is a scene variant
    /// > of this API: ``DocumentGroupLaunchScene``.
    /// > If the app definition contains `DocumentGroup` scenes, consider using
    /// > a `DocumentGroupLaunchScene` instead of this view.
    ///
    /// - Parameters:
    ///   - title: A title to use for the view title.
    ///   - contentTypes: Content types that the view can open.
    ///   - actions: A view builder returning the view's actions
    ///   - onDocumentOpen: A closure that handles an open file.
    ///   - background: A background of the view.
    public init(_ title: some StringProtocol, for contentTypes: [UTType], @ViewBuilder _ actions: () -> Actions, @ViewBuilder onDocumentOpen: @escaping (URL) -> DocumentView, @ViewBuilder background: () -> some View)

    /// Creates a view to present when launching document-related user experiences
    /// using a title text, custom actions, a background view, and accessory views.
    ///
    /// > Note:
    /// > An alternative to `DocumentLaunchView` is a scene variant
    /// > of this API: ``DocumentGroupLaunchScene``.
    /// > If the app definition contains `DocumentGroup` scenes, consider using
    /// > a `DocumentGroupLaunchScene` instead of this view.
    ///
    /// - Parameters:
    ///   - title: A text value to use for the view title.
    ///   - contentTypes: Content types that the view can open.
    ///   - actions: A view builder returning the view's actions
    ///   - onDocumentOpen: A closure that handles an open file.
    ///   - background: A background of the view.
    ///   - backgroundAccessoryView: A view builder for returning the view's
    ///   background accessory view.
    ///   - overlayAccessoryView: A view builder for returning the view's overlay
    ///   accessory view.
    public init(_ title: Text? = nil, for contentTypes: [UTType], @ViewBuilder _ actions: () -> Actions, @ViewBuilder onDocumentOpen: @escaping (URL) -> DocumentView, @ViewBuilder background: () -> some View, @ViewBuilder backgroundAccessoryView: @escaping (DocumentLaunchGeometryProxy) -> some View, @ViewBuilder overlayAccessoryView: @escaping (DocumentLaunchGeometryProxy) -> some View)

    /// Creates a view to present when launching document-related user experiences
    /// using a title text, custom actions, a background view, and a background accessory view.
    ///
    /// > Note:
    /// > An alternative to `DocumentLaunchView` is a scene variant
    /// > of this API: ``DocumentGroupLaunchScene``.
    /// > If the app definition contains `DocumentGroup` scenes, consider using
    /// > a `DocumentGroupLaunchScene` instead of this view.
    ///
    /// - Parameters:
    ///   - title: A text value to use for the view title.
    ///   - contentTypes: Content types that the view can open.
    ///   - actions: A view builder returning the view's actions
    ///   - onDocumentOpen: A closure that handles an open file.
    ///   - background: A background of the view.
    ///   - backgroundAccessoryView: A view builder for returning the view's
    ///   background accessory view.
    public init(_ title: Text? = nil, for contentTypes: [UTType], @ViewBuilder _ actions: () -> Actions, @ViewBuilder onDocumentOpen: @escaping (URL) -> DocumentView, @ViewBuilder background: () -> some View, @ViewBuilder backgroundAccessoryView: @escaping (DocumentLaunchGeometryProxy) -> some View)

    /// Creates a view to present when launching document-related user experiences
    /// using a title text, custom actions, a background view, and an overlay accessory view.
    ///
    /// > Note:
    /// > An alternative to `DocumentLaunchView` is a scene variant
    /// > of this API: ``DocumentGroupLaunchScene``.
    /// > If the app definition contains `DocumentGroup` scenes, consider using
    /// > a `DocumentGroupLaunchScene` instead of this view.
    ///
    /// - Parameters:
    ///   - title: A text value to use for the view title.
    ///   - contentTypes: Content types that the view can open.
    ///   - actions: A view builder returning the view's actions
    ///   - onDocumentOpen: A closure that handles an open file.
    ///   - background: A background of the view.
    ///   - overlayAccessoryView: A view builder for returning the view's overlay
    ///   accessory view.
    public init(_ title: Text? = nil, for contentTypes: [UTType], @ViewBuilder _ actions: () -> Actions, @ViewBuilder onDocumentOpen: @escaping (URL) -> DocumentView, @ViewBuilder background: () -> some View, @ViewBuilder overlayAccessoryView: @escaping (DocumentLaunchGeometryProxy) -> some View)

    /// Creates a view to present when launching document-related user experiences
    /// using a title text, custom actions, and a background view.
    ///
    /// > Note:
    /// > An alternative to `DocumentLaunchView` is a scene variant
    /// > of this API: ``DocumentGroupLaunchScene``.
    /// > If the app definition contains `DocumentGroup` scenes, consider using
    /// > a `DocumentGroupLaunchScene` instead of this view.
    ///
    /// - Parameters:
    ///   - title: A text value to use for the view title.
    ///   - contentTypes: Content types that the view can open.
    ///   - actions: A view builder returning the view's actions
    ///   - onDocumentOpen: A closure that handles an open file.
    ///   - background: A background of the view.
    public init(_ title: Text? = nil, for contentTypes: [UTType], @ViewBuilder _ actions: () -> Actions, @ViewBuilder onDocumentOpen: @escaping (URL) -> DocumentView, @ViewBuilder background: () -> some View)

    /// Creates a view to present when launching document-related user experiences
    /// using a localized title, custom actions, a background style, and accessory views.
    ///
    /// > Note:
    /// > An alternative to `DocumentLaunchView` is a scene variant
    /// > of this API: ``DocumentGroupLaunchScene``.
    /// > If the app definition contains `DocumentGroup` scenes, consider using
    /// > a `DocumentGroupLaunchScene` instead of this view.
    ///
    /// - Parameters:
    ///   - title: A title key to use for the view title.
    ///   - contentTypes: Content types that the view can open.
    ///   - backgroundStyle: An optional background style of the view.
    ///   - actions: A view builder returning the view's actions
    ///   - onDocumentOpen: A closure that handles an open file.
    ///   - backgroundAccessoryView: A view builder for returning the view's
    ///   background accessory view.
    ///   - overlayAccessoryView: A view builder for returning the view's overlay
    ///   accessory view.
    public init<B>(_ title: LocalizedStringKey, for contentTypes: [UTType], backgroundStyle: B, @ViewBuilder _ actions: () -> Actions, @ViewBuilder onDocumentOpen: @escaping (URL) -> DocumentView, @ViewBuilder backgroundAccessoryView: @escaping (DocumentLaunchGeometryProxy) -> some View, @ViewBuilder overlayAccessoryView: @escaping (DocumentLaunchGeometryProxy) -> some View) where B : ShapeStyle

    /// Creates a view to present when launching document-related user experiences
    /// using a localized title, custom actions, a background style, and a background accessory view.
    ///
    /// > Note:
    /// > An alternative to `DocumentLaunchView` is a scene variant
    /// > of this API: ``DocumentGroupLaunchScene``.
    /// > If the app definition contains `DocumentGroup` scenes, consider using
    /// > a `DocumentGroupLaunchScene` instead of this view.
    ///
    /// - Parameters:
    ///   - title: A title key to use for the view title.
    ///   - contentTypes: Content types that the view can open.
    ///   - backgroundStyle: An optional background style of the view.
    ///   - actions: A view builder returning the view's actions
    ///   - onDocumentOpen: A closure that handles an open file.
    ///   - backgroundAccessoryView: A view builder for returning the view's
    ///   background accessory view.
    public init<B>(_ title: LocalizedStringKey, for contentTypes: [UTType], backgroundStyle: B, @ViewBuilder _ actions: () -> Actions, @ViewBuilder onDocumentOpen: @escaping (URL) -> DocumentView, @ViewBuilder backgroundAccessoryView: @escaping (DocumentLaunchGeometryProxy) -> some View) where B : ShapeStyle

    /// Creates a view to present when launching document-related user experiences
    /// using a localized title, custom actions, a background style, and an overlay accessory view.
    ///
    /// > Note:
    /// > An alternative to `DocumentLaunchView` is a scene variant
    /// > of this API: ``DocumentGroupLaunchScene``.
    /// > If the app definition contains `DocumentGroup` scenes, consider using
    /// > a `DocumentGroupLaunchScene` instead of this view.
    ///
    /// - Parameters:
    ///   - title: A title key to use for the view title.
    ///   - contentTypes: Content types that the view can open.
    ///   - backgroundStyle: An optional background style of the view.
    ///   - actions: A view builder returning the view's actions
    ///   - onDocumentOpen: A closure that handles an open file.
    ///   - overlayAccessoryView: A view builder for returning the view's overlay
    ///   accessory view.
    public init<B>(_ title: LocalizedStringKey, for contentTypes: [UTType], backgroundStyle: B, @ViewBuilder _ actions: () -> Actions, @ViewBuilder onDocumentOpen: @escaping (URL) -> DocumentView, @ViewBuilder overlayAccessoryView: @escaping (DocumentLaunchGeometryProxy) -> some View) where B : ShapeStyle

    /// Creates a view to present when launching document-related user experiences
    /// using a localized title, custom actions, and a background style.
    ///
    /// > Note:
    /// > An alternative to `DocumentLaunchView` is a scene variant
    /// > of this API: ``DocumentGroupLaunchScene``.
    /// > If the app definition contains `DocumentGroup` scenes, consider using
    /// > a `DocumentGroupLaunchScene` instead of this view.
    ///
    /// - Parameters:
    ///   - title: A title key to use for the view title.
    ///   - contentTypes: Content types that the view can open.
    ///   - backgroundStyle: An optional background style of the view.
    ///   - actions: A view builder returning the view's actions
    ///   - onDocumentOpen: A closure that handles an open file.
    public init<B>(_ title: LocalizedStringKey, for contentTypes: [UTType], backgroundStyle: B, @ViewBuilder _ actions: () -> Actions, @ViewBuilder onDocumentOpen: @escaping (URL) -> DocumentView) where B : ShapeStyle

    /// Creates a view to present when launching document-related user experiences
    /// using a custom title, actions, a background style, and accessory views.
    ///
    /// > Note:
    /// > An alternative to `DocumentLaunchView` is a scene variant
    /// > of this API: ``DocumentGroupLaunchScene``.
    /// > If the app definition contains `DocumentGroup` scenes, consider using
    /// > a `DocumentGroupLaunchScene` instead of this view.
    ///
    /// - Parameters:
    ///   - title: A title to use for the view title.
    ///   - contentTypes: Content types that the view can open.
    ///   - backgroundStyle: An optional background style of the view.
    ///   - actions: A view builder returning the view's actions
    ///   - onDocumentOpen: A closure that handles an open file.
    ///   - backgroundAccessoryView: A view builder for returning the view's
    ///   background accessory view.
    ///   - overlayAccessoryView: A view builder for returning the view's overlay
    ///   accessory view.
    public init<B>(_ title: some StringProtocol, for contentTypes: [UTType], backgroundStyle: B, @ViewBuilder _ actions: () -> Actions, @ViewBuilder onDocumentOpen: @escaping (URL) -> DocumentView, @ViewBuilder backgroundAccessoryView: @escaping (DocumentLaunchGeometryProxy) -> some View, @ViewBuilder overlayAccessoryView: @escaping (DocumentLaunchGeometryProxy) -> some View) where B : ShapeStyle

    /// Creates a view to present when launching document-related user experiences
    /// using a custom title, actions, a background style, and a background accessory view.
    ///
    /// > Note:
    /// > An alternative to `DocumentLaunchView` is a scene variant
    /// > of this API: ``DocumentGroupLaunchScene``.
    /// > If the app definition contains `DocumentGroup` scenes, consider using
    /// > a `DocumentGroupLaunchScene` instead of this view.
    ///
    /// - Parameters:
    ///   - title: A title to use for the view title.
    ///   - contentTypes: Content types that the view can open.
    ///   - backgroundStyle: An optional background style of the view.
    ///   - actions: A view builder returning the view's actions
    ///   - onDocumentOpen: A closure that handles an open file.
    ///   - backgroundAccessoryView: A view builder for returning the view's
    ///   background accessory view.
    public init<B>(_ title: some StringProtocol, for contentTypes: [UTType], backgroundStyle: B, @ViewBuilder _ actions: () -> Actions, @ViewBuilder onDocumentOpen: @escaping (URL) -> DocumentView, @ViewBuilder backgroundAccessoryView: @escaping (DocumentLaunchGeometryProxy) -> some View) where B : ShapeStyle

    /// Creates a view to present when launching document-related user experiences
    /// using a custom title, actions, a background style, and an overlay accessory view.
    ///
    /// > Note:
    /// > An alternative to `DocumentLaunchView` is a scene variant
    /// > of this API: ``DocumentGroupLaunchScene``.
    /// > If the app definition contains `DocumentGroup` scenes, consider using
    /// > a `DocumentGroupLaunchScene` instead of this view.
    ///
    /// - Parameters:
    ///   - title: A title to use for the view title.
    ///   - contentTypes: Content types that the view can open.
    ///   - backgroundStyle: An optional background style of the view.
    ///   - actions: A view builder returning the view's actions
    ///   - onDocumentOpen: A closure that handles an open file.
    ///   - overlayAccessoryView: A view builder for returning the view's overlay
    ///   accessory view.
    public init<B>(_ title: some StringProtocol, for contentTypes: [UTType], backgroundStyle: B, @ViewBuilder _ actions: () -> Actions, @ViewBuilder onDocumentOpen: @escaping (URL) -> DocumentView, @ViewBuilder overlayAccessoryView: @escaping (DocumentLaunchGeometryProxy) -> some View) where B : ShapeStyle

    /// Creates a view to present when launching document-related user experiences
    /// using a custom title, actions, and a background style.
    ///
    /// > Note:
    /// > An alternative to `DocumentLaunchView` is a scene variant
    /// > of this API: ``DocumentGroupLaunchScene``.
    /// > If the app definition contains `DocumentGroup` scenes, consider using
    /// > a `DocumentGroupLaunchScene` instead of this view.
    ///
    /// - Parameters:
    ///   - title: A title to use for the view title.
    ///   - contentTypes: Content types that the view can open.
    ///   - backgroundStyle: An optional background style of the view.
    ///   - actions: A view builder returning the view's actions
    ///   - onDocumentOpen: A closure that handles an open file.
    public init<B>(_ title: some StringProtocol, for contentTypes: [UTType], backgroundStyle: B, @ViewBuilder _ actions: () -> Actions, @ViewBuilder onDocumentOpen: @escaping (URL) -> DocumentView) where B : ShapeStyle

    /// Creates a view to present when launching document-related user experiences
    /// using a title text, custom actions, a background style, and accessory views.
    ///
    /// > Note:
    /// > An alternative to `DocumentLaunchView` is a scene variant
    /// > of this API: ``DocumentGroupLaunchScene``.
    /// > If the app definition contains `DocumentGroup` scenes, consider using
    /// > a `DocumentGroupLaunchScene` instead of this view.
    ///
    /// - Parameters:
    ///   - title: A text value to use for the view title.
    ///   - contentTypes: Content types that the view can open.
    ///   - backgroundStyle: An optional background style of the view.
    ///   - actions: A view builder returning the view's actions
    ///   - onDocumentOpen: A closure that handles an open file.
    ///   - backgroundAccessoryView: A view builder for returning the view's
    ///   background accessory view.
    ///   - overlayAccessoryView: A view builder for returning the view's overlay
    ///   accessory view.
    public init<B>(_ title: Text? = nil, for contentTypes: [UTType], backgroundStyle: B, @ViewBuilder _ actions: () -> Actions, @ViewBuilder onDocumentOpen: @escaping (URL) -> DocumentView, @ViewBuilder backgroundAccessoryView: @escaping (DocumentLaunchGeometryProxy) -> some View, @ViewBuilder overlayAccessoryView: @escaping (DocumentLaunchGeometryProxy) -> some View) where B : ShapeStyle

    /// Creates a view to present when launching document-related user experiences
    /// using a title text, custom actions, a background style, and an overlay accessory view.
    ///
    /// > Note:
    /// > An alternative to `DocumentLaunchView` is a scene variant
    /// > of this API: ``DocumentGroupLaunchScene``.
    /// > If the app definition contains `DocumentGroup` scenes, consider using
    /// > a `DocumentGroupLaunchScene` instead of this view.
    ///
    /// - Parameters:
    ///   - title: A text value to use for the view title.
    ///   - contentTypes: Content types that the view can open.
    ///   - backgroundStyle: An optional background style of the view.
    ///   - actions: A view builder returning the view's actions
    ///   - onDocumentOpen: A closure that handles an open file.
    ///   - overlayAccessoryView: A view builder for returning the view's overlay
    ///   accessory view.
    public init<B>(_ title: Text? = nil, for contentTypes: [UTType], backgroundStyle: B, @ViewBuilder _ actions: () -> Actions, @ViewBuilder onDocumentOpen: @escaping (URL) -> DocumentView, @ViewBuilder overlayAccessoryView: @escaping (DocumentLaunchGeometryProxy) -> some View) where B : ShapeStyle

    /// Creates a view to present when launching document-related user experiences
    /// using a title text, custom actions, a background style, and a background accessory view.
    ///
    /// > Note:
    /// > An alternative to `DocumentLaunchView` is a scene variant
    /// > of this API: ``DocumentGroupLaunchScene``.
    /// > If the app definition contains `DocumentGroup` scenes, consider using
    /// > a `DocumentGroupLaunchScene` instead of this view.
    ///
    /// - Parameters:
    ///   - title: A text value to use for the view title.
    ///   - contentTypes: Content types that the view can open.
    ///   - backgroundStyle: An optional background style of the view.
    ///   - actions: A view builder returning the view's actions
    ///   - onDocumentOpen: A closure that handles an open file.
    ///   - backgroundAccessoryView: A view builder for returning the view's
    ///   background accessory view.
    public init<B>(_ title: Text? = nil, for contentTypes: [UTType], backgroundStyle: B, @ViewBuilder _ actions: () -> Actions, @ViewBuilder onDocumentOpen: @escaping (URL) -> DocumentView, @ViewBuilder backgroundAccessoryView: @escaping (DocumentLaunchGeometryProxy) -> some View) where B : ShapeStyle

    /// Creates a view to present when launching document-related user experiences
    /// using a title text, custom actions, and a background style.
    ///
    /// > Note:
    /// > An alternative to `DocumentLaunchView` is a scene variant
    /// > of this API: ``DocumentGroupLaunchScene``.
    /// > If the app definition contains `DocumentGroup` scenes, consider using
    /// > a `DocumentGroupLaunchScene` instead of this view.
    ///
    /// - Parameters:
    ///   - title: A text value to use for the view title.
    ///   - contentTypes: Content types that the view can open.
    ///   - backgroundStyle: An optional background style of the view.
    ///   - actions: A view builder returning the view's actions
    ///   - onDocumentOpen: A closure that handles an open file.
    public init<B>(_ title: Text? = nil, for contentTypes: [UTType], backgroundStyle: B, @ViewBuilder _ actions: () -> Actions, @ViewBuilder onDocumentOpen: @escaping (URL) -> DocumentView) where B : ShapeStyle

    /// Creates a view to present when launching document-related user experiences
    /// using a localized title, custom actions, and accessory views.
    ///
    /// > Note:
    /// > An alternative to `DocumentLaunchView` is a scene variant
    /// > of this API: ``DocumentGroupLaunchScene``.
    /// > If the app definition contains `DocumentGroup` scenes, consider using
    /// > a `DocumentGroupLaunchScene` instead of this view.
    ///
    /// - Parameters:
    ///   - title: A title key to use for the view title.
    ///   - contentTypes: Content types that the view can open.
    ///   - actions: A view builder returning the view's actions
    ///   - onDocumentOpen: A closure that handles an open file.
    ///   - backgroundAccessoryView: A view builder for returning the view's
    ///   background accessory view.
    ///   - overlayAccessoryView: A view builder for returning the view's overlay
    ///   accessory view.
    public init(_ title: LocalizedStringKey, for contentTypes: [UTType], @ViewBuilder _ actions: () -> Actions, @ViewBuilder onDocumentOpen: @escaping (URL) -> DocumentView, @ViewBuilder backgroundAccessoryView: @escaping (DocumentLaunchGeometryProxy) -> some View, @ViewBuilder overlayAccessoryView: @escaping (DocumentLaunchGeometryProxy) -> some View)

    /// Creates a view to present when launching document-related user experiences
    /// using a localized title, custom actions, and an overlay accessory view.
    ///
    /// > Note:
    /// > An alternative to `DocumentLaunchView` is a scene variant
    /// > of this API: ``DocumentGroupLaunchScene``.
    /// > If the app definition contains `DocumentGroup` scenes, consider using
    /// > a `DocumentGroupLaunchScene` instead of this view.
    ///
    /// - Parameters:
    ///   - title: A title key to use for the view title.
    ///   - contentTypes: Content types that the view can open.
    ///   - actions: A view builder returning the view's actions
    ///   - onDocumentOpen: A closure that handles an open file.
    ///   - overlayAccessoryView: A view builder for returning the view's overlay
    ///   accessory view.
    public init(_ title: LocalizedStringKey, for contentTypes: [UTType], @ViewBuilder _ actions: () -> Actions, @ViewBuilder onDocumentOpen: @escaping (URL) -> DocumentView, @ViewBuilder overlayAccessoryView: @escaping (DocumentLaunchGeometryProxy) -> some View)

    /// Creates a view to present when launching document-related user experiences
    /// using a localized title, custom actions, and a background accessory view.
    ///
    /// > Note:
    /// > An alternative to `DocumentLaunchView` is a scene variant
    /// > of this API: ``DocumentGroupLaunchScene``.
    /// > If the app definition contains `DocumentGroup` scenes, consider using
    /// > a `DocumentGroupLaunchScene` instead of this view.
    ///
    /// - Parameters:
    ///   - title: A title key to use for the view title.
    ///   - contentTypes: Content types that the view can open.
    ///   - actions: A view builder returning the view's actions
    ///   - onDocumentOpen: A closure that handles an open file.
    ///   - backgroundAccessoryView: A view builder for returning the view's
    ///   background accessory view.
    public init(_ title: LocalizedStringKey, for contentTypes: [UTType], @ViewBuilder _ actions: () -> Actions, @ViewBuilder onDocumentOpen: @escaping (URL) -> DocumentView, @ViewBuilder backgroundAccessoryView: @escaping (DocumentLaunchGeometryProxy) -> some View)

    /// Creates a view to present when launching document-related user experiences
    /// using a localized title and custom actions.
    ///
    /// > Note:
    /// > An alternative to `DocumentLaunchView` is a scene variant
    /// > of this API: ``DocumentGroupLaunchScene``.
    /// > If the app definition contains `DocumentGroup` scenes, consider using
    /// > a `DocumentGroupLaunchScene` instead of this view.
    ///
    /// - Parameters:
    ///   - title: A title key to use for the view title.
    ///   - contentTypes: Content types that the view can open.
    ///   - actions: A view builder returning the view's actions
    ///   - onDocumentOpen: A closure that handles an open file.
    public init(_ title: LocalizedStringKey, for contentTypes: [UTType], @ViewBuilder _ actions: () -> Actions, @ViewBuilder onDocumentOpen: @escaping (URL) -> DocumentView)

    /// Creates a view to present when launching document-related user experiences
    /// using a custom title, actions, and accessory views.
    ///
    /// > Note:
    /// > An alternative to `DocumentLaunchView` is a scene variant
    /// > of this API: ``DocumentGroupLaunchScene``.
    /// > If the app definition contains `DocumentGroup` scenes, consider using
    /// > a `DocumentGroupLaunchScene` instead of this view.
    ///
    /// - Parameters:
    ///   - title: A title to use for the view title.
    ///   - contentTypes: Content types that the view can open.
    ///   - actions: A view builder returning the view's actions
    ///   - onDocumentOpen: A closure that handles an open file.
    ///   - backgroundAccessoryView: A view builder for returning the view's
    ///   background accessory view.
    ///   - overlayAccessoryView: A view builder for returning the view's overlay
    ///   accessory view.
    public init(_ title: some StringProtocol, for contentTypes: [UTType], @ViewBuilder _ actions: () -> Actions, @ViewBuilder onDocumentOpen: @escaping (URL) -> DocumentView, @ViewBuilder backgroundAccessoryView: @escaping (DocumentLaunchGeometryProxy) -> some View, @ViewBuilder overlayAccessoryView: @escaping (DocumentLaunchGeometryProxy) -> some View)

    /// Creates a view to present when launching document-related user experiences
    /// using a custom title, actions, and a background accessory view.
    ///
    /// > Note:
    /// > An alternative to `DocumentLaunchView` is a scene variant
    /// > of this API: ``DocumentGroupLaunchScene``.
    /// > If the app definition contains `DocumentGroup` scenes, consider using
    /// > a `DocumentGroupLaunchScene` instead of this view.
    ///
    /// - Parameters:
    ///   - title: A title to use for the view title.
    ///   - contentTypes: Content types that the view can open.
    ///   - actions: A view builder returning the view's actions
    ///   - onDocumentOpen: A closure that handles an open file.
    ///   - backgroundAccessoryView: A view builder for returning the view's
    ///   background accessory view.
    public init(_ title: some StringProtocol, for contentTypes: [UTType], @ViewBuilder _ actions: () -> Actions, @ViewBuilder onDocumentOpen: @escaping (URL) -> DocumentView, @ViewBuilder backgroundAccessoryView: @escaping (DocumentLaunchGeometryProxy) -> some View)

    /// Creates a view to present when launching document-related user experiences
    /// using a custom title, actions, and an overlay accessory view.
    ///
    /// > Note:
    /// > An alternative to `DocumentLaunchView` is a scene variant
    /// > of this API: ``DocumentGroupLaunchScene``.
    /// > If the app definition contains `DocumentGroup` scenes, consider using
    /// > a `DocumentGroupLaunchScene` instead of this view.
    ///
    /// - Parameters:
    ///   - title: A title to use for the view title.
    ///   - contentTypes: Content types that the view can open.
    ///   - actions: A view builder returning the view's actions
    ///   - onDocumentOpen: A closure that handles an open file.
    ///   - overlayAccessoryView: A view builder for returning the view's overlay
    ///   accessory view.
    public init(_ title: some StringProtocol, for contentTypes: [UTType], @ViewBuilder _ actions: () -> Actions, @ViewBuilder onDocumentOpen: @escaping (URL) -> DocumentView, @ViewBuilder overlayAccessoryView: @escaping (DocumentLaunchGeometryProxy) -> some View)

    /// Creates a view to present when launching document-related user experiences
    /// using a custom title and actions.
    ///
    /// > Note:
    /// > An alternative to `DocumentLaunchView` is a scene variant
    /// > of this API: ``DocumentGroupLaunchScene``.
    /// > If the app definition contains `DocumentGroup` scenes, consider using
    /// > a `DocumentGroupLaunchScene` instead of this view.
    ///
    /// - Parameters:
    ///   - title: A title to use for the view title.
    ///   - contentTypes: Content types that the view can open.
    ///   - actions: A view builder returning the view's actions
    ///   - onDocumentOpen: A closure that handles an open file.
    public init(_ title: some StringProtocol, for contentTypes: [UTType], @ViewBuilder _ actions: () -> Actions, @ViewBuilder onDocumentOpen: @escaping (URL) -> DocumentView)

    /// Creates a view to present when launching document-related user experiences
    /// using a title text, custom actions, and accessory views.
    ///
    /// > Note:
    /// > An alternative to `DocumentLaunchView` is a scene variant
    /// > of this API: ``DocumentGroupLaunchScene``.
    /// > If the app definition contains `DocumentGroup` scenes, consider using
    /// > a `DocumentGroupLaunchScene` instead of this view.
    ///
    /// - Parameters:
    ///   - title: A text value to use for the view title.
    ///   - contentTypes: Content types that the view can open.
    ///   - actions: A view builder returning the view's actions
    ///   - onDocumentOpen: A closure that handles an open file.
    ///   - backgroundAccessoryView: A view builder for returning the view's
    ///   background accessory view.
    ///   - overlayAccessoryView: A view builder for returning the view's overlay
    ///   accessory view.
    public init(_ title: Text? = nil, for contentTypes: [UTType], @ViewBuilder _ actions: () -> Actions, @ViewBuilder onDocumentOpen: @escaping (URL) -> DocumentView, @ViewBuilder backgroundAccessoryView: @escaping (DocumentLaunchGeometryProxy) -> some View, @ViewBuilder overlayAccessoryView: @escaping (DocumentLaunchGeometryProxy) -> some View)

    /// Creates a view to present when launching document-related user experiences
    /// using a title text, custom actions, and a background accessory view.
    ///
    /// > Note:
    /// > An alternative to `DocumentLaunchView` is a scene variant
    /// > of this API: ``DocumentGroupLaunchScene``.
    /// > If the app definition contains `DocumentGroup` scenes, consider using
    /// > a `DocumentGroupLaunchScene` instead of this view.
    ///
    /// - Parameters:
    ///   - title: A text value to use for the view title.
    ///   - contentTypes: Content types that the view can open.
    ///   - actions: A view builder returning the view's actions
    ///   - onDocumentOpen: A closure that handles an open file.
    ///   - backgroundAccessoryView: A view builder for returning the view's
    ///   background accessory view.
    public init(_ title: Text? = nil, for contentTypes: [UTType], @ViewBuilder _ actions: () -> Actions, @ViewBuilder onDocumentOpen: @escaping (URL) -> DocumentView, @ViewBuilder backgroundAccessoryView: @escaping (DocumentLaunchGeometryProxy) -> some View)

    /// Creates a view to present when launching document-related user experiences
    /// using a title text, custom actions, and an overlay accessory view.
    ///
    /// > Note:
    /// > An alternative to `DocumentLaunchView` is a scene variant
    /// > of this API: ``DocumentGroupLaunchScene``.
    /// > If the app definition contains `DocumentGroup` scenes, consider using
    /// > a `DocumentGroupLaunchScene` instead of this view.
    ///
    /// - Parameters:
    ///   - title: A text value to use for the view title.
    ///   - contentTypes: Content types that the view can open.
    ///   - actions: A view builder returning the view's actions
    ///   - onDocumentOpen: A closure that handles an open file.
    ///   - overlayAccessoryView: A view builder for returning the view's overlay
    ///   accessory view.
    public init(_ title: Text? = nil, for contentTypes: [UTType], @ViewBuilder _ actions: () -> Actions, @ViewBuilder onDocumentOpen: @escaping (URL) -> DocumentView, @ViewBuilder overlayAccessoryView: @escaping (DocumentLaunchGeometryProxy) -> some View)

    /// Creates a view to present when launching document-related user experiences
    /// using a title text and custom actions.
    ///
    /// > Note:
    /// > An alternative to `DocumentLaunchView` is a scene variant
    /// > of this API: ``DocumentGroupLaunchScene``.
    /// > If the app definition contains `DocumentGroup` scenes, consider using
    /// > a `DocumentGroupLaunchScene` instead of this view.
    ///
    /// - Parameters:
    ///   - title: A text value to use for the view title.
    ///   - contentTypes: Content types that the view can open.
    ///   - actions: A view builder returning the view's actions
    ///   - onDocumentOpen: A closure that handles an open file.
    public init(_ title: Text? = nil, for contentTypes: [UTType], @ViewBuilder _ actions: () -> Actions, @ViewBuilder onDocumentOpen: @escaping (URL) -> DocumentView)

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    @available(iOS 18.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    @available(visionOS, unavailable)
    @available(macOS, unavailable)
    @available(macCatalyst, unavailable)
    public typealias Body = some View
}

/// A navigation view style represented by a primary view stack that
/// navigates to a detail view.
@available(iOS, introduced: 13.0, deprecated: 100000.0, message: "replace styled NavigationView with NavigationStack or NavigationSplitView instead")
@available(macOS, introduced: 10.15, deprecated: 100000.0, message: "replace styled NavigationView with NavigationSplitView instead")
@available(tvOS, introduced: 13.0, deprecated: 100000.0, message: "replace styled NavigationView with NavigationStack or NavigationSplitView instead")
@available(watchOS, unavailable)
@available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "replace styled NavigationView with NavigationStack or NavigationSplitView instead")
public struct DoubleColumnNavigationViewStyle : NavigationViewStyle {

    public init()
}

/// A dragging motion that invokes an action as the drag-event sequence changes.
///
/// To recognize a drag gesture on a view, create and configure the gesture, and
/// then add it to the view using the ``View/gesture(_:including:)`` modifier.
///
/// Add a drag gesture to a ``Circle`` and change its color while the user
/// performs the drag gesture:
///
///     struct DragGestureView: View {
///         @State private var isDragging = false
///
///         var drag: some Gesture {
///             DragGesture()
///                 .onChanged { _ in self.isDragging = true }
///                 .onEnded { _ in self.isDragging = false }
///         }
///
///         var body: some View {
///             Circle()
///                 .fill(self.isDragging ? Color.red : Color.blue)
///                 .frame(width: 100, height: 100, alignment: .center)
///                 .gesture(drag)
///         }
///     }
@available(iOS 13.0, macOS 10.15, watchOS 6.0, *)
@available(tvOS, unavailable)
@MainActor @preconcurrency public struct DragGesture : Gesture {

    /// The attributes of a drag gesture.
    public struct Value : Equatable, Sendable {

        /// The time associated with the drag gesture's current event.
        public var time: Date

        /// The location of the drag gesture's current event.
        public var location: CGPoint

        /// The location of the drag gesture's first event.
        public var startLocation: CGPoint

        /// The total translation from the start of the drag gesture to the
        /// current event of the drag gesture.
        ///
        /// This is equivalent to `location.{x,y} - startLocation.{x,y}`.
        public var translation: CGSize { get }

        /// The current drag velocity.
        public var velocity: CGSize { get }

        /// A prediction, based on the current drag velocity, of where the final
        /// location will be if dragging stopped now.
        public var predictedEndLocation: CGPoint { get }

        /// A prediction, based on the current drag velocity, of what the final
        /// translation will be if dragging stopped now.
        public var predictedEndTranslation: CGSize { get }

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: DragGesture.Value, b: DragGesture.Value) -> Bool
    }

    /// The minimum dragging distance before the gesture succeeds.
    @MainActor @preconcurrency public var minimumDistance: CGFloat

    /// The coordinate space in which to receive location values.
    @MainActor @preconcurrency public var coordinateSpace: CoordinateSpace

    /// Creates a dragging gesture with the minimum dragging distance before the
    /// gesture succeeds and the coordinate space of the gesture's location.
    ///
    /// - Parameters:
    ///   - minimumDistance: The minimum dragging distance for the gesture to
    ///     succeed.
    ///   - coordinateSpace: The coordinate space of the dragging gesture's
    ///     location.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, message: "use overload that accepts a CoordinateSpaceProtocol instead")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, message: "use overload that accepts a CoordinateSpaceProtocol instead")
    @available(watchOS, introduced: 6.0, deprecated: 100000.0, message: "use overload that accepts a CoordinateSpaceProtocol instead")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "use overload that accepts a CoordinateSpaceProtocol instead")
    @available(tvOS, unavailable)
    @MainActor @preconcurrency public init(minimumDistance: CGFloat = 10, coordinateSpace: CoordinateSpace = .local)

    /// Creates a dragging gesture with the minimum dragging distance before the
    /// gesture succeeds and the coordinate space of the gesture's location.
    ///
    /// - Parameters:
    ///   - minimumDistance: The minimum dragging distance for the gesture to
    ///     succeed.
    ///   - coordinateSpace: The coordinate space of the dragging gesture's
    ///     location.
    @available(iOS 17.0, macOS 14.0, watchOS 10.0, *)
    @available(tvOS, unavailable)
    @MainActor @preconcurrency public init(minimumDistance: CGFloat = 10, coordinateSpace: some CoordinateSpaceProtocol = .local)

    /// The type of gesture representing the body of `Self`.
    @available(iOS 13.0, watchOS 6.0, macOS 10.15, *)
    @available(tvOS, unavailable)
    public typealias Body = Never
}

/// An interface that you implement to interact with a drop operation in a view
/// modified to accept drops.
///
/// The ``DropDelegate`` protocol provides a comprehensive and flexible way to
/// interact with a drop operation. Specify a drop delegate when you modify a
/// view to accept drops with the ``View/onDrop(of:delegate:)`` method.
///
/// Alternatively, for simple drop cases that don't require the full
/// functionality of a drop delegate, you can modify a view to accept drops
/// using the ``View/onDrop(of:isTargeted:perform:)`` method. This method handles the
/// drop using a closure you provide as part of the modifier.
@available(iOS 13.4, macOS 10.15, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@MainActor @preconcurrency public protocol DropDelegate {

    /// Tells the delegate that a drop containing items conforming to one of the
    /// expected types entered a view that accepts drops.
    ///
    /// Specify the expected types when you apply the drop modifier to the view.
    /// The default implementation returns `true`.
    @MainActor @preconcurrency func validateDrop(info: DropInfo) -> Bool

    /// Tells the delegate it can request the item provider data from the given
    /// information.
    ///
    /// Incorporate the received data into your app's data model as appropriate.
    /// - Returns: A Boolean that is `true` if the drop was successful, `false`
    ///   otherwise.
    @MainActor @preconcurrency func performDrop(info: DropInfo) -> Bool

    /// Tells the delegate a validated drop has entered the modified view.
    ///
    /// The default implementation does nothing.
    @MainActor @preconcurrency func dropEntered(info: DropInfo)

    /// Tells the delegate that a validated drop moved inside the modified view.
    ///
    /// Use this method to return a drop proposal containing the operation the
    /// delegate intends to perform at the drop ``DropInfo/location``. The
    /// default implementation of this method returns `nil`, which tells the
    /// drop to use the last valid returned value or else
    /// ``DropOperation/copy``.
    @MainActor @preconcurrency func dropUpdated(info: DropInfo) -> DropProposal?

    /// Tells the delegate a validated drop operation has exited the modified
    /// view.
    ///
    /// The default implementation does nothing.
    @MainActor @preconcurrency func dropExited(info: DropInfo)
}

@available(iOS 13.4, macOS 10.15, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension DropDelegate {

    /// Tells the delegate that a drop containing items conforming to one of the
    /// expected types entered a view that accepts drops.
    ///
    /// Specify the expected types when you apply the drop modifier to the view.
    /// The default implementation returns `true`.
    @MainActor @preconcurrency public func validateDrop(info: DropInfo) -> Bool

    /// Tells the delegate a validated drop has entered the modified view.
    ///
    /// The default implementation does nothing.
    @MainActor @preconcurrency public func dropEntered(info: DropInfo)

    /// Tells the delegate that a validated drop moved inside the modified view.
    ///
    /// Use this method to return a drop proposal containing the operation the
    /// delegate intends to perform at the drop ``DropInfo/location``. The
    /// default implementation of this method returns `nil`, which tells the
    /// drop to use the last valid returned value or else
    /// ``DropOperation/copy``.
    @MainActor @preconcurrency public func dropUpdated(info: DropInfo) -> DropProposal?

    /// Tells the delegate a validated drop operation has exited the modified
    /// view.
    ///
    /// The default implementation does nothing.
    @MainActor @preconcurrency public func dropExited(info: DropInfo)
}

/// The current state of a drop.
@available(iOS 13.4, macOS 10.15, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct DropInfo {

    /// The location of the drag in the coordinate space of the drop view.
    public var location: CGPoint { get }

    /// Indicates whether at least one item conforms to at least one of the
    /// specified uniform type identifiers.
    ///
    /// - Parameter contentTypes: The uniform type identifiers to query for.
    /// - Returns: Whether at least one item conforms to one of `contentTypes`.
    @available(iOS 14.0, macOS 11.0, *)
    public func hasItemsConforming(to contentTypes: [UTType]) -> Bool

    /// Finds item providers that conform to at least one of the specified
    /// uniform type identifiers.
    ///
    /// This function is only valid during the `performDrop()` action.
    ///
    /// - Parameter contentTypes: The uniform type identifiers to query for.
    /// - Returns: The item providers that conforms to `contentTypes`.
    @available(iOS 14.0, macOS 11.0, *)
    public func itemProviders(for contentTypes: [UTType]) -> [NSItemProvider]
}

@available(iOS, introduced: 13.4, deprecated: 100000.0, message: "Provide `UTType`s as the `types` instead.")
@available(macOS, introduced: 10.15, deprecated: 100000.0, message: "Provide `UTType`s as the `types` instead.")
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Provide `UTType`s as the `types` instead.")
extension DropInfo {

    /// Returns whether at least one item conforms to at least one of the
    /// specified uniform type identifiers.
    public func hasItemsConforming(to types: [String]) -> Bool

    /// Returns an Array of items that each conform to at least one of the
    /// specified uniform type identifiers.
    ///
    /// This function is only valid during the performDrop() action.
    public func itemProviders(for types: [String]) -> [NSItemProvider]
}

/// Operation types that determine how a drag and drop session resolves when the
/// user drops a drag item.
@available(iOS 13.4, macOS 10.15, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public enum DropOperation : Sendable {

    /// Cancel the drag operation and transfer no data.
    case cancel

    /// The drop activity is not allowed at this time or location.
    case forbidden

    /// Copy the data to the modified view.
    case copy

    /// Move the data represented by the drag items instead of copying it.
    case move

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: DropOperation, b: DropOperation) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

@available(iOS 13.4, macOS 10.15, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension DropOperation : Equatable {
}

@available(iOS 13.4, macOS 10.15, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension DropOperation : Hashable {
}

/// The behavior of a drop.
@available(iOS 13.4, macOS 10.15, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct DropProposal : Sendable {

    /// The drop operation that the drop proposes to perform.
    public let operation: DropOperation

    public init(operation: DropOperation)
}

/// A type of table row content that generates table rows from an underlying
/// collection of data.
///
/// This table row content type provides drag-and-drop support for tables. Use
/// the ``DynamicTableRowContent/onInsert(of:perform:)`` modifier to add an
/// action to call when the table inserts new contents into its underlying
/// collection.
@available(iOS 16.0, macOS 12.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public protocol DynamicTableRowContent : TableRowContent {

    /// The type of the underlying collection of data.
    associatedtype Data : Collection

    /// The collection of underlying data.
    var data: Self.Data { get }
}

@available(iOS 16.0, macOS 13.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension DynamicTableRowContent {

    /// Sets the insert action for the dynamic table rows.
    ///
    ///     struct Profile: Identifiable {
    ///         let givenName: String
    ///         let familyName: String
    ///         let id = UUID()
    ///     }
    ///
    ///     @State private var profiles: [Profile] = [
    ///         Person(givenName: "Juan", familyName: "Chavez"),
    ///         Person(givenName: "Mei", familyName: "Chen"),
    ///         Person(givenName: "Tom", familyName: "Clark"),
    ///         Person(givenName: "Gita", familyName: "Kumar")
    ///     ]
    ///
    ///     var body: some View {
    ///         Table {
    ///             TableColumn("Given Name", value: \.givenName)
    ///             TableColumn("Family Name", value: \.familyName)
    ///         } rows: {
    ///             ForEach(profiles) {
    ///                 TableRow($0)
    ///             }
    ///             .dropDestination(
    ///                 for: Profile.self
    ///             ) { offset, receivedProfiles in
    ///                 people.insert(contentsOf: receivedProfiles, at: offset)
    ///             }
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - payloadType: Type of the models that are dropped.
    ///   - action: A closure that SwiftUI invokes when elements are added to
    ///     the collection of rows.
    ///     The closure takes two arguments: The first argument is the
    ///     offset relative to the dynamic view's underlying collection of data.
    ///     The second argument is an array of `Transferable` items that
    ///     represents the data that you want to insert.
    ///
    /// - Returns: A view that calls `action` when elements are inserted into
    ///   the original view.
    @available(iOS 16.0, macOS 13.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public func dropDestination<T>(for payloadType: T.Type = T.self, action: @escaping (Int, [T]) -> Void) -> ModifiedContent<Self, OnInsertTableRowModifier> where T : Transferable
}

@available(iOS 16.0, macOS 12.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension DynamicTableRowContent {

    /// Sets the insert action for the dynamic table rows.
    ///
    /// - Parameters:
    ///   - supportedContentTypes: An array of universal type identifiers types that the rows supports.
    ///   - action: A closure that SwiftUI invokes when adding elements to
    ///     the collection of rows.
    ///     The closure takes two arguments. The first argument is the
    ///     offset relative to the dynamic view's underlying collection of data.
    ///     The second argument is an array of
    ///     <doc://com.apple.documentation/documentation/Foundation/NSItemProvider>
    ///     items that represents the data that you want to insert.
    ///
    /// - Returns: A view that calls `action` when inserting elements into
    ///   the original view.
    public func onInsert(of supportedContentTypes: [UTType], perform action: @escaping (Int, [NSItemProvider]) -> Void) -> ModifiedContent<Self, OnInsertTableRowModifier>
}

/// A set of edit actions on a collection of data that a view can offer
/// to a user.
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct EditActions<Data> : OptionSet, Sendable {

    /// The raw value.
    public let rawValue: Int

    /// Creates a new set from a raw value.
    ///
    /// - Parameter rawValue: The raw value with which to create the
    /// collection edits.
    public init(rawValue: Int)

    /// All the edit actions available on this collection.
    public static var all: EditActions<Data> { get }

    /// The type of the elements of an array literal.
    @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
    public typealias ArrayLiteralElement = EditActions<Data>

    /// The element type of the option set.
    ///
    /// To inherit all the default implementations from the `OptionSet` protocol,
    /// the `Element` type must be `Self`, the default.
    @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
    public typealias Element = EditActions<Data>

    /// The raw type that can be used to represent all values of the conforming
    /// type.
    ///
    /// Every distinct value of the conforming type has a corresponding unique
    /// value of the `RawValue` type, but there may be values of the `RawValue`
    /// type that don't have a corresponding value of the conforming type.
    @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
    public typealias RawValue = Int
}

@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension EditActions where Data : RangeReplaceableCollection {

    /// An edit action that allows the user to delete one or more elements
    /// of a collection.
    public static var delete: EditActions<Data> { get }

    /// All the edit actions available on this collection.
    public static var all: EditActions<Data> { get }
}

@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension EditActions where Data : MutableCollection {

    /// An edit action that allows the user to move elements of a
    /// collection.
    public static var move: EditActions<Data> { get }

    /// All the edit actions available on this collection.
    public static var all: EditActions<Data> { get }
}

@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension EditActions where Data : MutableCollection, Data : RangeReplaceableCollection {

    /// All the edit actions available on this collection.
    public static var all: EditActions<Data> { get }
}

/// A button that toggles the edit mode environment value.
///
/// An edit button toggles the environment's ``EnvironmentValues/editMode``
/// value for content within a container that supports edit mode.
/// In the following example, an edit button placed inside a ``NavigationView``
/// supports editing of a ``List``:
///
///     @State private var fruits = [
///         "Apple",
///         "Banana",
///         "Papaya",
///         "Mango"
///     ]
///
///     var body: some View {
///         NavigationView {
///             List {
///                 ForEach(fruits, id: \.self) { fruit in
///                     Text(fruit)
///                 }
///                 .onDelete { fruits.remove(atOffsets: $0) }
///                 .onMove { fruits.move(fromOffsets: $0, toOffset: $1) }
///             }
///             .navigationTitle("Fruits")
///             .toolbar {
///                 EditButton()
///             }
///         }
///     }
///
/// Because the ``ForEach`` in the above example defines behaviors for
/// ``DynamicViewContent/onDelete(perform:)`` and
/// ``DynamicViewContent/onMove(perform:)``, the editable list displays the
/// delete and move UI when the user taps Edit. Notice that the Edit button
/// displays the title "Done" while edit mode is active:
///
/// ![A screenshot of an app with an Edit button in the navigation bar.
/// The button is labeled Done to indicate edit mode is active. Below the
/// navigation bar, a list labeled Fruits in edit mode. The list contains
/// four members, each showing a red circle containing a white dash to the
/// left of the item, and an icon composed of three horizontal lines to the
/// right of the item.](EditButton-1)
///
/// You can also create custom views that react to changes in the edit mode
/// state, as described in ``EditMode``.
@available(iOS 13.0, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct EditButton : View {

    /// Creates an Edit button instance.
    public init()

    /// The content and behavior of the view.
    ///
    /// When you implement a custom view, you must implement a computed
    /// `body` property to provide the content for your view. Return a view
    /// that's composed of built-in views that SwiftUI provides, plus other
    /// composite views that you've already defined:
    ///
    ///     struct MyView: View {
    ///         var body: some View {
    ///             Text("Hello, World!")
    ///         }
    ///     }
    ///
    /// For more information about composing views and a view hierarchy,
    /// see <doc:Declaring-a-Custom-View>.
    @MainActor @preconcurrency public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    @available(iOS 13.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    @available(macOS, unavailable)
    public typealias Body = some View
}

/// A mode that indicates whether the user can edit a view's content.
///
/// You receive an optional binding to the edit mode state when you
/// read the ``EnvironmentValues/editMode`` environment value. The binding
/// contains an `EditMode` value that indicates whether edit mode is active,
/// and that you can use to change the mode. To learn how to read an environment
/// value, see ``EnvironmentValues``.
///
/// Certain built-in views automatically alter their appearance and behavior
/// in edit mode. For example, a ``List`` with a ``ForEach`` that's
/// configured with the ``DynamicViewContent/onDelete(perform:)`` or
/// ``DynamicViewContent/onMove(perform:)`` modifier provides controls to
/// delete or move list items while in edit mode. On devices without an attached
/// keyboard and mouse or trackpad, people can make multiple selections in lists
/// only when edit mode is active.
///
/// You can also customize your own views to react to edit mode.
/// The following example replaces a read-only ``Text`` view with
/// an editable ``TextField``, checking for edit mode by
/// testing the wrapped value's ``EditMode/isEditing`` property:
///
///     @Environment(\.editMode) private var editMode
///     @State private var name = "Maria Ruiz"
///
///     var body: some View {
///         Form {
///             if editMode?.wrappedValue.isEditing == true {
///                 TextField("Name", text: $name)
///             } else {
///                 Text(name)
///             }
///         }
///         .animation(nil, value: editMode?.wrappedValue)
///         .toolbar { // Assumes embedding this view in a NavigationView.
///             EditButton()
///         }
///     }
///
/// You can set the edit mode through the binding, or you can
/// rely on an ``EditButton`` to do that for you, as the example above
/// demonstrates. The button activates edit mode when the user
/// taps it, and disables the mode when the user taps again.
@available(iOS 13.0, tvOS 13.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
public enum EditMode : Sendable {

    /// The user can't edit the view content.
    ///
    /// The ``isEditing`` property is `false` in this state.
    case inactive

    /// The view is in a temporary edit mode.
    ///
    /// The use of this state varies by platform and for different
    /// controls. As an example, SwiftUI might engage temporary edit mode
    /// over the duration of a swipe gesture.
    ///
    /// The ``isEditing`` property is `true` in this state.
    case transient

    /// The user can edit the view content.
    ///
    /// The ``isEditing`` property is `true` in this state.
    case active

    /// Indicates whether a view is being edited.
    ///
    /// This property returns `true` if the mode is something other than
    /// inactive.
    public var isEditing: Bool { get }

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: EditMode, b: EditMode) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

@available(iOS 13.0, tvOS 13.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension EditMode : Equatable {
}

@available(iOS 13.0, tvOS 13.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension EditMode : Hashable {
}

/// An opaque wrapper view that adds editing capabilities to a row in a list.
///
/// You don't use this type directly. Instead SwiftUI creates this type on
/// your behalf.
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct EditableCollectionContent<Content, Data> {
}

@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension EditableCollectionContent : View where Content : View {

    /// The content and behavior of the view.
    ///
    /// When you implement a custom view, you must implement a computed
    /// `body` property to provide the content for your view. Return a view
    /// that's composed of built-in views that SwiftUI provides, plus other
    /// composite views that you've already defined:
    ///
    ///     struct MyView: View {
    ///         var body: some View {
    ///             Text("Hello, World!")
    ///         }
    ///     }
    ///
    /// For more information about composing views and a view hierarchy,
    /// see <doc:Declaring-a-Custom-View>.
    @MainActor @preconcurrency public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
    public typealias Body = some View
}

/// An empty group of commands.
@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct EmptyCommands : Commands {

    /// Creates an empty command hierarchy.
    public init()

    /// The type of commands that represents the body of this command hierarchy.
    ///
    /// When you create custom commands, Swift infers this type from your
    /// implementation of the required ``SwiftUI/Commands/body-swift.property``
    /// property.
    @available(iOS 14.0, macOS 11.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias Body = Never
}

/// An empty control widget configuration.
@available(iOS 18.0, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@available(visionOS, unavailable)
@MainActor @frozen @preconcurrency public struct EmptyControlWidgetConfiguration : ControlWidgetConfiguration {

    /// The type of control widget configuration representing the body of this
    /// configuration.
    public typealias Body = Never

    @MainActor @inlinable @preconcurrency public init()
}

@available(iOS 18.0, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@available(visionOS, unavailable)
extension EmptyControlWidgetConfiguration : BitwiseCopyable {
}

/// An empty control widget template.
@available(iOS 18.0, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@available(visionOS, unavailable)
@MainActor @frozen @preconcurrency public struct EmptyControlWidgetTemplate {

    /// The type of control widget template representing the body of this template.
    ///
    /// When you create a custom control widget, Swift infers this type from your
    /// implementation of the required ``ControlWidgetTemplate/body-swift.property``
    /// property.
    public typealias Body = Never

    @MainActor @inlinable @preconcurrency public init()
}

@available(iOS 18.0, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@available(visionOS, unavailable)
extension EmptyControlWidgetTemplate : ControlWidgetTemplate {
}

@available(iOS 18.0, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@available(visionOS, unavailable)
extension EmptyControlWidgetTemplate : BitwiseCopyable {
}

/// An unstyled matched transition source configuration.
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct EmptyMatchedTransitionSourceConfiguration : MatchedTransitionSourceConfiguration {
}

/// A table row content that doesn't produce any rows.
///
/// You will rarely, if ever, need to create an `EmptyTableRowContent` directly.
/// Instead, `EmptyTableRowContent` represents the absence of a row.
@available(iOS 16.0, macOS 13.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct EmptyTableRowContent<Value> where Value : Identifiable {

    /// The type of value represented by this table row content.
    public typealias TableRowValue = Value

    /// The type of content representing the body of this table row content.
    public typealias TableRowBody = Never
}

@available(iOS 16.0, macOS 13.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension EmptyTableRowContent : TableRowContent {
}

/// An empty widget configuration.
@available(iOS 14.0, macOS 11.0, watchOS 9.0, *)
@available(tvOS, unavailable)
@frozen public struct EmptyWidgetConfiguration : WidgetConfiguration {

    @inlinable public init()

    /// The type of widget configuration representing the body of
    /// this configuration.
    ///
    /// When you create a custom widget, Swift infers this type from your
    /// implementation of the required `body` property.
    @available(iOS 14.0, watchOS 9.0, macOS 11.0, *)
    @available(tvOS, unavailable)
    public typealias Body = Never
}

@available(iOS 14.0, macOS 11.0, watchOS 9.0, *)
@available(tvOS, unavailable)
extension EmptyWidgetConfiguration : Sendable {
}

@available(iOS 14.0, macOS 11.0, watchOS 9.0, *)
@available(tvOS, unavailable)
extension EmptyWidgetConfiguration : BitwiseCopyable {
}

/// A view type that compares itself against its previous value and prevents its
/// child updating if its new value is the same as its old value.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@frozen public struct EquatableView<Content> : View where Content : Equatable, Content : View {

    public var content: Content

    @inlinable public init(content: Content)

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    public typealias Body = Never
}

/// A property wrapper type that retrieves entities from a Core Data persistent
/// store.
///
/// Use a `FetchRequest` property wrapper to declare a ``FetchedResults``
/// property that provides a collection of Core Data managed objects to a
/// SwiftUI view. The request infers the entity type from the `Result`
/// placeholder type that you specify. Condition the request with an optional
/// predicate and sort descriptors. For example, you can create a request to
/// list all `Quake` managed objects that the
/// <doc://com.apple.documentation/documentation/CoreData/loading_and_displaying_a_large_data_feed>
/// sample code project defines to store earthquake data, sorted by their
/// `time` property:
///
///     @FetchRequest(sortDescriptors: [SortDescriptor(\.time, order: .reverse)])
///     private var quakes: FetchedResults<Quake> // Define Quake in your model.
///
/// Alternatively, when you need more flexibility, you can initialize the
/// request with a configured
/// <doc://com.apple.documentation/documentation/CoreData/NSFetchRequest>
/// instance:
///
///     @FetchRequest(fetchRequest: request)
///     private var quakes: FetchedResults<Quake>
///
/// Always declare properties that have a fetch request wrapper as private.
/// This lets the compiler help you avoid accidentally setting
/// the property from the memberwise initializer of the enclosing view.
///
/// The fetch request and its results use the managed object context stored
/// in the environment, which you can access using the
/// ``EnvironmentValues/managedObjectContext`` environment value. To
/// support user interface activity, you typically rely on the
/// <doc://com.apple.documentation/documentation/CoreData/NSPersistentContainer/1640622-viewContext>
/// property of a shared
/// <doc://com.apple.documentation/documentation/CoreData/NSPersistentContainer>
/// instance. For example, you can set a context on your top level content
/// view using a shared container that you define as part of your model:
///
///     ContentView()
///         .environment(
///             \.managedObjectContext,
///             QuakesProvider.shared.container.viewContext)
///
/// When you need to dynamically change the predicate or sort descriptors,
/// access the request's ``FetchRequest/Configuration`` structure.
/// To create a request that groups the fetched results according to a
/// characteristic that they share, use ``SectionedFetchRequest`` instead.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@MainActor @propertyWrapper @preconcurrency public struct FetchRequest<Result> where Result : NSFetchRequestResult {

    /// The fetched results of the fetch request.
    ///
    /// SwiftUI returns the value associated with this property
    /// when you use ``FetchRequest`` as a property wrapper, and then access
    /// the wrapped property by name. For example, consider the following
    /// `quakes` property declaration that fetches a `Quake` type that the
    /// <doc://com.apple.documentation/documentation/CoreData/loading_and_displaying_a_large_data_feed>
    /// sample code project defines:
    ///
    ///     @FetchRequest(fetchRequest: request)
    ///     private var quakes: FetchedResults<Quake>
    ///
    /// You access the request's `wrappedValue`, which contains a
    /// ``FetchedResults`` instance, by referring to the `quakes` property
    /// by name:
    ///
    ///     Text("Found \(quakes.count) earthquakes")
    ///
    /// If you need to separate the request and the result
    /// entities, you can declare `quakes` in two steps by
    /// using the request's `wrappedValue` to obtain the results:
    ///
    ///     var fetchRequest = FetchRequest<Quake>(fetchRequest: request)
    ///     var quakes: FetchedResults<Quake> { fetchRequest.wrappedValue }
    ///
    /// The `wrappedValue` property returns an empty array when there are no
    /// fetched results --- for example, because no entities satisfy the
    /// predicate, or because the data store is empty.
    @MainActor @preconcurrency public var wrappedValue: FetchedResults<Result> { get }

    /// The request's configurable properties.
    ///
    /// You initialize a ``FetchRequest`` with an optional predicate and
    /// sort descriptors, either explicitly or using a configured
    /// <doc://com.apple.documentation/documentation/CoreData/NSFetchRequest>.
    /// Later, you can dynamically update the predicate and sort
    /// parameters using the request's configuration structure.
    ///
    /// You access or bind to a request's configuration components through
    /// properties on the associated ``FetchedResults`` instance.
    ///
    /// ### Configure using a binding
    ///
    /// Get a ``Binding`` to a fetch request's configuration structure
    /// by accessing the request's ``FetchRequest/projectedValue``, which you
    /// do by using the dollar sign (`$`) prefix on the associated
    /// results property. For example, you can create a request for `Quake`
    /// entities --- a managed object type that the
    /// <doc://com.apple.documentation/documentation/CoreData/loading_and_displaying_a_large_data_feed>
    /// sample code project defines --- that initially sorts the results by time:
    ///
    ///     @FetchRequest(sortDescriptors: [SortDescriptor(\.time, order: .reverse)])
    ///     private var quakes: FetchedResults<Quake>
    ///
    /// Then you can bind the request's sort descriptors,
    /// which you access through the `quakes` result, to those
    /// of a ``Table`` instance:
    ///
    ///     Table(quakes, sortOrder: $quakes.sortDescriptors) {
    ///         TableColumn("Place", value: \.place)
    ///         TableColumn("Time", value: \.time) { quake in
    ///             Text(quake.time, style: .time)
    ///         }
    ///     }
    ///
    /// A user who clicks on a table column header initiates the following
    /// sequence of events:
    /// 1. The table updates the sort descriptors through the binding.
    /// 2. The modified sort descriptors reconfigure the request.
    /// 3. The reconfigured request fetches new results.
    /// 4. SwiftUI redraws the table in response to new results.
    ///
    /// ### Set configuration directly
    ///
    /// If you need to access the fetch request's configuration elements
    /// directly, use the ``FetchedResults/nsPredicate`` and
    /// ``FetchedResults/sortDescriptors`` or
    /// ``FetchedResults/nsSortDescriptors`` properties of the
    /// ``FetchedResults`` instance. Continuing the example above, to
    /// enable the user to dynamically update the predicate, declare a
    /// ``State`` property to hold a query string:
    ///
    ///     @State private var query = ""
    ///
    /// Then add an ``View/onChange(of:initial:_:)`` modifier to the
    /// ``Table`` that sets a new predicate any time the query changes:
    ///
    ///     .onChange(of: query) { _, value in
    ///         quakes.nsPredicate = query.isEmpty
    ///             ? nil
    ///             : NSPredicate(format: "place CONTAINS %@", value)
    ///     }
    ///
    /// To give the user control over the string, add a ``TextField`` in your
    /// user interface that's bound to the `query` state:
    ///
    ///     TextField("Filter", text: $query)
    ///
    /// When the user types into the text field, the predicate updates,
    /// the request fetches new results, and SwiftUI redraws the table.
    @available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
    @MainActor @preconcurrency public struct Configuration {

        /// The request's sort descriptors, accessed as reference types.
        ///
        /// Set this configuration value to cause a ``FetchRequest`` to execute
        /// a fetch with a new collection of
        /// <doc://com.apple.documentation/documentation/Foundation/NSSortDescriptor>
        /// instances. If you want to use
        /// <doc://com.apple.documentation/documentation/Foundation/SortDescriptor>
        /// instances, set ``FetchRequest/Configuration/sortDescriptors``
        /// instead.
        ///
        /// Access this value of a ``FetchRequest/Configuration`` structure for
        /// a given request by using the ``FetchedResults/nsSortDescriptors``
        /// property on the associated ``FetchedResults`` instance, either
        /// directly or through a ``Binding``.
        @MainActor @preconcurrency public var nsSortDescriptors: [NSSortDescriptor]

        /// The request's predicate.
        ///
        /// Set this configuration value to cause a ``FetchRequest`` to execute
        /// a fetch with a new predicate.
        ///
        /// Access this value of a ``FetchRequest/Configuration`` structure for
        /// a given request by using the ``FetchedResults/nsPredicate``
        /// property on the associated ``FetchedResults`` instance, either
        /// directly or through a ``Binding``.
        @MainActor @preconcurrency public var nsPredicate: NSPredicate?
    }

    /// A binding to the request's mutable configuration properties.
    ///
    /// SwiftUI returns the value associated with this property when you use
    /// ``FetchRequest`` as a property wrapper on a ``FetchedResults`` instance,
    /// and then access the results with a dollar sign (`$`) prefix. The value
    /// that SwiftUI returns is a ``Binding`` to the request's
    /// ``FetchRequest/Configuration`` structure, which dynamically
    /// configures the request.
    ///
    /// For example, consider the following fetch request for a type that the
    /// <doc://com.apple.documentation/documentation/CoreData/loading_and_displaying_a_large_data_feed>
    /// sample code project defines to store earthquake data, sorted based on
    /// the `time` property:
    ///
    ///     @FetchRequest(sortDescriptors: [SortDescriptor(\.time, order: .reverse)])
    ///     private var quakes: FetchedResults<Quake>
    ///
    /// You can use the projected value to enable a ``Table`` instance to make
    /// updates:
    ///
    ///     Table(quakes, sortOrder: $quakes.sortDescriptors) {
    ///         TableColumn("Place", value: \.place)
    ///         TableColumn("Time", value: \.time) { quake in
    ///             Text(quake.time, style: .time)
    ///         }
    ///     }
    ///
    /// Because you initialize the table using a binding to the descriptors,
    /// the table can modify the sort in response to actions that the user
    /// takes, like clicking a column header.
    @available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
    @MainActor @preconcurrency public var projectedValue: Binding<FetchRequest<Result>.Configuration> { get }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension FetchRequest : DynamicProperty {

    /// Updates the fetched results.
    ///
    /// SwiftUI calls this function before rendering a view's
    /// ``View/body-swift.property`` to ensure the view has the most recent
    /// fetched results.
    @MainActor @preconcurrency public mutating func update()
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension FetchRequest {

    /// Creates a fetch request for a specified entity description, based on a
    /// predicate and sort parameters.
    ///
    /// Use this initializer if you need to explicitly specify the entity type
    /// for the request. If you specify a placeholder `Result` type in the
    /// request declaration, use the
    /// ``init(sortDescriptors:predicate:animation:)`` initializer to
    /// let the request infer the entity type. If you need more control over
    /// the fetch request configuration, use ``init(fetchRequest:animation:)``.
    ///
    /// - Parameters:
    ///   - entity: The description of the Core Data entity to fetch.
    ///   - sortDescriptors: An array of sort descriptors that define the sort
    ///     order of the fetched results.
    ///   - predicate: An
    ///     <doc://com.apple.documentation/documentation/Foundation/NSPredicate>
    ///     instance that defines logical conditions used to filter the fetched
    ///     results.
    ///   - animation: The animation to use for user interface changes that
    ///     result from changes to the fetched results.
    @MainActor @preconcurrency public init(entity: NSEntityDescription, sortDescriptors: [NSSortDescriptor], predicate: NSPredicate? = nil, animation: Animation? = nil)

    /// Creates a fully configured fetch request that uses the specified
    /// animation when updating results.
    ///
    /// Use this initializer when you want to configure a fetch
    /// request with more than a predicate and sort descriptors.
    /// For example, you can vend a request from a `Quake` managed object
    /// that the
    /// <doc://com.apple.documentation/documentation/CoreData/loading_and_displaying_a_large_data_feed>
    /// sample code project defines to store earthquake data.
    /// Limit the number of results to `1000` by setting a
    /// <doc://com.apple.documentation/documentation/CoreData/NSFetchRequest/1506622-fetchLimit>
    /// for the request:
    ///
    ///     extension Quake {
    ///         var request: NSFetchRequest<Quake> {
    ///             let request = NSFetchRequest<Quake>(entityName: "Quake")
    ///             request.sortDescriptors = [
    ///                 NSSortDescriptor(
    ///                     keyPath: \Quake.time,
    ///                     ascending: true)]
    ///             request.fetchLimit = 1000
    ///             return request
    ///         }
    ///     }
    ///
    /// Use the request to define a ``FetchedResults`` property:
    ///
    ///     @FetchRequest(fetchRequest: Quake.request)
    ///     private var quakes: FetchedResults<Quake>
    ///
    /// If you only need to configure the request's predicate and sort
    /// descriptors, use ``init(sortDescriptors:predicate:animation:)``
    /// instead. If you need to specify a ``Transaction`` rather than an
    /// optional ``Animation``, use ``init(fetchRequest:transaction:)``.
    ///
    /// - Parameters:
    ///   - fetchRequest: An
    ///     <doc://com.apple.documentation/documentation/CoreData/NSFetchRequest>
    ///     instance that describes the search criteria for retrieving data
    ///     from the persistent store.
    ///   - animation: The animation to use for user interface changes that
    ///     result from changes to the fetched results.
    @MainActor @preconcurrency public init(fetchRequest: NSFetchRequest<Result>, animation: Animation? = nil)

    /// Creates a fully configured fetch request that uses the specified
    /// transaction when updating results.
    ///
    /// Use this initializer if you need a fetch request with updates that
    /// affect the user interface based on a ``Transaction``. Otherwise, use
    /// ``init(fetchRequest:animation:)``.
    ///
    /// - Parameters:
    ///   - fetchRequest: An
    ///     <doc://com.apple.documentation/documentation/CoreData/NSFetchRequest>
    ///     instance that describes the search criteria for retrieving data
    ///     from the persistent store.
    ///   - transaction: A transaction to use for user interface changes that
    ///     result from changes to the fetched results.
    @MainActor @preconcurrency public init(fetchRequest: NSFetchRequest<Result>, transaction: Transaction)
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension FetchRequest where Result : NSManagedObject {

    /// Creates a fetch request based on a predicate and reference type sort
    /// parameters.
    ///
    /// The request gets the entity type from the `Result` instance by calling
    /// that managed object's
    /// <doc://com.apple.documentation/documentation/CoreData/NSManagedObject/1640588-entity>
    /// type method. If you need to specify the entity type explicitly, use the
    /// ``init(entity:sortDescriptors:predicate:animation:)`` initializer
    /// instead. If you need more control over the fetch request configuration,
    /// use ``init(fetchRequest:animation:)``.
    ///
    /// - Parameters:
    ///   - sortDescriptors: An array of sort descriptors that define the sort
    ///     order of the fetched results.
    ///   - predicate: An
    ///     <doc://com.apple.documentation/documentation/Foundation/NSPredicate>
    ///     instance that defines logical conditions used to filter the fetched
    ///     results.
    ///   - animation: The animation to use for user interface changes that
    ///     result from changes to the fetched results.
    @MainActor @preconcurrency public init(sortDescriptors: [NSSortDescriptor], predicate: NSPredicate? = nil, animation: Animation? = nil)
}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension FetchRequest where Result : NSManagedObject {

    /// Creates a fetch request based on a predicate and value type sort
    /// parameters.
    ///
    /// The request gets the entity type from the `Result` instance by calling
    /// that managed object's
    /// <doc://com.apple.documentation/documentation/CoreData/NSManagedObject/1640588-entity>
    /// type method. If you need to specify the entity type explicitly, use the
    /// ``init(entity:sortDescriptors:predicate:animation:)`` initializer
    /// instead. If you need more control over the fetch request configuration,
    /// use ``init(fetchRequest:animation:)``.
    ///
    /// - Parameters:
    ///   - sortDescriptors: An array of sort descriptors that define the sort
    ///     order of the fetched results.
    ///   - predicate: An
    ///     <doc://com.apple.documentation/documentation/Foundation/NSPredicate>
    ///     instance that defines logical conditions used to filter the fetched
    ///     results.
    ///   - animation: The animation to use for user interface changes that
    ///     result from changes to the fetched results.
    @MainActor @preconcurrency public init(sortDescriptors: [SortDescriptor<Result>], predicate: NSPredicate? = nil, animation: Animation? = nil)
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension FetchRequest : Sendable {
}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension FetchRequest.Configuration where Result : NSManagedObject {

    /// The request's sort descriptors, accessed as value types.
    ///
    /// Set this configuration value to cause a ``FetchRequest`` to execute a
    /// fetch with a new collection of
    /// <doc://com.apple.documentation/documentation/Foundation/SortDescriptor>
    /// instances. If you want to use
    /// <doc://com.apple.documentation/documentation/Foundation/NSSortDescriptor>
    /// instances, set ``FetchRequest/Configuration/nsSortDescriptors`` instead.
    ///
    /// Access this value of a ``FetchRequest/Configuration`` structure for
    /// a given request by using the ``FetchedResults/sortDescriptors``
    /// property on the associated ``FetchedResults`` instance, either
    /// directly or through a ``Binding``.
    @MainActor @preconcurrency public var sortDescriptors: [SortDescriptor<Result>]
}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension FetchRequest.Configuration : Sendable {
}

/// A collection of results retrieved from a Core Data store.
///
/// Use a `FetchedResults` instance to show or edit Core Data managed objects in
/// your app's user interface. You request a particular set of results by
/// specifying a `Result` type as the entity type, and annotating the fetched
/// results property declaration with a ``FetchRequest`` property wrapper.
/// For example, you can create a request to list all `Quake` managed objects
/// that the
/// <doc://com.apple.documentation/documentation/CoreData/loading_and_displaying_a_large_data_feed>
/// sample code project defines to store earthquake data, sorted by their
/// `time` property:
///
///     @FetchRequest(sortDescriptors: [SortDescriptor(\.time, order: .reverse)])
///     private var quakes: FetchedResults<Quake>
///
/// The results instance conforms to
/// <doc://com.apple.documentation/documentation/Swift/RandomAccessCollection>,
/// so you access it like any other collection. For example, you can create
/// a ``List`` that iterates over all the results:
///
///     List(quakes) { quake in
///         NavigationLink(destination: QuakeDetail(quake: quake)) {
///             QuakeRow(quake: quake)
///         }
///     }
///
/// When you need to dynamically change the request's predicate or sort
/// descriptors, set the result instance's ``nsPredicate`` and
/// ``sortDescriptors`` or ``nsSortDescriptors`` properties, respectively.
///
/// The fetch request and its results use the managed object context stored
/// in the environment, which you can access using the
/// ``EnvironmentValues/managedObjectContext`` environment value. To
/// support user interface activity, you typically rely on the
/// <doc://com.apple.documentation/documentation/CoreData/NSPersistentContainer/1640622-viewContext>
/// property of a shared
/// <doc://com.apple.documentation/documentation/CoreData/NSPersistentContainer>
/// instance. For example, you can set a context on your top level content
/// view using a container that you define as part of your model:
///
///     ContentView()
///         .environment(
///             \.managedObjectContext,
///             QuakesProvider.shared.container.viewContext)
///
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@MainActor @preconcurrency public struct FetchedResults<Result> : @preconcurrency RandomAccessCollection where Result : NSFetchRequestResult {

    /// The request's sort descriptors, accessed as reference types.
    ///
    /// Set this value to cause the associated ``FetchRequest`` to execute
    /// a fetch with a new collection of
    /// <doc://com.apple.documentation/documentation/Foundation/NSSortDescriptor>
    /// instances.
    /// The order of managed objects stored in the results collection may change
    /// as a result.
    ///
    /// If you want to use
    /// <doc://com.apple.documentation/documentation/Foundation/SortDescriptor>
    /// instances, set ``FetchedResults/sortDescriptors`` instead.
    @available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
    @MainActor @preconcurrency public var nsSortDescriptors: [NSSortDescriptor] { get nonmutating set }

    /// The request's predicate.
    ///
    /// Set this value to cause the associated ``FetchRequest`` to execute a
    /// fetch with a new predicate, producing an updated collection of results.
    @available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
    @MainActor @preconcurrency public var nsPredicate: NSPredicate? { get nonmutating set }

    /// The index of the first entity in the results collection.
    nonisolated public var startIndex: Int { get }

    /// The index that's one greater than the last valid subscript argument.
    @MainActor @preconcurrency public var endIndex: Int { get }

    /// Gets the entity at the specified index.
    @MainActor @preconcurrency public subscript(position: Int) -> Result { get }

    /// A type representing the sequence's elements.
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    public typealias Element = Result

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    public typealias Index = Int

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    public typealias Indices = Range<Int>

    /// A type that provides the collection's iteration interface and
    /// encapsulates its iteration state.
    ///
    /// By default, a collection conforms to the `Sequence` protocol by
    /// supplying `IndexingIterator` as its associated `Iterator`
    /// type.
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    public typealias Iterator = IndexingIterator<FetchedResults<Result>>

    /// A collection representing a contiguous subrange of this collection's
    /// elements. The subsequence shares indices with the original collection.
    ///
    /// The default subsequence type for collections that don't define their own
    /// is `Slice`.
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    public typealias SubSequence = Slice<FetchedResults<Result>>
}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension FetchedResults where Result : NSManagedObject {

    /// The request's sort descriptors, accessed as value types.
    ///
    /// Set this value to cause the associated ``FetchRequest`` to execute a
    /// fetch with a new collection of
    /// <doc://com.apple.documentation/documentation/Foundation/SortDescriptor>
    /// instances.
    /// The order of entities stored in the results collection may change
    /// as a result.
    ///
    /// If you want to use
    /// <doc://com.apple.documentation/documentation/Foundation/NSSortDescriptor>
    /// instances, set ``FetchedResults/nsSortDescriptors`` instead.
    @MainActor @preconcurrency public var sortDescriptors: [SortDescriptor<Result>] { get nonmutating set }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension FetchedResults : Sendable {
}

/// The way that file dialogs present the file system.
///
/// Apply the options using the ``View/fileDialogBrowserOptions(_:)`` modifier.
@available(iOS 17.0, macOS 14.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct FileDialogBrowserOptions : OptionSet {

    /// The corresponding value of the raw type.
    ///
    /// A new instance initialized with `rawValue` will be equivalent to this
    /// instance. For example:
    ///
    ///     enum PaperSize: String {
    ///         case A4, A5, Letter, Legal
    ///     }
    ///
    ///     let selectedSize = PaperSize.Letter
    ///     print(selectedSize.rawValue)
    ///     // Prints "Letter"
    ///
    ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
    ///     // Prints "true"
    public let rawValue: Int

    /// Creates a new option set from the given raw value.
    ///
    /// This initializer always succeeds, even if the value passed as `rawValue`
    /// exceeds the static properties declared as part of the option set. This
    /// example creates an instance of `ShippingOptions` with a raw value beyond
    /// the highest element, with a bit mask that effectively contains all the
    /// declared static members.
    ///
    ///     let extraOptions = ShippingOptions(rawValue: 255)
    ///     print(extraOptions.isStrictSuperset(of: .all))
    ///     // Prints "true"
    ///
    /// - Parameter rawValue: The raw value of the option set to create. Each bit
    ///   of `rawValue` potentially represents an element of the option set,
    ///   though raw values may include bits that are not defined as distinct
    ///   values of the `OptionSet` type.
    public init(rawValue: Int)

    /// Allows enumerating packages contents in contrast to the default behavior
    /// when packages are represented flatly, similar to files.
    public static let enumeratePackages: FileDialogBrowserOptions

    /// Displays the files that are hidden by default.
    public static let includeHiddenFiles: FileDialogBrowserOptions

    /// On iOS, configures the `fileExporter`, `fileImporter`,
    /// or `fileMover` to show or hide file extensions.
    /// Default behavior is to hide them.
    /// On macOS, this option has no effect.
    public static let displayFileExtensions: FileDialogBrowserOptions

    /// The type of the elements of an array literal.
    @available(iOS 17.0, macOS 14.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias ArrayLiteralElement = FileDialogBrowserOptions

    /// The element type of the option set.
    ///
    /// To inherit all the default implementations from the `OptionSet` protocol,
    /// the `Element` type must be `Self`, the default.
    @available(iOS 17.0, macOS 14.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias Element = FileDialogBrowserOptions

    /// The raw type that can be used to represent all values of the conforming
    /// type.
    ///
    /// Every distinct value of the conforming type has a corresponding unique
    /// value of the `RawValue` type, but there may be values of the `RawValue`
    /// type that don't have a corresponding value of the conforming type.
    @available(iOS 17.0, macOS 14.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias RawValue = Int
}

@available(iOS 17.0, macOS 14.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension FileDialogBrowserOptions : Sendable {
}

/// A type that you use to serialize documents to and from file.
///
/// To store a document as a value type --- like a structure --- create a type
/// that conforms to the `FileDocument` protocol and implement the
/// required methods and properties. Your implementation:
///
/// * Provides a list of the content types that the document can read from and
///   write to by defining ``readableContentTypes``. If the list of content
///   types that the document can write to is different from those that it reads
///   from, you can optionally also define ``writableContentTypes-2opfc``.
/// * Loads documents from file in the ``init(configuration:)`` initializer.
/// * Stores documents to file by serializing their content in the
///   ``fileWrapper(configuration:)`` method.
///
/// > Important: If you store your document as a reference type --- like a
///   class --- use ``ReferenceFileDocument`` instead.
///
/// Ensure that types that conform to this protocol are ``Sendable``.
/// In particular, SwiftUI calls the protocol's methods from different isolation domains.
/// Don't perform serialization and deserialization on ``MainActor``.
@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@preconcurrency public protocol FileDocument : Sendable {

    /// The file and data types that the document reads from.
    ///
    /// Define this list to indicate the content types that your document can
    /// read. By default, SwiftUI assumes that your document can also write
    /// the same set of content types. If you need to indicate a different set
    /// of types for writing files, define the ``writableContentTypes-2opfc``
    /// property in addition to this property.
    static var readableContentTypes: [UTType] { get }

    /// The file types that the document supports saving or exporting to.
    ///
    /// By default, SwiftUI assumes that your document reads and writes the
    /// same set of content types. Only define this property if you need to
    /// indicate a different set of types for writing files. Otherwise, the
    /// default implementation of this property returns the list that you
    /// specify in your implementation of ``readableContentTypes``.
    static var writableContentTypes: [UTType] { get }

    /// Creates a document and initializes it with the contents of a file.
    ///
    /// SwiftUI calls this initializer when someone opens a file type
    /// that matches one of those that your document type supports.
    /// Use the ``FileDocumentReadConfiguration/file`` property of the
    /// `configuration` input to get document's data. Deserialize the data,
    /// and store it in your document's data structure:
    ///
    ///     init(configuration: ReadConfiguration) throws {
    ///         guard let data = configuration.file.regularFileContents
    ///         else { /* Throw an error. */ }
    ///         model = try JSONDecoder().decode(Model.self, from: data)
    ///     }
    ///
    /// The above example assumes that you define `Model` to contain
    /// the document's data, that `Model` conforms to the
    /// <doc://com.apple.documentation/documentation/Swift/Codable> protocol,
    /// and that you store a `model` property of that type inside your document.
    ///
    /// > Note: SwiftUI calls this method on a background thread. Don't
    ///   make user interface changes from that thread.
    ///
    /// - Parameter configuration: Information about the file that you read
    ///   document data from.
    init(configuration: Self.ReadConfiguration) throws

    /// The configuration for reading document contents.
    ///
    /// This type is an alias for ``FileDocumentReadConfiguration``, which
    /// contains a content type and a file wrapper that you use to access the
    /// contents of a document file. You get a value of this type as an input
    /// to the ``init(configuration:)`` initializer. Use it to load a
    /// document from a file.
    typealias ReadConfiguration = FileDocumentReadConfiguration

    /// Serializes a document snapshot to a file wrapper.
    ///
    /// To store a document --- for example, in response to a Save command ---
    /// SwiftUI calls this method. Use it to serialize the document's data and
    /// create or modify a file wrapper with the serialized data:
    ///
    ///     func fileWrapper(configuration: WriteConfiguration) throws -> FileWrapper {
    ///         let data = try JSONEncoder().encode(model)
    ///         return FileWrapper(regularFileWithContents: data)
    ///     }
    ///
    /// > Note: SwiftUI calls this method on a background thread. Don't
    ///   make user interface changes from that thread.
    ///
    /// - Parameters:
    ///   - configuration: Information about a file that already exists for the
    ///     document, if any.
    ///
    /// - Returns: The destination to serialize the document contents to. The
    ///   value can be a newly created
    ///   <doc://com.apple.documentation/documentation/Foundation/FileWrapper>
    ///   or an update of the one provided in the `configuration` input.
    func fileWrapper(configuration: Self.WriteConfiguration) throws -> FileWrapper

    /// The configuration for writing document contents.
    ///
    /// This type is an alias for ``FileDocumentWriteConfiguration``, which
    /// contains a content type and a file wrapper that you use to access the
    /// contents of a document file, if one already exists. You get a value
    /// of this type as an input to the ``fileWrapper(configuration:)``
    /// method.
    typealias WriteConfiguration = FileDocumentWriteConfiguration
}

@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension FileDocument {

    /// The file types that the document supports saving or exporting to.
    ///
    /// By default, SwiftUI assumes that your document reads and writes the
    /// same set of content types. Only define this property if you need to
    /// indicate a different set of types for writing files. Otherwise, the
    /// default implementation of this property returns the list that you
    /// specify in your implementation of ``readableContentTypes``.
    public static var writableContentTypes: [UTType] { get }
}

/// The properties of an open file document.
///
/// You receive an instance of this structure when you create a
/// ``DocumentGroup`` with a value file type. Use it to access the
/// document in your viewer or editor.
@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct FileDocumentConfiguration<Document> where Document : FileDocument {

    /// The current document model.
    ///
    /// Setting a new value marks the document as having changes for later
    /// saving and registers an undo action to restore the model to its
    /// previous value.
    ///
    /// If ``isEditable`` is `false`, setting a new value has no effect
    /// because the document is in viewing mode.
    @Binding public var document: Document { get nonmutating set }

    public var $document: Binding<Document> { get }

    /// The URL of the open file document.
    public var fileURL: URL?

    /// A Boolean that indicates whether you can edit the document.
    ///
    /// This value is `false` if the document is in viewing mode, or if the
    /// file is not writable.
    public var isEditable: Bool
}

/// The configuration for reading file contents.
@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct FileDocumentReadConfiguration {

    /// The expected uniform type of the file contents.
    public let contentType: UTType

    /// The file wrapper containing the document content.
    public let file: FileWrapper
}

/// The configuration for serializing file contents.
@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct FileDocumentWriteConfiguration {

    /// The expected uniform type of the file contents.
    public let contentType: UTType

    /// The file wrapper containing the current document content.
    /// `nil` if the document is unsaved.
    public let existingFile: FileWrapper?
}

/// A shape style that displays one of the overlay fills.
@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
@frozen public struct FillShapeStyle : ShapeStyle {

    /// An overlay fill style for filling shapes.
    ///
    /// This shape style is appropriate for items situated on top of an existing
    /// background color. It incorporates transparency to allow the background
    /// color to show through.
    ///
    /// Use the primary version of this style to fill thin or small shapes, such
    /// as the track of a slider.
    /// Use the secondary version of this style to fill medium-size shapes, such
    /// as the background of a switch.
    /// Use the tertiary version of this style to fill large shapes, such as
    /// input fields, search bars, or buttons.
    /// Use the quaternary version of this style to fill large areas that
    /// contain complex content, such as an expanded table cell.
    public init()

    /// The type of shape style this will resolve to.
    ///
    /// When you create a custom shape style, Swift infers this type
    /// from your implementation of the required `resolve` function.
    @available(iOS 17.0, tvOS 17.0, watchOS 10.0, macOS 14.0, *)
    public typealias Resolved = Never
}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension FillShapeStyle : BitwiseCopyable {
}

/// The size of the presentation is dictated by the ideal size of the content.
///
/// The presentation is sized by proposing `nil` in the horizontal and
/// vertical dimensions.
///
/// - Seealso: ``PresentationSizing/fitted``
@available(iOS 18.0, macOS 15.0, tvOS 18.0, visionOS 2.0, watchOS 11.0, *)
public struct FittedPresentationSizing : PresentationSizing, Sendable {

    public func proposedSize(for root: PresentationSizingRoot, context: PresentationSizingContext) -> ProposedViewSize
}

/// Values describe different focus interactions that a view can support.
@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
public struct FocusInteractions : OptionSet, Sendable {

    /// The view has a primary action that can be activated via focus gestures.
    ///
    /// On macOS and iOS, focus-driven activation interactions are only possible
    /// when all-controls keyboard navigation is enabled. On tvOS and watchOS,
    /// focus-driven activation interactions are always possible.
    public static let activate: FocusInteractions

    /// The view captures input from non-spatial sources like a keyboard or
    /// Digital Crown.
    ///
    /// Views that support focus-driven editing interactions become focused when
    /// the user taps or clicks on them, or when the user issues a focus
    /// movement command.
    public static let edit: FocusInteractions

    /// The view supports whatever focus-driven interactions are commonly
    /// expected for interactive content on the current platform.
    public static var automatic: FocusInteractions { get }

    /// The corresponding value of the raw type.
    ///
    /// A new instance initialized with `rawValue` will be equivalent to this
    /// instance. For example:
    ///
    ///     enum PaperSize: String {
    ///         case A4, A5, Letter, Legal
    ///     }
    ///
    ///     let selectedSize = PaperSize.Letter
    ///     print(selectedSize.rawValue)
    ///     // Prints "Letter"
    ///
    ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
    ///     // Prints "true"
    public var rawValue: Int

    /// Creates a new option set from the given raw value.
    ///
    /// This initializer always succeeds, even if the value passed as `rawValue`
    /// exceeds the static properties declared as part of the option set. This
    /// example creates an instance of `ShippingOptions` with a raw value beyond
    /// the highest element, with a bit mask that effectively contains all the
    /// declared static members.
    ///
    ///     let extraOptions = ShippingOptions(rawValue: 255)
    ///     print(extraOptions.isStrictSuperset(of: .all))
    ///     // Prints "true"
    ///
    /// - Parameter rawValue: The raw value of the option set to create. Each bit
    ///   of `rawValue` potentially represents an element of the option set,
    ///   though raw values may include bits that are not defined as distinct
    ///   values of the `OptionSet` type.
    public init(rawValue: Int)

    /// The type of the elements of an array literal.
    @available(iOS 17.0, tvOS 17.0, watchOS 10.0, macOS 14.0, *)
    public typealias ArrayLiteralElement = FocusInteractions

    /// The element type of the option set.
    ///
    /// To inherit all the default implementations from the `OptionSet` protocol,
    /// the `Element` type must be `Self`, the default.
    @available(iOS 17.0, tvOS 17.0, watchOS 10.0, macOS 14.0, *)
    public typealias Element = FocusInteractions

    /// The raw type that can be used to represent all values of the conforming
    /// type.
    ///
    /// Every distinct value of the conforming type has a corresponding unique
    /// value of the `RawValue` type, but there may be values of the `RawValue`
    /// type that don't have a corresponding value of the conforming type.
    @available(iOS 17.0, tvOS 17.0, watchOS 10.0, macOS 14.0, *)
    public typealias RawValue = Int
}

/// A property wrapper type that can read and write a value that SwiftUI updates
/// as the placement of focus within the scene changes.
///
/// Use this property wrapper in conjunction with ``View/focused(_:equals:)``
/// and ``View/focused(_:)`` to
/// describe views whose appearance and contents relate to the location of
/// focus in the scene. When focus enters the modified view, the wrapped value
/// of this property updates to match a given prototype value. Similarly, when
/// focus leaves, the wrapped value of this property resets to `nil`
/// or `false`. Setting the property's value programmatically has the reverse
/// effect, causing focus to move to the view associated with the
/// updated value.
///
/// In the following example of a simple login screen, when the user presses the
/// Sign In button and one of the fields is still empty, focus moves to that
/// field. Otherwise, the sign-in process proceeds.
///
///     struct LoginForm {
///         enum Field: Hashable {
///             case username
///             case password
///         }
///
///         @State private var username = ""
///         @State private var password = ""
///         @FocusState private var focusedField: Field?
///
///         var body: some View {
///             Form {
///                 TextField("Username", text: $username)
///                     .focused($focusedField, equals: .username)
///
///                 SecureField("Password", text: $password)
///                     .focused($focusedField, equals: .password)
///
///                 Button("Sign In") {
///                     if username.isEmpty {
///                         focusedField = .username
///                     } else if password.isEmpty {
///                         focusedField = .password
///                     } else {
///                         handleLogin(username, password)
///                     }
///                 }
///             }
///         }
///     }
///
/// To allow for cases where focus is completely absent from a view tree, the
/// wrapped value must be either an optional or a Boolean. Set the focus binding
/// to `false` or `nil` as appropriate to remove focus from all bound fields.
/// You can also use this to remove focus from a ``TextField`` and thereby
/// dismiss the keyboard.
///
/// ### Avoid ambiguous focus bindings
///
/// The same view can have multiple focus bindings. In the following example,
/// setting `focusedField` to either `name` or `fullName` causes the field
/// to receive focus:
///
///     struct ContentView: View {
///         enum Field: Hashable {
///             case name
///             case fullName
///         }
///         @FocusState private var focusedField: Field?
///
///         var body: some View {
///             TextField("Full Name", ...)
///                 .focused($focusedField, equals: .name)
///                 .focused($focusedField, equals: .fullName)
///         }
///     }
///
/// On the other hand, binding the same value to two views is ambiguous. In
/// the following example, two separate fields bind focus to the `name` value:
///
///     struct ContentView: View {
///         enum Field: Hashable {
///             case name
///             case fullName
///         }
///         @FocusState private var focusedField: Field?
///
///         var body: some View {
///             TextField("Name", ...)
///                 .focused($focusedField, equals: .name)
///             TextField("Full Name", ...)
///                 .focused($focusedField, equals: .name) // incorrect re-use of .name
///         }
///     }
///
/// If the user moves focus to either field, the `focusedField` binding updates
/// to `name`. However, if the app programmatically sets the value to `name`,
/// SwiftUI chooses the first candidate, which in this case is the "Name"
/// field. SwiftUI also emits a runtime warning in this case, since the repeated
/// binding is likely a programmer error.
///
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
@frozen @propertyWrapper public struct FocusState<Value> : DynamicProperty where Value : Hashable {

    /// A property wrapper type that can read and write a value that indicates
    /// the current focus location.
    @frozen @propertyWrapper public struct Binding {

        /// The underlying value referenced by the bound property.
        public var wrappedValue: Value { get nonmutating set }

        /// A projection of the binding value that returns a binding.
        ///
        /// Use the projected value to pass a binding value down a view
        /// hierarchy.
        public var projectedValue: FocusState<Value>.Binding { get }
    }

    /// The current state value, taking into account whatever bindings might be
    /// in effect due to the current location of focus.
    ///
    /// When focus is not in any view that is bound to this state, the wrapped
    /// value will be `nil` (for optional-typed state) or `false` (for `Bool`-
    /// typed state).
    public var wrappedValue: Value { get nonmutating set }

    /// A projection of the focus state value that returns a binding.
    ///
    /// When focus is outside any view that is bound to this state, the wrapped
    /// value is `nil` for optional-typed state or `false` for Boolean state.
    ///
    /// In the following example of a simple navigation sidebar, when the user
    /// presses the Filter Sidebar Contents button, focus moves to the sidebar's
    /// filter text field. Conversely, if the user moves focus to the sidebar's
    /// filter manually, then the value of `isFiltering` automatically
    /// becomes `true`, and the sidebar view updates.
    ///
    ///     struct Sidebar: View {
    ///         @State private var filterText = ""
    ///         @FocusState private var isFiltering: Bool
    ///
    ///         var body: some View {
    ///             VStack {
    ///                 Button("Filter Sidebar Contents") {
    ///                     isFiltering = true
    ///                 }
    ///
    ///                 TextField("Filter", text: $filterText)
    ///                     .focused($isFiltering)
    ///             }
    ///         }
    ///     }
    public var projectedValue: FocusState<Value>.Binding { get }

    /// Creates a focus state that binds to a Boolean.
    public init() where Value == Bool

    /// Creates a focus state that binds to an optional type.
    public init<T>() where Value == T?, T : Hashable
}

/// A convenience property wrapper for observing and automatically unwrapping
/// state bindings from the focused view or one of its ancestors.
///
/// If multiple views publish bindings using the same key, the wrapped property
/// will reflect the value of the binding from the view closest to focus.
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
@propertyWrapper public struct FocusedBinding<Value> : DynamicProperty {

    /// A new property wrapper for the given key path.
    ///
    /// The value of the property wrapper is updated dynamically as focus
    /// changes and different published bindings go in and out of scope.
    ///
    /// - Parameter keyPath: The key path for the focus value to read.
    public init(_ keyPath: KeyPath<FocusedValues, Binding<Value>?>)

    /// The unwrapped value for the focus key given the current scope and state
    /// of the focused view hierarchy.
    @inlinable public var wrappedValue: Value? { get nonmutating set }

    /// A binding to the optional value.
    ///
    /// The unwrapped value is `nil` when no focused view hierarchy has
    /// published a corresponding binding.
    public var projectedValue: Binding<Value?> { get }
}

/// A property wrapper type for an observable object supplied by the focused
/// view or one of its ancestors.
///
/// Focused objects invalidate the current view whenever the observable object
/// changes. If multiple views publish a focused object using the same key, the
/// wrapped property will reflect the object that's closest to the focused view.
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
@MainActor @frozen @propertyWrapper @preconcurrency public struct FocusedObject<ObjectType> : DynamicProperty where ObjectType : ObservableObject {

    /// A wrapper around the underlying focused object that can create bindings
    /// to its properties using dynamic member lookup.
    @MainActor @preconcurrency @dynamicMemberLookup @frozen public struct Wrapper {

        /// Returns a binding to the value of a given key path.
        ///
        /// - Parameter keyPath: A key path to a specific value on the
        ///   wrapped object.
        /// - Returns: A new binding.
        @MainActor @preconcurrency public subscript<T>(dynamicMember keyPath: ReferenceWritableKeyPath<ObjectType, T>) -> Binding<T> { get }
    }

    /// The underlying value referenced by the focused object.
    ///
    /// This property provides primary access to the value's data. However, you
    /// don't access `wrappedValue` directly. Instead, you use the property
    /// variable created with the ``FocusedObject`` attribute.
    ///
    /// When a mutable value changes, the new value is immediately available.
    /// However, a view displaying the value is updated asynchronously and may
    /// not show the new value immediately.
    @MainActor @inlinable @preconcurrency public var wrappedValue: ObjectType? { get }

    /// A projection of the focused object that creates bindings to its
    /// properties using dynamic member lookup.
    ///
    /// Use the projected value to pass a focused object down a view hierarchy.
    @MainActor @preconcurrency public var projectedValue: FocusedObject<ObjectType>.Wrapper? { get }

    /// Creates a focused object.
    @MainActor @preconcurrency public init()
}

/// A property wrapper for observing values from the focused view or one of its
/// ancestors.
///
/// If multiple views publish values using the same key, the wrapped property
///  will reflect the value from the view closest to focus.
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
@propertyWrapper public struct FocusedValue<Value> : DynamicProperty {

    /// A new property wrapper for the given key path.
    ///
    /// The value of the property wrapper is updated dynamically as focus
    /// changes and different published values go in and out of scope.
    ///
    /// - Parameter keyPath: The key path for the focus value to read.
    public init(_ keyPath: KeyPath<FocusedValues, Value?>)

    /// The value for the focus key given the current scope and state of the
    /// focused view hierarchy.
    ///
    /// Returns `nil` when nothing in the focused view hierarchy exports a
    /// value.
    @inlinable public var wrappedValue: Value? { get }
}

extension FocusedValue {

    /// A new property wrapper for the given object type.
    ///
    /// Reads the focused value of the given object type.
    ///
    /// - Important: This initializer only accepts objects conforming to the
    ///   `Observable` protocol. For reading environment objects that conform to
    ///   `ObservableObject`, use `FocusedObject`, instead.
    ///
    /// To set the focused value that is read by this, use the `focusedValue(_:)` view modifier.
    ///
    /// - Parameter objectType: The type of object to read the focus value for.
    @available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
    public init(_ objectType: Value.Type) where Value : AnyObject, Value : Observable
}

/// A protocol for identifier types used when publishing and observing focused
/// values.
///
/// Unlike ``EnvironmentKey``, `FocusedValueKey` has no default value
/// requirement, because the default value for a key is always `nil`.
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public protocol FocusedValueKey {

    associatedtype Value
}

/// A collection of state exported by the focused view and its ancestors.
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public struct FocusedValues {

    /// Reads and writes values associated with a given focused value key.
    public subscript<Key>(key: Key.Type) -> Key.Value? where Key : FocusedValueKey
}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension FocusedValues : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: FocusedValues, rhs: FocusedValues) -> Bool
}

/// A collection which allows a view to be treated as a collection of its
/// sections in a for each loop.
///
/// You don't use this type directly. Instead SwiftUI creates this type on
/// your behalf.
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct ForEachSectionCollection<Content> : RandomAccessCollection where Content : View {

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: Int { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.firstIndex(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: Int { get }

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    ///
    /// - Complexity: O(1)
    public subscript(index: Int) -> SectionConfiguration { get }

    /// A type representing the sequence's elements.
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias Element = SectionConfiguration

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias Index = Int

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias Indices = Range<Int>

    /// A type that provides the collection's iteration interface and
    /// encapsulates its iteration state.
    ///
    /// By default, a collection conforms to the `Sequence` protocol by
    /// supplying `IndexingIterator` as its associated `Iterator`
    /// type.
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias Iterator = IndexingIterator<ForEachSectionCollection<Content>>

    /// A collection representing a contiguous subrange of this collection's
    /// elements. The subsequence shares indices with the original collection.
    ///
    /// The default subsequence type for collections that don't define their own
    /// is `Slice`.
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias SubSequence = Slice<ForEachSectionCollection<Content>>
}

/// A collection which allows a view to be treated as a collection of its
/// subviews in a for each loop.
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct ForEachSubviewCollection<Content> : RandomAccessCollection where Content : View {

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: Int { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.firstIndex(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: Int { get }

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    ///
    /// - Complexity: O(1)
    public subscript(index: Int) -> Subview { get }

    /// A type representing the sequence's elements.
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias Element = Subview

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias Index = Int

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias Indices = Range<Int>

    /// A type that provides the collection's iteration interface and
    /// encapsulates its iteration state.
    ///
    /// By default, a collection conforms to the `Sequence` protocol by
    /// supplying `IndexingIterator` as its associated `Iterator`
    /// type.
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias Iterator = IndexingIterator<ForEachSubviewCollection<Content>>

    /// A collection representing a contiguous subrange of this collection's
    /// elements. The subsequence shares indices with the original collection.
    ///
    /// The default subsequence type for collections that don't define their own
    /// is `Slice`.
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias SubSequence = Slice<ForEachSubviewCollection<Content>>
}

/// A container for grouping controls used for data entry, such as in settings
/// or inspectors.
///
/// SwiftUI applies platform-appropriate styling to views contained inside a
/// form, to group them together. Form-specific styling applies to
/// things like buttons, toggles, labels, lists, and more. Keep in mind that
/// these stylings may be platform-specific. For example, forms apppear as
/// grouped lists on iOS, and as aligned vertical stacks on macOS.
///
/// The following example shows a simple data entry form on iOS, grouped into
/// two sections. The supporting types (`NotifyMeAboutType` and
/// `ProfileImageSize`) and state variables (`notifyMeAbout`, `profileImageSize`,
/// `playNotificationSounds`, and `sendReadReceipts`) are omitted for
/// simplicity.
///
///     var body: some View {
///         NavigationView {
///             Form {
///                 Section(header: Text("Notifications")) {
///                     Picker("Notify Me About", selection: $notifyMeAbout) {
///                         Text("Direct Messages").tag(NotifyMeAboutType.directMessages)
///                         Text("Mentions").tag(NotifyMeAboutType.mentions)
///                         Text("Anything").tag(NotifyMeAboutType.anything)
///                     }
///                     Toggle("Play notification sounds", isOn: $playNotificationSounds)
///                     Toggle("Send read receipts", isOn: $sendReadReceipts)
///                 }
///                 Section(header: Text("User Profiles")) {
///                     Picker("Profile Image Size", selection: $profileImageSize) {
///                         Text("Large").tag(ProfileImageSize.large)
///                         Text("Medium").tag(ProfileImageSize.medium)
///                         Text("Small").tag(ProfileImageSize.small)
///                     }
///                     Button("Clear Image Cache") {}
///                 }
///             }
///         }
///     }
///
///
/// ![A form on iOS, presented as a grouped list with two sections. The
/// first section is labeled Notifications and contains a navigation link with
/// the label Notify Me About and the current value Direct Messages. The section
/// also contains two toggles, Play Notification Sounds and Send Read Receipts,
/// the first of which is set to the on position. A second section named User
/// Profiles has a navigation link labeled Profile Image Size and the value
/// Medium, followed by a button labeled Clear Image
/// Cache.](SwiftUI-Form-iOS.png)
///
/// On macOS, a similar form renders as a vertical stack. To adhere to macOS
/// platform conventions, this version doesn't use sections, and uses colons at
/// the end of its labels. It also sets the picker to use
/// the ``PickerStyle/inline`` style, which produces radio buttons on macOS.
///
///     var body: some View {
///         Spacer()
///         HStack {
///             Spacer()
///             Form {
///                 Picker("Notify Me About:", selection: $notifyMeAbout) {
///                     Text("Direct Messages").tag(NotifyMeAboutType.directMessages)
///                     Text("Mentions").tag(NotifyMeAboutType.mentions)
///                     Text("Anything").tag(NotifyMeAboutType.anything)
///                 }
///                 Toggle("Play notification sounds", isOn: $playNotificationSounds)
///                 Toggle("Send read receipts", isOn: $sendReadReceipts)
///
///                 Picker("Profile Image Size:", selection: $profileImageSize) {
///                     Text("Large").tag(ProfileImageSize.large)
///                     Text("Medium").tag(ProfileImageSize.medium)
///                     Text("Small").tag(ProfileImageSize.small)
///                 }
///                 .pickerStyle(.inline)
///
///                 Button("Clear Image Cache") {}
///             }
///             Spacer()
///         }
///         Spacer()
///     }
///
/// ![A form on iOS, presented as a vertical stack of views. At top, it shows
/// a pop-up menu with the label label Notify Me about and the current value
/// Direct Messages. Below this are two checkboxes, labeled Play Notification
/// Sounds and Send Read Receipts, the first of which is set on. Below this
/// is the label Profile Image Size with three radio buttons -- Large, Medium,
/// and Small -- with Medium currently selected. At the bottom of the form,
/// there is a button titled Clear Image Cache.](SwiftUI-Form-macOS.png)
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public struct Form<Content> : View where Content : View {

    /// Creates a form with the provided content.
    /// - Parameter content: A ``SwiftUI/ViewBuilder`` that provides the content for the
    /// form.
    public init(@ViewBuilder content: () -> Content)

    /// The content and behavior of the view.
    ///
    /// When you implement a custom view, you must implement a computed
    /// `body` property to provide the content for your view. Return a view
    /// that's composed of built-in views that SwiftUI provides, plus other
    /// composite views that you've already defined:
    ///
    ///     struct MyView: View {
    ///         var body: some View {
    ///             Text("Hello, World!")
    ///         }
    ///     }
    ///
    /// For more information about composing views and a view hierarchy,
    /// see <doc:Declaring-a-Custom-View>.
    @MainActor @preconcurrency public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    public typealias Body = some View
}

@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Form where Content == FormStyleConfiguration.Content {

    /// Creates a form based on a form style configuration.
    ///
    /// - Parameter configuration: The properties of the form.
    nonisolated public init(_ configuration: FormStyleConfiguration)
}

/// The size is appropriate for forms and slightly less wide than`.page`
///
/// On iOS, `.form` sizing enforces a platform-defined floor for the vertical
/// and horizontal dimensions. On macOS, no floor is enforced, however a maximum
/// proposed height is derived from the presenter height. To achieve
/// presentations outside of these bounds, see ``PresentationSizing.fitted``
/// or implement your own custom ``PresentationSizing``.
///
/// - Seealso: ``PresentationSizing/form``
@available(iOS 18.0, macOS 15.0, tvOS 18.0, visionOS 2.0, watchOS 11.0, *)
public struct FormPresentationSizing : PresentationSizing, Sendable {

    public func proposedSize(for root: PresentationSizingRoot, context: PresentationSizingContext) -> ProposedViewSize
}

/// The appearance and behavior of a form.
///
/// To configure the style for a single ``Form`` or for all form instances
/// in a view hierarchy, use the ``View/formStyle(_:)`` modifier.
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
@MainActor @preconcurrency public protocol FormStyle {

    /// A view that represents the appearance and interaction of a form.
    associatedtype Body : View

    /// Creates a view that represents the body of a form.
    ///
    /// - Parameter configuration: The properties of the form.
    /// - Returns: A view that has behavior and appearance that enables it
    ///   to function as a ``Form``.
    @ViewBuilder @MainActor @preconcurrency func makeBody(configuration: Self.Configuration) -> Self.Body

    /// The properties of a form instance.
    ///
    /// You receive a `configuration` parameter of this type --- which is an
    /// alias for the ``FormStyleConfiguration`` type --- when you implement
    /// the required ``makeBody(configuration:)`` method in a custom form
    /// style implementation.
    typealias Configuration = FormStyleConfiguration
}

@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension FormStyle where Self == ColumnsFormStyle {

    /// A non-scrolling form style with a trailing aligned column of labels
    /// next to a leading aligned column of values.
    @MainActor @preconcurrency public static var columns: ColumnsFormStyle { get }
}

@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension FormStyle where Self == GroupedFormStyle {

    /// A form style with grouped rows.
    ///
    /// Rows in a grouped rows form have leading aligned labels and trailing
    /// aligned controls within visually grouped sections.
    @MainActor @preconcurrency public static var grouped: GroupedFormStyle { get }
}

@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension FormStyle where Self == AutomaticFormStyle {

    /// The default form style.
    @MainActor @preconcurrency public static var automatic: AutomaticFormStyle { get }
}

/// The properties of a form instance.
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct FormStyleConfiguration {

    /// A type-erased content of a form.
    @MainActor @preconcurrency public struct Content : View {

        /// The type of view representing the body of this view.
        ///
        /// When you create a custom view, Swift infers this type from your
        /// implementation of the required ``View/body-swift.property`` property.
        @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
        public typealias Body = Never
    }

    /// A view that is the content of the form.
    public let content: FormStyleConfiguration.Content
}

/// A view that shows a value within a range.
///
/// A gauge is a view that shows a current level of a value in relation
/// to a specified finite capacity, very much like a fuel gauge in an
/// automobile. Gauge displays are configurable; they can show
/// any combination of the gauge's current value, the range the gauge can
/// display, and a label describing the purpose of the gauge itself.
///
/// In its most basic form, a gauge displays a single value along the path of
/// the gauge mapped into a range from 0 to 100 percent. The example below sets
/// the gauge's indicator to a position 40 percent along the gauge's path:
///
///     struct SimpleGauge: View {
///         @State private var batteryLevel = 0.4
///
///         var body: some View {
///             Gauge(value: batteryLevel) {
///                 Text("Battery Level")
///             }
///         }
///     }
///
/// ![A linear gauge displaying a current value set to 40 percent in a range of 0
///  to 1.](SwiftUI-Gauge-ValueLabelLinear.png)
///
/// You can make a gauge more descriptive by describing its purpose, showing
/// its current value and its start and end values. This example shows the
/// gauge variant that accepts a range and adds labels using multiple
/// trailing closures describing the current value and the minimum
/// and maximum values of the gauge:
///
///     struct LabeledGauge: View {
///         @State private var current = 67.0
///         @State private var minValue = 0.0
///         @State private var maxValue = 170.0
///
///         var body: some View {
///             Gauge(value: current, in: minValue...maxValue) {
///                 Text("BPM")
///             } currentValueLabel: {
///                 Text("\(Int(current))")
///             } minimumValueLabel: {
///                 Text("\(Int(minValue))")
///             } maximumValueLabel: {
///                 Text("\(Int(maxValue))")
///             }
///         }
///     }
///
/// ![A linear gauge describing heart-rate in beats per minute with its
/// value set to 67 in a range of 0 to
/// 170.](SwiftUI-Gauge-Label-CurrentValueLinear.png)
///
/// As shown above, the default style for gauges is a linear, continuous bar
/// with an indicator showing the current value, and optional labels describing
/// the gauge's purpose, current, minimum, and maximum values.
///
/// > Note: Some visual presentations of `Gauge` don't display all the
///   labels required by the API. However, the accessibility system does use
///   the label content and you should use these labels to fully describe
///   the gauge for accessibility users.
///
/// To change the style of a gauge, use the ``View/gaugeStyle(_:)``
/// view modifier and supply an initializer for a specific gauge style. For
/// example, to display the same gauge in a circular style, apply the
/// ``GaugeStyle/circular`` style to the view:
///
///     struct LabeledGauge: View {
///         @State private var current = 67.0
///         @State private var minValue = 0.0
///         @State private var maxValue = 170.0
///
///         var body: some View {
///             Gauge(value: current, in: minValue...maxValue) {
///                 Text("BPM")
///             } currentValueLabel: {
///                 Text("\(Int(current))")
///             } minimumValueLabel: {
///                 Text("\(Int(minValue))")
///             } maximumValueLabel: {
///                 Text("\(Int(maxValue))")
///             }
///             .gaugeStyle(.circular)
///         }
///     }
///
/// ![A circular gauge describing heart rate in beats per minute with its
/// value set to 67 in a range of 0 to 170.](SwiftUI-Gauge-LabeledCircular.png)
///
/// To style elements of a gauge's presentation, you apply view modifiers to
/// the elements that you want to change. In the example below, the current
/// value, minimum and maximum value labels have custom colors:
///
///     struct StyledGauge: View {
///         @State private var current = 67.0
///         @State private var minValue = 50.0
///         @State private var maxValue = 170.0
///
///         var body: some View {
///             Gauge(value: current, in: minValue...maxValue) {
///                 Image(systemName: "heart.fill")
///                     .foregroundColor(.red)
///             } currentValueLabel: {
///                 Text("\(Int(current))")
///                     .foregroundColor(Color.green)
///             } minimumValueLabel: {
///                 Text("\(Int(minValue))")
///                     .foregroundColor(Color.green)
///             } maximumValueLabel: {
///                 Text("\(Int(maxValue))")
///                     .foregroundColor(Color.red)
///             }
///             .gaugeStyle(.circular)
///         }
///     }
///
/// ![A circular gauge describing heart rate in beats per minute with its
/// value set to 67 on a range of 0 to 170. The style of each label is
/// individually set showing custom label
/// colors.](SwiftUI-Gauge-CircularStyled.png)
///
/// You can further style a gauge's appearance by supplying a tint color or
/// a gradient to the style's initializer. The following example shows the
/// effect of a gradient in the initialization of a ``CircularGaugeStyle``
/// gauge with a colorful gradient across the length of the gauge:
///
///     struct StyledGauge: View {
///         @State private var current = 67.0
///         @State private var minValue = 50.0
///         @State private var maxValue = 170.0
///         let gradient = Gradient(colors: [.green, .yellow, .orange, .red])
///
///         var body: some View {
///             Gauge(value: current, in: minValue...maxValue) {
///                 Image(systemName: "heart.fill")
///                     .foregroundColor(.red)
///             } currentValueLabel: {
///                 Text("\(Int(current))")
///                     .foregroundColor(Color.green)
///             } minimumValueLabel: {
///                 Text("\(Int(minValue))")
///                     .foregroundColor(Color.green)
///             } maximumValueLabel: {
///                 Text("\(Int(maxValue))")
///                     .foregroundColor(Color.red)
///             }
///             .gaugeStyle(CircularGaugeStyle(tint: gradient))
///         }
///     }
/// ![A screenshot showing a circular gauge with a gradient
///  tint.](SwiftUI-Gauge-Circular-Gradient.png)
///
@available(iOS 16.0, macOS 13.0, watchOS 7.0, *)
@available(tvOS, unavailable)
public struct Gauge<Label, CurrentValueLabel, BoundsLabel, MarkedValueLabels> : View where Label : View, CurrentValueLabel : View, BoundsLabel : View, MarkedValueLabels : View {

    /// Creates a gauge showing a value within a range and describes the
    /// gauge's purpose and current value.
    ///
    /// Use this modifier to create a gauge that shows the value at its
    /// relative position along the gauge and a label describing the gauge's
    /// purpose. In the example below, the gauge has a range of `0...1`, the
    /// indicator is set to `0.4`, or 40 percent of the distance along the
    /// gauge:
    ///
    ///     struct SimpleGauge: View {
    ///         @State private var batteryLevel = 0.4
    ///
    ///         var body: some View {
    ///             Gauge(value: batteryLevel) {
    ///                 Text("Battery Level")
    ///             }
    ///         }
    ///     }
    ///
    /// ![A linear gauge that shows an indicator at 40 percent along the length
    /// of the gauge.](SwiftUI-Gauge-ValueLabelLinear.png)
    ///
    /// - Parameters:
    ///     - value: The value to show in the gauge.
    ///     - bounds: The range of the valid values. Defaults to `0...1`.
    ///     - label: A view that describes the purpose of the gauge.
    public init<V>(value: V, in bounds: ClosedRange<V> = 0...1, @ViewBuilder label: () -> Label) where CurrentValueLabel == EmptyView, BoundsLabel == EmptyView, MarkedValueLabels == EmptyView, V : BinaryFloatingPoint

    /// Creates a gauge showing a value within a range and that describes the
    /// gauge's purpose and current value.
    ///
    /// Use this method to create a gauge that displays a value within a range
    /// you supply with labels that describe the purpose of the gauge and its
    /// current value. In the example below, a gauge using the
    /// ``GaugeStyle/circular`` style shows its current value of `67` along with a
    /// label describing the (BPM) for the gauge:
    ///
    ///     struct SimpleGauge: View {
    ///         @State private var current = 67.0
    ///
    ///         var body: some View {
    ///             Gauge(value: currrent, in: 0...170) {
    ///                 Text("BPM")
    ///             } currentValueLabel: {
    ///                 Text("\(current)")
    ///             }
    ///             .gaugeStyle(.circular)
    ///        }
    ///     }
    ///
    /// ![A screenshot showing a circular gauge describing heart rate in beats
    /// per minute, with the indicator and the current value label indicating a
    /// value of 67.](SwiftUI-Gauge-LabelCurrentValueCircular.png)
    ///
    /// - Parameters:
    ///     - value: The value to show on the gauge.
    ///     - bounds: The range of the valid values. Defaults to `0...1`.
    ///     - label: A view that describes the purpose of the gauge.
    ///     - currentValueLabel: A view that describes the current value of
    ///       the gauge.
    public init<V>(value: V, in bounds: ClosedRange<V> = 0...1, @ViewBuilder label: () -> Label, @ViewBuilder currentValueLabel: () -> CurrentValueLabel) where BoundsLabel == EmptyView, MarkedValueLabels == EmptyView, V : BinaryFloatingPoint

    /// Creates a gauge showing a value within a range and describes the
    /// gauge's current, minimum, and maximum values.
    ///
    /// Use this method to create a gauge that shows a value within a
    /// prescribed bounds. The gauge has labels that describe its purpose,
    /// and for the gauge's current, minimum, and maximum values.
    ///
    ///     struct LabeledGauge: View {
    ///         @State private var current = 67.0
    ///         @State private var minValue = 0.0
    ///         @State private var maxValue = 170.0
    ///
    ///         var body: some View {
    ///             Gauge(value: current, in: minValue...maxValue) {
    ///                 Text("BPM")
    ///             } currentValueLabel: {
    ///                 Text("\(Int(current))")
    ///             } minimumValueLabel: {
    ///                 Text("\(Int(minValue))")
    ///             } maximumValueLabel: {
    ///                 Text("\(Int(maxValue))")
    ///             }
    ///         }
    ///     }
    ///
    /// ![A screenshot of a gauge, labeled BPM, that's represented by a
    /// semicircle showing its current value of 67 along a range of 0
    /// to 170.](SwiftUI-Gauge-LabeledCircular.png)
    ///
    /// - Parameters:
    ///     - value: The value to show on the gauge.
    ///     - bounds: The range of the valid values. Defaults to `0...1`.
    ///     - label: A view that describes the purpose of the gauge.
    ///     - currentValueLabel: A view that describes the current value of
    ///       the gauge.
    ///     - minimumValueLabel: A view that describes the lower bounds of the
    ///       gauge.
    ///     - maximumValueLabel: A view that describes the upper bounds of the
    ///       gauge.
    public init<V>(value: V, in bounds: ClosedRange<V> = 0...1, @ViewBuilder label: () -> Label, @ViewBuilder currentValueLabel: () -> CurrentValueLabel, @ViewBuilder minimumValueLabel: () -> BoundsLabel, @ViewBuilder maximumValueLabel: () -> BoundsLabel) where MarkedValueLabels == EmptyView, V : BinaryFloatingPoint

    /// Creates a gauge representing a value within a range.
    ///
    /// - Parameters:
    ///     - value: The value to show in the instance.
    ///     - bounds: The range of the valid values. Defaults to `0...1`.
    ///     - label: A view that describes the purpose of the gauge.
    ///     - currentValueLabel: A view that describes the current value of
    ///       the gauge.
    ///     - minimumValueLabel: A view that describes the lower bounds of the
    ///       gauge.
    ///     - maximumValueLabel: A view that describes the upper bounds of the
    ///       gauge.
    ///     - markedValueLabels: A view builder containing tagged views,
    ///       each of which describes a particular value of the gauge.
    ///       The method ignores this parameter.
    public init<V>(value: V, in bounds: ClosedRange<V> = 0...1, @ViewBuilder label: () -> Label, @ViewBuilder currentValueLabel: () -> CurrentValueLabel, @ViewBuilder markedValueLabels: () -> MarkedValueLabels) where BoundsLabel == EmptyView, V : BinaryFloatingPoint

    /// Creates a gauge representing a value within a range.
    ///
    /// - Parameters:
    ///     - value: The value to show in the gauge.
    ///     - bounds: The range of the valid values. Defaults to `0...1`.
    ///     - label: A view that describes the purpose of the gauge.
    ///     - currentValueLabel: A view that describes the current value of
    ///       the gauge.
    ///     - minimumValueLabel: A view that describes the lower bounds of the
    ///       gauge.
    ///     - maximumValueLabel: A view that describes the upper bounds of the
    ///       gauge.
    ///     - markedValueLabels: A view builder containing tagged views.
    ///       each of which describes a particular value of the gauge.
    ///       The method ignores this parameter.
    public init<V>(value: V, in bounds: ClosedRange<V> = 0...1, @ViewBuilder label: () -> Label, @ViewBuilder currentValueLabel: () -> CurrentValueLabel, @ViewBuilder minimumValueLabel: () -> BoundsLabel, @ViewBuilder maximumValueLabel: () -> BoundsLabel, @ViewBuilder markedValueLabels: () -> MarkedValueLabels) where V : BinaryFloatingPoint

    /// The content and behavior of the view.
    ///
    /// When you implement a custom view, you must implement a computed
    /// `body` property to provide the content for your view. Return a view
    /// that's composed of built-in views that SwiftUI provides, plus other
    /// composite views that you've already defined:
    ///
    ///     struct MyView: View {
    ///         var body: some View {
    ///             Text("Hello, World!")
    ///         }
    ///     }
    ///
    /// For more information about composing views and a view hierarchy,
    /// see <doc:Declaring-a-Custom-View>.
    @MainActor @preconcurrency public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    @available(iOS 16.0, watchOS 7.0, macOS 13.0, *)
    @available(tvOS, unavailable)
    public typealias Body = some View
}

/// Defines the implementation of all gauge instances within a view
/// hierarchy.
///
/// To configure the style for all the ``Gauge`` instances in a view hierarchy,
/// use the ``View/gaugeStyle(_:)`` modifier. For example, you can configure
/// a gauge to use the ``circular`` style:
///
///     Gauge(value: batteryLevel, in: 0...100) {
///         Text("Battery Level")
///     }
///     .gaugeStyle(.circular)
///
@available(iOS 16.0, macOS 13.0, watchOS 7.0, *)
@available(tvOS, unavailable)
@MainActor @preconcurrency public protocol GaugeStyle {

    /// A view representing the body of a gauge.
    associatedtype Body : View

    /// Creates a view representing the body of a gauge.
    ///
    /// The system calls this modifier on each instance of gauge within a view
    /// hierarchy where this style is the current gauge style.
    ///
    /// - Parameter configuration: The properties to apply to the gauge instance.
    @ViewBuilder @MainActor @preconcurrency func makeBody(configuration: Self.Configuration) -> Self.Body

    /// The properties of a gauge instance.
    typealias Configuration = GaugeStyleConfiguration
}

@available(iOS 16.0, macOS 13.0, watchOS 9.0, *)
@available(tvOS, unavailable)
extension GaugeStyle where Self == AccessoryCircularCapacityGaugeStyle {

    /// A gauge style that displays a closed ring that's partially filled in to
    /// indicate the gauge's current value.
    ///
    /// Apply this style to a ``Gauge`` or to a view hierarchy that contains
    /// gauges using the ``View/gaugeStyle(_:)`` modifier:
    ///
    ///     Gauge(value: batteryLevel, in: 0...100) {
    ///         Text("Battery Level")
    ///     }
    ///     .gaugeStyle(.accessoryCircularCapacity)
    ///
    /// This style displays the gauge's `currentValueLabel` value at the center
    /// of the gauge.
    @MainActor @preconcurrency public static var accessoryCircularCapacity: AccessoryCircularCapacityGaugeStyle { get }
}

@available(iOS 16.0, macOS 13.0, watchOS 9.0, *)
@available(tvOS, unavailable)
extension GaugeStyle where Self == LinearCapacityGaugeStyle {

    /// A gauge style that displays a bar that fills from leading to trailing
    /// edges as the gauge's current value increases.
    ///
    /// Apply this style to a ``Gauge`` or to a view hierarchy that contains
    /// gauges using the ``View/gaugeStyle(_:)`` modifier:
    ///
    ///     Gauge(value: batteryLevel, in: 0...100) {
    ///         Text("Battery Level")
    ///     }
    ///     .gaugeStyle(.linearCapacity)
    ///
    /// If you provide `minimumValueLabel` and `maximumValueLabel`
    /// parameters when you create the gauge, they appear on leading and
    /// trailing edges of the bar, respectively. The `label` appears above
    /// the gauge, and the `currentValueLabel` appears below.
    @MainActor @preconcurrency public static var linearCapacity: LinearCapacityGaugeStyle { get }
}

@available(iOS 16.0, macOS 13.0, watchOS 9.0, *)
@available(tvOS, unavailable)
extension GaugeStyle where Self == AccessoryLinearGaugeStyle {

    /// A gauge style that displays bar with a marker that appears at a
    /// point along the bar to indicate the gauge's current value.
    ///
    /// Apply this style to a ``Gauge`` or to a view hierarchy that contains
    /// gauges using the ``View/gaugeStyle(_:)`` modifier:
    ///
    ///     Gauge(value: batteryLevel, in: 0...100) {
    ///         Text("Battery Level")
    ///     }
    ///     .gaugeStyle(.accessoryLinear)
    ///
    /// If you provide `minimumValueLabel` and `maximumValueLabel`
    /// parameters when you create the gauge, they appear on leading and
    /// trailing edges of the bar, respectively. Otherwise, the gauge displays
    /// the `currentValueLabel` value on the leading edge.
    @MainActor @preconcurrency public static var accessoryLinear: AccessoryLinearGaugeStyle { get }
}

@available(iOS 16.0, macOS 13.0, watchOS 9.0, *)
@available(tvOS, unavailable)
extension GaugeStyle where Self == AccessoryLinearCapacityGaugeStyle {

    /// A gauge style that displays bar that fills from leading to trailing
    /// edges as the gauge's current value increases.
    ///
    /// Apply this style to a ``Gauge`` or to a view hierarchy that contains
    /// gauges using the ``View/gaugeStyle(_:)`` modifier:
    ///
    ///     Gauge(value: batteryLevel, in: 0...100) {
    ///         Text("Battery Level")
    ///     }
    ///     .gaugeStyle(.accessoryLinearCapacity)
    ///
    /// If you provide `minimumValueLabel` and `maximumValueLabel`
    /// parameters when you create the gauge, they appear on leading and
    /// trailing edges of the bar, respectively. The `label` appears above
    /// the gauge, and the `currentValueLabel` appears below.
    @MainActor @preconcurrency public static var accessoryLinearCapacity: AccessoryLinearCapacityGaugeStyle { get }
}

@available(iOS 16.0, macOS 13.0, watchOS 7.0, *)
@available(tvOS, unavailable)
extension GaugeStyle where Self == DefaultGaugeStyle {

    /// The default gauge view style in the current context of the view being
    /// styled.
    @MainActor @preconcurrency public static var automatic: DefaultGaugeStyle { get }
}

@available(iOS 16.0, macOS 13.0, watchOS 9.0, *)
@available(tvOS, unavailable)
extension GaugeStyle where Self == AccessoryCircularGaugeStyle {

    /// A gauge style that displays an open ring with a marker that appears at a
    /// point along the ring to indicate the gauge's current value.
    ///
    /// Apply this style to a ``Gauge`` or to a view hierarchy that contains
    /// gauges using the ``View/gaugeStyle(_:)`` modifier:
    ///
    ///     Gauge(value: batteryLevel, in: 0...100) {
    ///         Text("Battery Level")
    ///     }
    ///     .gaugeStyle(.accessoryCircular)
    ///
    /// This style displays the gauge's `currentValueLabel` value at the center
    /// of the gauge. If you provide `minimumValueLabel` and `maximumValueLabel`
    /// parameters when you create the gauge, they appear in the opening at the
    /// bottom of the ring. Otherwise, the gauge places its label in that
    /// location.
    @MainActor @preconcurrency public static var accessoryCircular: AccessoryCircularGaugeStyle { get }
}

/// The properties of a gauge instance.
@available(iOS 16.0, macOS 13.0, watchOS 7.0, *)
@available(tvOS, unavailable)
public struct GaugeStyleConfiguration {

    /// A type-erased label of a gauge, describing its purpose.
    @MainActor @preconcurrency public struct Label : View {

        /// The type of view representing the body of this view.
        ///
        /// When you create a custom view, Swift infers this type from your
        /// implementation of the required ``View/body-swift.property`` property.
        @available(iOS 16.0, watchOS 7.0, macOS 13.0, *)
        @available(tvOS, unavailable)
        public typealias Body = Never
    }

    /// A type-erased value label of a gauge that contains the current value.
    @MainActor @preconcurrency public struct CurrentValueLabel : View {

        /// The type of view representing the body of this view.
        ///
        /// When you create a custom view, Swift infers this type from your
        /// implementation of the required ``View/body-swift.property`` property.
        @available(iOS 16.0, watchOS 7.0, macOS 13.0, *)
        @available(tvOS, unavailable)
        public typealias Body = Never
    }

    /// A type-erased value label of a gauge describing the minimum value.
    @MainActor @preconcurrency public struct MinimumValueLabel : View {

        /// The type of view representing the body of this view.
        ///
        /// When you create a custom view, Swift infers this type from your
        /// implementation of the required ``View/body-swift.property`` property.
        @available(iOS 16.0, watchOS 7.0, macOS 13.0, *)
        @available(tvOS, unavailable)
        public typealias Body = Never
    }

    /// A type-erased value label of a gauge describing the maximum value.
    @MainActor @preconcurrency public struct MaximumValueLabel : View {

        /// The type of view representing the body of this view.
        ///
        /// When you create a custom view, Swift infers this type from your
        /// implementation of the required ``View/body-swift.property`` property.
        @available(iOS 16.0, watchOS 7.0, macOS 13.0, *)
        @available(tvOS, unavailable)
        public typealias Body = Never
    }

    /// A type-erased label describing a specific value of a gauge.
    @MainActor @preconcurrency public struct MarkedValueLabel : View {

        /// The type of view representing the body of this view.
        ///
        /// When you create a custom view, Swift infers this type from your
        /// implementation of the required ``View/body-swift.property`` property.
        @available(iOS 16.0, watchOS 7.0, macOS 13.0, *)
        @available(tvOS, unavailable)
        public typealias Body = Never
    }

    /// The current value of the gauge.
    ///
    /// The valid range is  `0.0...1.0`.
    public var value: Double

    /// A view that describes the purpose of the gauge.
    public var label: GaugeStyleConfiguration.Label

    /// A view that describes the current value.
    public var currentValueLabel: GaugeStyleConfiguration.CurrentValueLabel?

    /// A view that describes the minimum of the range for the current value.
    public var minimumValueLabel: GaugeStyleConfiguration.MinimumValueLabel?

    /// A view that describes the maximum of the range for the current value.
    public var maximumValueLabel: GaugeStyleConfiguration.MaximumValueLabel?
}

/// A property wrapper type that updates a property while the user performs a
/// gesture and resets the property back to its initial state when the gesture
/// ends.
///
/// Declare a property as `@GestureState`, pass as a binding to it as a
/// parameter to a gesture's ``Gesture/updating(_:body:)`` callback, and receive
/// updates to it. A property that's declared as `@GestureState` implicitly
/// resets when the gesture becomes inactive, making it suitable for tracking
/// transient state.
///
/// Add a long-press gesture to a ``Circle``, and update the interface during
/// the gesture by declaring a property as `@GestureState`:
///
///     struct SimpleLongPressGestureView: View {
///         @GestureState private var isDetectingLongPress = false
///
///         var longPress: some Gesture {
///             LongPressGesture(minimumDuration: 3)
///                 .updating($isDetectingLongPress) { currentState, gestureState, transaction in
///                     gestureState = currentState
///                 }
///         }
///
///         var body: some View {
///             Circle()
///                 .fill(self.isDetectingLongPress ? Color.red : Color.green)
///                 .frame(width: 100, height: 100, alignment: .center)
///                 .gesture(longPress)
///         }
///     }
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@propertyWrapper @frozen public struct GestureState<Value> : DynamicProperty {

    /// Creates a view state that's derived from a gesture.
    ///
    /// - Parameter wrappedValue: A wrapped value for the gesture state
    ///   property.
    public init(wrappedValue: Value)

    /// Creates a view state that's derived from a gesture with an initial
    /// value.
    ///
    /// - Parameter initialValue: An initial value for the gesture state
    ///   property.
    public init(initialValue: Value)

    /// Creates a view state that's derived from a gesture with a wrapped state
    /// value and a transaction to reset it.
    ///
    /// - Parameters:
    ///   - wrappedValue: A wrapped value for the gesture state property.
    ///   - resetTransaction: A transaction that provides metadata for view
    ///     updates.
    public init(wrappedValue: Value, resetTransaction: Transaction)

    /// Creates a view state that's derived from a gesture with an initial state
    /// value and a transaction to reset it.
    ///
    /// - Parameters:
    ///   - initialValue: An initial state value.
    ///   - resetTransaction: A transaction that provides metadata for view
    ///     updates.
    public init(initialValue: Value, resetTransaction: Transaction)

    /// Creates a view state that's derived from a gesture with a wrapped state
    /// value and a closure that provides a transaction to reset it.
    ///
    /// - Parameters:
    ///   - wrappedValue: A wrapped value for the gesture state property.
    ///   - reset: A closure that provides a ``Transaction``.
    public init(wrappedValue: Value, reset: @escaping (Value, inout Transaction) -> Void)

    /// Creates a view state that's derived from a gesture with an initial state
    /// value and a closure that provides a transaction to reset it.
    ///
    /// - Parameters:
    ///   - initialValue: An initial state value.
    ///   - reset: A closure that provides a ``Transaction``.
    public init(initialValue: Value, reset: @escaping (Value, inout Transaction) -> Void)

    /// The wrapped value referenced by the gesture state property.
    public var wrappedValue: Value { get }

    /// A binding to the gesture state property.
    public var projectedValue: GestureState<Value> { get }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension GestureState : @unchecked Sendable where Value : Sendable {
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension GestureState where Value : ExpressibleByNilLiteral {

    /// Creates a view state that's derived from a gesture with a transaction to
    /// reset it.
    ///
    /// - Parameter resetTransaction: A transaction that provides metadata for
    ///   view updates.
    public init(resetTransaction: Transaction = Transaction())

    /// Creates a view state that's derived from a gesture with a closure that
    /// provides a transaction to reset it.
    ///
    /// - Parameter reset: A closure that provides a ``Transaction``.
    public init(reset: @escaping (Value, inout Transaction) -> Void)
}

/// A gesture that updates the state provided by a gesture's updating callback.
///
/// A gesture's ``Gesture/updating(_:body:)`` callback returns a
/// `GestureStateGesture` instance for updating a transient state property
/// that's annotated with the ``GestureState`` property wrapper.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@frozen public struct GestureStateGesture<Base, State> : Gesture where Base : Gesture {

    /// The type representing the gesture's value.
    public typealias Value = Base.Value

    /// The originating gesture.
    public var base: Base

    /// A value that changes as the user performs the gesture.
    public var state: GestureState<State>

    /// The updating gesture containing the originating gesture's value, the
    /// updated state of the gesture, and a transaction.
    public var body: (GestureStateGesture<Base, State>.Value, inout State, inout Transaction) -> Void

    /// Creates a new gesture that's the result of an ongoing gesture.
    ///
    /// - Parameters:
    ///   - base: The originating gesture.
    ///   - state: The wrapped value of a ``GestureState`` property.
    ///   - body: The callback that SwiftUI invokes as the gesture's value
    ///     changes.
    @inlinable public init(base: Base, state: GestureState<State>, body: @escaping (GestureStateGesture<Base, State>.Value, inout State, inout Transaction) -> Void)

    /// The type of gesture representing the body of `Self`.
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    public typealias Body = Never
}

/// A date picker style that displays an interactive calendar or clock.
///
/// You can also use ``DatePickerStyle/graphical`` to construct this style.
@available(iOS 14.0, macOS 10.15, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct GraphicalDatePickerStyle : DatePickerStyle {

    /// Creates an instance of the graphical date picker style.
    public init()

    /// Returns the appearance and interaction content for a `DatePicker`.
    ///
    /// The system calls this method for each ``DatePicker`` instance in a view
    /// hierarchy where this style is the current date picker style.
    ///
    /// - Parameter configuration : The properties of the date picker.
    @available(iOS 16.0, macOS 13.0, *)
    @MainActor @preconcurrency public func makeBody(configuration: GraphicalDatePickerStyle.Configuration) -> some View


    /// A view representing the appearance and interaction of a `DatePicker`.
    @available(iOS 14.0, macOS 10.15, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias Body = some View
}

/// A container view that arranges other views in a two dimensional layout.
///
/// Create a two dimensional layout by initializing a `Grid` with a collection
/// of ``GridRow`` structures. The first view in each grid row appears in
/// the grid's first column, the second view in the second column, and so
/// on. The following example creates a grid with two rows and two columns:
///
///     Grid {
///         GridRow {
///             Text("Hello")
///             Image(systemName: "globe")
///         }
///         GridRow {
///             Image(systemName: "hand.wave")
///             Text("World")
///         }
///     }
///
/// A grid and its rows behave something like a collection of ``HStack``
/// instances wrapped in a ``VStack``. However, the grid handles row and column
/// creation as a single operation, which applies alignment and spacing to
/// cells, rather than first to rows and then to a column of unrelated rows.
/// The grid produced by the example above demonstrates this:
///
/// ![A screenshot of items arranged in a grid. The upper-left
/// position in the grid contains the word hello. The upper-right contains
/// an image of a globe. The lower-left contains an image of a waving hand.
/// The lower-right contains the word world. The cells of the grid
/// have minimal vertical or horizontal spacing.](Grid-1-iOS)
///
/// > Note: If you need a grid that conforms to the ``Layout``
/// protocol, like when you want to create a conditional layout using
/// ``AnyLayout``, use ``GridLayout`` instead.
///
/// ### Multicolumn cells
///
/// If you provide a view rather than a ``GridRow`` as an element in the
/// grid's content, the grid uses the view to create a row that spans all of
/// the grid's columns. For example, you can add a ``Divider`` between the
/// rows of the previous example:
///
///     Grid {
///         GridRow {
///             Text("Hello")
///             Image(systemName: "globe")
///         }
///         Divider()
///         GridRow {
///             Image(systemName: "hand.wave")
///             Text("World")
///         }
///     }
///
/// Because a divider takes as much horizontal space as its parent offers, the
/// entire grid widens to fill the width offered by its parent view.
///
/// ![A screenshot of items arranged in a grid. The upper-left
/// cell in the grid contains the word hello. The upper right contains
/// an image of a globe. The lower-left contains an image of a waving hand.
/// The lower-right contains the word world. A dividing line that spans
/// the width of the grid separates the upper and lower elements. The grid's
/// rows have minimal vertical spacing, but it's columns have a lot of
/// horizontal spacing, with column content centered horizontally.](Grid-2-iOS)
///
/// To prevent a flexible view from taking more space on a given axis than the
/// other cells in a row or column require, add the
/// ``View/gridCellUnsizedAxes(_:)`` view modifier to the view:
///
///     Divider()
///         .gridCellUnsizedAxes(.horizontal)
///
/// This restores the grid to the width that the text and images require:
///
/// ![A screenshot of items arranged in a grid. The upper-left
/// position in the grid contains the word hello. The upper-right contains
/// an image of a globe. The lower-left contains an image of a waving hand.
/// The lower-right contains the word world. A dividing line that spans
/// the width of the grid separates the upper and lower elements. The grid's
/// rows and columns have minimal vertical or horizontal spacing.](Grid-3-iOS)
///
/// To make a cell span a specific number of columns rather than the whole
/// grid, use the ``View/gridCellColumns(_:)`` modifier on a view that's
/// contained inside a ``GridRow``.
///
/// ### Column count
///
/// The grid's column count grows to handle the row with the largest number of
/// columns. If you create rows with different numbers of columns, the grid
/// adds empty cells to the trailing edge of rows that have fewer columns.
/// The example below creates three rows with different column counts:
///
///     Grid {
///         GridRow {
///             Text("Row 1")
///             ForEach(0..<2) { _ in Color.red }
///         }
///         GridRow {
///             Text("Row 2")
///             ForEach(0..<5) { _ in Color.green }
///         }
///         GridRow {
///             Text("Row 3")
///             ForEach(0..<4) { _ in Color.blue }
///         }
///     }
///
/// The resulting grid has as many columns as the widest row, adding empty
/// cells to rows that don't specify enough views:
///
/// ![A screenshot of a grid with three rows and six columns. The first
/// column contains cells with the labels Row 1, Row 2, and Row 3, reading
/// from top to bottom. The text is centered in the cell in each case. The
/// other columns contain cells that are either filled with a rectangle, or
/// that are empty. Scanning from left to right, the first row contains two
/// red rectangle cells after its label cell, and then three empty cells.
/// The second row contains five green rectangle cells after its label cell.
/// The third row contains four blue rectangle cells after its label cell,
/// and then one empty cell. There's 20 points of space between each of
/// the cells.](Grid-4-iOS)
///
/// The grid sets the width of all the cells in a column to match the needs of
/// column's widest cell. In the example above, the width of the first column
/// depends on the width of the widest ``Text`` view that the column contains.
/// The other columns, which contain flexible ``Color`` views, share the
/// remaining horizontal space offered by the grid's parent view equally.
///
/// Similarly, the tallest cell in a row sets the height of the entire row.
/// The cells in the first column of the grid above need only the height
/// required for each string, but the ``Color`` cells expand to equally share
/// the total height available to the grid. As a result, the color cells
/// determine the row heights.
///
/// ### Cell spacing and alignment
///
/// You can control the spacing between cells in both the horizontal and
/// vertical dimensions and set a default alignment for the content in all
/// the grid cells when you initialize the grid using the
/// ``init(alignment:horizontalSpacing:verticalSpacing:content:)`` initializer.
/// Consider a modified version of the previous example:
///
///     Grid(alignment: .bottom, horizontalSpacing: 1, verticalSpacing: 1) {
///         // ...
///     }
///
/// This configuration causes all of the cells to use ``Alignment/bottom``
/// alignment --- which only affects the text cells because the colors fill
/// their cells completely --- and it reduces the spacing between cells:
///
/// ![A screenshot of a grid with three rows and six columns. The first
/// column contains cells with the labels Row 1, Row 2, and Row 3, reading
/// from top to bottom. The text is horizontally centered and bottom aligned
/// in the cell in each case. The other columns contain cells that are either
/// filled with a rectangle, or that are empty. Scanning from left to right,
/// the first row contains two red rectangle cells after its label cell, and
/// then three empty cells. The second row contains five green rectangle cells
/// after its label cell. The third row contains four blue rectangle cells
/// after its label cell, and then one empty cell. There's 1 point of space
/// between each of the cells.](Grid-5-iOS)
///
/// You can override the alignment of specific cells or groups of cells. For
/// example, you can change the horizontal alignment of the cells in a column
/// by adding the ``View/gridColumnAlignment(_:)`` modifier, or the vertical
/// alignment of the cells in a row by configuring the row's
/// ``GridRow/init(alignment:content:)`` initializer. You can also align
/// a single cell with the ``View/gridCellAnchor(_:)`` modifier.
///
/// ### Performance considerations
///
/// A grid can size its rows and columns correctly because
/// it renders all of its child views immediately. If your app exhibits
/// poor performance when it first displays a large grid that appears
/// inside a ``ScrollView``, consider switching to a ``LazyVGrid`` or
/// ``LazyHGrid`` instead.
///
/// Lazy grids render their cells when SwiftUI needs to display
/// them, rather than all at once. This reduces the initial cost of displaying
/// a large scrollable grid that's never fully visible, but also reduces the
/// grid's ability to optimally lay out cells. Switch to a lazy grid only if
/// profiling your code shows a worthwhile performance improvement.
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
@frozen public struct Grid<Content> where Content : View {

    /// Creates a grid with the specified spacing, alignment, and child
    /// views.
    ///
    /// Use this initializer to create a ``Grid``. Provide a content closure
    /// that defines the rows of the grid, and optionally customize the
    /// spacing between cells and the alignment of content within each cell.
    /// The following example customizes the spacing between cells:
    ///
    ///     Grid(horizontalSpacing: 30, verticalSpacing: 30) {
    ///         ForEach(0..<5) { row in
    ///             GridRow {
    ///                 ForEach(0..<5) { column in
    ///                     Text("(\(column), \(row))")
    ///                 }
    ///             }
    ///         }
    ///     }
    ///
    /// You can list rows and the cells within rows directly, or you can
    /// use a ``ForEach`` structure to generate either, as the example above
    /// does:
    ///
    /// ![A screenshot of a grid that contains five rows and five columns.
    /// Each cell in the grid contains an pair of integers in parentheses.
    /// The first integer indicates the column position, counting from zero
    /// on the left up to four on the right. The second integer indicates the
    /// row position, counting from zero on the top to four on the
    /// bottom.](Grid-init-1-iOS)
    ///
    /// By default, the grid's alignment value applies to all of the cells in
    /// the grid. However, you can also change the alignment for particular
    /// cells or groups of cells:
    ///
    /// * Override the vertical alignment for the cells in a row
    ///   by specifying a ``VerticalAlignment`` parameter to the corresponding
    ///   row's ``GridRow/init(alignment:content:)`` initializer.
    /// * Override the horizontal alignment for the cells in a column by adding
    ///   a ``View/gridColumnAlignment(_:)`` view modifier to exactly one of
    ///   the cells in the column, and specifying a ``HorizontalAlignment``
    ///   parameter.
    /// * Specify a custom alignment anchor for a particular cell by using the
    ///   ``View/gridCellAnchor(_:)`` modifier on the cell's view.
    ///
    /// - Parameters:
    ///   - alignment: The guide for aligning the child views within the
    ///     space allocated for a given cell. The default is
    ///     ``Alignment/center``.
    ///   - horizontalSpacing: The horizontal distance between each cell, given
    ///     in points. The value is `nil` by default, which results in a
    ///     default distance between cells that's appropriate for the platform.
    ///   - verticalSpacing: The vertical distance between each cell, given
    ///     in points. The value is `nil` by default, which results in a
    ///     default distance between cells that's appropriate for the platform.
    ///   - content: A closure that creates the grid's rows.
    ///
    @inlinable public init(alignment: Alignment = .center, horizontalSpacing: CGFloat? = nil, verticalSpacing: CGFloat? = nil, @ViewBuilder content: () -> Content)

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
    public typealias Body = Never
}

@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Grid : View {
}

/// A description of a row or a column in a lazy grid.
///
/// Use an array of `GridItem` instances to configure the layout of items in
/// a lazy grid. Each grid item in the array specifies layout properties like
/// size and spacing for the rows of a ``LazyHGrid`` or the columns of
/// a ``LazyVGrid``. The following example defines four rows for a
/// horizontal grid, each with different characteristics:
///
///     struct GridItemDemo: View {
///         let rows = [
///             GridItem(.fixed(30), spacing: 1),
///             GridItem(.fixed(60), spacing: 10),
///             GridItem(.fixed(90), spacing: 20),
///             GridItem(.fixed(10), spacing: 50)
///         ]
///
///         var body: some View {
///             ScrollView(.horizontal) {
///                 LazyHGrid(rows: rows, spacing: 5) {
///                     ForEach(0...300, id: \.self) { _ in
///                         Color.red.frame(width: 30)
///                         Color.green.frame(width: 30)
///                         Color.blue.frame(width: 30)
///                         Color.yellow.frame(width: 30)
///                     }
///                 }
///             }
///         }
///     }
///
/// A lazy horizontal grid sets the width of each column based on the widest
/// cell in the column. It can do this because it has access to all of the views
/// in a given column at once. In the example above, the ``Color`` views always
/// have the same fixed width, resulting in a uniform column width across the
/// whole grid.
///
/// However, a lazy horizontal grid doesn't generally have access to all the
/// views in a row, because it generates new cells as people scroll through
/// information in your app. Instead, it relies on a grid item for information
/// about each row. The example above indicates a different fixed height for
/// each row, and sets a different amount of spacing to appear after each row:
///
/// ![A screenshot of a grid of rectangles arranged in four rows and a large
/// number of colums. All the rectangles are the same width, and have a uniform
/// horizontal spacing. The rectangles in a given row are the same height as
/// each other, but different than the rectangles in other rows. The vertical
/// spacing between rows also varies.](GridItem-1-iOS)
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public struct GridItem : Sendable {

    /// The size in the minor axis of one or more rows or columns in a grid
    /// layout.
    ///
    /// Use a `Size` instance when you create a ``GridItem``. The value tells a
    /// ``LazyHGrid`` how to size its rows, or a ``LazyVGrid`` how to size
    /// its columns.
    public enum Size : Sendable {

        /// A single item with the specified fixed size.
        case fixed(CGFloat)

        /// A single flexible item.
        ///
        /// The size of this item is the size of the grid with spacing and
        /// inflexible items removed, divided by the number of flexible items,
        /// clamped to the provided bounds.
        case flexible(minimum: CGFloat = 10, maximum: CGFloat = .infinity)

        /// Multiple items in the space of a single flexible item.
        ///
        /// This size case places one or more items into the space assigned to
        /// a single `flexible` item, using the provided bounds and
        /// spacing to decide exactly how many items fit. This approach prefers
        /// to insert as many items of the `minimum` size as possible
        /// but lets them increase to the `maximum` size.
        case adaptive(minimum: CGFloat, maximum: CGFloat = .infinity)
    }

    /// The size of the item, which is the width of a column item or the
    /// height of a row item.
    public var size: GridItem.Size

    /// The spacing to the next item.
    ///
    /// If this value is `nil`, the item uses a reasonable default for the
    /// current platform.
    public var spacing: CGFloat?

    /// The alignment to use when placing each view.
    ///
    /// Use this property to anchor the view's relative position to the same
    /// relative position in the view's assigned grid space.
    public var alignment: Alignment?

    /// Creates a grid item with the specified size, spacing, and alignment.
    ///
    /// - Parameters:
    ///   - size: The size of the grid item.
    ///   - spacing: The spacing to use between this and the next item.
    ///   - alignment: The alignment to use for this grid item.
    public init(_ size: GridItem.Size = .flexible(), spacing: CGFloat? = nil, alignment: Alignment? = nil)
}

/// A grid that you can use in conditional layouts.
///
/// This layout container behaves like a ``Grid``, but conforms to the
/// ``Layout`` protocol so you can use it in the conditional layouts that you
/// construct with ``AnyLayout``. If you don't need a conditional layout, use
/// ``Grid`` instead.
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
@frozen public struct GridLayout {

    /// The alignment of subviews.
    public var alignment: Alignment

    /// The horizontal distance between adjacent subviews.
    ///
    /// Set this value to `nil` to use default horizonal distances between
    /// subviews.
    public var horizontalSpacing: CGFloat?

    /// The vertical distance between adjacent subviews.
    ///
    /// Set this value to `nil` to use default vertical distances between
    /// subviews.
    public var verticalSpacing: CGFloat?

    /// Creates a grid with the specified spacing and alignment.
    ///
    /// - Parameters:
    ///   - alignment: The guide for aligning subviews within the
    ///     space allocated for a given cell. The default is
    ///     ``Alignment/center``.
    ///   - horizontalSpacing: The horizontal distance between each cell, given
    ///     in points. The value is `nil` by default, which results in a
    ///     default distance between cells that's appropriate for the platform.
    ///   - verticalSpacing: The vertical distance between each cell, given
    ///     in points. The value is `nil` by default, which results in a
    ///     default distance between cells that's appropriate for the platform.
    @inlinable public init(alignment: Alignment = .center, horizontalSpacing: CGFloat? = nil, verticalSpacing: CGFloat? = nil)

    @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
    public typealias Body = Never
}

@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension GridLayout : Layout {

    /// Creates and initializes a cache for a layout instance.
    ///
    /// You can optionally use a cache to preserve calculated values across
    /// calls to a layout container's methods. Many layout types don't need
    /// a cache, because SwiftUI automatically reuses both the results of
    /// calls into the layout and the values that the layout reads from its
    /// subviews. Rely on the protocol's default implementation of this method
    /// if you don't need a cache.
    ///
    /// However you might find a cache useful when:
    ///
    /// - The layout container repeats complex, intermediate calculations
    /// across calls like ``sizeThatFits(proposal:subviews:cache:)``,
    /// ``placeSubviews(in:proposal:subviews:cache:)``, and
    /// ``explicitAlignment(of:in:proposal:subviews:cache:)``.
    /// You might be able to improve performance by calculating values
    /// once and storing them in a cache.
    /// - The layout container reads many ``LayoutValueKey`` values from
    /// subviews. It might be more efficient to do that once and store the
    /// results in the cache, rather than rereading the subviews' values before
    /// each layout call.
    /// - You want to maintain working storage, like temporary Swift arrays,
    /// across calls into the layout, to minimize the number of allocation
    /// events.
    ///
    /// Only implement a cache if profiling shows that it improves performance.
    ///
    /// ### Initialize a cache
    ///
    /// Implement the `makeCache(subviews:)` method to create a cache.
    /// You can add computed values to the cache right away, using information
    /// from the `subviews` input parameter, or you can do that later. The
    /// methods of the ``Layout`` protocol that can access the cache
    /// take the cache as an in-out parameter, which enables you to modify
    /// the cache anywhere that you can read it.
    ///
    /// You can use any storage type that makes sense for your layout
    /// algorithm, but be sure that you only store data that you derive
    /// from the layout and its subviews (lazily, if possible). For this to
    /// work correctly, SwiftUI needs to be able to call this method to
    /// recreate the cache without changing the layout result.
    ///
    /// When you return a cache from this method, you implicitly define a type
    /// for your cache. Be sure to either make the type of the `cache`
    /// parameters on your other ``Layout`` protocol methods match, or use
    /// a type alias to define the ``Cache`` associated type.
    ///
    /// ### Update the cache
    ///
    /// If the layout container or any of its subviews change, SwiftUI
    /// calls the ``updateCache(_:subviews:)`` method so you can
    /// modify or invalidate the contents of the
    /// cache. The default implementation of that method calls the
    /// `makeCache(subviews:)` method to recreate the cache, but you can
    /// provide your own implementation of the update method to take an
    /// incremental approach, if appropriate.
    ///
    /// - Parameters:
    ///   - subviews: A collection of proxy instances that represent the
    ///     views that the container arranges. You can use the proxies in the
    ///     collection to get information about the subviews as you
    ///     calculate values to store in the cache.
    ///
    /// - Returns: Storage for calculated data that you share among
    ///   the methods of your custom layout container.
    public func makeCache(subviews: GridLayout.Subviews) -> GridLayout.Cache

    /// Updates the layout's cache when something changes.
    ///
    /// If your custom layout container creates a cache by implementing the
    /// ``makeCache(subviews:)`` method, SwiftUI calls the update method
    /// when your layout or its subviews change, giving you an opportunity
    /// to modify or invalidate the contents of the cache.
    /// The method's default implementation recreates the
    /// cache by calling the ``makeCache(subviews:)`` method,
    /// but you can provide your own implementation to take an
    /// incremental approach, if appropriate.
    ///
    /// - Parameters:
    ///   - cache: Storage for calculated data that you share among
    ///     the methods of your custom layout container.
    ///   - subviews: A collection of proxy instances that represent the
    ///     views arranged by the container. You can use the proxies in the
    ///     collection to get information about the subviews as you
    ///     calculate values to store in the cache.
    public func updateCache(_ cache: inout GridLayout.Cache, subviews: GridLayout.Subviews)

    /// Returns the preferred spacing values of the composite view.
    ///
    /// Implement this method to provide custom spacing preferences
    /// for a layout container. The value you return affects
    /// the spacing around the container, but it doesn't affect how the
    /// container arranges subviews relative to one another inside the
    /// container.
    ///
    /// Create a custom ``ViewSpacing`` instance for your container by
    /// initializing one with default values, and then merging that with
    /// spacing instances of certain subviews. For example, if you define
    /// a basic vertical stack that places subviews in a column, you could
    /// use the spacing preferences of the subview edges that make
    /// contact with the container's edges:
    ///
    ///     extension BasicVStack {
    ///         func spacing(subviews: Subviews, cache: inout ()) -> ViewSpacing {
    ///             var spacing = ViewSpacing()
    ///
    ///             for index in subviews.indices {
    ///                 var edges: Edge.Set = [.leading, .trailing]
    ///                 if index == 0 { edges.formUnion(.top) }
    ///                 if index == subviews.count - 1 { edges.formUnion(.bottom) }
    ///                 spacing.formUnion(subviews[index].spacing, edges: edges)
    ///             }
    ///
    ///             return spacing
    ///         }
    ///     }
    ///
    /// In the above example, the first and last subviews contribute to the
    /// spacing above and below the container, respectively, while all subviews
    /// affect the spacing on the leading and trailing edges.
    ///
    /// If you don't implement this method, the protocol provides a default
    /// implementation that merges the spacing preferences across all subviews on all edges.
    ///
    /// - Parameters:
    ///   - subviews: A collection of proxy instances that represent the
    ///     views that the container arranges. You can use the proxies in the
    ///     collection to get information about the subviews as you determine
    ///     how much spacing the container prefers around it.
    ///   - cache: Optional storage for calculated data that you can share among
    ///     the methods of your custom layout container. See
    ///     ``makeCache(subviews:)`` for details.
    ///
    /// - Returns: A ``ViewSpacing`` instance that describes the preferred
    ///   spacing around the container view.
    public func spacing(subviews: GridLayout.Subviews, cache: inout GridLayout.Cache) -> ViewSpacing

    /// Returns the size of the composite view, given a proposed size
    /// and the view's subviews.
    ///
    /// Implement this method to tell your custom layout container's parent
    /// view how much space the container needs for a set of subviews, given
    /// a size proposal. The parent might call this method more than once
    /// during a layout pass with different proposed sizes to test the
    /// flexibility of the container, using proposals like:
    ///
    /// * The ``ProposedViewSize/zero`` proposal; respond with the
    ///   layout's minimum size.
    /// * The ``ProposedViewSize/infinity`` proposal; respond with the
    ///   layout's maximum size.
    /// * The ``ProposedViewSize/unspecified`` proposal; respond with the
    ///   layout's ideal size.
    ///
    /// The parent might also choose to test flexibility in one dimension at a
    /// time. For example, a horizontal stack might propose a fixed height and
    /// an infinite width, and then the same height with a zero width.
    ///
    /// The following example calculates the size for a basic vertical stack
    /// that places views in a column, with no spacing between the views:
    ///
    ///     private struct BasicVStack: Layout {
    ///         func sizeThatFits(
    ///             proposal: ProposedViewSize,
    ///             subviews: Subviews,
    ///             cache: inout ()
    ///         ) -> CGSize {
    ///             subviews.reduce(CGSize.zero) { result, subview in
    ///                 let size = subview.sizeThatFits(.unspecified)
    ///                 return CGSize(
    ///                     width: max(result.width, size.width),
    ///                     height: result.height + size.height)
    ///             }
    ///         }
    ///
    ///         // This layout also needs a placeSubviews() implementation.
    ///     }
    ///
    /// The implementation asks each subview for its ideal size by calling the
    /// ``LayoutSubview/sizeThatFits(_:)`` method with an
    /// ``ProposedViewSize/unspecified`` proposed size.
    /// It then reduces these values into a single size that represents
    /// the maximum subview width and the sum of subview heights.
    /// Because this example isn't flexible, it ignores its size proposal
    /// input and always returns the same value for a given set of subviews.
    ///
    /// SwiftUI views choose their own size, so the layout engine always
    /// uses a value that you return from this method as the actual size of the
    /// composite view. That size factors into the construction of the `bounds`
    /// input to the ``placeSubviews(in:proposal:subviews:cache:)`` method.
    ///
    /// - Parameters:
    ///   - proposal: A size proposal for the container. The container's parent
    ///     view that calls this method might call the method more than once
    ///     with different proposals to learn more about the container's
    ///     flexibility before deciding which proposal to use for placement.
    ///   - subviews: A collection of proxies that represent the
    ///     views that the container arranges. You can use the proxies in the
    ///     collection to get information about the subviews as you determine
    ///     how much space the container needs to display them.
    ///   - cache: Optional storage for calculated data that you can share among
    ///     the methods of your custom layout container. See
    ///     ``makeCache(subviews:)`` for details.
    ///
    /// - Returns: A size that indicates how much space the container
    ///   needs to arrange its subviews.
    public func sizeThatFits(proposal: ProposedViewSize, subviews: GridLayout.Subviews, cache: inout GridLayout.Cache) -> CGSize

    /// Assigns positions to each of the layout's subviews.
    ///
    /// SwiftUI calls your implementation of this method to tell your
    /// custom layout container to place its subviews. From this method, call
    /// the ``LayoutSubview/place(at:anchor:proposal:)`` method on each
    /// element in `subviews` to tell the subviews where to appear in the
    /// user interface.
    ///
    /// For example, you can create a basic vertical stack that places views
    /// in a column, with views horizontally aligned on their leading edge:
    ///
    ///     struct BasicVStack: Layout {
    ///         func placeSubviews(
    ///             in bounds: CGRect,
    ///             proposal: ProposedViewSize,
    ///             subviews: Subviews,
    ///             cache: inout ()
    ///         ) {
    ///             var point = bounds.origin
    ///             for subview in subviews {
    ///                 subview.place(at: point, anchor: .topLeading, proposal: .unspecified)
    ///                 point.y += subview.dimensions(in: .unspecified).height
    ///             }
    ///         }
    ///
    ///         // This layout also needs a sizeThatFits() implementation.
    ///     }
    ///
    /// The example creates a placement point that starts at the origin of the
    /// specified `bounds` input and uses that to place the first subview. It
    /// then moves the point in the y dimension by the subview's height,
    /// which it reads using the ``LayoutSubview/dimensions(in:)`` method.
    /// This prepares the point for the next iteration of the loop. All
    /// subview operations use an ``ProposedViewSize/unspecified`` size
    /// proposal to indicate that subviews should use and report their ideal
    /// size.
    ///
    /// A more complex layout container might add space between subviews
    /// according to their ``LayoutSubview/spacing`` preferences, or a
    /// fixed space based on input configuration. For example, you can extend
    /// the basic vertical stack's placement method to calculate the
    /// preferred distances between adjacent subviews and store the results in
    /// an array:
    ///
    ///     let spacing: [CGFloat] = subviews.indices.dropLast().map { index in
    ///         subviews[index].spacing.distance(
    ///             to: subviews[index + 1].spacing,
    ///             along: .vertical)
    ///     }
    ///
    /// The spacing's ``ViewSpacing/distance(to:along:)`` method considers the
    /// preferences of adjacent views on the edge where they meet. It returns
    /// the smallest distance that satisfies both views' preferences for the
    /// given edge. For example, if one view prefers at least `2` points on its
    /// bottom edge, and the next view prefers at least `8` points on its top
    /// edge, the distance method returns `8`, because that's the smallest
    /// value that satisfies both preferences.
    ///
    /// Update the placement calculations to use the spacing values:
    ///
    ///     var point = bounds.origin
    ///     for (index, subview) in subviews.enumerated() {
    ///         if index > 0 { point.y += spacing[index - 1] } // Add spacing.
    ///         subview.place(at: point, anchor: .topLeading, proposal: .unspecified)
    ///         point.y += subview.dimensions(in: .unspecified).height
    ///     }
    ///
    /// Be sure that you use computations during placement that are consistent
    /// with those in your implementation of other protocol methods for a given
    /// set of inputs. For example, if you add spacing during placement,
    /// make sure your implementation of
    /// ``sizeThatFits(proposal:subviews:cache:)`` accounts for the extra space.
    /// Similarly, if the sizing method returns different values for different
    /// size proposals, make sure the placement method responds to its
    /// `proposal` input in the same way.
    ///
    /// - Parameters:
    ///   - bounds: The region that the container view's parent allocates to the
    ///     container view, specified in the parent's coordinate space.
    ///     Place all the container's subviews within the region.
    ///     The size of this region matches a size that your container
    ///     previously returned from a call to the
    ///     ``sizeThatFits(proposal:subviews:cache:)`` method.
    ///   - proposal: The size proposal from which the container generated the
    ///     size that the parent used to create the `bounds` parameter.
    ///     The parent might propose more than one size before calling the
    ///     placement method, but it always uses one of the proposals and the
    ///     corresponding returned size when placing the container.
    ///   - subviews: A collection of proxies that represent the
    ///     views that the container arranges. Use the proxies in the collection
    ///     to get information about the subviews and to tell the subviews
    ///     where to appear.
    ///   - cache: Optional storage for calculated data that you can share among
    ///     the methods of your custom layout container. See
    ///     ``makeCache(subviews:)`` for details.
    public func placeSubviews(in bounds: CGRect, proposal: ProposedViewSize, subviews: GridLayout.Subviews, cache: inout GridLayout.Cache)

    /// Returns the position of the specified horizontal alignment guide along
    /// the x axis.
    ///
    /// Implement this method to return a value for the specified alignment
    /// guide of a custom layout container. The value you return affects
    /// the placement of the container as a whole, but it doesn't affect how the
    /// container arranges subviews relative to one another.
    ///
    /// You can use this method to put an alignment guide in a nonstandard
    /// position. For example, you can indent the container's leading edge
    /// alignment guide by 10 points:
    ///
    ///     extension BasicVStack {
    ///         func explicitAlignment(
    ///             of guide: HorizontalAlignment,
    ///             in bounds: CGRect,
    ///             proposal: ProposedViewSize,
    ///             subviews: Subviews,
    ///             cache: inout ()
    ///         ) -> CGFloat? {
    ///             if guide == .leading {
    ///                 return bounds.minX + 10
    ///             }
    ///             return nil
    ///         }
    ///     }
    ///
    /// The above example returns `nil` for other guides to indicate that they
    /// don't have an explicit value. A guide without an explicit value behaves
    /// as it would for any other view. If you don't implement the
    /// method, the protocol's default implementation merges the
    /// subviews' guides.
    ///
    /// - Parameters:
    ///   - guide: The ``HorizontalAlignment`` guide that the method calculates
    ///     the position of.
    ///   - bounds: The region that the container view's parent allocates to the
    ///     container view, specified in the parent's coordinate space.
    ///   - proposal: A proposed size for the container.
    ///   - subviews: A collection of proxy instances that represent the
    ///     views arranged by the container. You can use the proxies in the
    ///     collection to get information about the subviews as you determine
    ///     where to place the guide.
    ///   - cache: Optional storage for calculated data that you can share among
    ///     the methods of your custom layout container. See
    ///     ``makeCache(subviews:)`` for details.
    ///
    /// - Returns: The guide's position relative to the `bounds`.
    ///   Return `nil` to indicate that the guide doesn't have an explicit
    ///   value.
    public func explicitAlignment(of guide: HorizontalAlignment, in bounds: CGRect, proposal: ProposedViewSize, subviews: GridLayout.Subviews, cache: inout GridLayout.Cache) -> CGFloat?

    /// Returns the position of the specified vertical alignment guide along
    /// the y axis.
    ///
    /// Implement this method to return a value for the specified alignment
    /// guide of a custom layout container. The value you return affects
    /// the placement of the container as a whole, but it doesn't affect how the
    /// container arranges subviews relative to one another.
    ///
    /// You can use this method to put an alignment guide in a nonstandard
    /// position. For example, you can raise the container's bottom edge
    /// alignment guide by 10 points:
    ///
    ///     extension BasicVStack {
    ///         func explicitAlignment(
    ///             of guide: VerticalAlignment,
    ///             in bounds: CGRect,
    ///             proposal: ProposedViewSize,
    ///             subviews: Subviews,
    ///             cache: inout ()
    ///         ) -> CGFloat? {
    ///             if guide == .bottom {
    ///                 return bounds.minY - 10
    ///             }
    ///             return nil
    ///         }
    ///     }
    ///
    /// The above example returns `nil` for other guides to indicate that they
    /// don't have an explicit value. A guide without an explicit value behaves
    /// as it would for any other view. If you don't implement the
    /// method, the protocol's default implementation merges the
    /// subviews' guides.
    ///
    /// - Parameters:
    ///   - guide: The ``VerticalAlignment`` guide that the method calculates
    ///     the position of.
    ///   - bounds: The region that the container view's parent allocates to the
    ///     container view, specified in the parent's coordinate space.
    ///   - proposal: A proposed size for the container.
    ///   - subviews: A collection of proxy instances that represent the
    ///     views arranged by the container. You can use the proxies in the
    ///     collection to get information about the subviews as you determine
    ///     where to place the guide.
    ///   - cache: Optional storage for calculated data that you can share among
    ///     the methods of your custom layout container. See
    ///     ``makeCache(subviews:)`` for details.
    ///
    /// - Returns: The guide's position relative to the `bounds`.
    ///   Return `nil` to indicate that the guide doesn't have an explicit
    ///   value.
    public func explicitAlignment(of guide: VerticalAlignment, in bounds: CGRect, proposal: ProposedViewSize, subviews: GridLayout.Subviews, cache: inout GridLayout.Cache) -> CGFloat?

    /// The type defining the data to animate.
    @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
    public typealias AnimatableData = EmptyAnimatableData
}

@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension GridLayout {

    /// A stateful grid layout algorithm.
    @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
    public struct Cache {
    }
}

@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension GridLayout : Sendable {
}

@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension GridLayout : BitwiseCopyable {
}

/// A horizontal row in a two dimensional grid container.
///
/// Use one or more `GridRow` instances to define the rows of a ``Grid``
/// container. The child views inside the row define successive grid cells.
/// You can add rows to the grid explicitly, or use the ``ForEach`` structure
/// to generate multiple rows. Similarly, you can add cells to the row
/// explicitly or you can use ``ForEach`` to generate multiple cells inside
/// the row. The following example mixes these strategies:
///
///     Grid {
///         GridRow {
///             Color.clear
///                 .gridCellUnsizedAxes([.horizontal, .vertical])
///             ForEach(1..<4) { column in
///                 Text("C\(column)")
///             }
///         }
///         ForEach(1..<4) { row in
///             GridRow {
///                 Text("R\(row)")
///                 ForEach(1..<4) { _ in
///                     Circle().foregroundStyle(.mint)
///                 }
///             }
///         }
///     }
///
/// The grid in the example above has an explicit first row and three generated
/// rows. Similarly, each row has an explicit first cell and three generated
/// cells:
///
/// ![A screenshot of a grid that contains four rows and four columns. Scanning
/// from left to right, the first row contains an empty cell followed by cells
/// with the strings C1, C2, and C3. Scanning from top to bottom, the first
/// column contains an empty cell, followed by cells with the strings R1, R2,
/// and R3. All the other cells contain circles in a mint color.](GridRow-1-iOS)
///
/// To create an empty cell, use something invisible, like the
/// ``ShapeStyle/clear`` color that appears in the first column of the first
/// row in the example above. However, if you use a flexible view like a
/// ``Color`` or a ``Spacer``, you might also need to add the
/// ``View/gridCellUnsizedAxes(_:)`` modifier to prevent the view from
/// taking up more space than the other cells in the row or column need.
///
/// > Important: You can't use ``EmptyView`` to create a blank cell because
/// that resolves to the absence of a view and doesn't generate a cell.
///
/// By default, the cells in the row use the ``Alignment`` that you define
/// when you initialize the ``Grid``. However, you can override the vertical
/// alignment for the cells in a row by providing a ``VerticalAlignment``
/// value to the row's ``init(alignment:content:)`` initializer.
///
/// If you apply a view modifier to a row, the row applies the modifier to
/// all of the cells, similar to how a ``Group`` behaves. For example,  if
/// you apply the ``View/border(_:width:)`` modifier to a row, SwiftUI draws
/// a border on each cell in the row rather than around the row.
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
@frozen public struct GridRow<Content> where Content : View {

    /// Creates a horizontal row of child views in a grid.
    ///
    /// Use this initializer to create a ``GridRow`` inside of a ``Grid``.
    /// Provide a content closure that defines the cells of the row, and
    /// optionally customize the vertical alignment of content within each cell.
    /// The following example customizes the vertical alignment of the cells
    /// in the first and third rows:
    ///
    ///     Grid(alignment: .trailing) {
    ///         GridRow(alignment: .top) { // Use top vertical alignment.
    ///             Text("Top")
    ///             Color.red.frame(width: 1, height: 50)
    ///             Color.blue.frame(width: 50, height: 1)
    ///         }
    ///         GridRow { // Use the default (center) alignment.
    ///             Text("Center")
    ///             Color.red.frame(width: 1, height: 50)
    ///             Color.blue.frame(width: 50, height: 1)
    ///         }
    ///         GridRow(alignment: .bottom) { // Use bottom vertical alignment.
    ///             Text("Bottom")
    ///             Color.red.frame(width: 1, height: 50)
    ///             Color.blue.frame(width: 50, height: 1)
    ///         }
    ///     }
    ///
    /// The example above specifies ``Alignment/trailing`` alignment for the
    /// grid, which is composed of ``VerticalAlignment/center`` vertical
    /// alignment and ``HorizontalAlignment/trailing`` horizontal alignment.
    /// The middle row relies on the center vertical alignment, but the
    /// other two rows specify custom vertical alignments:
    ///
    /// ![A grid with three rows and three columns. Scanning from top to bottom,
    /// the first column contains cells with the strings top, center, and
    /// bottom. All strings are horizontally aligned on the right and vertically
    /// aligned in a way that matches their content. The second column contains
    /// cells with red vertical lines. The lines consume both the full height
    /// and full width of the cells they occupy. The third column contains
    /// cells with blue horizontal lines that consume the full width of the
    /// cells they occupy, and that are vertically aligned in a way that matches
    /// the text in column one of the corresponding row.](GridRow-init-1-iOS)
    ///
    /// > Important: A grid row behaves like a ``Group`` if you create it
    /// outside of a grid.
    ///
    /// To override column alignment, use ``View/gridColumnAlignment(_:)``. To
    /// override alignment for a single cell, use ``View/gridCellAnchor(_:)``.
    ///
    /// - Parameters:
    ///   - alignment: An optional ``VerticalAlignment`` for the row. If you
    ///     don't specify a value, the row uses the vertical alignment component
    ///     of the ``Alignment`` parameter that you specify in the grid's
    ///     ``Grid/init(alignment:horizontalSpacing:verticalSpacing:content:)``
    ///     initializer, which is ``VerticalAlignment/center`` by default.
    ///   - content: The builder closure that contains the child views. Each
    ///     view in the closure implicitly maps to a cell in the grid.
    ///
    @inlinable public init(alignment: VerticalAlignment? = nil, @ViewBuilder content: () -> Content)

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
    public typealias Body = Never
}

@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension GridRow : View {
}

/// A stylized view, with an optional label, that visually collects a logical
/// grouping of content.
///
/// Use a group box when you want to visually distinguish a portion of your
/// user interface with an optional title for the boxed content.
///
/// The following example sets up a `GroupBox` with the label "End-User
/// Agreement", and a long `agreementText` string in a ``SwiftUI/Text`` view
/// wrapped by a ``SwiftUI/ScrollView``. The box also contains a
/// ``SwiftUI/Toggle`` for the user to interact with after reading the text.
///
///     var body: some View {
///         GroupBox(label:
///             Label("End-User Agreement", systemImage: "building.columns")
///         ) {
///             ScrollView(.vertical, showsIndicators: true) {
///                 Text(agreementText)
///                     .font(.footnote)
///             }
///             .frame(height: 100)
///             Toggle(isOn: $userAgreed) {
///                 Text("I agree to the above terms")
///             }
///         }
///     }
///
/// ![An iOS status bar above a gray rounded rectangle region marking the bounds
/// of the group box. At the top of the region, the title End-User Agreement
/// in a large bold font with an icon of a building with columns. Below this,
/// a scroll view with six lines of text visible. At the bottom of the gray
/// group box region, a toggle switch with the label I agree to the above
/// terms.](SwiftUI-GroupBox-EULA.png)
///
@available(iOS 14.0, macOS 10.15, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct GroupBox<Label, Content> : View where Label : View, Content : View {

    /// Creates a group box with the provided label and view content.
    /// - Parameters:
    ///   - content: A ``SwiftUI/ViewBuilder`` that produces the content for the
    ///     group box.
    ///   - label: A ``SwiftUI/ViewBuilder`` that produces a label for the group
    ///     box.
    @available(iOS 14.0, macOS 10.15, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public init(@ViewBuilder content: () -> Content, @ViewBuilder label: () -> Label)

    /// The content and behavior of the view.
    ///
    /// When you implement a custom view, you must implement a computed
    /// `body` property to provide the content for your view. Return a view
    /// that's composed of built-in views that SwiftUI provides, plus other
    /// composite views that you've already defined:
    ///
    ///     struct MyView: View {
    ///         var body: some View {
    ///             Text("Hello, World!")
    ///         }
    ///     }
    ///
    /// For more information about composing views and a view hierarchy,
    /// see <doc:Declaring-a-Custom-View>.
    @MainActor @preconcurrency public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    @available(iOS 14.0, macOS 10.15, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias Body = some View
}

@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension GroupBox where Label == GroupBoxStyleConfiguration.Label, Content == GroupBoxStyleConfiguration.Content {

    /// Creates a group box based on a style configuration.
    ///
    /// Use this initializer within the ``GroupBoxStyle/makeBody(configuration:)``
    /// method of a ``GroupBoxStyle`` instance to create a styled group box,
    /// with customizations, while preserving its existing style.
    ///
    /// The following example adds a pink border around the group box,
    /// without overriding its current style:
    ///
    ///     struct PinkBorderGroupBoxStyle: GroupBoxStyle {
    ///         func makeBody(configuration: Configuration) -> some View {
    ///             GroupBox(configuration)
    ///                 .border(Color.pink)
    ///         }
    ///     }
    /// - Parameter configuration: The properties of the group box instance being created.
    nonisolated public init(_ configuration: GroupBoxStyleConfiguration)
}

@available(iOS 14.0, macOS 10.15, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension GroupBox where Label == EmptyView {

    /// Creates an unlabeled group box with the provided view content.
    /// - Parameters:
    ///   - content: A ``SwiftUI/ViewBuilder`` that produces the content for
    ///    the group box.
    nonisolated public init(@ViewBuilder content: () -> Content)
}

@available(iOS 15.0, macOS 12.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension GroupBox where Label == Text {

    /// Creates a group box with the provided view content and title.
    /// - Parameters:
    ///   - titleKey: The key for the group box's title, which describes the
    ///     content of the group box.
    ///   - content: A ``SwiftUI/ViewBuilder`` that produces the content for the
    ///     group box.
    nonisolated public init(_ titleKey: LocalizedStringKey, @ViewBuilder content: () -> Content)

    /// Creates a group box with the provided view content.
    /// - Parameters:
    ///   - title: A string that describes the content of the group box.
    ///   - content: A ``SwiftUI/ViewBuilder`` that produces the content for the
    ///     group box.
    nonisolated public init<S>(_ title: S, @ViewBuilder content: () -> Content) where S : StringProtocol
}

@available(iOS 14.0, macOS 10.15, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension GroupBox {

    @available(iOS, deprecated: 100000.0, renamed: "GroupBox(content:label:)")
    @available(macOS, deprecated: 100000.0, renamed: "GroupBox(content:label:)")
    @available(visionOS, deprecated: 100000.0, renamed: "GroupBox(content:label:)")
    nonisolated public init(label: Label, @ViewBuilder content: () -> Content)
}

/// A type that specifies the appearance and interaction of all group boxes
/// within a view hierarchy.
///
/// To configure the current `GroupBoxStyle` for a view hierarchy, use the
/// ``View/groupBoxStyle(_:)`` modifier.
@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@MainActor @preconcurrency public protocol GroupBoxStyle {

    /// A view that represents the body of a group box.
    associatedtype Body : View

    /// Creates a view representing the body of a group box.
    ///
    /// SwiftUI calls this method for each instance of ``SwiftUI/GroupBox``
    /// created within a view hierarchy where this style is the current
    /// group box style.
    ///
    /// - Parameter configuration: The properties of the group box instance being
    ///   created.
    @ViewBuilder @MainActor @preconcurrency func makeBody(configuration: Self.Configuration) -> Self.Body

    /// The properties of a group box instance.
    typealias Configuration = GroupBoxStyleConfiguration
}

@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension GroupBoxStyle where Self == DefaultGroupBoxStyle {

    /// The default style for group box views.
    @MainActor @preconcurrency public static var automatic: DefaultGroupBoxStyle { get }
}

/// The properties of a group box instance.
@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct GroupBoxStyleConfiguration {

    /// A type-erased label of a group box.
    @MainActor @preconcurrency public struct Label : View {

        /// The type of view representing the body of this view.
        ///
        /// When you create a custom view, Swift infers this type from your
        /// implementation of the required ``View/body-swift.property`` property.
        @available(iOS 14.0, macOS 11.0, *)
        @available(tvOS, unavailable)
        @available(watchOS, unavailable)
        public typealias Body = Never
    }

    /// A type-erased content of a group box.
    @MainActor @preconcurrency public struct Content : View {

        /// The type of view representing the body of this view.
        ///
        /// When you create a custom view, Swift infers this type from your
        /// implementation of the required ``View/body-swift.property`` property.
        @available(iOS 14.0, macOS 11.0, *)
        @available(tvOS, unavailable)
        @available(watchOS, unavailable)
        public typealias Body = Never
    }

    /// A view that provides the title of the group box.
    public let label: GroupBoxStyleConfiguration.Label

    /// A view that represents the content of the group box.
    public let content: GroupBoxStyleConfiguration.Content
}

/// Transforms the subviews of a given view into a resulting content view.
///
/// You don't use this type directly. Instead SwiftUI creates this type on
/// your behalf.
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct GroupElementsOfContent<Subviews, Content> : View where Subviews : View, Content : View {

    /// The content and behavior of the view.
    ///
    /// When you implement a custom view, you must implement a computed
    /// `body` property to provide the content for your view. Return a view
    /// that's composed of built-in views that SwiftUI provides, plus other
    /// composite views that you've already defined:
    ///
    ///     struct MyView: View {
    ///         var body: some View {
    ///             Text("Hello, World!")
    ///         }
    ///     }
    ///
    /// For more information about composing views and a view hierarchy,
    /// see <doc:Declaring-a-Custom-View>.
    @MainActor @preconcurrency public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias Body = some View
}

/// Transforms the sections of a given view into a resulting content view.
///
/// You don't use this type directly. Instead SwiftUI creates this type on
/// your behalf.
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct GroupSectionsOfContent<Sections, Content> : View where Sections : View, Content : View {

    /// The content and behavior of the view.
    ///
    /// When you implement a custom view, you must implement a computed
    /// `body` property to provide the content for your view. Return a view
    /// that's composed of built-in views that SwiftUI provides, plus other
    /// composite views that you've already defined:
    ///
    ///     struct MyView: View {
    ///         var body: some View {
    ///             Text("Hello, World!")
    ///         }
    ///     }
    ///
    /// For more information about composing views and a view hierarchy,
    /// see <doc:Declaring-a-Custom-View>.
    @MainActor @preconcurrency public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias Body = some View
}

/// A form style with grouped rows.
///
/// Rows in this form style have leading aligned labels and trailing
/// aligned controls within visually grouped sections.
///
/// Use the ``FormStyle/grouped`` static variable to create this style:
///
///     Form {
///        ...
///     }
///     .formStyle(.grouped)
///
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct GroupedFormStyle : FormStyle {

    /// Creates a form style with scrolling, grouped rows.
    ///
    /// Don't call this initializer directly. Instead, use the
    /// ``FormStyle/grouped`` static variable to create this style:
    ///
    ///     Form {
    ///        ...
    ///     }
    ///     .formStyle(.grouped)
    ///
    public init()

    /// Creates a view that represents the body of a form.
    ///
    /// - Parameter configuration: The properties of the form.
    /// - Returns: A view that has behavior and appearance that enables it
    ///   to function as a ``Form``.
    @MainActor @preconcurrency public func makeBody(configuration: GroupedFormStyle.Configuration) -> some View


    /// A view that represents the appearance and interaction of a form.
    @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
    public typealias Body = some View
}

/// The list style that describes the behavior and appearance of a grouped list.
///
/// You can also use ``ListStyle/grouped`` to construct this style.
@available(iOS 13.0, tvOS 13.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
public struct GroupedListStyle : ListStyle {

    /// Creates a grouped list style.
    public init()
}

/// Hand gesture shortcuts describe finger and wrist movements that the user can
/// perform in order to activate a button or toggle.
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, *)
@available(visionOS, unavailable)
public struct HandGestureShortcut : Sendable, Equatable {

    /// The hand gesture shortcut for the primary action.
    ///
    /// On watchOS, this is performed by double-tapping the thumb and index
    /// finger together.
    public static let primaryAction: HandGestureShortcut

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: HandGestureShortcut, b: HandGestureShortcut) -> Bool
}

/// A hover effect that highlights views using a light source to indicate
/// position.
///
/// You can also use ``CustomHoverEffect/highlight`` to construct this hover
/// effect.
@available(iOS 18.0, tvOS 18.0, visionOS 2.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
public struct HighlightHoverEffect : CustomHoverEffect {

    /// Creates a highlight hover effect.
    public init()

    /// Defines the effect produced by this effect.
    ///
    /// You implement this method to describe a custom effect to apply to a
    /// view. `content` is an empty effect you use to build your effect, which
    /// will later be applied to a View, or combined with other
    /// `CustomHoverEffect`s.
    ///
    /// - Parameter content: An empty effect you use to compose the custom
    ///   effect.
    /// - Returns: A custom effect.
    public func body(content: HighlightHoverEffect.Content) -> some CustomHoverEffect


    /// The type of effect representing the body of this effect. When you create
    /// a custom effect, Swift infers this type from your implementation of the
    /// required ``CustomHoverEffect/body(content:)`` method.
    @available(iOS 18.0, tvOS 18.0, visionOS 2.0, *)
    @available(watchOS, unavailable)
    @available(macOS, unavailable)
    public typealias Body = some CustomHoverEffect
}

/// An effect applied when the pointer hovers over a view.
@available(iOS 13.4, tvOS 16.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
public struct HoverEffect {

    /// Create a `HoverEffect` that contains the specified custom hover effect.
    @available(iOS 18.0, tvOS 18.0, visionOS 2.0, *)
    @available(macOS, unavailable)
    @available(watchOS, unavailable)
    public init<E>(_ effect: E) where E : CustomHoverEffect

    /// An effect  that attempts to determine the effect automatically.
    /// This is the default effect.
    public static let automatic: HoverEffect

    /// An effect  that morphs the pointer into a platter behind the view
    /// and shows a light source indicating position.
    ///
    /// On tvOS, it applies a projection effect accompanied with a specular
    /// highlight on the view when contained within a focused view. It also
    /// incorporates motion effects to produce a parallax effect by adjusting
    /// the projection matrix and specular offset.
    @available(tvOS 17.0, *)
    public static let highlight: HoverEffect

    /// An effect that slides the pointer under the view and disappears as the
    /// view scales up and gains a shadow.
    public static let lift: HoverEffect
}

@available(iOS 18.0, tvOS 18.0, visionOS 2.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension HoverEffect : CustomHoverEffect {

    /// The type of effect representing the body of this effect. When you create
    /// a custom effect, Swift infers this type from your implementation of the
    /// required ``CustomHoverEffect/body(content:)`` method.
    @available(iOS 18.0, tvOS 18.0, visionOS 2.0, *)
    @available(watchOS, unavailable)
    @available(macOS, unavailable)
    public typealias Body = Never
}

/// The current hovering state and value of the pointer.
///
/// When you use the ``View/onContinuousHover(coordinateSpace:perform:)``
/// modifier, you can handle the hovering state using the `action` closure.
/// SwiftUI calls the closure with a phase value to indicate the current
/// hovering state. The following example updates `hoverLocation` and
/// `isHovering` based on the phase provided to the closure:
///
///     @State private var hoverLocation: CGPoint = .zero
///     @State private var isHovering = false
///
///     var body: some View {
///         VStack {
///             Color.red
///                 .frame(width: 400, height: 400)
///                 .onContinuousHover { phase in
///                     switch phase {
///                     case .active(let location):
///                         hoverLocation = location
///                         isHovering = true
///                     case .ended:
///                         isHovering = false
///                     }
///                 }
///                 .overlay {
///                     Rectangle()
///                         .frame(width: 50, height: 50)
///                         .foregroundColor(isHovering ? .green : .blue)
///                         .offset(x: hoverLocation.x, y: hoverLocation.y)
///                 }
///         }
///     }
///
@available(iOS 16.0, macOS 13.0, tvOS 16.0, *)
@available(watchOS, unavailable)
@frozen public enum HoverPhase : Equatable {

    /// The pointer's location moved to the specified point within the view.
    case active(CGPoint)

    /// The pointer exited the view.
    case ended

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: HoverPhase, b: HoverPhase) -> Bool
}

@available(iOS 16.0, macOS 13.0, tvOS 16.0, *)
@available(watchOS, unavailable)
extension HoverPhase : Sendable {
}

@available(iOS 16.0, macOS 13.0, tvOS 16.0, *)
@available(watchOS, unavailable)
extension HoverPhase : BitwiseCopyable {
}

/// A label style that only displays the icon of the label.
///
/// You can also use ``LabelStyle/iconOnly`` to construct this style.
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public struct IconOnlyLabelStyle : LabelStyle {

    /// Creates an icon-only label style.
    public init()

    /// Creates a view that represents the body of a label.
    ///
    /// The system calls this method for each ``Label`` instance in a view
    /// hierarchy where this style is the current label style.
    ///
    /// - Parameter configuration: The properties of the label.
    @MainActor @preconcurrency public func makeBody(configuration: IconOnlyLabelStyle.Configuration) -> some View


    /// A view that represents the body of a label.
    @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
    public typealias Body = some View
}

/// An object that creates images from SwiftUI views.
///
/// Use `ImageRenderer` to export bitmap image data from a SwiftUI view. You
/// initialize the renderer with a view, then render images on demand,
/// either by calling the ``render(rasterizationScale:renderer:)`` method, or
/// by using the renderer's properties to create a
/// <doc://com.apple.documentation/documentation/CoreGraphics/CGImage>,
/// <doc://com.apple.documentation/documentation/AppKit/NSImage>, or
/// <doc://com.apple.documentation/documentation/UIKit/UIImage>.
///
/// By drawing to a ``Canvas`` and exporting with an `ImageRenderer`,
/// you can generate images from any progammatically-rendered content, like
/// paths, shapes, gradients, and more. You can also render standard SwiftUI
/// views like ``Text`` views, or containers of multiple view types.
///
/// The following example uses a private `createAwardView(forUser:date:)` method
/// to create a game app's view of a trophy symbol with a user name and date.
/// This view combines a ``Canvas`` that applies a shadow filter with
/// two ``Text`` views into a ``VStack``. A ``Button`` allows the person to
/// save this view. The button's action uses an `ImageRenderer` to rasterize a
/// `CGImage` and then calls a private `uploadAchievementImage(_:)` method to
/// encode and upload the image.
///
///     var body: some View {
///         let trophyAndDate = createAwardView(forUser: playerName,
///                                              date: achievementDate)
///         VStack {
///             trophyAndDate
///             Button("Save Achievement") {
///                 let renderer = ImageRenderer(content: trophyAndDate)
///                 if let image = renderer.cgImage {
///                     uploadAchievementImage(image)
///                 }
///             }
///         }
///     }
///
///     private func createAwardView(forUser: String, date: Date) -> some View {
///         VStack {
///             Image(systemName: "trophy")
///                 .resizable()
///                 .frame(width: 200, height: 200)
///                 .frame(maxWidth: .infinity, maxHeight: .infinity)
///                 .shadow(color: .mint, radius: 5)
///             Text(playerName)
///                 .font(.largeTitle)
///             Text(achievementDate.formatted())
///         }
///         .multilineTextAlignment(.center)
///         .frame(width: 200, height: 290)
///     }
///
/// ![A large trophy symbol, drawn with a mint-colored shadow. Below this, a
/// user name and the date and time. At the bottom, a button with the title
/// Save Achievement allows people to save and upload an image of this
/// view.](ImageRenderer-1)
///
/// Because `ImageRenderer` conforms to
/// <doc://com.apple.documentation/documentation/Combine/ObservableObject>, you
/// can use it to produce a stream of images as its properties change. Subscribe
/// to the renderer's ``ImageRenderer/objectWillChange`` publisher, then use the
/// renderer to rasterize a new image each time the subscriber receives an
/// update.
///
/// - Important: `ImageRenderer` output only includes views that SwiftUI renders,
/// such as text, images, shapes, and composite views of these types. It
/// does not render views provided by native platform frameworks (AppKit and
/// UIKit) such as web views, media players, and some controls. For these views,
/// `ImageRenderer` displays a placeholder image, similar to the behavior of
/// ``View/drawingGroup(opaque:colorMode:)``.
///
/// ### Rendering to a PDF context
///
/// The ``render(rasterizationScale:renderer:)`` method renders the specified
/// view to any
/// <doc://com.apple.documentation/documentation/CoreGraphics/CGContext>. That
/// means you aren't limited to creating a rasterized `CGImage`. For
/// example, you can generate PDF data by rendering to a PDF context. The
/// resulting PDF maintains resolution-independence for supported members of the
/// view hierarchy, such as text, symbol images, lines, shapes, and fills.
///
/// The following example uses the `createAwardView(forUser:date:)` method from
/// the previous example, and exports its contents as an 800-by-600 point PDF to
/// the file URL `renderURL`. It uses the `size` parameter sent to the
/// rendering closure to center the `trophyAndDate` view vertically and
/// horizontally on the page.
///
///     var body: some View {
///         let trophyAndDate = createAwardView(forUser: playerName,
///                                             date: achievementDate)
///         VStack {
///             trophyAndDate
///             Button("Save Achievement") {
///                 let renderer = ImageRenderer(content: trophyAndDate)
///                 renderer.render { size, renderer in
///                     var mediaBox = CGRect(origin: .zero,
///                                           size: CGSize(width: 800, height: 600))
///                     guard let consumer = CGDataConsumer(url: renderURL as CFURL),
///                           let pdfContext =  CGContext(consumer: consumer,
///                                                       mediaBox: &mediaBox, nil)
///                     else {
///                         return
///                     }
///                     pdfContext.beginPDFPage(nil)
///                     pdfContext.translateBy(x: mediaBox.size.width / 2 - size.width / 2,
///                                            y: mediaBox.size.height / 2 - size.height / 2)
///                     renderer(pdfContext)
///                     pdfContext.endPDFPage()
///                     pdfContext.closePDF()
///                 }
///             }
///         }
///     }
///
/// ### Creating an image from drawing instructions
///
/// `ImageRenderer` makes it possible to create a custom image by drawing into a
/// ``Canvas``, rendering a `CGImage` from it, and using that to initialize an
/// ``Image``. To simplify this process, use the `Image`
/// initializer ``Image/init(size:label:opaque:colorMode:renderer:)``, which
/// takes a closure whose argument is a ``GraphicsContext`` that you can
/// directly draw into.
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
final public class ImageRenderer<Content> : ObservableObject where Content : View {

    /// A publisher that informs subscribers of changes to the image.
    ///
    /// The renderer's
    /// <doc://com.apple.documentation/documentation/Combine/ObservableObject/ObjectWillChangePublisher>
    /// publishes `Void` elements.
    /// Subscribers should interpret any event as indicating that the contents
    /// of the image may have changed.
    final public let objectWillChange: PassthroughSubject<Void, Never>

    /// If observers of this observed object should be notified when the
    /// produced image changes.
    @available(iOS 17.2, macOS 14.2, tvOS 17.2, watchOS 10.2, *)
    final public var isObservationEnabled: Bool

    /// The root view rendered by this image renderer.
    @MainActor final public var content: Content

    /// The size proposed to the root view.
    ///
    /// The default value of this property, ``ProposedViewSize/unspecified``,
    /// produces an image that matches the original view size. You can provide
    /// a custom ``ProposedViewSize`` to override the view's size in one or
    /// both dimensions.
    @MainActor final public var proposedSize: ProposedViewSize

    /// The scale at which to render the image.
    ///
    /// This value is a ratio of view points to image pixels. This relationship
    /// means that values greater than `1.0` create an image larger than the
    /// original content view, and less than `1.0` creates a smaller image. The
    /// following example shows a 100 x 50 rectangle view and an image rendered
    /// from it with a `scale` of `2.0`, resulting in an image size of
    /// 200 x 100.
    ///
    ///     let rectangle = Rectangle()
    ///         .frame(width: 100, height: 50)
    ///     let renderer = ImageRenderer(content: rectangle)
    ///     renderer.scale = 2.0
    ///     if let rendered = renderer.cgImage {
    ///         print("Scaled image: \(rendered.width) x \(rendered.height)")
    ///     }
    ///     // Prints "Scaled image: 200 x 100"
    ///
    /// The default value of this property is `1.0`.
    @MainActor final public var scale: CGFloat

    /// A Boolean value that indicates whether the alpha channel of the image is
    /// fully opaque.
    ///
    /// Setting this value to `true`, meaning the alpha channel is opaque, may
    /// improve performance. Don't render non-opaque pixels to a renderer
    /// declared as opaque. This property defaults to `false`.
    @MainActor final public var isOpaque: Bool

    /// The working color space and storage format of the image.
    @MainActor final public var colorMode: ColorRenderingMode

    /// Creates a renderer object with a source content view.
    ///
    /// - Parameter view: A ``View`` to render.
    @MainActor public init(content view: Content)

    /// The current contents of the view, rasterized as a Core Graphics image.
    ///
    /// The renderer notifies its `objectWillChange` publisher when
    /// the contents of the image may have changed.
    @MainActor final public var cgImage: CGImage? { get }

    /// Draws the renderer's current contents to an arbitrary Core Graphics
    /// context.
    ///
    /// Use this method to rasterize the renderer's content to a
    /// <doc://com.apple.documentation/documentation/CoreGraphics/CGContext>
    /// you provide. The `renderer` closure receives two parameters: the current
    /// size of the view, and a function that renders the view to your
    /// `CGContext`. Implement the closure to provide a suitable `CGContext`,
    /// then invoke the function to render the content to that context.
    ///
    /// - Parameters:
    ///   - rasterizationScale: The scale factor for converting user
    ///     interface points to pixels when rasterizing parts of the
    ///     view that can't be represented as native Core Graphics drawing
    ///     commands.
    ///   - renderer: The closure that sets up the Core Graphics context and
    ///     renders the view. This closure receives two parameters: the size of
    ///     the view and a function that you invoke in the closure to render the
    ///     view at the reported size. This function takes a
    ///     <doc://com.apple.documentation/documentation/CoreGraphics/CGContext>
    ///     parameter, and assumes a bottom-left coordinate space origin.
    @MainActor final public func render(rasterizationScale: CGFloat = 1, renderer: (CGSize, (CGContext) -> Void) -> Void)

    /// The type of publisher that emits before the object has changed.
    @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
    public typealias ObjectWillChangePublisher = PassthroughSubject<Void, Never>
}

@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension ImageRenderer {

    /// The current contents of the view, rasterized as a UIKit image.
    ///
    /// The renderer notifies its `objectWillChange` publisher when
    /// the contents of the image may have changed.
    @MainActor final public var uiImage: UIImage? { get }
}

@available(iOS 17.1, macOS 14.1, tvOS 17.1, watchOS 10.1, *)
extension ImageRenderer : Observable {
}

/// Defines the implementation of all `IndexView` instances within a view
/// hierarchy.
///
/// To configure the current `IndexViewStyle` for a view hierarchy, use the
/// `.indexViewStyle()` modifier.
@available(iOS 14.0, tvOS 14.0, watchOS 8.0, *)
@available(macOS, unavailable)
public protocol IndexViewStyle {
}

@available(iOS 14.0, tvOS 14.0, watchOS 8.0, *)
@available(macOS, unavailable)
extension IndexViewStyle where Self == PageIndexViewStyle {

    /// An index view style that places a page index view over its content.
    public static var page: PageIndexViewStyle { get }

    /// An index view style that places a page index view over its content.
    ///
    /// - Parameter backgroundDisplayMode: The display mode of the background of
    ///   any page index views receiving this style
    public static func page(backgroundDisplayMode: PageIndexViewStyle.BackgroundDisplayMode) -> PageIndexViewStyle
}

/// A collection wrapper that iterates over the indices and identifiers of a
/// collection together.
///
/// You don't use this type directly. Instead SwiftUI creates this type on
/// your behalf.
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct IndexedIdentifierCollection<Base, ID> : Collection where Base : Collection, ID : Hashable {

    /// A type representing the sequence's elements.
    public struct Element {
    }

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    public typealias Index = Base.Index

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: IndexedIdentifierCollection<Base, ID>.Index { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.firstIndex(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: IndexedIdentifierCollection<Base, ID>.Index { get }

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    ///
    /// - Complexity: O(1)
    public subscript(position: IndexedIdentifierCollection<Base, ID>.Index) -> IndexedIdentifierCollection<Base, ID>.Element { get }

    /// Returns the position immediately after the given index.
    ///
    /// The successor of an index must be well defined. For an index `i` into a
    /// collection `c`, calling `c.index(after: i)` returns the same index every
    /// time.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: IndexedIdentifierCollection<Base, ID>.Index) -> IndexedIdentifierCollection<Base, ID>.Index

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
    public typealias Indices = DefaultIndices<IndexedIdentifierCollection<Base, ID>>

    /// A type that provides the collection's iteration interface and
    /// encapsulates its iteration state.
    ///
    /// By default, a collection conforms to the `Sequence` protocol by
    /// supplying `IndexingIterator` as its associated `Iterator`
    /// type.
    @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
    public typealias Iterator = IndexingIterator<IndexedIdentifierCollection<Base, ID>>

    /// A collection representing a contiguous subrange of this collection's
    /// elements. The subsequence shares indices with the original collection.
    ///
    /// The default subsequence type for collections that don't define their own
    /// is `Slice`.
    @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
    public typealias SubSequence = Slice<IndexedIdentifierCollection<Base, ID>>
}

@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension IndexedIdentifierCollection : BidirectionalCollection where Base : BidirectionalCollection {

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    public func index(before i: IndexedIdentifierCollection<Base, ID>.Index) -> IndexedIdentifierCollection<Base, ID>.Index
}

@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension IndexedIdentifierCollection : RandomAccessCollection where Base : RandomAccessCollection {
}

/// A `PickerStyle` where each option is displayed inline with other views in
/// the current container.
///
/// You can also use ``PickerStyle/inline`` to construct this style.
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public struct InlinePickerStyle : PickerStyle {

    /// Creates an inline picker style.
    public init()
}

/// The list style that describes the behavior and appearance of an inset
/// grouped list.
///
/// You can also use ``ListStyle/insetGrouped`` to construct this style.
@available(iOS 14.0, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct InsetGroupedListStyle : ListStyle {

    /// Creates an inset grouped list style.
    public init()
}

/// The list style that describes the behavior and appearance of an inset list.
///
/// You can also use ``ListStyle/inset`` to construct this style.
@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct InsetListStyle : ListStyle {

    /// Creates an inset list style.
    public init()
}

/// The table style that describes the behavior and appearance of a table with
/// its content and selection inset from the table edges.
///
/// You can also use ``TableStyle/inset`` to construct this style.
@available(iOS 16.0, macOS 12.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct InsetTableStyle : TableStyle {

    /// Creates a default inset table style, with alternating row backgrounds.
    public init()

    /// Creates a view that represents the body of a table.
    ///
    /// The system calls this method for each ``Table`` instance in a view
    /// hierarchy where this style is the current table style.
    ///
    /// - Parameter configuration: The properties of the table.
    @MainActor @preconcurrency public func makeBody(configuration: InsetTableStyle.Configuration) -> some View


    /// A view that represents the body of a table.
    @available(iOS 16.0, macOS 12.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias Body = some View
}

/// A built-in set of commands for manipulating inspectors.
///
/// `InspectorCommands` include a command for toggling the presented state of
/// the inspector with a keyboard shortcut of I.
///
/// These commands are optional and can be explicitly requested by passing a
/// value of this type to the ``Scene/commands(content:)`` modifier:
///
///     @State var presented = true
///     WindowGroup {
///         MainView()
///             .inspector(isPresented: $presented) {
///                 InspectorView()
///             }
///     }
///     .commands {
///         InspectorCommands()
///     }
@available(iOS 17.0, macOS 14.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct InspectorCommands : Commands {

    /// A new value describing the built-in inspector-related commands.
    public init()

    /// The contents of the command hierarchy.
    ///
    /// For any commands that you create, provide a computed `body` property
    /// that defines the scene as a composition of other scenes. You can
    /// assemble a command hierarchy from built-in commands that SwiftUI
    /// provides, as well as other commands that you've defined.
    @MainActor @preconcurrency public var body: some Commands { get }

    /// The type of commands that represents the body of this command hierarchy.
    ///
    /// When you create custom commands, Swift infers this type from your
    /// implementation of the required ``SwiftUI/Commands/body-swift.property``
    /// property.
    @available(iOS 17.0, macOS 14.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias Body = some Commands
}

/// The orientation of the interface from the user's perspective.
///
/// By default, device previews appear right side up, using orientation
/// ``InterfaceOrientation/portrait``. You can change the orientation
/// with a call to the ``View/previewInterfaceOrientation(_:)`` modifier:
///
///     struct CircleImage_Previews: PreviewProvider {
///         static var previews: some View {
///             CircleImage()
///                 .previewInterfaceOrientation(.landscapeRight)
///         }
///     }
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public struct InterfaceOrientation : CaseIterable, Identifiable, Equatable, Sendable {

    /// A collection of all values of this type.
    public static var allCases: [InterfaceOrientation] { get }

    /// The stable identity of the entity associated with this instance.
    public var id: String { get }

    /// The device is in portrait mode, with the top of the device on top.
    public static let portrait: InterfaceOrientation

    /// The device is in portrait mode, but is upside down.
    public static let portraitUpsideDown: InterfaceOrientation

    /// The device is in landscape mode, with the top of the device on the left.
    public static let landscapeLeft: InterfaceOrientation

    /// The device is in landscape mode, with the top of the device on the right.
    public static let landscapeRight: InterfaceOrientation

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: InterfaceOrientation, b: InterfaceOrientation) -> Bool

    /// A type that can represent a collection of all values of this type.
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias AllCases = [InterfaceOrientation]

    /// A type representing the stable identity of the entity associated with
    /// an instance.
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias ID = String
}

/// A table row modifier that associates an item provider with some base
/// row content.
@available(iOS 16.0, macOS 12.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@MainActor @preconcurrency public struct ItemProviderTableRowModifier {

    @MainActor @preconcurrency public var body: some _TableRowContentModifier { get }

    @available(iOS 16.0, macOS 12.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias Body = some _TableRowContentModifier
}

/// Key equivalents consist of a letter, punctuation, or function key that can
/// be combined with an optional set of modifier keys to specify a keyboard
/// shortcut.
///
/// Key equivalents are used to establish keyboard shortcuts to app
/// functionality. Any key can be used as a key equivalent as long as pressing
/// it produces a single character value. Key equivalents are typically
/// initialized using a single-character string literal, with constants for
/// unprintable or hard-to-type values.
///
/// The modifier keys necessary to type a key equivalent are factored in to the
/// resulting keyboard shortcut. That is, a key equivalent whose raw value is
/// the capitalized string "A" corresponds with the keyboard shortcut
/// Command-Shift-A. The exact mapping may depend on the keyboard layoutfor
/// example, a key equivalent with the character value "}" produces a shortcut
/// equivalent to Command-Shift-] on ANSI keyboards, but would produce a
/// different shortcut for keyboard layouts where punctuation characters are in
/// different locations.
@available(iOS 14.0, macOS 11.0, tvOS 17.0, *)
@available(watchOS, unavailable)
public struct KeyEquivalent : Sendable {

    /// Up Arrow (U+F700)
    public static let upArrow: KeyEquivalent

    /// Down Arrow (U+F701)
    public static let downArrow: KeyEquivalent

    /// Left Arrow (U+F702)
    public static let leftArrow: KeyEquivalent

    /// Right Arrow (U+F703)
    public static let rightArrow: KeyEquivalent

    /// Escape (U+001B)
    public static let escape: KeyEquivalent

    /// Delete (U+0008)
    public static let delete: KeyEquivalent

    /// Delete Forward (U+F728)
    public static let deleteForward: KeyEquivalent

    /// Home (U+F729)
    public static let home: KeyEquivalent

    /// End (U+F72B)
    public static let end: KeyEquivalent

    /// Page Up (U+F72C)
    public static let pageUp: KeyEquivalent

    /// Page Down (U+F72D)
    public static let pageDown: KeyEquivalent

    /// Clear (U+F739)
    public static let clear: KeyEquivalent

    /// Tab (U+0009)
    public static let tab: KeyEquivalent

    /// Space (U+0020)
    public static let space: KeyEquivalent

    /// Return (U+000D)
    public static let `return`: KeyEquivalent

    /// The character value that the key equivalent represents.
    public var character: Character

    /// Creates a new key equivalent from the given character value.
    public init(_ character: Character)
}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, *)
@available(watchOS, unavailable)
extension KeyEquivalent : Hashable {

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: KeyEquivalent, b: KeyEquivalent) -> Bool

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

@available(iOS 14.0, macOS 11.0, tvOS 17.0, *)
@available(watchOS, unavailable)
extension KeyEquivalent : ExpressibleByExtendedGraphemeClusterLiteral {

    /// Creates an instance initialized to the given value.
    ///
    /// - Parameter value: The value of the new instance.
    public init(extendedGraphemeClusterLiteral: Character)

    /// A type that represents an extended grapheme cluster literal.
    ///
    /// Valid types for `ExtendedGraphemeClusterLiteralType` are `Character`,
    /// `String`, and `StaticString`.
    @available(iOS 14.0, tvOS 17.0, macOS 11.0, *)
    @available(watchOS, unavailable)
    public typealias ExtendedGraphemeClusterLiteralType = Character

    /// A type that represents a Unicode scalar literal.
    ///
    /// Valid types for `UnicodeScalarLiteralType` are `Unicode.Scalar`,
    /// `Character`, `String`, and `StaticString`.
    @available(iOS 14.0, tvOS 17.0, macOS 11.0, *)
    @available(watchOS, unavailable)
    public typealias UnicodeScalarLiteralType = Character
}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, *)
@available(watchOS, unavailable)
public struct KeyPress : Sendable {

    /// The phase of the key-press event (`.down`, `.repeat`, or `.up`).
    public let phase: KeyPress.Phases

    /// The key equivalent value for the pressed key.
    public let key: KeyEquivalent

    /// The characters generated by the pressed key as if no modifier
    /// key applies.
    public let characters: String

    /// The set of modifier keys the user held in addition to the
    /// pressed key.
    public let modifiers: EventModifiers
}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, *)
@available(watchOS, unavailable)
extension KeyPress : CustomDebugStringConvertible {

    /// Options for matching different phases of a key-press event.
    public struct Phases : OptionSet, Sendable, CustomDebugStringConvertible {

        /// The user pressed down on a key.
        public static let down: KeyPress.Phases

        /// The user held a key down to issue a sequence of repeating events.
        public static let `repeat`: KeyPress.Phases

        /// The user released a key.
        public static let up: KeyPress.Phases

        /// A value that matches all key press phases.
        public static let all: KeyPress.Phases

        /// A textual representation of this instance, suitable for debugging.
        ///
        /// Calling this property directly is discouraged. Instead, convert an
        /// instance of any type to a string by using the `String(reflecting:)`
        /// initializer. This initializer works with any type, and uses the custom
        /// `debugDescription` property for types that conform to
        /// `CustomDebugStringConvertible`:
        ///
        ///     struct Point: CustomDebugStringConvertible {
        ///         let x: Int, y: Int
        ///
        ///         var debugDescription: String {
        ///             return "(\(x), \(y))"
        ///         }
        ///     }
        ///
        ///     let p = Point(x: 21, y: 30)
        ///     let s = String(reflecting: p)
        ///     print(s)
        ///     // Prints "(21, 30)"
        ///
        /// The conversion of `p` to a string in the assignment to `s` uses the
        /// `Point` type's `debugDescription` property.
        public var debugDescription: String { get }

        /// The corresponding value of the raw type.
        ///
        /// A new instance initialized with `rawValue` will be equivalent to this
        /// instance. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     let selectedSize = PaperSize.Letter
        ///     print(selectedSize.rawValue)
        ///     // Prints "Letter"
        ///
        ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
        ///     // Prints "true"
        public let rawValue: Int

        /// Creates a new option set from the given raw value.
        ///
        /// This initializer always succeeds, even if the value passed as `rawValue`
        /// exceeds the static properties declared as part of the option set. This
        /// example creates an instance of `ShippingOptions` with a raw value beyond
        /// the highest element, with a bit mask that effectively contains all the
        /// declared static members.
        ///
        ///     let extraOptions = ShippingOptions(rawValue: 255)
        ///     print(extraOptions.isStrictSuperset(of: .all))
        ///     // Prints "true"
        ///
        /// - Parameter rawValue: The raw value of the option set to create. Each bit
        ///   of `rawValue` potentially represents an element of the option set,
        ///   though raw values may include bits that are not defined as distinct
        ///   values of the `OptionSet` type.
        public init(rawValue: Int)

        /// The type of the elements of an array literal.
        @available(iOS 17.0, tvOS 17.0, macOS 14.0, *)
        @available(watchOS, unavailable)
        public typealias ArrayLiteralElement = KeyPress.Phases

        /// The element type of the option set.
        ///
        /// To inherit all the default implementations from the `OptionSet` protocol,
        /// the `Element` type must be `Self`, the default.
        @available(iOS 17.0, tvOS 17.0, macOS 14.0, *)
        @available(watchOS, unavailable)
        public typealias Element = KeyPress.Phases

        /// The raw type that can be used to represent all values of the conforming
        /// type.
        ///
        /// Every distinct value of the conforming type has a corresponding unique
        /// value of the `RawValue` type, but there may be values of the `RawValue`
        /// type that don't have a corresponding value of the conforming type.
        @available(iOS 17.0, tvOS 17.0, macOS 14.0, *)
        @available(watchOS, unavailable)
        public typealias RawValue = Int
    }

    /// A result value returned from a key-press action that indicates whether
    /// the action consumed the event.
    public enum Result : Sendable {

        /// The action consumed the event, preventing dispatch from continuing.
        case handled

        /// The action ignored the event, allowing dispatch to continue.
        case ignored

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: KeyPress.Result, b: KeyPress.Result) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// A textual representation of this instance, suitable for debugging.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(reflecting:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `debugDescription` property for types that conform to
    /// `CustomDebugStringConvertible`:
    ///
    ///     struct Point: CustomDebugStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var debugDescription: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(reflecting: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `debugDescription` property.
    public var debugDescription: String { get }
}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, *)
@available(watchOS, unavailable)
extension KeyPress.Result : Equatable {
}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, *)
@available(watchOS, unavailable)
extension KeyPress.Result : Hashable {
}

/// Keyboard shortcuts describe combinations of keys on a keyboard that the user
/// can press in order to activate a button or toggle.
@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct KeyboardShortcut : Sendable {

    /// Options for how a keyboard shortcut participates in automatic localization.
    ///
    /// A shortcut's `key` that is defined on an US-English keyboard
    /// layout might not be reachable on international layouts.
    /// For example the shortcut `[` works well for the US layout but is
    /// hard to reach for German users.
    /// On the German keyboard layout, pressing `5` will produce
    /// `[`, which causes the shortcut to become `5`.
    /// If configured, which is the default behavior, automatic shortcut
    /// remapping will convert it to ``.
    ///
    /// In addition to that, some keyboard shortcuts carry information
    /// about directionality.
    /// Right-aligning a block of text or seeking forward in context of music
    /// playback are such examples. These kinds of shortcuts benefit from the option
    /// ``KeyboardShortcut/Localization-swift.struct/withoutMirroring``
    /// to tell the system that they won't be flipped when running in a
    /// right-to-left context.
    @available(iOS 15.0, macOS 12.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public struct Localization : Sendable {

        /// Remap shortcuts to their international counterparts, mirrored for
        /// right-to-left usage if appropriate.
        ///
        /// This is the default configuration.
        public static let automatic: KeyboardShortcut.Localization

        /// Don't mirror shortcuts.
        ///
        /// Use this for shortcuts that always have a specific directionality, like
        /// aligning something on the right.
        ///
        /// Don't use this option for navigational shortcuts like "Go Back" because navigation
        /// is flipped in right-to-left contexts.
        public static let withoutMirroring: KeyboardShortcut.Localization

        /// Don't use automatic shortcut remapping.
        ///
        /// When you use this mode, you have to take care of international use-cases separately.
        public static let custom: KeyboardShortcut.Localization
    }

    /// The standard keyboard shortcut for the default button, consisting of
    /// the Return () key and no modifiers.
    ///
    /// On macOS, the default button is designated with special coloration. If
    /// more than one control is assigned this shortcut, only the first one is
    /// emphasized.
    public static let defaultAction: KeyboardShortcut

    /// The standard keyboard shortcut for cancelling the in-progress action
    /// or dismissing a prompt, consisting of the Escape () key and no
    /// modifiers.
    public static let cancelAction: KeyboardShortcut

    /// The key equivalent that the user presses in conjunction with any
    /// specified modifier keys to activate the shortcut.
    public var key: KeyEquivalent

    /// The modifier keys that the user presses in conjunction with a key
    /// equivalent to activate the shortcut.
    public var modifiers: EventModifiers

    /// The localization strategy to apply to this shortcut.
    @available(iOS 15.0, macOS 12.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public var localization: KeyboardShortcut.Localization

    /// Creates a new keyboard shortcut with the given key equivalent and set of
    /// modifier keys.
    ///
    /// The localization configuration defaults to ``KeyboardShortcut/Localization-swift.struct/automatic``.
    public init(_ key: KeyEquivalent, modifiers: EventModifiers = .command)

    /// Creates a new keyboard shortcut with the given key equivalent and set of
    /// modifier keys.
    ///
    /// Use the `localization` parameter to specify a localization strategy
    /// for this shortcut.
    @available(iOS 15.0, macOS 12.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public init(_ key: KeyEquivalent, modifiers: EventModifiers = .command, localization: KeyboardShortcut.Localization)
}

@available(iOS 15.0, macOS 12.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension KeyboardShortcut : Hashable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: KeyboardShortcut, rhs: KeyboardShortcut) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

/// A standard label for user interface items, consisting of an icon with a
/// title.
///
/// One of the most common and recognizable user interface components is the
/// combination of an icon and a label. This idiom appears across many kinds of
/// apps and shows up in collections, lists, menus of action items, and
/// disclosable lists, just to name a few.
///
/// You create a label, in its simplest form, by providing a title and the name
/// of an image, such as an icon from the
/// <doc://com.apple.documentation/design/human-interface-guidelines/sf-symbols>
/// collection:
///
///     Label("Lightning", systemImage: "bolt.fill")
///
/// You can also apply styles to labels in several ways. In the case of dynamic
/// changes to the view after device rotation or change to a window size you
/// might want to show only the text portion of the label using the
/// ``LabelStyle/titleOnly`` label style:
///
///     Label("Lightning", systemImage: "bolt.fill")
///         .labelStyle(.titleOnly)
///
/// Conversely, there's also an icon-only label style:
///
///     Label("Lightning", systemImage: "bolt.fill")
///         .labelStyle(.iconOnly)
///
/// Some containers might apply a different default label style, such as only
/// showing icons within toolbars on macOS and iOS. To opt in to showing both
/// the title and the icon, you can apply the ``LabelStyle/titleAndIcon`` label
/// style:
///
///     Label("Lightning", systemImage: "bolt.fill")
///         .labelStyle(.titleAndIcon)
///
/// You can also create a customized label style by modifying an existing
/// style; this example adds a red border to the default label style:
///
///     struct RedBorderedLabelStyle: LabelStyle {
///         func makeBody(configuration: Configuration) -> some View {
///             Label(configuration)
///                 .border(Color.red)
///         }
///     }
///
/// For more extensive customization or to create a completely new label style,
/// you'll need to adopt the ``LabelStyle`` protocol and implement a
/// ``LabelStyleConfiguration`` for the new style.
///
/// To apply a common label style to a group of labels, apply the style
/// to the view hierarchy that contains the labels:
///
///     VStack {
///         Label("Rain", systemImage: "cloud.rain")
///         Label("Snow", systemImage: "snow")
///         Label("Sun", systemImage: "sun.max")
///     }
///     .labelStyle(.iconOnly)
///
/// It's also possible to make labels using views to compose the label's icon
/// programmatically, rather than using a pre-made image. In this example, the
/// icon portion of the label uses a filled ``Circle`` overlaid
/// with the user's initials:
///
///     Label {
///         Text(person.fullName)
///             .font(.body)
///             .foregroundColor(.primary)
///         Text(person.title)
///             .font(.subheadline)
///             .foregroundColor(.secondary)
///     } icon: {
///         Circle()
///             .fill(person.profileColor)
///             .frame(width: 44, height: 44, alignment: .center)
///             .overlay(Text(person.initials))
///     }
///
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public struct Label<Title, Icon> : View where Title : View, Icon : View {

    /// Creates a label with a custom title and icon.
    public init(@ViewBuilder title: () -> Title, @ViewBuilder icon: () -> Icon)

    /// The content and behavior of the view.
    ///
    /// When you implement a custom view, you must implement a computed
    /// `body` property to provide the content for your view. Return a view
    /// that's composed of built-in views that SwiftUI provides, plus other
    /// composite views that you've already defined:
    ///
    ///     struct MyView: View {
    ///         var body: some View {
    ///             Text("Hello, World!")
    ///         }
    ///     }
    ///
    /// For more information about composing views and a view hierarchy,
    /// see <doc:Declaring-a-Custom-View>.
    @MainActor @preconcurrency public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
    public typealias Body = some View
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension Label where Title == Text, Icon == Image {

    /// Creates a label with an icon image and a title generated from a
    /// localized string.
    ///
    /// - Parameters:
    ///    - titleKey: A title generated from a localized string.
    ///    - image: The name of the image resource to lookup.
    nonisolated public init(_ titleKey: LocalizedStringKey, image name: String)

    /// Creates a label with a system icon image and a title generated from a
    /// localized string.
    ///
    /// - Parameters:
    ///    - titleKey: A title generated from a localized string.
    ///    - systemImage: The name of the image resource to lookup.
    nonisolated public init(_ titleKey: LocalizedStringKey, systemImage name: String)

    /// Creates a label with an icon image and a title generated from a string.
    ///
    /// - Parameters:
    ///    - title: A string used as the label's title.
    ///    - image: The name of the image resource to lookup.
    nonisolated public init<S>(_ title: S, image name: String) where S : StringProtocol

    /// Creates a label with a system icon image and a title generated from a
    /// string.
    ///
    /// - Parameters:
    ///    - title: A string used as the label's title.
    ///    - systemImage: The name of the image resource to lookup.
    nonisolated public init<S>(_ title: S, systemImage name: String) where S : StringProtocol
}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension Label where Title == Text, Icon == Image {

    /// Creates a label with an icon image and a title generated from a
    /// localized string.
    ///
    /// - Parameters:
    ///    - titleKey: A title generated from a localized string.
    ///    - image: The image resource to lookup.
    nonisolated public init(_ titleKey: LocalizedStringKey, image resource: ImageResource)

    /// Creates a label with an icon image and a title generated from a string.
    ///
    /// - Parameters:
    ///    - title: A string used as the label's title.
    ///    - image: The image resource to lookup.
    nonisolated public init<S>(_ title: S, image resource: ImageResource) where S : StringProtocol
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension Label where Title == LabelStyleConfiguration.Title, Icon == LabelStyleConfiguration.Icon {

    /// Creates a label representing the configuration of a style.
    ///
    /// You can use this initializer within the ``LabelStyle/makeBody(configuration:)``
    /// method of a ``LabelStyle`` instance to create an instance of the label
    /// that's being styled. This is useful for custom label styles that only
    /// wish to modify the current style, as opposed to implementing a brand new
    /// style.
    ///
    /// For example, the following style adds a red border around the label,
    /// but otherwise preserves the current style:
    ///
    ///     struct RedBorderedLabelStyle: LabelStyle {
    ///         func makeBody(configuration: Configuration) -> some View {
    ///             Label(configuration)
    ///                 .border(Color.red)
    ///         }
    ///     }
    ///
    /// - Parameter configuration: The label style to use.
    nonisolated public init(_ configuration: LabelStyleConfiguration)
}

/// A type that applies a custom appearance to all labels within a view.
///
/// To configure the current label style for a view hierarchy, use the
/// ``View/labelStyle(_:)`` modifier.
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
@MainActor @preconcurrency public protocol LabelStyle {

    /// A view that represents the body of a label.
    associatedtype Body : View

    /// Creates a view that represents the body of a label.
    ///
    /// The system calls this method for each ``Label`` instance in a view
    /// hierarchy where this style is the current label style.
    ///
    /// - Parameter configuration: The properties of the label.
    @ViewBuilder @MainActor @preconcurrency func makeBody(configuration: Self.Configuration) -> Self.Body

    /// The properties of a label.
    typealias Configuration = LabelStyleConfiguration
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension LabelStyle where Self == DefaultLabelStyle {

    /// A label style that resolves its appearance automatically based on the
    /// current context.
    @MainActor @preconcurrency public static var automatic: DefaultLabelStyle { get }
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension LabelStyle where Self == IconOnlyLabelStyle {

    /// A label style that only displays the icon of the label.
    ///
    /// The title of the label is still used for non-visual descriptions, such as
    /// VoiceOver.
    @MainActor @preconcurrency public static var iconOnly: IconOnlyLabelStyle { get }
}

@available(iOS 14.5, macOS 11.3, tvOS 14.5, watchOS 7.4, *)
extension LabelStyle where Self == TitleAndIconLabelStyle {

    /// A label style that shows both the title and icon of the label using a
    /// system-standard layout.
    ///
    /// In most cases, labels show both their title and icon by default. However,
    /// some containers might apply a different default label style to their
    /// content, such as only showing icons within toolbars on macOS and iOS. To
    /// opt in to showing both the title and the icon, you can apply the title
    /// and icon label style:
    ///
    ///     Label("Lightning", systemImage: "bolt.fill")
    ///         .labelStyle(.titleAndIcon)
    ///
    /// To apply the title and icon style to a group of labels, apply the style
    /// to the view hierarchy that contains the labels:
    ///
    ///     VStack {
    ///         Label("Rain", systemImage: "cloud.rain")
    ///         Label("Snow", systemImage: "snow")
    ///         Label("Sun", systemImage: "sun.max")
    ///     }
    ///     .labelStyle(.titleAndIcon)
    ///
    /// The relative layout of the title and icon is dependent on the context it
    /// is displayed in. In most cases, however, the label is arranged
    /// horizontally with the icon leading.
    @MainActor @preconcurrency public static var titleAndIcon: TitleAndIconLabelStyle { get }
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension LabelStyle where Self == TitleOnlyLabelStyle {

    /// A label style that only displays the title of the label.
    @MainActor @preconcurrency public static var titleOnly: TitleOnlyLabelStyle { get }
}

/// The properties of a label.
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public struct LabelStyleConfiguration {

    /// A type-erased title view of a label.
    @MainActor @preconcurrency public struct Title {

        /// The type of view representing the body of this view.
        ///
        /// When you create a custom view, Swift infers this type from your
        /// implementation of the required ``View/body-swift.property`` property.
        @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
        public typealias Body = Never
    }

    /// A type-erased icon view of a label.
    @MainActor @preconcurrency public struct Icon {

        /// The type of view representing the body of this view.
        ///
        /// When you create a custom view, Swift infers this type from your
        /// implementation of the required ``View/body-swift.property`` property.
        @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
        public typealias Body = Never
    }

    /// A description of the labeled item.
    public var title: LabelStyleConfiguration.Title { get }

    /// A symbolic representation of the labeled item.
    public var icon: LabelStyleConfiguration.Icon { get }
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension LabelStyleConfiguration.Title : View {
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension LabelStyleConfiguration.Icon : View {
}

/// A container for attaching a label to a value-bearing view.
///
/// The instance's content represents a read-only or read-write value, and its
/// label identifies or describes the purpose of that value.
/// The resulting element has a layout that's consistent with other framework
/// controls and automatically adapts to its container, like a form or toolbar.
/// Some styles of labeled content also apply styling or behaviors to the value
/// content, like making ``Text`` views selectable.
///
/// The following example associates a label with a custom view and has
/// a layout that matches the label of the ``Picker``:
///
///     Form {
///         LabeledContent("Custom Value") {
///             MyCustomView(value: $value)
///         }
///         Picker("Selected Value", selection: $selection) {
///             Text("Option 1").tag(1)
///             Text("Option 2").tag(2)
///         }
///     }
///
/// ### Custom view labels
///
/// You can assemble labeled content with an explicit view for its label
/// using the ``init(content:label:)`` initializer. For example, you can
/// rewrite the previous labeled content example using a ``Text`` view:
///
///     LabeledContent {
///         MyCustomView(value: $value)
///     } label: {
///         Text("Custom Value")
///     }
///
/// The `label` view builder accepts any kind of view, like a ``Label``:
///
///     LabeledContent {
///         MyCustomView(value: $value)
///     } label: {
///         Label("Custom Value", systemImage: "hammer")
///     }
///
/// For cases where adding a subtitle to the label is desired, use a view
/// builder that creates multiple `Text` views where the first text represents
/// the title and the second text represents the subtitle:
///
///     LabeledContent {
///         MyCustomView(value: $value)
///     } label: {
///         Text("Custom Value")
///         Text("Custom Subtitle Value")
///     }
///
/// ### Textual labeled content
///
/// You can construct labeled content with string values or formatted values
/// to create read-only displays of textual values:
///
///     Form {
///         Section("Information") {
///             LabeledContent("Name", value: person.name)
///             LabeledContent("Age", value: person.age, format: .number)
///             LabeledContent("Height", value: person.height,
///                 format: .measurement(width: .abbreviated))
///         }
///         if !person.pets.isEmpty {
///             Section("Pets") {
///                 ForEach(pet) { pet in
///                     LabeledContent(pet.species, value: pet.name)
///                 }
///             }
///         }
///     }
///
/// Wherever possible, SwiftUI makes this text selectable.
///
/// ### Compositional elements
///
/// You can use labeled content as the label for other elements. For example,
/// a ``NavigationLink`` can present a summary value for the destination it
/// links to:
///
///     Form {
///         NavigationLink(value: Settings.wifiDetail) {
///             LabeledContent("Wi-Fi", value: ssidName)
///         }
///     }
///
/// In some cases, the styling of views used as the value content is
/// specialized as well. For example, while a ``Toggle`` in an inset group
/// form on macOS is styled as a switch by default, it's styled as a checkbox
/// when used as a value element within a surrounding `LabeledContent`
/// instance:
///
///     Form {
///         LabeledContent("Source Control") {
///             Toggle("Refresh local status automatically",
///                 isOn: $refreshLocalStatus)
///             Toggle("Fetch and refresh server status automatically",
///                 isOn: $refreshServerStatus)
///             Toggle("Add and remove files automatically",
///                 isOn: $addAndRemoveFiles)
///             Toggle("Select files to commit automatically",
///                 isOn: $selectFiles)
///         }
///     }
///
/// ### Controlling label visibility
///
/// A label communicates the identity or purpose of the value, which is
/// important for accessibility. However, you might want to hide the label
/// in the display, and some controls or contexts may visually hide their label
/// by default. The ``View/labelsHidden()`` modifier allows controlling that
/// visibility. The following example hides both labels, producing only a
/// group of the two value views:
///
///     Group {
///         LabeledContent("Custom Value") {
///             MyCustomView(value: $value)
///         }
///         Picker("Selected Value", selection: $selection) {
///             Text("Option 1").tag(1)
///             Text("Option 2").tag(2)
///         }
///     }
///     .labelsHidden()
///
/// ### Styling labeled content
///
/// You can set label styles using the ``View/labeledContentStyle(_:)``
/// modifier. You can also build custom styles using ``LabeledContentStyle``.
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct LabeledContent<Label, Content> {
}

@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension LabeledContent : View where Label : View, Content : View {

    /// Creates a standard labeled element, with a view that conveys
    /// the value of the element and a label.
    ///
    /// - Parameters:
    ///   - content: The view that conveys the value of the resulting labeled
    ///     element.
    ///   - label: The label that describes the purpose of the result.
    nonisolated public init(@ViewBuilder content: () -> Content, @ViewBuilder label: () -> Label)

    /// The content and behavior of the view.
    ///
    /// When you implement a custom view, you must implement a computed
    /// `body` property to provide the content for your view. Return a view
    /// that's composed of built-in views that SwiftUI provides, plus other
    /// composite views that you've already defined:
    ///
    ///     struct MyView: View {
    ///         var body: some View {
    ///             Text("Hello, World!")
    ///         }
    ///     }
    ///
    /// For more information about composing views and a view hierarchy,
    /// see <doc:Declaring-a-Custom-View>.
    @MainActor @preconcurrency public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
    public typealias Body = some View
}

@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension LabeledContent where Label == Text, Content : View {

    /// Creates a labeled view that generates its label from a localized string
    /// key.
    ///
    /// This initializer creates a ``Text`` label on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// `Text` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the view's localized title, that describes
    ///     the purpose of the view.
    ///   - content: The value content being labeled.
    public init(_ titleKey: LocalizedStringKey, @ViewBuilder content: () -> Content)

    /// Creates a labeled view that generates its label from a string.
    ///
    /// This initializer creates a ``Text`` label on your behalf, and treats the
    /// title similar to ``Text/init(_:)``. See `Text` for more
    /// information about localizing strings.
    ///
    /// - Parameters:
    ///   - title: A string that describes the purpose of the view.
    ///   - content: The value content being labeled.
    public init<S>(_ title: S, @ViewBuilder content: () -> Content) where S : StringProtocol
}

@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension LabeledContent where Label == Text, Content == Text {

    /// Creates a labeled informational view.
    ///
    /// This initializer creates a ``Text`` label on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// `Text` for more information about localizing strings.
    ///
    ///     Form {
    ///         LabeledContent("Name", value: person.name)
    ///     }
    ///
    /// In some contexts, this text will be selectable by default.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the view's localized title, that describes
    ///     the purpose of the view.
    ///   - value: The value being labeled.
    public init<S>(_ titleKey: LocalizedStringKey, value: S) where S : StringProtocol

    /// Creates a labeled informational view.
    ///
    /// This initializer creates a ``Text`` label on your behalf, and treats the
    /// title similar to ``Text/init(_:)``. See `Text` for more
    /// information about localizing strings.
    ///
    ///     Form {
    ///         ForEach(person.pet) { pet in
    ///             LabeledContent(pet.species, value: pet.name)
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - title: A string that describes the purpose of the view.
    ///   - value: The value being labeled.
    public init<S1, S2>(_ title: S1, value: S2) where S1 : StringProtocol, S2 : StringProtocol

    /// Creates a labeled informational view from a formatted value.
    ///
    /// This initializer creates a ``Text`` label on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// `Text` for more information about localizing strings.
    ///
    ///     Form {
    ///         LabeledContent("Age", value: person.age, format: .number)
    ///         LabeledContent("Height", value: person.height,
    ///             format: .measurement(width: .abbreviated))
    ///     }
    ///
    /// - Parameters:
    ///   - titleKey: The key for the view's localized title, that describes
    ///     the purpose of the view.
    ///   - value: The value being labeled.
    ///   - format: A format style of type `F` to convert the underlying value
    ///     of type `F.FormatInput` to a string representation.
    public init<F>(_ titleKey: LocalizedStringKey, value: F.FormatInput, format: F) where F : FormatStyle, F.FormatInput : Equatable, F.FormatOutput == String

    /// Creates a labeled informational view from a formatted value.
    ///
    /// This initializer creates a ``Text`` label on your behalf, and treats the
    /// title similar to ``Text/init(_:)``. See `Text` for more
    /// information about localizing strings.
    ///
    ///     Form {
    ///         Section("Downloads") {
    ///             ForEach(download) { file in
    ///                 LabeledContent(file.name, value: file.downloadSize,
    ///                     format: .byteCount(style: .file))
    ///            }
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - title: A string that describes the purpose of the view.
    ///   - value: The value being labeled.
    ///   - format: A format style of type `F` to convert the underlying value
    ///     of type `F.FormatInput` to a string representation.
    public init<S, F>(_ title: S, value: F.FormatInput, format: F) where S : StringProtocol, F : FormatStyle, F.FormatInput : Equatable, F.FormatOutput == String
}

@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension LabeledContent where Label == LabeledContentStyleConfiguration.Label, Content == LabeledContentStyleConfiguration.Content {

    /// Creates labeled content based on a labeled content style configuration.
    ///
    /// You can use this initializer within the
    /// ``LabeledContentStyle/makeBody(configuration:)`` method of a
    /// ``LabeledContentStyle`` to create a labeled content instance.
    /// This is useful for custom styles that only modify the current style,
    /// as opposed to implementing a brand new style.
    ///
    /// For example, the following style adds a red border around the labeled
    /// content, but otherwise preserves the current style:
    ///
    ///     struct RedBorderLabeledContentStyle: LabeledContentStyle {
    ///         func makeBody(configuration: Configuration) -> some View {
    ///             LabeledContent(configuration)
    ///                 .border(.red)
    ///         }
    ///     }
    ///
    /// - Parameter configuration: The properties of the labeled content
    public init(_ configuration: LabeledContentStyleConfiguration)
}

/// The appearance and behavior of a labeled content instance..
///
/// Use ``View/labeledContentStyle(_:)`` to set a style on a view.
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
@MainActor @preconcurrency public protocol LabeledContentStyle {

    /// A view that represents the appearance and behavior of labeled content.
    associatedtype Body : View

    /// Creates a view that represents the body of labeled content.
    @ViewBuilder @MainActor @preconcurrency func makeBody(configuration: Self.Configuration) -> Self.Body

    /// The properties of a labeled content instance.
    typealias Configuration = LabeledContentStyleConfiguration
}

@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension LabeledContentStyle where Self == AutomaticLabeledContentStyle {

    /// A labeled content style that resolves its appearance automatically based
    /// on the current context.
    @MainActor @preconcurrency public static var automatic: AutomaticLabeledContentStyle { get }
}

/// The properties of a labeled content instance.
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct LabeledContentStyleConfiguration {

    /// A type-erased label of a labeled content instance.
    @MainActor @preconcurrency public struct Label : View {

        /// The type of view representing the body of this view.
        ///
        /// When you create a custom view, Swift infers this type from your
        /// implementation of the required ``View/body-swift.property`` property.
        @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
        public typealias Body = Never
    }

    /// A type-erased content of a labeled content instance.
    @MainActor @preconcurrency public struct Content : View {

        /// The type of view representing the body of this view.
        ///
        /// When you create a custom view, Swift infers this type from your
        /// implementation of the required ``View/body-swift.property`` property.
        @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
        public typealias Body = Never
    }

    /// The label of the labeled content instance.
    public let label: LabeledContentStyleConfiguration.Label

    /// The content of the labeled content instance.
    public let content: LabeledContentStyleConfiguration.Content
}

/// A view that represents the body of a control group with a specified
/// label.
///
/// You don't create this type directly. SwiftUI creates it when you build
/// a ``ControlGroup``.
@available(iOS 16.0, macOS 13.0, tvOS 17.0, *)
@available(watchOS, unavailable)
public struct LabeledControlGroupContent<Content, Label> : View where Content : View, Label : View {

    /// The content and behavior of the view.
    ///
    /// When you implement a custom view, you must implement a computed
    /// `body` property to provide the content for your view. Return a view
    /// that's composed of built-in views that SwiftUI provides, plus other
    /// composite views that you've already defined:
    ///
    ///     struct MyView: View {
    ///         var body: some View {
    ///             Text("Hello, World!")
    ///         }
    ///     }
    ///
    /// For more information about composing views and a view hierarchy,
    /// see <doc:Declaring-a-Custom-View>.
    @MainActor @preconcurrency public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    @available(iOS 16.0, tvOS 17.0, macOS 13.0, *)
    @available(watchOS, unavailable)
    public typealias Body = some View
}

/// A view that represents the view of a toolbar item group with a specified
/// label.
///
/// You don't create this type directly. SwiftUI creates it when you build
/// a ``ToolbarItemGroup``.
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct LabeledToolbarItemGroupContent<Content, Label> : View where Content : View, Label : View {

    /// The content and behavior of the view.
    ///
    /// When you implement a custom view, you must implement a computed
    /// `body` property to provide the content for your view. Return a view
    /// that's composed of built-in views that SwiftUI provides, plus other
    /// composite views that you've already defined:
    ///
    ///     struct MyView: View {
    ///         var body: some View {
    ///             Text("Hello, World!")
    ///         }
    ///     }
    ///
    /// For more information about composing views and a view hierarchy,
    /// see <doc:Declaring-a-Custom-View>.
    @MainActor @preconcurrency public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
    public typealias Body = some View
}

/// A container view that arranges its child views in a grid that
/// grows horizontally, creating items only as needed.
///
/// Use a lazy horizontal grid when you want to display a large, horizontally
/// scrollable collection of views arranged in a two dimensional layout. The
/// first view that you provide to the grid's `content` closure appears in the
/// top row of the column that's on the grid's leading edge. Additional views
/// occupy successive cells in the grid, filling the first column from top to
/// bottom, then the second column, and so on. The number of columns can grow
/// unbounded, but you specify the number of rows by providing a
/// corresponding number of ``GridItem`` instances to the grid's initializer.
///
/// The grid in the following example defines two rows and uses a ``ForEach``
/// structure to repeatedly generate a pair of ``Text`` views for the rows
/// in each column:
///
///     struct HorizontalSmileys: View {
///         let rows = [GridItem(.fixed(30)), GridItem(.fixed(30))]
///
///         var body: some View {
///             ScrollView(.horizontal) {
///                 LazyHGrid(rows: rows) {
///                     ForEach(0x1f600...0x1f679, id: \.self) { value in
///                         Text(String(format: "%x", value))
///                         Text(emoji(value))
///                             .font(.largeTitle)
///                     }
///                 }
///             }
///         }
///
///         private func emoji(_ value: Int) -> String {
///             guard let scalar = UnicodeScalar(value) else { return "?" }
///             return String(Character(scalar))
///         }
///     }
///
/// For each column in the grid, the top row shows a Unicode code point from
/// the "Smileys" group, and the bottom shows its corresponding emoji:
///
/// ![A screenshot of a row of hexadecimal numbers above a row of emoji,
/// with each number and a corresponding emoji making up a column.
/// Half of each of the first and last column are cut off on either end
/// of the image, with eight columns fully visible.](LazyHGrid-1-iOS)
///
/// You can achieve a similar layout using a ``Grid`` container. Unlike a lazy
/// grid, which creates child views only when SwiftUI needs to display
/// them, a regular grid creates all of its child views right away. This
/// enables the grid to provide better support for cell spacing and alignment.
/// Only use a lazy grid if profiling your app shows that a ``Grid`` view
/// performs poorly because it tries to load too many views at once.
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public struct LazyHGrid<Content> : View where Content : View {

    /// Creates a grid that grows horizontally.
    ///
    /// - Parameters:
    ///   - rows: An array of grid items that size and position each column of
    ///    the grid.
    ///   - alignment: The alignment of the grid within its parent view.
    ///   - spacing: The spacing between the grid and the next item in its
    ///   parent view.
    ///   - pinnedViews: Views to pin to the bounds of a parent scroll view.
    ///   - content: The content of the grid.
    public init(rows: [GridItem], alignment: VerticalAlignment = .center, spacing: CGFloat? = nil, pinnedViews: PinnedScrollableViews = .init(), @ViewBuilder content: () -> Content)

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
    public typealias Body = Never
}

/// A view that arranges its children in a line that grows horizontally,
/// creating items only as needed.
///
/// The stack is "lazy," in that the stack view doesn't create items until
/// it needs to render them onscreen.
///
/// In the following example, a ``ScrollView`` contains a `LazyHStack` that
/// consists of a horizontal row of text views. The stack aligns to the top
/// of the scroll view and uses 10-point spacing between each text view.
///
///     ScrollView(.horizontal) {
///         LazyHStack(alignment: .top, spacing: 10) {
///             ForEach(1...100, id: \.self) {
///                 Text("Column \($0)")
///             }
///         }
///     }
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public struct LazyHStack<Content> : View where Content : View {

    /// Creates a lazy horizontal stack view with the given spacing,
    /// vertical alignment, pinning behavior, and content.
    ///
    /// - Parameters:
    ///     - alignment: The guide for aligning the subviews in this stack. All
    ///       child views have the same vertical screen coordinate.
    ///     - spacing: The distance between adjacent subviews, or `nil` if you
    ///       want the stack to choose a default distance for each pair of
    ///       subviews.
    ///     - pinnedViews: The kinds of child views that will be pinned.
    ///     - content: A view builder that creates the content of this stack.
    public init(alignment: VerticalAlignment = .center, spacing: CGFloat? = nil, pinnedViews: PinnedScrollableViews = .init(), @ViewBuilder content: () -> Content)

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
    public typealias Body = Never
}

/// A container view that arranges its child views in a grid that
/// grows vertically, creating items only as needed.
///
/// Use a lazy vertical grid when you want to display a large, vertically
/// scrollable collection of views arranged in a two dimensional layout. The
/// first view that you provide to the grid's `content` closure appears in the
/// top row of the column that's on the grid's leading edge. Additional views
/// occupy successive cells in the grid, filling the first row from leading to
/// trailing edges, then the second row, and so on. The number of rows can grow
/// unbounded, but you specify the number of columns by providing a
/// corresponding number of ``GridItem`` instances to the grid's initializer.
///
/// The grid in the following example defines two columns and uses a
/// ``ForEach`` structure to repeatedly generate a pair of ``Text`` views for
/// the columns in each row:
///
///     struct VerticalSmileys: View {
///         let columns = [GridItem(.flexible()), GridItem(.flexible())]
///
///         var body: some View {
///              ScrollView {
///                  LazyVGrid(columns: columns) {
///                      ForEach(0x1f600...0x1f679, id: \.self) { value in
///                          Text(String(format: "%x", value))
///                          Text(emoji(value))
///                              .font(.largeTitle)
///                      }
///                  }
///              }
///         }
///
///         private func emoji(_ value: Int) -> String {
///             guard let scalar = UnicodeScalar(value) else { return "?" }
///             return String(Character(scalar))
///         }
///     }
///
/// For each row in the grid, the first column shows a Unicode code point from
/// the "Smileys" group, and the second shows its corresponding emoji:
///
/// ![A screenshot of a colunb of hexadecimal numbers to the left of a column
/// of emoji, with each number and a corresponding emoji making up a row.
/// Half of the last row is cut off, with seventeen rows fully
/// visible.](LazyVGrid-1-iOS)
///
/// You can achieve a similar layout using a ``Grid`` container. Unlike a lazy
/// grid, which creates child views only when SwiftUI needs to display
/// them, a regular grid creates all of its child views right away. This
/// enables the grid to provide better support for cell spacing and alignment.
/// Only use a lazy grid if profiling your app shows that a ``Grid`` view
/// performs poorly because it tries to load too many views at once.
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public struct LazyVGrid<Content> : View where Content : View {

    /// Creates a grid that grows vertically.
    ///
    /// - Parameters:
    ///   - columns: An array of grid items to size and position each row of
    ///    the grid.
    ///   - alignment: The alignment of the grid within its parent view.
    ///   - spacing: The spacing between the grid and the next item in its
    ///   parent view.
    ///   - pinnedViews: Views to pin to the bounds of a parent scroll view.
    ///   - content: The content of the grid.
    public init(columns: [GridItem], alignment: HorizontalAlignment = .center, spacing: CGFloat? = nil, pinnedViews: PinnedScrollableViews = .init(), @ViewBuilder content: () -> Content)

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
    public typealias Body = Never
}

/// A view that arranges its children in a line that grows vertically,
/// creating items only as needed.
///
/// The stack is "lazy," in that the stack view doesn't create items until
/// it needs to render them onscreen.
///
/// In the following example, a ``ScrollView`` contains a `LazyVStack` that
/// consists of a vertical row of text views. The stack aligns to the
/// leading edge of the scroll view, and uses default spacing between the
/// text views.
///
///     ScrollView {
///         LazyVStack(alignment: .leading) {
///             ForEach(1...100, id: \.self) {
///                 Text("Row \($0)")
///             }
///         }
///     }
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public struct LazyVStack<Content> : View where Content : View {

    /// Creates a lazy vertical stack view with the given spacing,
    /// vertical alignment, pinning behavior, and content.
    ///
    /// - Parameters:
    ///     - alignment: The guide for aligning the subviews in this stack. All
    ///     child views have the same horizontal screen coordinate.
    ///     - spacing: The distance between adjacent subviews, or `nil` if you
    ///       want the stack to choose a default distance for each pair of
    ///       subviews.
    ///     - pinnedViews: The kinds of child views that will be pinned.
    ///     - content: A view builder that creates the content of this stack.
    public init(alignment: HorizontalAlignment = .center, spacing: CGFloat? = nil, pinnedViews: PinnedScrollableViews = .init(), @ViewBuilder content: () -> Content)

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
    public typealias Body = Never
}

/// A hover effect that slides the pointer under the view and disappears as the
/// view scales up and gains a shadow.
///
/// You can also use ``CustomHoverEffect/lift`` to construct this hover effect.
@available(iOS 18.0, tvOS 18.0, visionOS 2.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
public struct LiftHoverEffect : CustomHoverEffect {

    /// Creates a lift hover effect.
    public init()

    /// Defines the effect produced by this effect.
    ///
    /// You implement this method to describe a custom effect to apply to a
    /// view. `content` is an empty effect you use to build your effect, which
    /// will later be applied to a View, or combined with other
    /// `CustomHoverEffect`s.
    ///
    /// - Parameter content: An empty effect you use to compose the custom
    ///   effect.
    /// - Returns: A custom effect.
    public func body(content: LiftHoverEffect.Content) -> some CustomHoverEffect


    /// The type of effect representing the body of this effect. When you create
    /// a custom effect, Swift infers this type from your implementation of the
    /// required ``CustomHoverEffect/body(content:)`` method.
    @available(iOS 18.0, tvOS 18.0, visionOS 2.0, *)
    @available(watchOS, unavailable)
    @available(macOS, unavailable)
    public typealias Body = some CustomHoverEffect
}

/// A type-erased widget configuration.
///
/// You don't use this type directly. Instead SwiftUI creates this type on
/// your behalf.
@available(iOS 16.1, macOS 13.0, watchOS 9.1, *)
@available(tvOS, unavailable)
@MainActor @frozen @preconcurrency public struct LimitedAvailabilityConfiguration : WidgetConfiguration {

    /// The type of widget configuration representing the body of
    /// this configuration.
    ///
    /// When you create a custom widget, Swift infers this type from your
    /// implementation of the required `body` property.
    @available(iOS 16.1, watchOS 9.1, macOS 13.0, *)
    @available(tvOS, unavailable)
    public typealias Body = Never
}

/// A gauge style that displays bar that fills from leading to trailing
/// edges as the gauge's current value increases.
///
/// Use ``GaugeStyle/linearCapacity`` to construct this style.
@available(iOS 16.0, macOS 13.0, watchOS 9.0, *)
@available(tvOS, unavailable)
@MainActor @preconcurrency public struct LinearCapacityGaugeStyle : GaugeStyle {

    /// Creates a linear capacity gauge style.
    @MainActor @preconcurrency public init()

    /// Creates a view representing the body of a gauge.
    ///
    /// The system calls this modifier on each instance of gauge within a view
    /// hierarchy where this style is the current gauge style.
    ///
    /// - Parameter configuration: The properties to apply to the gauge instance.
    @MainActor @preconcurrency public func makeBody(configuration: LinearCapacityGaugeStyle.Configuration) -> some View


    /// A view representing the body of a gauge.
    @available(iOS 16.0, watchOS 9.0, macOS 13.0, *)
    @available(tvOS, unavailable)
    public typealias Body = some View
}

/// A progress view that visually indicates its progress using a horizontal bar.
///
/// Use ``ProgressViewStyle/linear`` to construct this style.
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public struct LinearProgressViewStyle : ProgressViewStyle {

    /// Creates a linear progress view style.
    public init()

    /// Creates a linear progress view style with a tint color.
    @available(iOS, introduced: 14.0, deprecated: 100000.0, message: "Use ``View/tint(_)`` instead.")
    @available(macOS, introduced: 11.0, deprecated: 100000.0, message: "Use ``View/tint(_)`` instead.")
    @available(tvOS, introduced: 14.0, deprecated: 100000.0, message: "Use ``View/tint(_)`` instead.")
    @available(watchOS, introduced: 7.0, deprecated: 100000.0, message: "Use ``View/tint(_)`` instead.")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Use ``View/tint(_)`` instead.")
    public init(tint: Color)

    /// Creates a view representing the body of a progress view.
    ///
    /// - Parameter configuration: The properties of the progress view being
    ///   created.
    ///
    /// The view hierarchy calls this method for each progress view where this
    /// style is the current progress view style.
    ///
    /// - Parameter configuration: The properties of the progress view, such as
    ///  its preferred progress type.
    @MainActor @preconcurrency public func makeBody(configuration: LinearProgressViewStyle.Configuration) -> some View


    /// A view representing the body of a progress view.
    @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
    public typealias Body = some View
}

/// A control for navigating to a URL.
///
/// Create a link by providing a destination URL and a title. The title
/// tells the user the purpose of the link, and can be a string, a title
/// key that produces a localized string, or a view that acts as a label.
/// The example below creates a link to `example.com` and displays the
/// title string as a link-styled view:
///
///     Link("View Our Terms of Service",
///           destination: URL(string: "https://www.example.com/TOS.html")!)
///
/// When a user taps or clicks a `Link`, the default behavior depends on the
/// contents of the URL. For example, SwiftUI opens a Universal Link in the
/// associated app if possible, or in the user's default web browser if not.
/// Alternatively, you can override the default behavior by setting the
/// ``EnvironmentValues/openURL`` environment value with a custom
/// ``OpenURLAction``:
///
///     Link("Visit Our Site", destination: URL(string: "https://www.example.com")!)
///         .environment(\.openURL, OpenURLAction { url in
///             print("Open \(url)")
///             return .handled
///         })
///
/// As with other views, you can style links using standard view modifiers
/// depending on the view type of the link's label. For example, a ``Text``
/// label could be modified with a custom ``View/font(_:)`` or
/// ``View/foregroundColor(_:)`` to customize the appearance of the link in
/// your app's UI.
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public struct Link<Label> : View where Label : View {

    /// Creates a control, consisting of a URL and a label, used to navigate
    /// to the given URL.
    ///
    /// - Parameters:
    ///     - destination: The URL for the link.
    ///     - label: A view that describes the destination of URL.
    public init(destination: URL, @ViewBuilder label: () -> Label)

    /// The content and behavior of the view.
    ///
    /// When you implement a custom view, you must implement a computed
    /// `body` property to provide the content for your view. Return a view
    /// that's composed of built-in views that SwiftUI provides, plus other
    /// composite views that you've already defined:
    ///
    ///     struct MyView: View {
    ///         var body: some View {
    ///             Text("Hello, World!")
    ///         }
    ///     }
    ///
    /// For more information about composing views and a view hierarchy,
    /// see <doc:Declaring-a-Custom-View>.
    @MainActor @preconcurrency public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
    public typealias Body = some View
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension Link where Label == Text {

    /// Creates a control, consisting of a URL and a title key, used to
    /// navigate to a URL.
    ///
    /// Use ``Link`` to create a control that your app uses to navigate to a
    /// URL that you provide. The example below creates a link to
    /// `example.com` and uses `Visit Example Co` as the title key to
    /// generate a link-styled view in your app:
    ///
    ///     Link("Visit Example Co",
    ///           destination: URL(string: "https://www.example.com/")!)
    ///
    /// - Parameters:
    ///     - titleKey: The key for the localized title that describes the
    ///       purpose of this link.
    ///     - destination: The URL for the link.
    nonisolated public init(_ titleKey: LocalizedStringKey, destination: URL)

    /// Creates a control, consisting of a URL and a title string, used to
    /// navigate to a URL.
    ///
    /// Use ``Link`` to create a control that your app uses to navigate to a
    /// URL that you provide. The example below creates a link to
    /// `example.com` and displays the title string you provide as a
    /// link-styled view in your app:
    ///
    ///     func marketingLink(_ callToAction: String) -> Link {
    ///         Link(callToAction,
    ///             destination: URL(string: "https://www.example.com/")!)
    ///     }
    ///
    /// - Parameters:
    ///     - title: A text string used as the title for describing the
    ///       underlying `destination` URL.
    ///     - destination: The URL for the link.
    nonisolated public init<S>(_ title: S, destination: URL) where S : StringProtocol
}

/// A style appropriate for links.
@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
@frozen public struct LinkShapeStyle : ShapeStyle {

    /// Creates a new link shape style instance.
    public init()

    /// The type of shape style this will resolve to.
    ///
    /// When you create a custom shape style, Swift infers this type
    /// from your implementation of the required `resolve` function.
    @available(iOS 17.0, tvOS 17.0, watchOS 10.0, macOS 14.0, *)
    public typealias Resolved = Never
}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension LinkShapeStyle : BitwiseCopyable {
}

/// A container that presents rows of data arranged in a single column,
/// optionally providing the ability to select one or more members.
///
/// In its simplest form, a `List` creates its contents statically, as shown in
/// the following example:
///
///     var body: some View {
///         List {
///             Text("A List Item")
///             Text("A Second List Item")
///             Text("A Third List Item")
///         }
///     }
///
/// ![A vertical list with three text views.](List-1-iOS)
///
/// More commonly, you create lists dynamically from an underlying collection
/// of data. The following example shows how to create a simple list from an
/// array of an `Ocean` type which conforms to
/// <doc://com.apple.documentation/documentation/Swift/Identifiable>:
///
///     struct Ocean: Identifiable {
///         let name: String
///         let id = UUID()
///     }
///
///     private var oceans = [
///         Ocean(name: "Pacific"),
///         Ocean(name: "Atlantic"),
///         Ocean(name: "Indian"),
///         Ocean(name: "Southern"),
///         Ocean(name: "Arctic")
///     ]
///
///     var body: some View {
///         List(oceans) {
///             Text($0.name)
///         }
///     }
///
/// ![A vertical list with five text views, each with the name of an
/// ocean.](List-2-iOS)
///
/// ### Supporting selection in lists
///
/// To make members of a list selectable, provide a binding to a selection
/// variable. Binding to a single instance of the list data's `Identifiable.ID`
/// type creates a single-selection list. Binding to a
/// <doc://com.apple.documentation/documentation/Swift/Set> creates a list that
/// supports multiple selections. The following example shows how to add
/// multiselect to the previous example:
///
///     struct Ocean: Identifiable, Hashable {
///         let name: String
///         let id = UUID()
///     }
///
///     private var oceans = [
///         Ocean(name: "Pacific"),
///         Ocean(name: "Atlantic"),
///         Ocean(name: "Indian"),
///         Ocean(name: "Southern"),
///         Ocean(name: "Arctic")
///     ]
///
///     @State private var multiSelection = Set<UUID>()
///
///     var body: some View {
///         NavigationView {
///             List(oceans, selection: $multiSelection) {
///                 Text($0.name)
///             }
///             .navigationTitle("Oceans")
///             .toolbar { EditButton() }
///         }
///         Text("\(multiSelection.count) selections")
///     }
///
/// When people make a single selection by tapping or clicking, the selected
/// cell changes its appearance to indicate the selection. To enable multiple
/// selections with tap gestures, put the list into edit mode by either
/// modifying the ``EnvironmentValues/editMode`` value, or adding an
/// ``EditButton`` to your app's interface. When you put the list into edit
/// mode, the list shows a circle next to each list item. The circle contains
/// a checkmark when the user selects the associated item. The example above
/// uses an Edit button, which changes its title to Done while in edit mode:
///
/// ![A navigation view with the title Oceans and a vertical list that contains
/// five text views, each with the name of an ocean. The second and third items
/// are highlighted to indicate that they are selected. At the bottom, a text
/// view reads 2 selections.](List-3-iOS)
///
/// People can make multiple selections without needing to enter edit mode on
/// devices that have a keyboard and mouse or trackpad, like Mac and iPad.
///
/// ### Refreshing the list content
///
/// To make the content of the list refreshable using the standard refresh
/// control, use the ``View/refreshable(action:)`` modifier.
///
/// The following example shows how to add a standard refresh control to a list.
/// When the user drags the top of the list downward, SwiftUI reveals the refresh
/// control and executes the specified action. Use an `await` expression
/// inside the `action` closure to refresh your data. The refresh indicator remains
/// visible for the duration of the awaited operation.
///
///     struct Ocean: Identifiable, Hashable {
///          let name: String
///          let id = UUID()
///          let stats: [String: String]
///      }
///
///      class OceanStore: ObservableObject {
///          @Published var oceans = [Ocean]()
///          func loadStats() async {}
///      }
///
///      @EnvironmentObject var store: OceanStore
///
///      var body: some View {
///          NavigationView {
///              List(store.oceans) { ocean in
///                  HStack {
///                      Text(ocean.name)
///                      StatsSummary(stats: ocean.stats) // A custom view for showing statistics.
///                  }
///              }
///              .refreshable {
///                  await store.loadStats()
///              }
///              .navigationTitle("Oceans")
///          }
///      }
///
/// ### Supporting multidimensional lists
///
/// To create two-dimensional lists, group items inside ``Section`` instances.
/// The following example creates sections named after the world's oceans,
/// each of which has ``Text`` views named for major seas attached to those
/// oceans. The example also allows for selection of a single list item,
/// identified by the `id` of the example's `Sea` type.
///
///     struct ContentView: View {
///         struct Sea: Hashable, Identifiable {
///             let name: String
///             let id = UUID()
///         }
///
///         struct OceanRegion: Identifiable {
///             let name: String
///             let seas: [Sea]
///             let id = UUID()
///         }
///
///         private let oceanRegions: [OceanRegion] = [
///             OceanRegion(name: "Pacific",
///                         seas: [Sea(name: "Australasian Mediterranean"),
///                                Sea(name: "Philippine"),
///                                Sea(name: "Coral"),
///                                Sea(name: "South China")]),
///             OceanRegion(name: "Atlantic",
///                         seas: [Sea(name: "American Mediterranean"),
///                                Sea(name: "Sargasso"),
///                                Sea(name: "Caribbean")]),
///             OceanRegion(name: "Indian",
///                         seas: [Sea(name: "Bay of Bengal")]),
///             OceanRegion(name: "Southern",
///                         seas: [Sea(name: "Weddell")]),
///             OceanRegion(name: "Arctic",
///                         seas: [Sea(name: "Greenland")])
///         ]
///
///         @State private var singleSelection: UUID?
///
///         var body: some View {
///             NavigationView {
///                 List(selection: $singleSelection) {
///                     ForEach(oceanRegions) { region in
///                         Section(header: Text("Major \(region.name) Ocean Seas")) {
///                             ForEach(region.seas) { sea in
///                                 Text(sea.name)
///                             }
///                         }
///                     }
///                 }
///                 .navigationTitle("Oceans and Seas")
///             }
///         }
///     }
///
/// Because this example uses single selection, people can make selections
/// outside of edit mode on all platforms.
///
/// ![A vertical list split into sections titled Major Pacific Ocean Seas,
/// Major Atlantic Ocean Seas, and so on. Each section has a different number of
/// rows, with the names of various seas. Within the Major Atlantic Ocean
/// Seas section, the row Sargasso is selected.](List-4-iOS)
///
/// > Note: In iOS 15, iPadOS 15, and tvOS 15 and earlier, lists support
///   selection only in edit mode, even for single selections.
///
/// ### Creating hierarchical lists
///
/// You can also create a hierarchical list of arbitrary depth by providing
/// tree-structured data and a `children` parameter that provides a key path to
/// get the child nodes at any level. The following example uses a deeply-nested
/// collection of a custom `FileItem` type to simulate the contents of a
/// file system. The list created from this data uses collapsing cells to allow
/// the user to navigate the tree structure.
///
///     struct ContentView: View {
///         struct FileItem: Hashable, Identifiable, CustomStringConvertible {
///             var id: Self { self }
///             var name: String
///             var children: [FileItem]? = nil
///             var description: String {
///                 switch children {
///                 case nil:
///                     return " \(name)"
///                 case .some(let children):
///                     return children.isEmpty ? " \(name)" : " \(name)"
///                 }
///             }
///         }
///         let fileHierarchyData: [FileItem] = [
///           FileItem(name: "users", children:
///             [FileItem(name: "user1234", children:
///               [FileItem(name: "Photos", children:
///                 [FileItem(name: "photo001.jpg"),
///                  FileItem(name: "photo002.jpg")]),
///                FileItem(name: "Movies", children:
///                  [FileItem(name: "movie001.mp4")]),
///                   FileItem(name: "Documents", children: [])
///               ]),
///              FileItem(name: "newuser", children:
///                [FileItem(name: "Documents", children: [])
///                ])
///             ]),
///             FileItem(name: "private", children: nil)
///         ]
///         var body: some View {
///             List(fileHierarchyData, children: \.children) { item in
///                 Text(item.description)
///             }
///         }
///     }
///
/// ![A list providing an expanded view of a tree structure. Some rows have a
/// chevron on the right to indicate that they have child rows. The chevron
/// points right when the row's child rows are hidden and points down when they
/// are visible. Row content that is slightly indented from the content in the
/// previous row indicates that the row is a child of the row above. The first
/// three rows, titled users, user1234, and Photos, have downward facing
/// chevrons and are progressively indented. The next two rows, indented
/// together from Photos and titled photo001.jpg and photo002.jpg, have no
/// chevron. The next two rows, titled Movies and Documents have right facing
/// chevrons and align with the Photos row. The next row, titled newuser, has a
/// right facing chevron and is aligned with user1234. The last row is titled
/// private, has no chevron, and is aligned with users.](List-5-iOS)
///
/// ### Styling lists
///
/// SwiftUI chooses a display style for a list based on the platform and the
/// view type in which it appears. Use the ``View/listStyle(_:)`` modifier to
/// apply a different ``ListStyle`` to all lists within a view. For example,
/// adding `.listStyle(.plain)` to the example shown in the
/// "Creating Multidimensional Lists" topic applies the
/// ``ListStyle/plain`` style, the following screenshot shows:
///
/// ![A vertical list split into sections titled Major Pacific Ocean Seas,
/// Major Atlantic Ocean Seas, etc. Each section has a different number of
/// rows, with the names of various seas. Within the Major Atlantic Ocean
/// Seas section, the row Sargasso is selected.](List-6-iOS)
///
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@MainActor @preconcurrency public struct List<SelectionValue, Content> : View where SelectionValue : Hashable, Content : View {

    /// Creates a list with the given content that supports selecting multiple
    /// rows.
    ///
    /// - Parameters:
    ///   - selection: A binding to a set that identifies selected rows.
    ///   - content: The content of the list.
    @available(watchOS, unavailable)
    @MainActor @preconcurrency public init(selection: Binding<Set<SelectionValue>>?, @ViewBuilder content: () -> Content)

    /// Creates a list with the given content that supports selecting a single
    /// row.
    ///
    /// - Parameters:
    ///   - selection: A binding to a selected row.
    ///   - content: The content of the list.
    @available(watchOS 10.0, *)
    @MainActor @preconcurrency public init(selection: Binding<SelectionValue?>?, @ViewBuilder content: () -> Content)

    /// The content of the list.
    @MainActor @preconcurrency public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    public typealias Body = some View
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension List {

    /// Creates a list that computes its rows on demand from an underlying
    /// collection of identifiable data, optionally allowing users to select
    /// multiple rows.
    ///
    /// - Parameters:
    ///   - data: The identifiable data for computing the list.
    ///   - selection: A binding to a set that identifies selected rows.
    ///   - rowContent: A view builder that creates the view for a single row of
    ///     the list.
    @available(watchOS, unavailable)
    @MainActor @preconcurrency public init<Data, RowContent>(_ data: Data, selection: Binding<Set<SelectionValue>>?, @ViewBuilder rowContent: @escaping (Data.Element) -> RowContent) where Content == ForEach<Data, Data.Element.ID, RowContent>, Data : RandomAccessCollection, RowContent : View, Data.Element : Identifiable

    /// Creates a hierarchical list that computes its rows on demand from an
    /// underlying collection of identifiable data, optionally allowing users to
    /// select multiple rows.
    ///
    /// - Parameters:
    ///   - data: The identifiable data for computing the list.
    ///   - children: A key path to a property whose non-`nil` value gives the
    ///     children of `data`. A non-`nil` but empty value denotes an element
    ///     capable of having children that's currently childless, such as an
    ///     empty directory in a file system. On the other hand, if the property
    ///     at the key path is `nil`, then the outline group treats `data` as a
    ///     leaf in the tree, like a regular file in a file system.
    ///   - selection: A binding to a set that identifies selected rows.
    ///   - rowContent: A view builder that creates the view for a single row of
    ///     the list.
    @available(iOS 14.0, macOS 11.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    @MainActor @preconcurrency public init<Data, RowContent>(_ data: Data, children: KeyPath<Data.Element, Data?>, selection: Binding<Set<SelectionValue>>?, @ViewBuilder rowContent: @escaping (Data.Element) -> RowContent) where Content == OutlineGroup<Data, Data.Element.ID, RowContent, RowContent, DisclosureGroup<RowContent, OutlineSubgroupChildren>>, Data : RandomAccessCollection, RowContent : View, Data.Element : Identifiable

    /// Creates a list that identifies its rows based on a key path to the
    /// identifier of the underlying data, optionally allowing users to select
    /// multiple rows.
    ///
    /// - Parameters:
    ///   - data: The data for populating the list.
    ///   - id: The key path to the data model's identifier.
    ///   - selection: A binding to a set that identifies selected rows.
    ///   - rowContent: A view builder that creates the view for a single row of
    ///     the list.
    @available(watchOS, unavailable)
    @MainActor @preconcurrency public init<Data, ID, RowContent>(_ data: Data, id: KeyPath<Data.Element, ID>, selection: Binding<Set<SelectionValue>>?, @ViewBuilder rowContent: @escaping (Data.Element) -> RowContent) where Content == ForEach<Data, ID, RowContent>, Data : RandomAccessCollection, ID : Hashable, RowContent : View

    /// Creates a hierarchical list that identifies its rows based on a key path
    /// to the identifier of the underlying data, optionally allowing users to
    /// select multiple rows.
    ///
    /// - Parameters:
    ///   - data: The data for populating the list.
    ///   - id: The key path to the data model's identifier.
    ///   - children: A key path to a property whose non-`nil` value gives the
    ///     children of `data`. A non-`nil` but empty value denotes a node capable
    ///     of having children that is currently childless, such as an empty
    ///     directory in a file system. On the other hand, if the property at the
    ///     key path is `nil`, then `data` is treated as a leaf node in the tree,
    ///     like a regular file in a file system.
    ///   - selection: A binding to a set that identifies selected rows.
    ///   - rowContent: A view builder that creates the view for a single row of
    ///     the list.
    @available(iOS 14.0, macOS 11.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    @MainActor @preconcurrency public init<Data, ID, RowContent>(_ data: Data, id: KeyPath<Data.Element, ID>, children: KeyPath<Data.Element, Data?>, selection: Binding<Set<SelectionValue>>?, @ViewBuilder rowContent: @escaping (Data.Element) -> RowContent) where Content == OutlineGroup<Data, ID, RowContent, RowContent, DisclosureGroup<RowContent, OutlineSubgroupChildren>>, Data : RandomAccessCollection, ID : Hashable, RowContent : View

    /// Creates a list that computes its views on demand over a constant range,
    /// optionally allowing users to select multiple rows.
    ///
    /// This instance only reads the initial value of `data` and doesn't need to
    /// identify views across updates. To compute views on demand over a dynamic
    /// range, use ``List/init(_:id:selection:rowContent:)``.
    ///
    /// - Parameters:
    ///   - data: A constant range of data to populate the list.
    ///   - selection: A binding to a set that identifies selected rows.
    ///   - rowContent: A view builder that creates the view for a single row of
    ///     the list.
    @available(watchOS, unavailable)
    @MainActor @preconcurrency public init<RowContent>(_ data: Range<Int>, selection: Binding<Set<SelectionValue>>?, @ViewBuilder rowContent: @escaping (Int) -> RowContent) where Content == ForEach<Range<Int>, Int, HStack<RowContent>>, RowContent : View

    /// Creates a list that computes its rows on demand from an underlying
    /// collection of identifiable data, optionally allowing users to select a
    /// single row.
    ///
    /// - Parameters:
    ///   - data: The identifiable data for computing the list.
    ///   - selection: A binding to a selected value.
    ///   - rowContent: A view builder that creates the view for a single row of
    ///     the list.
    @available(watchOS 10.0, *)
    @MainActor @preconcurrency public init<Data, RowContent>(_ data: Data, selection: Binding<SelectionValue?>?, @ViewBuilder rowContent: @escaping (Data.Element) -> RowContent) where Content == ForEach<Data, Data.Element.ID, RowContent>, Data : RandomAccessCollection, RowContent : View, Data.Element : Identifiable

    /// Creates a hierarchical list that computes its rows on demand from an
    /// underlying collection of identifiable data, optionally allowing users to
    /// select a single row.
    ///
    /// - Parameters:
    ///   - data: The identifiable data for computing the list.
    ///   - children: A key path to a property whose non-`nil` value gives the
    ///     children of `data`. A non-`nil` but empty value denotes a node capable
    ///     of having children that is currently childless, such as an empty
    ///     directory in a file system. On the other hand, if the property at the
    ///     key path is `nil`, then `data` is treated as a leaf node in the tree,
    ///     like a regular file in a file system.
    ///   - selection: A binding to a selected value.
    ///   - rowContent: A view builder that creates the view for a single row of
    ///     the list.
    @available(iOS 14.0, macOS 11.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    @MainActor @preconcurrency public init<Data, RowContent>(_ data: Data, children: KeyPath<Data.Element, Data?>, selection: Binding<SelectionValue?>?, @ViewBuilder rowContent: @escaping (Data.Element) -> RowContent) where Content == OutlineGroup<Data, Data.Element.ID, RowContent, RowContent, DisclosureGroup<RowContent, OutlineSubgroupChildren>>, Data : RandomAccessCollection, RowContent : View, Data.Element : Identifiable

    /// Creates a list that identifies its rows based on a key path to the
    /// identifier of the underlying data, optionally allowing users to select a
    /// single row.
    ///
    /// - Parameters:
    ///   - data: The data for populating the list.
    ///   - id: The key path to the data model's identifier.
    ///   - selection: A binding to a selected value.
    ///   - rowContent: A view builder that creates the view for a single row of
    ///     the list.
    @available(watchOS 10.0, *)
    @MainActor @preconcurrency public init<Data, ID, RowContent>(_ data: Data, id: KeyPath<Data.Element, ID>, selection: Binding<SelectionValue?>?, @ViewBuilder rowContent: @escaping (Data.Element) -> RowContent) where Content == ForEach<Data, ID, RowContent>, Data : RandomAccessCollection, ID : Hashable, RowContent : View

    /// Creates a hierarchical list that identifies its rows based on a key path
    /// to the identifier of the underlying data, optionally allowing users to
    /// select a single row.
    ///
    /// - Parameters:
    ///   - data: The data for populating the list.
    ///   - id: The key path to the data model's identifier.
    ///   - children: A key path to a property whose non-`nil` value gives the
    ///     children of `data`. A non-`nil` but empty value denotes a node capable
    ///     of having children that is currently childless, such as an empty
    ///     directory in a file system. On the other hand, if the property at the
    ///     key path is `nil`, then `data` is treated as a leaf node in the tree,
    ///     like a regular file in a file system.
    ///   - selection: A binding to a selected value.
    ///   - rowContent: A view builder that creates the view for a single row of
    ///     the list.
    @available(iOS 14.0, macOS 11.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    @MainActor @preconcurrency public init<Data, ID, RowContent>(_ data: Data, id: KeyPath<Data.Element, ID>, children: KeyPath<Data.Element, Data?>, selection: Binding<SelectionValue?>?, @ViewBuilder rowContent: @escaping (Data.Element) -> RowContent) where Content == OutlineGroup<Data, ID, RowContent, RowContent, DisclosureGroup<RowContent, OutlineSubgroupChildren>>, Data : RandomAccessCollection, ID : Hashable, RowContent : View

    /// Creates a list that computes its views on demand over a constant range,
    /// optionally allowing users to select a single row.
    ///
    /// This instance only reads the initial value of `data` and doesn't need to
    /// identify views across updates. To compute views on demand over a dynamic
    /// range, use ``List/init(_:id:selection:rowContent:)``.
    ///
    /// - Parameters:
    ///   - data: A constant range of data to populate the list.
    ///   - selection: A binding to a selected value.
    ///   - rowContent: A view builder that creates the view for a single row of
    ///     the list.
    @available(watchOS, unavailable)
    @MainActor @preconcurrency public init<RowContent>(_ data: Range<Int>, selection: Binding<SelectionValue?>?, @ViewBuilder rowContent: @escaping (Int) -> RowContent) where Content == ForEach<Range<Int>, Int, RowContent>, RowContent : View
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension List where SelectionValue == Never {

    /// Creates a list with the given content.
    ///
    /// - Parameter content: The content of the list.
    @MainActor @preconcurrency public init(@ViewBuilder content: () -> Content)

    /// Creates a list that computes its rows on demand from an underlying
    /// collection of identifiable data.
    ///
    /// - Parameters:
    ///   - data: A collection of identifiable data for computing the list.
    ///   - rowContent: A view builder that creates the view for a single row of
    ///     the list.
    @MainActor @preconcurrency public init<Data, RowContent>(_ data: Data, @ViewBuilder rowContent: @escaping (Data.Element) -> RowContent) where Content == ForEach<Data, Data.Element.ID, RowContent>, Data : RandomAccessCollection, RowContent : View, Data.Element : Identifiable

    /// Creates a hierarchical list that computes its rows on demand from an
    /// underlying collection of identifiable data.
    ///
    /// - Parameters:
    ///   - data: A collection of identifiable data for computing the list.
    ///   - children: A key path to a property whose non-`nil` value gives the
    ///     children of `data`. A non-`nil` but empty value denotes a node capable
    ///     of having children that is currently childless, such as an empty
    ///     directory in a file system. On the other hand, if the property at the
    ///     key path is `nil`, then `data` is treated as a leaf node in the tree,
    ///     like a regular file in a file system.
    ///   - rowContent: A view builder that creates the view for a single row of
    ///     the list.
    @available(iOS 14.0, macOS 11.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    @MainActor @preconcurrency public init<Data, RowContent>(_ data: Data, children: KeyPath<Data.Element, Data?>, @ViewBuilder rowContent: @escaping (Data.Element) -> RowContent) where Content == OutlineGroup<Data, Data.Element.ID, RowContent, RowContent, DisclosureGroup<RowContent, OutlineSubgroupChildren>>, Data : RandomAccessCollection, RowContent : View, Data.Element : Identifiable

    /// Creates a list that identifies its rows based on a key path to the
    /// identifier of the underlying data.
    ///
    /// - Parameters:
    ///   - data: The data for populating the list.
    ///   - id: The key path to the data model's identifier.
    ///   - rowContent: A view builder that creates the view for a single row of
    ///     the list.
    @MainActor @preconcurrency public init<Data, ID, RowContent>(_ data: Data, id: KeyPath<Data.Element, ID>, @ViewBuilder rowContent: @escaping (Data.Element) -> RowContent) where Content == ForEach<Data, ID, RowContent>, Data : RandomAccessCollection, ID : Hashable, RowContent : View

    /// Creates a hierarchical list that identifies its rows based on a key path
    /// to the identifier of the underlying data.
    ///
    /// - Parameters:
    ///   - data: The data for populating the list.
    ///   - id: The key path to the data model's identifier.
    ///   - children: A key path to a property whose non-`nil` value gives the
    ///     children of `data`. A non-`nil` but empty value denotes a node capable
    ///     of having children that is currently childless, such as an empty
    ///     directory in a file system. On the other hand, if the property at the
    ///     key path is `nil`, then `data` is treated as a leaf node in the tree,
    ///     like a regular file in a file system.
    ///   - rowContent: A view builder that creates the view for a single row of
    ///     the list.
    @available(iOS 14.0, macOS 11.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    @MainActor @preconcurrency public init<Data, ID, RowContent>(_ data: Data, id: KeyPath<Data.Element, ID>, children: KeyPath<Data.Element, Data?>, @ViewBuilder rowContent: @escaping (Data.Element) -> RowContent) where Content == OutlineGroup<Data, ID, RowContent, RowContent, DisclosureGroup<RowContent, OutlineSubgroupChildren>>, Data : RandomAccessCollection, ID : Hashable, RowContent : View

    /// Creates a list that computes its views on demand over a constant range.
    ///
    /// This instance only reads the initial value of `data` and doesn't need to
    /// identify views across updates. To compute views on demand over a dynamic
    /// range, use ``List/init(_:id:rowContent:)``.
    ///
    /// - Parameters:
    ///   - data: A constant range of data to populate the list.
    ///   - rowContent: A view builder that creates the view for a single row of
    ///     the list.
    @MainActor @preconcurrency public init<RowContent>(_ data: Range<Int>, @ViewBuilder rowContent: @escaping (Int) -> RowContent) where Content == ForEach<Range<Int>, Int, RowContent>, RowContent : View
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension List {

    /// Creates a list that computes its rows on demand from an underlying
    /// collection of identifiable data, optionally allowing users to select
    /// multiple rows.
    ///
    /// - Parameters:
    ///   - data: The identifiable data for computing the list.
    ///   - selection: A binding to a set that identifies selected rows.
    ///   - rowContent: A view builder that creates the view for a single row of
    ///     the list.
    @available(watchOS, unavailable)
    @MainActor @preconcurrency public init<Data, RowContent>(_ data: Binding<Data>, selection: Binding<Set<SelectionValue>>?, @ViewBuilder rowContent: @escaping (Binding<Data.Element>) -> RowContent) where Content == ForEach<LazyMapSequence<Data.Indices, (Data.Index, Data.Element.ID)>, Data.Element.ID, RowContent>, Data : MutableCollection, Data : RandomAccessCollection, RowContent : View, Data.Element : Identifiable, Data.Index : Hashable

    /// Creates a list that identifies its rows based on a key path to the
    /// identifier of the underlying data, optionally allowing users to select
    /// multiple rows.
    ///
    /// - Parameters:
    ///   - data: The data for populating the list.
    ///   - id: The key path to the data model's identifier.
    ///   - selection: A binding to a set that identifies selected rows.
    ///   - rowContent: A view builder that creates the view for a single row of
    ///     the list.
    @available(watchOS, unavailable)
    @MainActor @preconcurrency public init<Data, ID, RowContent>(_ data: Binding<Data>, id: KeyPath<Data.Element, ID>, selection: Binding<Set<SelectionValue>>?, @ViewBuilder rowContent: @escaping (Binding<Data.Element>) -> RowContent) where Content == ForEach<LazyMapSequence<Data.Indices, (Data.Index, ID)>, ID, RowContent>, Data : MutableCollection, Data : RandomAccessCollection, ID : Hashable, RowContent : View, Data.Index : Hashable

    /// Creates a list that computes its rows on demand from an underlying
    /// collection of identifiable data, optionally allowing users to select a
    /// single row.
    ///
    /// - Parameters:
    ///   - data: The identifiable data for computing the list.
    ///   - selection: A binding to a selected value.
    ///   - rowContent: A view builder that creates the view for a single row of
    ///     the list.
    @available(watchOS, unavailable)
    @MainActor @preconcurrency public init<Data, RowContent>(_ data: Binding<Data>, selection: Binding<SelectionValue?>?, @ViewBuilder rowContent: @escaping (Binding<Data.Element>) -> RowContent) where Content == ForEach<LazyMapSequence<Data.Indices, (Data.Index, Data.Element.ID)>, Data.Element.ID, RowContent>, Data : MutableCollection, Data : RandomAccessCollection, RowContent : View, Data.Element : Identifiable, Data.Index : Hashable

    /// Creates a list that identifies its rows based on a key path to the
    /// identifier of the underlying data, optionally allowing users to select a
    /// single row.
    ///
    /// - Parameters:
    ///   - data: The data for populating the list.
    ///   - id: The key path to the data model's identifier.
    ///   - selection: A binding to a selected value.
    ///   - rowContent: A view builder that creates the view for a single row of
    ///     the list.
    @available(watchOS, unavailable)
    @MainActor @preconcurrency public init<Data, ID, RowContent>(_ data: Binding<Data>, id: KeyPath<Data.Element, ID>, selection: Binding<SelectionValue?>?, @ViewBuilder rowContent: @escaping (Binding<Data.Element>) -> RowContent) where Content == ForEach<LazyMapSequence<Data.Indices, (Data.Index, ID)>, ID, RowContent>, Data : MutableCollection, Data : RandomAccessCollection, ID : Hashable, RowContent : View, Data.Index : Hashable
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension List where SelectionValue == Never {

    /// Creates a list that computes its rows on demand from an underlying
    /// collection of identifiable data.
    ///
    /// - Parameters:
    ///   - data: A collection of identifiable data for computing the list.
    ///   - rowContent: A view builder that creates the view for a single row of
    ///     the list.
    @MainActor @preconcurrency public init<Data, RowContent>(_ data: Binding<Data>, @ViewBuilder rowContent: @escaping (Binding<Data.Element>) -> RowContent) where Content == ForEach<LazyMapSequence<Data.Indices, (Data.Index, Data.Element.ID)>, Data.Element.ID, RowContent>, Data : MutableCollection, Data : RandomAccessCollection, RowContent : View, Data.Element : Identifiable, Data.Index : Hashable

    /// Creates a list that identifies its rows based on a key path to the
    /// identifier of the underlying data.
    ///
    /// - Parameters:
    ///   - data: The data for populating the list.
    ///   - id: The key path to the data model's identifier.
    ///   - rowContent: A view builder that creates the view for a single row of
    ///     the list.
    @MainActor @preconcurrency public init<Data, ID, RowContent>(_ data: Binding<Data>, id: KeyPath<Data.Element, ID>, @ViewBuilder rowContent: @escaping (Binding<Data.Element>) -> RowContent) where Content == ForEach<LazyMapSequence<Data.Indices, (Data.Index, ID)>, ID, RowContent>, Data : MutableCollection, Data : RandomAccessCollection, ID : Hashable, RowContent : View, Data.Index : Hashable
}

@available(iOS 15.0, macOS 12.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension List {

    /// Creates a hierarchical list that computes its rows on demand from a
    /// binding to an underlying collection of identifiable data, optionally
    /// allowing users to select multiple rows.
    ///
    /// - Parameters:
    ///   - data: The identifiable data for computing the list.
    ///   - children: A key path to a property whose non-`nil` value gives the
    ///     children of `data`. A non-`nil` but empty value denotes an element
    ///     capable of having children that's currently childless, such as an
    ///     empty directory in a file system. On the other hand, if the property
    ///     at the key path is `nil`, then the outline group treats `data` as a
    ///     leaf in the tree, like a regular file in a file system.
    ///   - selection: A binding to a set that identifies selected rows.
    ///   - rowContent: A view builder that creates the view for a single row of
    ///     the list.
    @MainActor @preconcurrency public init<Data, RowContent>(_ data: Binding<Data>, children: WritableKeyPath<Data.Element, Data?>, selection: Binding<Set<SelectionValue>>?, @ViewBuilder rowContent: @escaping (Binding<Data.Element>) -> RowContent) where Content == OutlineGroup<Binding<Data>, Data.Element.ID, RowContent, RowContent, DisclosureGroup<RowContent, OutlineSubgroupChildren>>, Data : MutableCollection, Data : RandomAccessCollection, RowContent : View, Data.Element : Identifiable

    /// Creates a hierarchical list that identifies its rows based on a key path
    /// to the identifier of the underlying data, optionally allowing users to
    /// select multiple rows.
    ///
    /// - Parameters:
    ///   - data: The data for populating the list.
    ///   - id: The key path to the data model's identifier.
    ///   - children: A key path to a property whose non-`nil` value gives the
    ///     children of `data`. A non-`nil` but empty value denotes a node capable
    ///     of having children that is currently childless, such as an empty
    ///     directory in a file system. On the other hand, if the property at the
    ///     key path is `nil`, then `data` is treated as a leaf node in the tree,
    ///     like a regular file in a file system.
    ///   - selection: A binding to a set that identifies selected rows.
    ///   - rowContent: A view builder that creates the view for a single row of
    ///     the list.
    @MainActor @preconcurrency public init<Data, ID, RowContent>(_ data: Binding<Data>, id: KeyPath<Data.Element, ID>, children: WritableKeyPath<Data.Element, Data?>, selection: Binding<Set<SelectionValue>>?, @ViewBuilder rowContent: @escaping (Binding<Data.Element>) -> RowContent) where Content == OutlineGroup<Binding<Data>, ID, RowContent, RowContent, DisclosureGroup<RowContent, OutlineSubgroupChildren>>, Data : MutableCollection, Data : RandomAccessCollection, ID : Hashable, RowContent : View

    /// Creates a hierarchical list that computes its rows on demand from a
    /// binding to an underlying collection of identifiable data, optionally
    /// allowing users to select a single row.
    ///
    /// - Parameters:
    ///   - data: The identifiable data for computing the list.
    ///   - children: A key path to a property whose non-`nil` value gives the
    ///     children of `data`. A non-`nil` but empty value denotes a node capable
    ///     of having children that is currently childless, such as an empty
    ///     directory in a file system. On the other hand, if the property at the
    ///     key path is `nil`, then `data` is treated as a leaf node in the tree,
    ///     like a regular file in a file system.
    ///   - selection: A binding to a selected value.
    ///   - rowContent: A view builder that creates the view for a single row of
    ///     the list.
    @MainActor @preconcurrency public init<Data, RowContent>(_ data: Binding<Data>, children: WritableKeyPath<Data.Element, Data?>, selection: Binding<SelectionValue?>?, @ViewBuilder rowContent: @escaping (Binding<Data.Element>) -> RowContent) where Content == OutlineGroup<Binding<Data>, Data.Element.ID, RowContent, RowContent, DisclosureGroup<RowContent, OutlineSubgroupChildren>>, Data : MutableCollection, Data : RandomAccessCollection, RowContent : View, Data.Element : Identifiable

    /// Creates a hierarchical list that identifies its rows based on a key path
    /// to the identifier of the underlying data, optionally allowing users to
    /// select a single row.
    ///
    /// - Parameters:
    ///   - data: The data for populating the list.
    ///   - id: The key path to the data model's identifier.
    ///   - children: A key path to a property whose non-`nil` value gives the
    ///     children of `data`. A non-`nil` but empty value denotes a node capable
    ///     of having children that is currently childless, such as an empty
    ///     directory in a file system. On the other hand, if the property at the
    ///     key path is `nil`, then `data` is treated as a leaf node in the tree,
    ///     like a regular file in a file system.
    ///   - selection: A binding to a selected value.
    ///   - rowContent: A view builder that creates the view for a single row of
    ///     the list.
    @MainActor @preconcurrency public init<Data, ID, RowContent>(_ data: Binding<Data>, id: KeyPath<Data.Element, ID>, children: WritableKeyPath<Data.Element, Data?>, selection: Binding<SelectionValue?>?, @ViewBuilder rowContent: @escaping (Binding<Data.Element>) -> RowContent) where Content == OutlineGroup<Binding<Data>, ID, RowContent, RowContent, DisclosureGroup<RowContent, OutlineSubgroupChildren>>, Data : MutableCollection, Data : RandomAccessCollection, ID : Hashable, RowContent : View
}

@available(iOS 15.0, macOS 12.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension List where SelectionValue == Never {

    /// Creates a hierarchical list that computes its rows on demand from a
    /// binding to an underlying collection of identifiable data.
    ///
    /// - Parameters:
    ///   - data: A collection of identifiable data for computing the list.
    ///   - children: A key path to a property whose non-`nil` value gives the
    ///     children of `data`. A non-`nil` but empty value denotes a node capable
    ///     of having children that is currently childless, such as an empty
    ///     directory in a file system. On the other hand, if the property at the
    ///     key path is `nil`, then `data` is treated as a leaf node in the tree,
    ///     like a regular file in a file system.
    ///   - rowContent: A view builder that creates the view for a single row of
    ///     the list.
    @MainActor @preconcurrency public init<Data, RowContent>(_ data: Binding<Data>, children: WritableKeyPath<Data.Element, Data?>, @ViewBuilder rowContent: @escaping (Binding<Data.Element>) -> RowContent) where Content == OutlineGroup<Binding<Data>, Data.Element.ID, RowContent, RowContent, DisclosureGroup<RowContent, OutlineSubgroupChildren>>, Data : MutableCollection, Data : RandomAccessCollection, RowContent : View, Data.Element : Identifiable

    /// Creates a hierarchical list that identifies its rows based on a key path
    /// to the identifier of the underlying data.
    ///
    /// - Parameters:
    ///   - data: The data for populating the list.
    ///   - id: The key path to the data model's identifier.
    ///   - children: A key path to a property whose non-`nil` value gives the
    ///     children of `data`. A non-`nil` but empty value denotes a node capable
    ///     of having children that is currently childless, such as an empty
    ///     directory in a file system. On the other hand, if the property at the
    ///     key path is `nil`, then `data` is treated as a leaf node in the tree,
    ///     like a regular file in a file system.
    ///   - rowContent: A view builder that creates the view for a single row of
    ///     the list.
    @MainActor @preconcurrency public init<Data, ID, RowContent>(_ data: Binding<Data>, id: KeyPath<Data.Element, ID>, children: WritableKeyPath<Data.Element, Data?>, @ViewBuilder rowContent: @escaping (Binding<Data.Element>) -> RowContent) where Content == OutlineGroup<Binding<Data>, ID, RowContent, RowContent, DisclosureGroup<RowContent, OutlineSubgroupChildren>>, Data : MutableCollection, Data : RandomAccessCollection, ID : Hashable, RowContent : View
}

@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension List {

    /// Creates a list that computes its rows on demand from an underlying
    /// collection of identifiable, allows to edit the collection, and
    /// optionally allows users to select multiple rows.
    ///
    /// The following example creates a list to display a collection of favorite
    /// foods allowing the user to delete or move elements from the
    /// collection, and select multiple elements.
    ///
    ///     List(
    ///         $foods,
    ///         editActions: [.delete, .move],
    ///         selection: $selectedFoods
    ///     ) { $food in
    ///        HStack {
    ///            Text(food.name)
    ///            Toggle("Favorite", isOn: $food.isFavorite)
    ///        }
    ///     }
    ///
    /// Use ``View/deleteDisabled(_:)`` and ``View/moveDisabled(_:)``
    /// to disable respectively delete or move actions on a per-row basis.
    ///
    /// Explicit ``DynamicViewContent.onDelete(perform:)``,
    /// ``DynamicViewContent.onMove(perform:)``, or
    /// ``View.swipeActions(edge:allowsFullSwipe:content:)``
    /// modifiers will override any synthesized action
    ///
    /// - Parameters:
    ///   - data: The identifiable data for computing and to be edited by
    ///     the list.
    ///   - editActions: The edit actions that are synthesized on `data`.
    ///   - selection: A binding to a set that identifies selected rows.
    ///   - rowContent: A view builder that creates the view for a single row of
    ///     the list.
    @available(watchOS, unavailable)
    @MainActor @preconcurrency public init<Data, RowContent>(_ data: Binding<Data>, editActions: EditActions<Data>, selection: Binding<Set<SelectionValue>>?, @ViewBuilder rowContent: @escaping (Binding<Data.Element>) -> RowContent) where Content == ForEach<IndexedIdentifierCollection<Data, Data.Element.ID>, Data.Element.ID, EditableCollectionContent<RowContent, Data>>, Data : MutableCollection, Data : RandomAccessCollection, RowContent : View, Data.Element : Identifiable, Data.Index : Hashable

    /// Creates a list that computes its rows on demand from an underlying
    /// collection of identifiable, allows to edit the collection, and
    /// optionally allows users to select multiple rows.
    ///
    /// The following example creates a list to display a collection of favorite
    /// foods allowing the user to delete or move elements from the
    /// collection, and select multiple elements.
    ///
    ///     List(
    ///         $foods,
    ///         editActions: [.delete, .move],
    ///         selection: $selectedFoods
    ///     ) { $food in
    ///        HStack {
    ///            Text(food.name)
    ///            Toggle("Favorite", isOn: $food.isFavorite)
    ///        }
    ///     }
    ///
    /// Use ``View/deleteDisabled(_:)`` and ``View/moveDisabled(_:)``
    /// to disable respectively delete or move actions on a per-row basis.
    ///
    /// Explicit ``DynamicViewContent.onDelete(perform:)``,
    /// ``DynamicViewContent.onMove(perform:)``, or
    /// ``View.swipeActions(edge:allowsFullSwipe:content:)``
    /// modifiers will override any synthesized action
    ///
    /// - Parameters:
    ///   - data: The identifiable data for computing and to be edited by
    ///     the list.
    ///   - id: The key path to the data model's identifier.
    ///   - editActions: The edit actions that are synthesized on `data`.
    ///   - selection: A binding to a set that identifies selected rows.
    ///   - rowContent: A view builder that creates the view for a single row of
    ///
    @available(watchOS, unavailable)
    @MainActor @preconcurrency public init<Data, ID, RowContent>(_ data: Binding<Data>, id: KeyPath<Data.Element, ID>, editActions: EditActions<Data>, selection: Binding<Set<SelectionValue>>?, @ViewBuilder rowContent: @escaping (Binding<Data.Element>) -> RowContent) where Content == ForEach<IndexedIdentifierCollection<Data, ID>, ID, EditableCollectionContent<RowContent, Data>>, Data : MutableCollection, Data : RandomAccessCollection, ID : Hashable, RowContent : View, Data.Index : Hashable
}

@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension List {

    /// Creates a list that computes its rows on demand from an underlying
    /// collection of identifiable data, allows to edit the collection, and
    /// optionally allowing users to select a single row.
    ///
    /// The following example creates a list to display a collection of favorite
    /// foods allowing the user to delete or move elements from the
    /// collection, and select a single elements.
    ///
    ///     List(
    ///         $foods,
    ///         editActions: [.delete, .move],
    ///         selection: $selectedFood
    ///     ) { $food in
    ///        HStack {
    ///            Text(food.name)
    ///            Toggle("Favorite", isOn: $food.isFavorite)
    ///        }
    ///     }
    ///
    /// Use ``View/deleteDisabled(_:)`` and ``View/moveDisabled(_:)``
    /// to disable respectively delete or move actions on a per-row basis.
    ///
    /// Explicit ``DynamicViewContent.onDelete(perform:)``,
    /// ``DynamicViewContent.onMove(perform:)``, or
    /// ``View.swipeActions(edge:allowsFullSwipe:content:)``
    /// modifiers will override any synthesized action
    ///
    /// - Parameters:
    ///   - data: The identifiable data for computing the list.
    ///   - editActions: The edit actions that are synthesized on `data`.
    ///   - selection: A binding to a selected value.
    ///   - rowContent: A view builder that creates the view for a single row of
    ///     the list.
    @available(watchOS, unavailable)
    @MainActor @preconcurrency public init<Data, RowContent>(_ data: Binding<Data>, editActions: EditActions<Data>, selection: Binding<SelectionValue?>?, @ViewBuilder rowContent: @escaping (Binding<Data.Element>) -> RowContent) where Content == ForEach<IndexedIdentifierCollection<Data, Data.Element.ID>, Data.Element.ID, EditableCollectionContent<RowContent, Data>>, Data : MutableCollection, Data : RandomAccessCollection, RowContent : View, Data.Element : Identifiable, Data.Index : Hashable

    /// Creates a list that computes its rows on demand from an underlying
    /// collection of identifiable data, allows to edit the collection, and
    /// optionally allowing users to select a single row.
    ///
    /// The following example creates a list to display a collection of favorite
    /// foods allowing the user to delete or move elements from the
    /// collection, and select a single elements.
    ///
    ///     List(
    ///         $foods,
    ///         editActions: [.delete, .move],
    ///         selection: $selectedFood
    ///     ) { $food in
    ///        HStack {
    ///            Text(food.name)
    ///            Toggle("Favorite", isOn: $food.isFavorite)
    ///        }
    ///     }
    ///
    /// Use ``View/deleteDisabled(_:)`` and ``View/moveDisabled(_:)``
    /// to disable respectively delete or move actions on a per-row basis.
    ///
    /// Explicit ``DynamicViewContent.onDelete(perform:)``,
    /// ``DynamicViewContent.onMove(perform:)``, or
    /// ``View.swipeActions(edge:allowsFullSwipe:content:)``
    /// modifiers will override any synthesized action
    ///
    /// - Parameters:
    ///   - data: The identifiable data for computing the list.
    ///   - id: The key path to the data model's identifier.
    ///   - editActions: The edit actions that are synthesized on `data`.
    ///   - selection: A binding to a selected value.
    ///   - rowContent: A view builder that creates the view for a single row of
    ///     the list.
    @available(watchOS, unavailable)
    @MainActor @preconcurrency public init<Data, ID, RowContent>(_ data: Binding<Data>, id: KeyPath<Data.Element, ID>, editActions: EditActions<Data>, selection: Binding<SelectionValue?>?, @ViewBuilder rowContent: @escaping (Binding<Data.Element>) -> RowContent) where Content == ForEach<IndexedIdentifierCollection<Data, ID>, ID, EditableCollectionContent<RowContent, Data>>, Data : MutableCollection, Data : RandomAccessCollection, ID : Hashable, RowContent : View, Data.Index : Hashable
}

@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension List where SelectionValue == Never {

    /// Creates a list that computes its rows on demand from an underlying
    /// collection of identifiable data and allows to edit the collection.
    ///
    /// The following example creates a list to display a collection of favorite
    /// foods allowing the user to delete or move elements from the
    /// collection.
    ///
    ///     List($foods, editActions: [.delete, .move]) { $food in
    ///        HStack {
    ///            Text(food.name)
    ///            Toggle("Favorite", isOn: $food.isFavorite)
    ///        }
    ///     }
    ///
    /// Use ``View/deleteDisabled(_:)`` and ``View/moveDisabled(_:)``
    /// to disable respectively delete or move actions on a per-row basis.
    ///
    /// Explicit ``DynamicViewContent.onDelete(perform:)``,
    /// ``DynamicViewContent.onMove(perform:)``, or
    /// ``View.swipeActions(edge:allowsFullSwipe:content:)``
    /// modifiers will override any synthesized action
    ///
    /// - Parameters:
    ///   - data: A collection of identifiable data for computing the list.
    ///   - editActions: The edit actions that are synthesized on `data`.
    ///   - rowContent: A view builder that creates the view for a single row of
    ///     the list.
    @MainActor @preconcurrency public init<Data, RowContent>(_ data: Binding<Data>, editActions: EditActions<Data>, @ViewBuilder rowContent: @escaping (Binding<Data.Element>) -> RowContent) where Content == ForEach<IndexedIdentifierCollection<Data, Data.Element.ID>, Data.Element.ID, EditableCollectionContent<RowContent, Data>>, Data : MutableCollection, Data : RandomAccessCollection, RowContent : View, Data.Element : Identifiable, Data.Index : Hashable

    /// Creates a list that computes its rows on demand from an underlying
    /// collection of identifiable data and allows to edit the collection.
    ///
    /// The following example creates a list to display a collection of favorite
    /// foods allowing the user to delete or move elements from the
    /// collection.
    ///
    ///     List($foods, editActions: [.delete, .move]) { $food in
    ///        HStack {
    ///            Text(food.name)
    ///            Toggle("Favorite", isOn: $food.isFavorite)
    ///        }
    ///     }
    ///
    /// Use ``View/deleteDisabled(_:)`` and ``View/moveDisabled(_:)``
    /// to disable respectively delete or move actions on a per-row basis.
    ///
    /// Explicit ``DynamicViewContent.onDelete(perform:)``,
    /// ``DynamicViewContent.onMove(perform:)``, or
    /// ``View.swipeActions(edge:allowsFullSwipe:content:)``
    /// modifiers will override any synthesized action
    ///
    /// - Parameters:
    ///   - data: A collection of identifiable data for computing the list.
    ///   - id: The key path to the data model's identifier.
    ///   - editActions: The edit actions that are synthesized on `data`.
    ///   - rowContent: A view builder that creates the view for a single row of
    ///     the list.
    @MainActor @preconcurrency public init<Data, ID, RowContent>(_ data: Binding<Data>, id: KeyPath<Data.Element, ID>, editActions: EditActions<Data>, @ViewBuilder rowContent: @escaping (Binding<Data.Element>) -> RowContent) where Content == ForEach<IndexedIdentifierCollection<Data, ID>, ID, EditableCollectionContent<RowContent, Data>>, Data : MutableCollection, Data : RandomAccessCollection, ID : Hashable, RowContent : View, Data.Index : Hashable
}

/// A tint effect configuration that you can apply to content in a list.
///
/// Use one of these tint values with the ``View/listItemTint(_:)`` view
/// modifier. The containing list applies the tint in a platform-specific way.
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public struct ListItemTint : Sendable {

    /// An explicit tint color.
    ///
    /// The system doesn't override this tint effect.
    ///
    /// - Parameter tint: The color to use to tint the content.
    public static func fixed(_ tint: Color) -> ListItemTint

    /// An explicit tint color that the system can override.
    ///
    /// The system can override this tint effect, like
    /// when the system has a custom user accent
    /// color on macOS.
    ///
    /// - Parameter tint: The color to use to tint the content.
    public static func preferred(_ tint: Color) -> ListItemTint

    /// A standard grayscale tint effect.
    ///
    /// The system doesn't override monochrome tints.
    public static let monochrome: ListItemTint
}

/// The spacing options between two adjacent sections in a list.
@available(iOS 17.0, watchOS 10.0, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
public struct ListSectionSpacing : Sendable {

    /// The default spacing between sections
    public static let `default`: ListSectionSpacing

    /// Compact spacing between sections
    public static let compact: ListSectionSpacing

    /// Creates a custom spacing value.
    ///
    /// - Parameter spacing: the amount of spacing to use.
    public static func custom(_ spacing: CGFloat) -> ListSectionSpacing
}

/// A protocol that describes the behavior and appearance of a list.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public protocol ListStyle {
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension ListStyle where Self == DefaultListStyle {

    /// The list style that describes a platform's default behavior and
    /// appearance for a list.
    public static var automatic: DefaultListStyle { get }
}

@available(iOS 14.0, macOS 10.15, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension ListStyle where Self == SidebarListStyle {

    /// The list style that describes the behavior and appearance of a
    /// sidebar list.
    ///
    /// On macOS and iOS, the sidebar list style displays disclosure indicators in
    /// the section headers that allow the user to collapse and expand sections.
    public static var sidebar: SidebarListStyle { get }
}

@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension ListStyle where Self == InsetListStyle {

    /// The list style that describes the behavior and appearance of an inset
    /// list.
    public static var inset: InsetListStyle { get }
}

@available(iOS 13.0, tvOS 13.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension ListStyle where Self == GroupedListStyle {

    /// The list style that describes the behavior and appearance of a grouped
    /// list.
    ///
    /// On iOS, the grouped list style displays a larger header and footer than
    /// the ``ListStyle/plain`` style, which visually distances the members of
    /// different sections.
    public static var grouped: GroupedListStyle { get }
}

@available(iOS 14.0, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension ListStyle where Self == InsetGroupedListStyle {

    /// The list style that describes the behavior and appearance of an inset
    /// grouped list.
    ///
    /// On iOS, the inset grouped list style displays a continuous background color
    /// that extends from the section header, around both sides of list items in the
    /// section, and down to the section footer. This visually groups the items
    /// to a greater degree than either the ``ListStyle/inset`` or
    /// ``ListStyle/grouped`` styles do.
    public static var insetGrouped: InsetGroupedListStyle { get }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension ListStyle where Self == PlainListStyle {

    /// The list style that describes the behavior and appearance of a plain
    /// list.
    public static var plain: PlainListStyle { get }
}

/// A gesture that succeeds when the user performs a long press.
///
/// To recognize a long-press gesture on a view, create and configure the
/// gesture, then add it to the view using the ``View/gesture(_:including:)``
/// modifier.
///
/// Add a long-press gesture to a ``Circle`` to animate its color from blue to
/// red, and then change it to green when the gesture ends:
///
///     struct LongPressGestureView: View {
///         @GestureState private var isDetectingLongPress = false
///         @State private var completedLongPress = false
///
///         var longPress: some Gesture {
///             LongPressGesture(minimumDuration: 3)
///                 .updating($isDetectingLongPress) { currentState, gestureState,
///                         transaction in
///                     gestureState = currentState
///                     transaction.animation = Animation.easeIn(duration: 2.0)
///                 }
///                 .onEnded { finished in
///                     self.completedLongPress = finished
///                 }
///         }
///
///         var body: some View {
///             Circle()
///                 .fill(self.isDetectingLongPress ?
///                     Color.red :
///                     (self.completedLongPress ? Color.green : Color.blue))
///                 .frame(width: 100, height: 100, alignment: .center)
///                 .gesture(longPress)
///         }
///     }
@available(iOS 13.0, macOS 10.15, watchOS 6.0, tvOS 14.0, *)
public struct LongPressGesture : Gesture {

    /// The minimum duration of the long press that must elapse before the
    /// gesture succeeds.
    public var minimumDuration: Double

    /// The maximum distance that the long press can move before the gesture
    /// fails.
    @available(tvOS, unavailable)
    public var maximumDistance: CGFloat

    /// Creates a long-press gesture with a minimum duration and a maximum
    /// distance that the interaction can move before the gesture fails.
    ///
    /// - Parameters:
    ///   - minimumDuration: The minimum duration of the long press that must
    ///     elapse before the gesture succeeds.
    ///   - maximumDistance: The maximum distance that the fingers or cursor
    ///     performing the long press can move before the gesture fails.
    @available(tvOS, unavailable)
    public init(minimumDuration: Double = 0.5, maximumDistance: CGFloat = 10)

    /// The type representing the gesture's value.
    public typealias Value = Bool

    /// The type of gesture representing the body of `Self`.
    @available(iOS 13.0, tvOS 14.0, watchOS 6.0, macOS 10.15, *)
    public typealias Body = Never
}

/// A gesture that recognizes a magnification motion and tracks the amount of
/// magnification.
///
/// A magnification gesture tracks how a magnification event sequence changes.
/// To recognize a magnification gesture on a view, create and configure the
/// gesture, and then add it to the view using the
/// ``View/gesture(_:including:)`` modifier.
///
/// Add a magnification gesture to a ``Circle`` that changes its size while the
/// user performs the gesture:
///
///     struct MagnificationGestureView: View {
///         @GestureState private var magnifyBy = 1.0
///
///         var magnification: some Gesture {
///             MagnificationGesture()
///                 .updating($magnifyBy) { currentState, gestureState, transaction in
///                     gestureState = currentState
///                 }
///         }
///
///         var body: some View {
///             Circle()
///                 .frame(width: 100, height: 100)
///                 .scaleEffect(magnifyBy)
///                 .gesture(magnification)
///         }
///     }
///
/// The circle's size resets to its original size when the gesture finishes.
@available(iOS, introduced: 13.0, deprecated: 100000.0, renamed: "MagnifyGesture")
@available(macOS, introduced: 10.15, deprecated: 100000.0, renamed: "MagnifyGesture")
@available(watchOS, unavailable)
@available(tvOS, unavailable)
@available(visionOS, introduced: 1.0, deprecated: 100000.0, renamed: "MagnifyGesture")
public struct MagnificationGesture : Gesture {

    /// The minimum required delta before the gesture starts.
    public var minimumScaleDelta: CGFloat

    /// Creates a magnification gesture with a given minimum delta for the
    /// gesture to start.
    ///
    /// - Parameter minimumScaleDelta: The minimum scale delta required before
    ///   the gesture starts.
    public init(minimumScaleDelta: CGFloat = 0.01)

    /// The type representing the gesture's value.
    public typealias Value = CGFloat

    /// The type of gesture representing the body of `Self`.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, renamed: "MagnifyGesture")
    @available(tvOS, unavailable, renamed: "MagnifyGesture")
    @available(watchOS, unavailable, renamed: "MagnifyGesture")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, renamed: "MagnifyGesture")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, renamed: "MagnifyGesture")
    public typealias Body = Never
}

/// A gesture that recognizes a magnification motion and tracks the amount of
/// magnification.
///
/// A magnify gesture tracks how a magnification event sequence changes.
/// To recognize a magnify gesture on a view, create and configure the
/// gesture, and then add it to the view using the
/// ``View/gesture(_:including:)`` modifier.
///
/// Add a magnify gesture to a ``Circle`` that changes its size while the
/// user performs the gesture:
///
///     struct MagnifyGestureView: View {
///         @GestureState private var magnifyBy = 1.0
///
///         var magnification: some Gesture {
///             MagnifyGesture()
///                 .updating($magnifyBy) { value, gestureState, transaction in
///                     gestureState = value.magnification
///                 }
///         }
///
///         var body: some View {
///             Circle()
///                 .frame(width: 100, height: 100)
///                 .scaleEffect(magnifyBy)
///                 .gesture(magnification)
///         }
///     }
///
@available(iOS 17.0, macOS 14.0, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
public struct MagnifyGesture : Gesture {

    /// The type representing the gesture's value.
    public struct Value : Equatable, Sendable {

        /// The time associated with the gesture's current event.
        public var time: Date

        /// The relative amount that the gesture has magnified by.
        ///
        /// A value of 2.0 means that the user has interacted with the gesture
        /// to increase the magnification by a factor of 2 more than before the
        /// gesture.
        public var magnification: CGFloat

        /// The current magnification velocity.
        public var velocity: CGFloat

        /// The initial anchor point of the gesture in the modified view's
        /// coordinate space.
        public var startAnchor: UnitPoint

        /// The initial center of the gesture in the modified view's coordinate
        /// space.
        public var startLocation: CGPoint

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: MagnifyGesture.Value, b: MagnifyGesture.Value) -> Bool
    }

    /// The minimum required delta before the gesture starts.
    public var minimumScaleDelta: CGFloat

    /// Creates a magnify gesture with a given minimum delta for the
    /// gesture to start.
    ///
    /// - Parameter minimumScaleDelta: The minimum scale delta required before
    ///   the gesture starts.
    public init(minimumScaleDelta: CGFloat = 0.01)

    /// The type of gesture representing the body of `Self`.
    @available(iOS 17.0, macOS 14.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias Body = Never
}

/// A configuration that defines the appearance of a matched transition
/// source.
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public protocol MatchedTransitionSourceConfiguration : Sendable {
}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension MatchedTransitionSourceConfiguration {

    /// Applies the specified shadow effect to the matched transition source.
    ///
    /// - Parameters:
    ///   - color: The shadow's color.
    ///   - radius: A measure of how much to blur the shadow. Larger values
    ///     result in more blur.
    ///   - x: An amount to offset the shadow horizontally from the view.
    ///   - y: An amount to offset the shadow vertically from the view.
    ///
    public func shadow(color: Color = Color(.sRGBLinear, white: 0, opacity: 0.33), radius: CGFloat, x: CGFloat = 0, y: CGFloat = 0) -> some MatchedTransitionSourceConfiguration


    /// Applies the specified shape as to the matched transition source,
    /// clipping its content.
    ///
    /// - Parameters:
    ///   - shape: The shape to use as a mask.
    public func clipShape(_ shape: RoundedRectangle) -> some MatchedTransitionSourceConfiguration


    /// Specifies a color that will be drawn behind the content within the
    /// matched transition source.
    ///
    /// During a zoom transition, the background color fills the interpolated
    /// shape as it groes from the matched transition source.
    ///
    /// - Parameters:
    ///   - color: The color to apply behind the content within the
    ///     matched transition source..
    public func background(_ style: Color) -> some MatchedTransitionSourceConfiguration

}

/// A control for presenting a menu of actions.
///
/// The following example presents a menu of three buttons and a submenu, which
/// contains three buttons of its own.
///
///     Menu("Actions") {
///         Button("Duplicate", action: duplicate)
///         Button("Rename", action: rename)
///         Button("Delete", action: delete)
///         Menu("Copy") {
///             Button("Copy", action: copy)
///             Button("Copy Formatted", action: copyFormatted)
///             Button("Copy Library Path", action: copyPath)
///         }
///     }
///
/// You can create the menu's title with a ``LocalizedStringKey``, as seen in
/// the previous example, or with a view builder that creates multiple views,
/// such as an image and a text view:
///
///     Menu {
///         Button("Open in Preview", action: openInPreview)
///         Button("Save as PDF", action: saveAsPDF)
///     } label: {
///         Label("PDF", systemImage: "doc.fill")
///     }
///
/// To support subtitles on menu items, initialize your `Button` with a view
/// builder that creates multiple `Text` views where the first text represents
/// the title and the second text represents the subtitle. The same approach
/// applies to other controls such as `Toggle`:
///
///     Menu {
///         Button(action: openInPreview) {
///             Text("Open in Preview")
///             Text("View the document in Preview")
///         }
///         Button(action: saveAsPDF) {
///             Text("Save as PDF")
///             Text("Export the document as a PDF file")
///         }
///     } label: {
///         Label("PDF", systemImage: "doc.fill")
///     }
///
/// > Note: This behavior does not apply to buttons outside of a menu's content.
///
/// ### Primary action
///
/// Menus can be created with a custom primary action. The primary action will
/// be performed when the user taps or clicks on the body of the control, and
/// the menu presentation will happen on a secondary gesture, such as on
/// long press or on click of the menu indicator. The following example creates
/// a menu that adds bookmarks, with advanced options that are presented in a
/// menu.
///
///     Menu {
///         Button(action: addCurrentTabToReadingList) {
///             Label("Add to Reading List", systemImage: "eyeglasses")
///         }
///         Button(action: bookmarkAll) {
///             Label("Add Bookmarks for All Tabs", systemImage: "book")
///         }
///         Button(action: show) {
///             Label("Show All Bookmarks", systemImage: "books.vertical")
///         }
///     } label: {
///         Label("Add Bookmark", systemImage: "book")
///     } primaryAction: {
///         addBookmark()
///     }
///
/// ### Styling menus
///
/// Use the ``View/menuStyle(_:)`` modifier to change the style of all menus
/// in a view. The following example shows how to apply a custom style:
///
///     Menu("Editing") {
///         Button("Set In Point", action: setInPoint)
///         Button("Set Out Point", action: setOutPoint)
///     }
///     .menuStyle(EditingControlsMenuStyle())
///
@available(iOS 14.0, macOS 11.0, tvOS 17.0, *)
@available(watchOS, unavailable)
public struct Menu<Label, Content> : View where Label : View, Content : View {

    /// The content and behavior of the view.
    ///
    /// When you implement a custom view, you must implement a computed
    /// `body` property to provide the content for your view. Return a view
    /// that's composed of built-in views that SwiftUI provides, plus other
    /// composite views that you've already defined:
    ///
    ///     struct MyView: View {
    ///         var body: some View {
    ///             Text("Hello, World!")
    ///         }
    ///     }
    ///
    /// For more information about composing views and a view hierarchy,
    /// see <doc:Declaring-a-Custom-View>.
    @MainActor @preconcurrency public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    @available(iOS 14.0, tvOS 17.0, macOS 11.0, *)
    @available(watchOS, unavailable)
    public typealias Body = some View
}

@available(iOS 14.0, macOS 11.0, tvOS 17.0, *)
@available(watchOS, unavailable)
extension Menu {

    /// Creates a menu with a custom label.
    ///
    /// - Parameters:
    ///     - content: A group of menu items.
    ///     - label: A view describing the content of the menu.
    nonisolated public init(@ViewBuilder content: () -> Content, @ViewBuilder label: () -> Label)

    /// Creates a menu that generates its label from a localized string key.
    ///
    /// - Parameters:
    ///     - titleKey: The key for the link's localized title, which describes
    ///         the contents of the menu.
    ///     - content: A group of menu items.
    nonisolated public init(_ titleKey: LocalizedStringKey, @ViewBuilder content: () -> Content) where Label == Text

    /// Creates a menu that generates its label from a string.
    ///
    /// - Parameters:
    ///     - title: A string that describes the contents of the menu.
    ///     - content: A group of menu items.
    nonisolated public init<S>(_ title: S, @ViewBuilder content: () -> Content) where Label == Text, S : StringProtocol
}

@available(iOS 15.0, macOS 12.0, tvOS 17.0, *)
@available(watchOS, unavailable)
extension Menu {

    /// Creates a menu with a custom primary action and custom label.
    ///
    /// - Parameters:
    ///   - content: A group of menu items.
    ///   - label: A view describing the content of the menu.
    ///   - primaryAction: The action to perform on primary
    ///     interaction with the menu.
    nonisolated public init(@ViewBuilder content: () -> Content, @ViewBuilder label: () -> Label, primaryAction: @escaping () -> Void)

    /// Creates a menu with a custom primary action that generates its label
    /// from a localized string key.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the link's localized title, which describes
    ///     the contents of the menu.
    ///   - primaryAction: The action to perform on primary
    ///     interaction with the menu.
    ///   - content: A group of menu items.
    nonisolated public init(_ titleKey: LocalizedStringKey, @ViewBuilder content: () -> Content, primaryAction: @escaping () -> Void) where Label == Text

    /// Creates a menu with a custom primary action that generates its label
    /// from a string.
    ///
    /// To create the label with a localized string key, use
    /// `Menu(_:primaryAction:content:)` instead.
    ///
    /// - Parameters:
    ///   - title: A string that describes the contents of the menu.
    ///   - primaryAction: The action to perform on primary
    ///     interaction with the menu.
    ///   - content: A group of menu items.
    nonisolated public init<S>(_ title: S, @ViewBuilder content: () -> Content, primaryAction: @escaping () -> Void) where Label == Text, S : StringProtocol
}

@available(iOS 14.0, macOS 11.0, tvOS 17.0, *)
@available(watchOS, unavailable)
extension Menu where Label == Label<Text, Image> {

    /// Creates a menu that generates its label from a localized string key
    /// and system image.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the link's localized title, which describes
    ///     the contents of the menu.
    ///   - systemImage: The name of the image resource to lookup.
    ///   - content: A group of menu items.
    nonisolated public init(_ titleKey: LocalizedStringKey, systemImage: String, @ViewBuilder content: () -> Content)

    /// Creates a menu that generates its label from a string and system image.
    ///
    /// - Parameters:
    ///   - title: A string that describes the contents of the menu.
    ///   - systemImage: The name of the image resource to lookup.
    ///   - content: A group of menu items.
    nonisolated public init<S>(_ title: S, systemImage: String, @ViewBuilder content: () -> Content) where S : StringProtocol

    /// Creates a menu with a custom primary action that generates its label
    /// from a localized string key and system image.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the link's localized title, which describes
    ///     the contents of the menu.
    ///   - systemImage: The name of the image resource to lookup.
    ///   - primaryAction: The action to perform on primary
    ///     interaction with the menu.
    ///   - content: A group of menu items.
    @available(iOS 15.0, macOS 12.0, tvOS 17.0, *)
    @available(watchOS, unavailable)
    nonisolated public init(_ titleKey: LocalizedStringKey, systemImage: String, @ViewBuilder content: () -> Content, primaryAction: @escaping () -> Void)
}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, *)
@available(watchOS, unavailable)
extension Menu where Label == Label<Text, Image> {

    /// Creates a menu that generates its label from a localized string key
    /// and image resource.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the link's localized title, which describes
    ///     the contents of the menu.
    ///   - image: The name of the image resource to lookup.
    ///   - content: A group of menu items.
    nonisolated public init(_ titleKey: LocalizedStringKey, image: ImageResource, @ViewBuilder content: () -> Content)

    /// Creates a menu that generates its label from a string and
    /// image resource.
    ///
    /// - Parameters:
    ///   - title: A string that describes the contents of the menu.
    ///   - image: The name of the image resource to lookup.
    ///   - content: A group of menu items.
    nonisolated public init<S>(_ title: S, image: ImageResource, @ViewBuilder content: () -> Content) where S : StringProtocol

    /// Creates a menu with a custom primary action that generates its label
    /// from a localized string key.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the link's localized title, which describes
    ///     the contents of the menu.
    ///   - image: The name of the image resource to lookup.
    ///   - primaryAction: The action to perform on primary
    ///     interaction with the menu.
    ///   - content: A group of menu items.
    nonisolated public init(_ titleKey: LocalizedStringKey, image: ImageResource, @ViewBuilder content: () -> Content, primaryAction: @escaping () -> Void)
}

@available(iOS 14.0, macOS 11.0, tvOS 17.0, *)
@available(watchOS, unavailable)
extension Menu where Label == MenuStyleConfiguration.Label, Content == MenuStyleConfiguration.Content {

    /// Creates a menu based on a style configuration.
    ///
    /// Use this initializer within the ``MenuStyle/makeBody(configuration:)``
    /// method of a ``MenuStyle`` instance to create an instance of the menu
    /// being styled. This is useful for custom menu styles that modify the
    /// current menu style.
    ///
    /// For example, the following code creates a new, custom style that adds a
    /// red border around the current menu style:
    ///
    ///     struct RedBorderMenuStyle: MenuStyle {
    ///         func makeBody(configuration: Configuration) -> some View {
    ///             Menu(configuration)
    ///                 .border(Color.red)
    ///         }
    ///     }
    ///
    nonisolated public init(_ configuration: MenuStyleConfiguration)
}

/// The set of menu dismissal behavior options.
///
/// Configure the menu dismissal behavior for a view hierarchy using the
/// ``View/menuActionDismissBehavior(_:)`` view modifier.
@available(iOS 16.4, macOS 13.3, tvOS 16.4, watchOS 9.4, *)
public struct MenuActionDismissBehavior : Equatable {

    /// Use the a dismissal behavior that's appropriate for the given context.
    ///
    /// In most cases, the default behavior is ``enabled``. There are some
    /// cases, like ``Stepper``, that use ``disabled`` by default.
    public static let automatic: MenuActionDismissBehavior

    /// Always dismiss the presented menu after performing an action.
    public static let enabled: MenuActionDismissBehavior

    /// Never dismiss the presented menu after performing an action.
    @available(tvOS 17.0, *)
    @available(macOS, unavailable)
    @available(watchOS, unavailable)
    public static let disabled: MenuActionDismissBehavior

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: MenuActionDismissBehavior, b: MenuActionDismissBehavior) -> Bool
}

/// A control group style that presents its content as a menu when the user
/// presses the control, or as a submenu when nested within a larger menu.
///
/// Use ``ControlGroupStyle/menu`` to construct this style.
@available(iOS 16.4, macOS 13.3, tvOS 17.0, *)
@available(watchOS, unavailable)
public struct MenuControlGroupStyle : ControlGroupStyle {

    /// Creates a menu control group style.
    public init()

    /// Creates a view representing the body of a control group.
    ///
    /// - Parameter configuration: The properties of the control group instance
    ///   being created.
    ///
    /// This method will be called for each instance of ``ControlGroup`` created
    /// within a view hierarchy where this style is the current
    /// `ControlGroupStyle`.
    @MainActor @preconcurrency public func makeBody(configuration: MenuControlGroupStyle.Configuration) -> some View


    /// A view representing the body of a control group.
    @available(iOS 16.4, tvOS 17.0, macOS 13.3, *)
    @available(watchOS, unavailable)
    public typealias Body = some View
}

/// The order in which a menu presents its content.
///
/// You can configure the preferred menu order using the
/// ``View/menuOrder(_:)`` view modifier.
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct MenuOrder : Equatable, Hashable, Sendable {

    /// The ordering of the menu chosen by the system for the current context.
    ///
    /// On iOS, this order resolves to ``fixed`` for menus
    /// presented within scrollable content. Pickers that use the
    /// ``PickerStyle/menu`` style also default to ``fixed`` order. In all
    /// other cases, menus default to ``priority`` order.
    ///
    /// On macOS, tvOS and watchOS, the `automatic` order always resolves to
    /// ``fixed`` order.
    public static let automatic: MenuOrder

    /// Keep the first items closest to user's interaction point.
    @available(macOS, unavailable)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public static let priority: MenuOrder

    /// Order items from top to bottom.
    public static let fixed: MenuOrder

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: MenuOrder, b: MenuOrder) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

/// A picker style that presents the options as a menu when the user presses a
/// button, or as a submenu when nested within a larger menu.
///
/// You can also use ``PickerStyle/menu`` to construct this style.
@available(iOS 14.0, macOS 11.0, tvOS 17.0, *)
@available(watchOS, unavailable)
public struct MenuPickerStyle : PickerStyle {

    /// Creates a menu picker style.
    public init()
}

/// A type that applies standard interaction behavior and a custom appearance
/// to all menus within a view hierarchy.
///
/// To configure the current menu style for a view hierarchy, use the
/// ``View/menuStyle(_:)`` modifier.
@available(iOS 14.0, macOS 11.0, tvOS 17.0, *)
@available(watchOS, unavailable)
@MainActor @preconcurrency public protocol MenuStyle {

    /// A view that represents the body of a menu.
    associatedtype Body : View

    /// Creates a view that represents the body of a menu.
    ///
    /// - Parameter configuration: The properties of the menu.
    ///
    /// The system calls this method for each ``Menu`` instance in a view
    /// hierarchy where this style is the current menu style.
    @ViewBuilder @MainActor @preconcurrency func makeBody(configuration: Self.Configuration) -> Self.Body

    /// The properties of a menu.
    typealias Configuration = MenuStyleConfiguration
}

@available(iOS 16.0, macOS 13.0, tvOS 17.0, *)
@available(watchOS, unavailable)
extension MenuStyle where Self == ButtonMenuStyle {

    /// A menu style that displays a button that toggles the display of
    /// the menu's contents when pressed.
    ///
    /// On macOS, the button displays an arrow to indicate that it presents a
    /// menu.
    ///
    /// Pressing and then dragging into the contents activates the selected
    /// action on release.
    @MainActor @preconcurrency public static var button: ButtonMenuStyle { get }
}

@available(iOS 14.0, macOS 11.0, tvOS 17.0, *)
@available(watchOS, unavailable)
extension MenuStyle where Self == DefaultMenuStyle {

    /// The default menu style, based on the menu's context.
    ///
    /// The default menu style can vary by platform. By default, macOS uses the
    /// bordered button style.
    ///
    /// If you create a menu inside a container, the style resolves to the
    /// recommended style for menus inside that container for that specific
    /// platform. For example, a menu nested within another menu will resolve to
    /// a submenu:
    ///
    ///     Menu("Edit") {
    ///         Menu("Arrange") {
    ///             Button("Bring to Front", action: moveSelectionToFront)
    ///             Button("Send to Back", action: moveSelectionToBack)
    ///         }
    ///         Button("Delete", action: deleteSelection)
    ///     }
    ///
    /// You can override a menu's style. To apply the default style to a menu,
    /// or to a view that contains a menu, use the ``View/menuStyle(_:)``
    /// modifier.
    @MainActor @preconcurrency public static var automatic: DefaultMenuStyle { get }
}

@available(iOS, introduced: 14.0, deprecated: 100000.0, message: "Use .menuStyle(.button) and .buttonStyle(.borderless).")
@available(macOS, introduced: 11.0, deprecated: 100000.0, message: "Use .menuStyle(.button) and .buttonStyle(.borderless).")
@available(tvOS, introduced: 17.0, deprecated: 100000.0, message: "Use .menuStyle(.button) and .buttonStyle(.borderless).")
@available(watchOS, unavailable)
@available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Use .menuStyle(.button) and .buttonStyle(.borderless).")
extension MenuStyle where Self == BorderlessButtonMenuStyle {

    /// A menu style that displays a borderless button that toggles the display of
    /// the menu's contents when pressed.
    ///
    /// On macOS, the button optionally displays an arrow indicating that it
    /// presents a menu.
    ///
    /// Pressing and then dragging into the contents triggers the chosen action on
    /// release.
    @MainActor @preconcurrency public static var borderlessButton: BorderlessButtonMenuStyle { get }
}

/// A configuration of a menu.
///
/// Use the ``Menu/init(_:)`` initializer of ``Menu`` to create an
/// instance using the current menu style, which you can modify to create a
/// custom style.
///
/// For example, the following code creates a new, custom style that adds a red
/// border to the current menu style:
///
///     struct RedBorderMenuStyle: MenuStyle {
///         func makeBody(configuration: Configuration) -> some View {
///             Menu(configuration)
///                 .border(Color.red)
///         }
///     }
@available(iOS 14.0, macOS 11.0, tvOS 17.0, *)
@available(watchOS, unavailable)
public struct MenuStyleConfiguration {

    /// A type-erased label of a menu.
    @MainActor @preconcurrency public struct Label : View {

        /// The type of view representing the body of this view.
        ///
        /// When you create a custom view, Swift infers this type from your
        /// implementation of the required ``View/body-swift.property`` property.
        @available(iOS 14.0, tvOS 17.0, macOS 11.0, *)
        @available(watchOS, unavailable)
        public typealias Body = Never
    }

    /// A type-erased content of a menu.
    @MainActor @preconcurrency public struct Content : View {

        /// The type of view representing the body of this view.
        ///
        /// When you create a custom view, Swift infers this type from your
        /// implementation of the required ``View/body-swift.property`` property.
        @available(iOS 14.0, tvOS 17.0, macOS 11.0, *)
        @available(watchOS, unavailable)
        public typealias Body = Never
    }
}

/// A control for picking multiple dates.
///
/// Use a `MultiDatePicker` when you want to provide a view that allows the
/// user to select multiple dates.
///
/// The following example creates a basic `MultiDatePicker`, which appears as a
/// calendar view representing the selected dates:
///
///     @State private var dates: Set<DateComponents> = []
///
///     var body: some View {
///         MultiDatePicker("Dates Available", selection: $dates)
///     }
///
/// You can limit the `MultiDatePicker` to specific ranges of dates
/// allowing selections only before or after a certain date or between two
/// dates. The following example shows a multi-date picker that only permits
/// selections within the 6th and (excluding) the 16th of December 2021
/// (in the `UTC` time zone):
///
///     @Environment(\.calendar) var calendar
///     @Environment(\.timeZone) var timeZone
///
///     var bounds: Range<Date> {
///         let start = calendar.date(from: DateComponents(
///             timeZone: timeZone, year: 2022, month: 6, day: 6))!
///         let end = calendar.date(from: DateComponents(
///             timeZone: timeZone, year: 2022, month: 6, day: 16))!
///         return start ..< end
///     }
///
///     @State private var dates: Set<DateComponents> = []
///
///     var body: some View {
///         MultiDatePicker("Dates Available", selection: $dates, in: bounds)
///     }
///
/// You can also specify an alternative locale, calendar and time zone through
/// environment values. This can be useful when using a ``PreviewProvider`` to
/// see how your multi-date picker behaves in environments that differ from
/// your own.
///
/// The following example shows a multi-date picker with a custom locale,
/// calendar and time zone:
///
///     struct ContentView_Previews: PreviewProvider {
///         static var previews: some View {
///             MultiDatePicker("Dates Available", selection: .constant([]))
///                 .environment(\.locale, Locale.init(identifier: "zh"))
///                 .environment(
///                     \.calendar, Calendar.init(identifier: .chinese))
///                 .environment(\.timeZone, TimeZone(abbreviation: "HKT")!)
///         }
///     }
///
@available(iOS 16.0, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct MultiDatePicker<Label> : View where Label : View {

    /// The content and behavior of the view.
    ///
    /// When you implement a custom view, you must implement a computed
    /// `body` property to provide the content for your view. Return a view
    /// that's composed of built-in views that SwiftUI provides, plus other
    /// composite views that you've already defined:
    ///
    ///     struct MyView: View {
    ///         var body: some View {
    ///             Text("Hello, World!")
    ///         }
    ///     }
    ///
    /// For more information about composing views and a view hierarchy,
    /// see <doc:Declaring-a-Custom-View>.
    @MainActor @preconcurrency public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    @available(iOS 16.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    @available(macOS, unavailable)
    public typealias Body = some View
}

@available(iOS 16.0, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension MultiDatePicker {

    /// Creates an instance that selects multiple dates with an unbounded
    /// range.
    ///
    /// - Parameters:
    ///   - selection: The date values being displayed and selected.
    ///   - label: A view that describes the use of the dates.
    nonisolated public init(selection: Binding<Set<DateComponents>>, @ViewBuilder label: () -> Label)

    /// Creates an instance that selects multiple dates in a range.
    ///
    /// - Parameters:
    ///   - selection: The date values being displayed and selected.
    ///   - bounds: The exclusive range of selectable dates.
    ///   - label: A view that describes the use of the dates.
    nonisolated public init(selection: Binding<Set<DateComponents>>, in bounds: Range<Date>, @ViewBuilder label: () -> Label)

    /// Creates an instance that selects multiple dates on or after some
    /// start date.
    ///
    /// - Parameters:
    ///   - selection: The date values being displayed and selected.
    ///   - bounds: The open range from some selectable start date.
    ///   - label: A view that describes the use of the dates.
    nonisolated public init(selection: Binding<Set<DateComponents>>, in bounds: PartialRangeFrom<Date>, @ViewBuilder label: () -> Label)

    /// Creates an instance that selects multiple dates before some end date.
    ///
    /// - Parameters:
    ///   - selection: The date values being displayed and selected.
    ///   - bounds: The open range before some end date.
    ///   - label: A view that describes the use of the dates.
    nonisolated public init(selection: Binding<Set<DateComponents>>, in bounds: PartialRangeUpTo<Date>, @ViewBuilder label: () -> Label)
}

@available(iOS 16.0, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension MultiDatePicker where Label == Text {

    /// Creates an instance that selects multiple dates with an unbounded
    /// range.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the localized title of `self`, describing
    ///     its purpose.
    ///   - selection: The date values being displayed and selected.
    nonisolated public init(_ titleKey: LocalizedStringKey, selection: Binding<Set<DateComponents>>)

    /// Creates an instance that selects multiple dates in a range.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the localized title of `self`, describing
    ///     its purpose.
    ///   - selection: The date values being displayed and selected.
    ///   - bounds: The exclusive range of selectable dates.
    nonisolated public init(_ titleKey: LocalizedStringKey, selection: Binding<Set<DateComponents>>, in bounds: Range<Date>)

    /// Creates an instance that selects multiple dates on or after some
    /// start date.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the localized title of `self`, describing
    ///     its purpose.
    ///   - selection: The date values being displayed and selected.
    ///   - bounds: The open range from some selectable start date.
    nonisolated public init(_ titleKey: LocalizedStringKey, selection: Binding<Set<DateComponents>>, in bounds: PartialRangeFrom<Date>)

    /// Creates an instance that selects multiple dates before some end date.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the localized title of `self`, describing
    ///     its purpose.
    ///   - selection: The date values being displayed and selected.
    ///   - bounds: The open range before some end date.
    nonisolated public init(_ titleKey: LocalizedStringKey, selection: Binding<Set<DateComponents>>, in bounds: PartialRangeUpTo<Date>)
}

@available(iOS 16.0, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension MultiDatePicker where Label == Text {

    /// Creates an instance that selects multiple dates with an unbounded
    /// range.
    ///
    /// - Parameters:
    ///   - title: The title of `self`, describing its purpose.
    ///   - selection: The date values being displayed and selected.
    nonisolated public init<S>(_ title: S, selection: Binding<Set<DateComponents>>) where S : StringProtocol

    /// Creates an instance that selects multiple dates in a range.
    ///
    /// - Parameters:
    ///   - title: The title of `self`, describing its purpose.
    ///   - selection: The date values being displayed and selected.
    ///   - bounds: The exclusive range of selectable dates.
    nonisolated public init<S>(_ title: S, selection: Binding<Set<DateComponents>>, in bounds: Range<Date>) where S : StringProtocol

    /// Creates an instance that selects multiple dates on or after some
    /// start date.
    ///
    /// - Parameters:
    ///   - title: The title of `self`, describing its purpose.
    ///   - selection: The date values being displayed and selected.
    ///   - bounds: The open range from some selectable start date.
    nonisolated public init<S>(_ title: S, selection: Binding<Set<DateComponents>>, in bounds: PartialRangeFrom<Date>) where S : StringProtocol

    /// Creates an instance that selects multiple dates before some end date.
    ///
    /// - Parameters:
    ///   - title: The title of `self`, describing its purpose.
    ///   - selection: The date values being displayed and selected.
    ///   - bounds: The open range before some end date.
    nonisolated public init<S>(_ title: S, selection: Binding<Set<DateComponents>>, in bounds: PartialRangeUpTo<Date>) where S : StringProtocol
}

/// A configuration for a navigation bar that represents a view at the top of a
/// navigation stack.
///
/// Use one of the ``TitleDisplayMode`` values to configure a navigation bar
/// title's display mode with the ``View/navigationBarTitleDisplayMode(_:)``
/// view modifier.
@available(iOS 13.0, tvOS 13.0, watchOS 6.0, *)
@available(macOS, unavailable)
public struct NavigationBarItem : Sendable {

    /// A style for displaying the title of a navigation bar.
    ///
    /// Use one of these values with the
    /// ``View/navigationBarTitleDisplayMode(_:)`` view modifier to configure
    /// the title of a navigation bar.
    public enum TitleDisplayMode : Sendable {

        /// Inherit the display mode from the previous navigation item.
        case automatic

        /// Display the title within the standard bounds of the navigation bar.
        case inline

        /// Display a large title within an expanded navigation bar.
        @available(watchOS 8.0, *)
        @available(tvOS, unavailable)
        case large

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: NavigationBarItem.TitleDisplayMode, b: NavigationBarItem.TitleDisplayMode) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }
}

@available(iOS 13.0, tvOS 13.0, watchOS 6.0, *)
@available(macOS, unavailable)
extension NavigationBarItem.TitleDisplayMode : Equatable {
}

@available(iOS 13.0, tvOS 13.0, watchOS 6.0, *)
@available(macOS, unavailable)
extension NavigationBarItem.TitleDisplayMode : Hashable {
}

/// The navigation control group style.
///
/// You can also use ``ControlGroupStyle/navigation`` to construct this style.
@available(iOS 15.0, macOS 12.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct NavigationControlGroupStyle : ControlGroupStyle {

    /// Creates a navigation control group style.
    public init()

    /// Creates a view representing the body of a control group.
    ///
    /// - Parameter configuration: The properties of the control group instance
    ///   being created.
    ///
    /// This method will be called for each instance of ``ControlGroup`` created
    /// within a view hierarchy where this style is the current
    /// `ControlGroupStyle`.
    @MainActor @preconcurrency public func makeBody(configuration: NavigationControlGroupStyle.Configuration) -> some View


    /// A view representing the body of a control group.
    @available(iOS 15.0, macOS 12.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias Body = some View
}

/// A view that controls a navigation presentation.
///
/// People click or tap a navigation link to present a view inside a
/// ``NavigationStack`` or ``NavigationSplitView``. You control the visual
/// appearance of the link by providing view content in the link's `label`
/// closure. For example, you can use a ``Label`` to display a link:
///
///     NavigationLink {
///         FolderDetail(id: workFolder.id)
///     } label: {
///         Label("Work Folder", systemImage: "folder")
///     }
///
/// For a link composed only of text, you can use one of the convenience
/// initializers that takes a string and creates a ``Text`` view for you:
///
///     NavigationLink("Work Folder") {
///         FolderDetail(id: workFolder.id)
///     }
///
/// ### Link to a destination view
///
/// You can perform navigation by initializing a link with a destination view
/// that you provide in the `destination` closure. For example, consider a
/// `ColorDetail` view that fills itself with a color:
///
///     struct ColorDetail: View {
///         var color: Color
///
///         var body: some View {
///             color.navigationTitle(color.description)
///         }
///     }
///
/// The following ``NavigationStack`` presents three links to color detail
/// views:
///
///     NavigationStack {
///         List {
///             NavigationLink("Mint") { ColorDetail(color: .mint) }
///             NavigationLink("Pink") { ColorDetail(color: .pink) }
///             NavigationLink("Teal") { ColorDetail(color: .teal) }
///         }
///         .navigationTitle("Colors")
///     }
///
/// ### Create a presentation link
///
/// Alternatively, you can use a navigation link to perform navigation based
/// on a presented data value. To support this, use the
/// ``View/navigationDestination(for:destination:)`` view modifier
/// inside a navigation stack to associate a view with a kind of data, and
/// then present a value of that data type from a navigation link. The
/// following example reimplements the previous example as a series of
/// presentation links:
///
///     NavigationStack {
///         List {
///             NavigationLink("Mint", value: Color.mint)
///             NavigationLink("Pink", value: Color.pink)
///             NavigationLink("Teal", value: Color.teal)
///         }
///         .navigationDestination(for: Color.self) { color in
///             ColorDetail(color: color)
///         }
///         .navigationTitle("Colors")
///     }
///
/// Separating the view from the data facilitates programmatic navigation
/// because you can manage navigation state by recording the presented data.
///
/// ### Control a presentation link programmatically
///
/// To navigate programmatically, introduce a state variable that tracks the
/// items on a stack. For example, you can create an array of colors to
/// store the stack state from the previous example, and initialize it as
/// an empty array to start with an empty stack:
///
///     @State private var colors: [Color] = []
///
/// Then pass a ``Binding`` to the state to the navigation stack:
///
///     NavigationStack(path: $colors) {
///         // ...
///     }
///
/// You can use the array to observe the current state of the stack. You can
/// also modify the array to change the contents of the stack. For example,
/// you can programmatically add ``ShapeStyle/blue`` to the array, and
/// navigation to a new color detail view using the following method:
///
///     func showBlue() {
///         colors.append(.blue)
///     }
///
/// ### Coordinate with a list
///
/// You can also use a navigation link to control ``List`` selection in a
/// ``NavigationSplitView``:
///
///     let colors: [Color] = [.mint, .pink, .teal]
///     @State private var selection: Color? // Nothing selected by default.
///
///     var body: some View {
///         NavigationSplitView {
///             List(colors, id: \.self, selection: $selection) { color in
///                 NavigationLink(color.description, value: color)
///             }
///         } detail: {
///             if let color = selection {
///                 ColorDetail(color: color)
///             } else {
///                 Text("Pick a color")
///             }
///         }
///     }
///
/// The list coordinates with the navigation logic so that changing the
/// selection state variable in another part of your code activates the
/// navigation link with the corresponding color. Similarly, if someone
/// chooses the navigation link associated with a particular color, the
/// list updates the selection value that other parts of your code can read.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public struct NavigationLink<Label, Destination> : View where Label : View, Destination : View {

    /// Creates a navigation link that presents the destination view.
    /// - Parameters:
    ///   - destination: A view for the navigation link to present.
    ///   - label: A view builder to produce a label describing the `destination`
    ///    to present.
    public init(@ViewBuilder destination: () -> Destination, @ViewBuilder label: () -> Label)

    /// Creates a navigation link that presents the destination view when active.
    /// - Parameters:
    ///   - isActive: A binding to a Boolean value that indicates whether
    ///   `destination` is currently presented.
    ///   - destination: A view for the navigation link to present.
    ///   - label: A view builder to produce a label describing the `destination`
    ///    to present.
    @available(iOS, introduced: 13.0, deprecated: 16.0, message: "use NavigationLink(value:label:), or navigationDestination(isPresented:destination:), inside a NavigationStack or NavigationSplitView")
    @available(macOS, introduced: 10.15, deprecated: 13.0, message: "use NavigationLink(value:label:), or navigationDestination(isPresented:destination:), inside a NavigationStack or NavigationSplitView")
    @available(tvOS, introduced: 13.0, deprecated: 16.0, message: "use NavigationLink(value:label:), or navigationDestination(isPresented:destination:), inside a NavigationStack or NavigationSplitView")
    @available(watchOS, introduced: 6.0, deprecated: 9.0, message: "use NavigationLink(value:label:), or navigationDestination(isPresented:destination:), inside a NavigationStack or NavigationSplitView")
    @available(visionOS, introduced: 1.0, deprecated: 1.0, message: "use NavigationLink(value:label:), or navigationDestination(isPresented:destination:), inside a NavigationStack or NavigationSplitView")
    public init(isActive: Binding<Bool>, @ViewBuilder destination: () -> Destination, @ViewBuilder label: () -> Label)

    /// Creates a navigation link that presents the destination view when
    /// a bound selection variable equals a given tag value.
    /// - Parameters:
    ///   - tag: The value of `selection` that causes the link to present
    ///   `destination`.
    ///   - selection: A bound variable that causes the link to present
    ///   `destination` when `selection` becomes equal to `tag`.
    ///   - destination: A view for the navigation link to present.
    ///   - label: A view builder to produce a label describing the
    ///   `destination` to present.
    @available(iOS, introduced: 13.0, deprecated: 16.0, message: "use NavigationLink(value:label:), or navigationDestination(isPresented:destination:), inside a NavigationStack or NavigationSplitView")
    @available(macOS, introduced: 10.15, deprecated: 13.0, message: "use NavigationLink(value:label:), or navigationDestination(isPresented:destination:), inside a NavigationStack or NavigationSplitView")
    @available(tvOS, introduced: 13.0, deprecated: 16.0, message: "use NavigationLink(value:label:), or navigationDestination(isPresented:destination:), inside a NavigationStack or NavigationSplitView")
    @available(watchOS, introduced: 6.0, deprecated: 9.0, message: "use NavigationLink(value:label:), or navigationDestination(isPresented:destination:), inside a NavigationStack or NavigationSplitView")
    @available(visionOS, introduced: 1.0, deprecated: 1.0, message: "use NavigationLink(value:label:), or navigationDestination(isPresented:destination:), inside a NavigationStack or NavigationSplitView")
    public init<V>(tag: V, selection: Binding<V?>, @ViewBuilder destination: () -> Destination, @ViewBuilder label: () -> Label) where V : Hashable

    /// The content and behavior of the view.
    ///
    /// When you implement a custom view, you must implement a computed
    /// `body` property to provide the content for your view. Return a view
    /// that's composed of built-in views that SwiftUI provides, plus other
    /// composite views that you've already defined:
    ///
    ///     struct MyView: View {
    ///         var body: some View {
    ///             Text("Hello, World!")
    ///         }
    ///     }
    ///
    /// For more information about composing views and a view hierarchy,
    /// see <doc:Declaring-a-Custom-View>.
    @MainActor @preconcurrency public var body: some View { get }

    /// Creates a navigation link that presents the destination view.
    /// - Parameters:
    ///   - destination: A view for the navigation link to present.
    ///   - label: A view builder to produce a label describing the `destination`
    ///    to present.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, message: "Pass a closure as the destination")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, message: "Pass a closure as the destination")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, message: "Pass a closure as the destination")
    @available(watchOS, introduced: 6.0, deprecated: 100000.0, message: "Pass a closure as the destination")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Pass a closure as the destination")
    public init(destination: Destination, @ViewBuilder label: () -> Label)

    /// Creates a navigation link that presents the destination view when active.
    /// - Parameters:
    ///   - destination: A view for the navigation link to present.
    ///   - isActive: A binding to a Boolean value that indicates whether
    ///   `destination` is currently presented.
    ///   - label: A view builder to produce a label describing the `destination`
    ///    to present.
    @available(iOS, introduced: 13.0, deprecated: 16.0, message: "use NavigationLink(value:label:), or navigationDestination(isPresented:destination:), inside a NavigationStack or NavigationSplitView")
    @available(macOS, introduced: 10.15, deprecated: 13.0, message: "use NavigationLink(value:label:), or navigationDestination(isPresented:destination:), inside a NavigationStack or NavigationSplitView")
    @available(tvOS, introduced: 13.0, deprecated: 16.0, message: "use NavigationLink(value:label:), or navigationDestination(isPresented:destination:), inside a NavigationStack or NavigationSplitView")
    @available(watchOS, introduced: 6.0, deprecated: 9.0, message: "use NavigationLink(value:label:), or navigationDestination(isPresented:destination:), inside a NavigationStack or NavigationSplitView")
    @available(visionOS, introduced: 1.0, deprecated: 1.0, message: "use NavigationLink(value:label:), or navigationDestination(isPresented:destination:), inside a NavigationStack or NavigationSplitView")
    public init(destination: Destination, isActive: Binding<Bool>, @ViewBuilder label: () -> Label)

    /// Creates a navigation link that presents the destination view when
    /// a bound selection variable equals a given tag value.
    /// - Parameters:
    ///   - destination: A view for the navigation link to present.
    ///   - tag: The value of `selection` that causes the link to present
    ///   `destination`.
    ///   - selection: A bound variable that causes the link to present
    ///   `destination` when `selection` becomes equal to `tag`.
    ///   - label: A view builder to produce a label describing the
    ///   `destination` to present.
    @available(iOS, introduced: 13.0, deprecated: 16.0, message: "use NavigationLink(value:label:), or navigationDestination(isPresented:destination:), inside a NavigationStack or NavigationSplitView")
    @available(macOS, introduced: 10.15, deprecated: 13.0, message: "use NavigationLink(value:label:), or navigationDestination(isPresented:destination:), inside a NavigationStack or NavigationSplitView")
    @available(tvOS, introduced: 13.0, deprecated: 16.0, message: "use NavigationLink(value:label:), or navigationDestination(isPresented:destination:), inside a NavigationStack or NavigationSplitView")
    @available(watchOS, introduced: 6.0, deprecated: 9.0, message: "use NavigationLink(value:label:), or navigationDestination(isPresented:destination:), inside a NavigationStack or NavigationSplitView")
    @available(visionOS, introduced: 1.0, deprecated: 1.0, message: "use NavigationLink(value:label:), or navigationDestination(isPresented:destination:), inside a NavigationStack or NavigationSplitView")
    public init<V>(destination: Destination, tag: V, selection: Binding<V?>, @ViewBuilder label: () -> Label) where V : Hashable

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    public typealias Body = some View
}

@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension NavigationLink where Destination == Never {

    /// Creates a navigation link that presents the view corresponding to a
    /// value.
    ///
    /// When someone activates the navigation link that this initializer
    /// creates, SwiftUI looks for a nearby
    /// ``View/navigationDestination(for:destination:)`` view modifier
    /// with a `data` input parameter that matches the type of this
    /// initializer's `value` input, with one of the following outcomes:
    ///
    /// * If SwiftUI finds a matching modifier within the view hierarchy of an
    ///   enclosing ``NavigationStack``, it pushes the modifier's corresponding
    ///   `destination` view onto the stack.
    /// * If SwiftUI finds a matching modifier in the view hierarchy of a stack
    ///   that's in a later column of a ``NavigationSplitView``, it puts the
    ///   modifier's destination view as the first and only item onto the stack
    ///   while preserving the stack's root view.
    /// * If there's no matching modifier, but the link appears in a ``List``
    ///   with selection inside a leading column of a navigation split view,
    ///   the link updates the selection, which might affect the appearance of
    ///   a trailing view. For an example of this, see ``NavigationLink``.
    /// * In other cases, the link doesn't do anything.
    ///
    /// If you want to be able to serialize a ``NavigationPath`` that includes
    /// this link, use use a `value` that conforms to the
    /// <doc://com.apple.documentation/documentation/Swift/Codable> protocol.
    ///
    /// - Parameters:
    ///   - value: An optional value to present.
    ///     When the user selects the link, SwiftUI stores a copy of the value.
    ///     Pass a `nil` value to disable the link.
    ///   - label: A label that describes the view that this link presents.
    nonisolated public init<P>(value: P?, @ViewBuilder label: () -> Label) where P : Hashable

    /// Creates a navigation link that presents the view corresponding to a
    /// value, with a text label that the link generates from a
    /// localized string key.
    ///
    /// When someone activates the navigation link that this initializer
    /// creates, SwiftUI looks for a nearby
    /// ``View/navigationDestination(for:destination:)`` view modifier
    /// with a `data` input parameter that matches the type of this
    /// initializer's `value` input, with one of the following outcomes:
    ///
    /// * If SwiftUI finds a matching modifier within the view hierarchy of an
    ///   enclosing ``NavigationStack``, it pushes the modifier's corresponding
    ///   `destination` view onto the stack.
    /// * If SwiftUI finds a matching modifier in the view hierarchy of a stack
    ///   that's in a later column of a ``NavigationSplitView``, it puts the
    ///   modifier's destination view as the first and only item onto the stack
    ///   while preserving the stack's root view.
    /// * If there's no matching modifier, but the link appears in a ``List``
    ///   with selection inside a leading column of a navigation split view,
    ///   the link updates the selection, which might affect the appearance of
    ///   a trailing view. For an example of this, see ``NavigationLink``.
    /// * In other cases, the link doesn't do anything.
    ///
    /// If you want to be able to serialize a ``NavigationPath`` that includes
    /// this link, use use a `value` that conforms to the
    /// <doc://com.apple.documentation/documentation/Swift/Codable> protocol.
    ///
    /// - Parameters:
    ///   - titleKey: A localized string that describes the view that this link
    ///     presents.
    ///   - value: An optional value to present.
    ///     When the user selects the link, SwiftUI stores a copy of the value.
    ///     Pass a `nil` value to disable the link.
    nonisolated public init<P>(_ titleKey: LocalizedStringKey, value: P?) where Label == Text, P : Hashable

    /// Creates a navigation link that presents the view corresponding to a
    /// value, with a text label that the link generates from a
    /// title string.
    ///
    /// When someone activates the navigation link that this initializer
    /// creates, SwiftUI looks for a nearby
    /// ``View/navigationDestination(for:destination:)`` view modifier
    /// with a `data` input parameter that matches the type of this
    /// initializer's `value` input, with one of the following outcomes:
    ///
    /// * If SwiftUI finds a matching modifier within the view hierarchy of an
    ///   enclosing ``NavigationStack``, it pushes the modifier's corresponding
    ///   `destination` view onto the stack.
    /// * If SwiftUI finds a matching modifier in the view hierarchy of a stack
    ///   that's in a later column of a ``NavigationSplitView``, it puts the
    ///   modifier's destination view as the first and only item onto the stack
    ///   while preserving the stack's root view.
    /// * If there's no matching modifier, but the link appears in a ``List``
    ///   with selection inside a leading column of a navigation split view,
    ///   the link updates the selection, which might affect the appearance of
    ///   a trailing view. For an example of this, see ``NavigationLink``.
    /// * In other cases, the link doesn't do anything.
    ///
    /// If you want to be able to serialize a ``NavigationPath`` that includes
    /// this link, use use a `value` that conforms to the
    /// <doc://com.apple.documentation/documentation/Swift/Codable> protocol.
    ///
    /// - Parameters:
    ///   - title: A string that describes the view that this link presents.
    ///   - value: An optional value to present.
    ///     When the user selects the link, SwiftUI stores a copy of the value.
    ///     Pass a `nil` value to disable the link.
    nonisolated public init<S, P>(_ title: S, value: P?) where Label == Text, S : StringProtocol, P : Hashable

    /// Creates a navigation link that presents the view corresponding to a
    /// codable value.
    ///
    /// When someone activates the navigation link that this initializer
    /// creates, SwiftUI looks for a nearby
    /// ``View/navigationDestination(for:destination:)`` view modifier
    /// with a `data` input parameter that matches the type of this
    /// initializer's `value` input, with one of the following outcomes:
    ///
    /// * If SwiftUI finds a matching modifier within the view hierarchy of an
    ///   enclosing ``NavigationStack``, it pushes the modifier's corresponding
    ///   `destination` view onto the stack.
    /// * If SwiftUI finds a matching modifier in the view hierarchy of a stack
    ///   that's in a later column of a ``NavigationSplitView``, it puts the
    ///   modifier's destination view as the first and only item onto the stack
    ///   while preserving the stack's root view.
    /// * If there's no matching modifier, but the link appears in a ``List``
    ///   with selection inside a leading column of a navigation split view,
    ///   the link updates the selection, which might affect the appearance of
    ///   a trailing view. For an example of this, see ``NavigationLink``.
    /// * In other cases, the link doesn't do anything.
    ///
    /// Because this initializer takes a value that conforms to the
    /// <doc://com.apple.documentation/documentation/Swift/Codable> protocol,
    /// you ensure that a ``NavigationPath`` that includes this link can produce
    /// a non-`nil` value for its ``NavigationPath/codable`` property. This
    /// helps to make the path serializable.
    ///
    /// - Parameters:
    ///   - value: An optional value to present.
    ///     When the user selects the link, SwiftUI stores a copy of the value.
    ///     Pass a `nil` value to disable the link.
    ///   - label: A label that describes the view that this link presents.
    nonisolated public init<P>(value: P?, @ViewBuilder label: () -> Label) where P : Decodable, P : Encodable, P : Hashable

    /// Creates a navigation link that presents the view corresponding to a
    /// codable value, with a text label that the link generates from a
    /// localized string key.
    ///
    /// When someone activates the navigation link that this initializer
    /// creates, SwiftUI looks for a nearby
    /// ``View/navigationDestination(for:destination:)`` view modifier
    /// with a `data` input parameter that matches the type of this
    /// initializer's `value` input, with one of the following outcomes:
    ///
    /// * If SwiftUI finds a matching modifier within the view hierarchy of an
    ///   enclosing ``NavigationStack``, it pushes the modifier's corresponding
    ///   `destination` view onto the stack.
    /// * If SwiftUI finds a matching modifier in the view hierarchy of a stack
    ///   that's in a later column of a ``NavigationSplitView``, it puts the
    ///   modifier's destination view as the first and only item onto the stack
    ///   while preserving the stack's root view.
    /// * If there's no matching modifier, but the link appears in a ``List``
    ///   with selection inside a leading column of a navigation split view,
    ///   the link updates the selection, which might affect the appearance of
    ///   a trailing view. For an example of this, see ``NavigationLink``.
    /// * In other cases, the link doesn't do anything.
    ///
    /// Because this initializer takes a value that conforms to the
    /// <doc://com.apple.documentation/documentation/Swift/Codable> protocol,
    /// you ensure that a ``NavigationPath`` that includes this link can produce
    /// a non-`nil` value for its ``NavigationPath/codable`` property. This
    /// helps to make the path serializable.
    ///
    /// - Parameters:
    ///   - titleKey: A localized string that describes the view that this link
    ///     presents.
    ///   - value: An optional value to present. When someone
    ///     taps or clicks the link, SwiftUI stores a copy of the value.
    ///     Pass a `nil` value to disable the link.
    nonisolated public init<P>(_ titleKey: LocalizedStringKey, value: P?) where Label == Text, P : Decodable, P : Encodable, P : Hashable

    /// Creates a navigation link that presents the view corresponding to a
    /// codable value, with a text label that the link generates from a
    /// title string.
    ///
    /// When someone activates the navigation link that this initializer
    /// creates, SwiftUI looks for a nearby
    /// ``View/navigationDestination(for:destination:)`` view modifier
    /// with a `data` input parameter that matches the type of this
    /// initializer's `value` input, with one of the following outcomes:
    ///
    /// * If SwiftUI finds a matching modifier within the view hierarchy of an
    ///   enclosing ``NavigationStack``, it pushes the modifier's corresponding
    ///   `destination` view onto the stack.
    /// * If SwiftUI finds a matching modifier in the view hierarchy of a stack
    ///   that's in a later column of a ``NavigationSplitView``, it puts the
    ///   modifier's destination view as the first and only item onto the stack
    ///   while preserving the stack's root view.
    /// * If there's no matching modifier, but the link appears in a ``List``
    ///   with selection inside a leading column of a navigation split view,
    ///   the link updates the selection, which might affect the appearance of
    ///   a trailing view. For an example of this, see ``NavigationLink``.
    /// * In other cases, the link doesn't do anything.
    ///
    /// Because this initializer takes a value that conforms to the
    /// <doc://com.apple.documentation/documentation/Swift/Codable> protocol,
    /// you ensure that a ``NavigationPath`` that includes this link can produce
    /// a non-`nil` value for its ``NavigationPath/codable`` property. This
    /// helps to make the path serializable.
    ///
    /// - Parameters:
    ///   - title: A string that describes the view that this link presents.
    ///   - value: An optional value to present.
    ///     When the user selects the link, SwiftUI stores a copy of the value.
    ///     Pass a `nil` value to disable the link.
    nonisolated public init<S, P>(_ title: S, value: P?) where Label == Text, S : StringProtocol, P : Decodable, P : Encodable, P : Hashable
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension NavigationLink where Label == Text {

    /// Creates a navigation link that presents a destination view, with a text label
    /// that the link generates from a localized string key.
    /// - Parameters:
    ///   - titleKey: A localized string key for creating a text label.
    ///   - destination: A view for the navigation link to present.
    nonisolated public init(_ titleKey: LocalizedStringKey, @ViewBuilder destination: () -> Destination)

    /// Creates a navigation link that presents a destination view, with a text label
    /// that the link generates from a title string.
    /// - Parameters:
    ///   - title: A string for creating a text label.
    ///   - destination: A view for the navigation link to present.
    nonisolated public init<S>(_ title: S, @ViewBuilder destination: () -> Destination) where S : StringProtocol

    /// Creates a navigation link that presents a destination view when active, with a
    /// text label that the link generates from a localized string key.
    /// - Parameters:
    ///   - titleKey: A localized string key for creating a text label.
    ///   - isActive: A binding to a Boolean value that indicates whether
    ///   `destination` is currently presented.
    ///   - destination: A view for the navigation link to present.
    @available(iOS, introduced: 13.0, deprecated: 16.0, message: "use NavigationLink(value:label:), or navigationDestination(isPresented:destination:), inside a NavigationStack or NavigationSplitView")
    @available(macOS, introduced: 10.15, deprecated: 13.0, message: "use NavigationLink(value:label:), or navigationDestination(isPresented:destination:), inside a NavigationStack or NavigationSplitView")
    @available(tvOS, introduced: 13.0, deprecated: 16.0, message: "use NavigationLink(value:label:), or navigationDestination(isPresented:destination:), inside a NavigationStack or NavigationSplitView")
    @available(watchOS, introduced: 6.0, deprecated: 9.0, message: "use NavigationLink(value:label:), or navigationDestination(isPresented:destination:), inside a NavigationStack or NavigationSplitView")
    @available(visionOS, introduced: 1.0, deprecated: 1.0, message: "use NavigationLink(value:label:), or navigationDestination(isPresented:destination:), inside a NavigationStack or NavigationSplitView")
    nonisolated public init(_ titleKey: LocalizedStringKey, isActive: Binding<Bool>, @ViewBuilder destination: () -> Destination)

    /// Creates a navigation link that presents a destination view when active, with a
    /// text label that the link generates from a title string.
    /// - Parameters:
    ///   - title: A string for creating a text label.
    ///   - isActive: A binding to a Boolean value that indicates whether
    ///   `destination` is currently presented.
    ///   - destination: A view for the navigation link to present.
    @available(iOS, introduced: 13.0, deprecated: 16.0, message: "use NavigationLink(value:label:), or navigationDestination(isPresented:destination:), inside a NavigationStack or NavigationSplitView")
    @available(macOS, introduced: 10.15, deprecated: 13.0, message: "use NavigationLink(value:label:), or navigationDestination(isPresented:destination:), inside a NavigationStack or NavigationSplitView")
    @available(tvOS, introduced: 13.0, deprecated: 16.0, message: "use NavigationLink(value:label:), or navigationDestination(isPresented:destination:), inside a NavigationStack or NavigationSplitView")
    @available(watchOS, introduced: 6.0, deprecated: 9.0, message: "use NavigationLink(value:label:), or navigationDestination(isPresented:destination:), inside a NavigationStack or NavigationSplitView")
    @available(visionOS, introduced: 1.0, deprecated: 1.0, message: "use NavigationLink(value:label:), or navigationDestination(isPresented:destination:), inside a NavigationStack or NavigationSplitView")
    nonisolated public init<S>(_ title: S, isActive: Binding<Bool>, @ViewBuilder destination: () -> Destination) where S : StringProtocol

    /// Creates a navigation link that presents a destination view when a bound
    /// selection variable matches a value you provide, using a text label
    /// that the link generates from a localized string key.
    /// - Parameters:
    ///   - titleKey: A localized string key for creating a text label.
    ///   - tag: The value of `selection` that causes the link to present
    ///   `destination`.
    ///   - selection: A bound variable that causes the link to present
    ///   `destination` when `selection` becomes equal to `tag`.
    ///   - destination: A view for the navigation link to present.
    @available(iOS, introduced: 13.0, deprecated: 16.0, message: "use NavigationLink(value:label:), or navigationDestination(isPresented:destination:), inside a NavigationStack or NavigationSplitView")
    @available(macOS, introduced: 10.15, deprecated: 13.0, message: "use NavigationLink(value:label:), or navigationDestination(isPresented:destination:), inside a NavigationStack or NavigationSplitView")
    @available(tvOS, introduced: 13.0, deprecated: 16.0, message: "use NavigationLink(value:label:), or navigationDestination(isPresented:destination:), inside a NavigationStack or NavigationSplitView")
    @available(watchOS, introduced: 6.0, deprecated: 9.0, message: "use NavigationLink(value:label:), or navigationDestination(isPresented:destination:), inside a NavigationStack or NavigationSplitView")
    @available(visionOS, introduced: 1.0, deprecated: 1.0, message: "use NavigationLink(value:label:), or navigationDestination(isPresented:destination:), inside a NavigationStack or NavigationSplitView")
    nonisolated public init<V>(_ titleKey: LocalizedStringKey, tag: V, selection: Binding<V?>, @ViewBuilder destination: () -> Destination) where V : Hashable

    /// Creates a navigation link that presents a destination view when a bound
    /// selection variable matches a value you provide, using a text label
    /// that the link generates from a title string.
    /// - Parameters:
    ///   - title: A string for creating a text label.
    ///   - tag: The value of `selection` that causes the link to present
    ///   `destination`.
    ///   - selection: A bound variable that causes the link to present
    ///   `destination` when `selection` becomes equal to `tag`.
    ///   - destination: A view for the navigation link to present.
    @available(iOS, introduced: 13.0, deprecated: 16.0, message: "use NavigationLink(value:label:), or navigationDestination(isPresented:destination:), inside a NavigationStack or NavigationSplitView")
    @available(macOS, introduced: 10.15, deprecated: 13.0, message: "use NavigationLink(value:label:), or navigationDestination(isPresented:destination:), inside a NavigationStack or NavigationSplitView")
    @available(tvOS, introduced: 13.0, deprecated: 16.0, message: "use NavigationLink(value:label:), or navigationDestination(isPresented:destination:), inside a NavigationStack or NavigationSplitView")
    @available(watchOS, introduced: 6.0, deprecated: 9.0, message: "use NavigationLink(value:label:), or navigationDestination(isPresented:destination:), inside a NavigationStack or NavigationSplitView")
    @available(visionOS, introduced: 1.0, deprecated: 1.0, message: "use NavigationLink(value:label:), or navigationDestination(isPresented:destination:), inside a NavigationStack or NavigationSplitView")
    nonisolated public init<S, V>(_ title: S, tag: V, selection: Binding<V?>, @ViewBuilder destination: () -> Destination) where S : StringProtocol, V : Hashable

    /// Creates a navigation link that presents a destination view, with a text
    /// label that the link generates from a localized string key.
    /// - Parameters:
    ///   - titleKey: A localized string key for creating a text label.
    ///   - destination: A view for the navigation link to present.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, message: "Pass a closure as the destination")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, message: "Pass a closure as the destination")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, message: "Pass a closure as the destination")
    @available(watchOS, introduced: 6.0, deprecated: 100000.0, message: "Pass a closure as the destination")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Pass a closure as the destination")
    nonisolated public init(_ titleKey: LocalizedStringKey, destination: Destination)

    /// Creates a navigation link that presents a destination view, with a text
    /// label that the link generates from a title string.
    /// - Parameters:
    ///   - title: A string for creating a text label.
    ///   - destination: A view for the navigation link to present.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, message: "Pass a closure as the destination")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, message: "Pass a closure as the destination")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, message: "Pass a closure as the destination")
    @available(watchOS, introduced: 6.0, deprecated: 100000.0, message: "Pass a closure as the destination")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Pass a closure as the destination")
    nonisolated public init<S>(_ title: S, destination: Destination) where S : StringProtocol

    /// Creates a navigation link that presents a destination view when active, with a
    /// text label that the link generates from a localized string key.
    /// - Parameters:
    ///   - titleKey: A localized string key for creating a text label.
    ///   - destination: A view for the navigation link to present.
    ///   - isActive: A binding to a Boolean value that indicates whether
    ///   `destination` is currently presented.
    @available(iOS, introduced: 13.0, deprecated: 16.0, message: "use NavigationLink(value:label:), or navigationDestination(isPresented:destination:), inside a NavigationStack or NavigationSplitView")
    @available(macOS, introduced: 10.15, deprecated: 13.0, message: "use NavigationLink(value:label:), or navigationDestination(isPresented:destination:), inside a NavigationStack or NavigationSplitView")
    @available(tvOS, introduced: 13.0, deprecated: 16.0, message: "use NavigationLink(value:label:), or navigationDestination(isPresented:destination:), inside a NavigationStack or NavigationSplitView")
    @available(watchOS, introduced: 6.0, deprecated: 9.0, message: "use NavigationLink(value:label:), or navigationDestination(isPresented:destination:), inside a NavigationStack or NavigationSplitView")
    @available(visionOS, introduced: 1.0, deprecated: 1.0, message: "use NavigationLink(value:label:), or navigationDestination(isPresented:destination:), inside a NavigationStack or NavigationSplitView")
    nonisolated public init(_ titleKey: LocalizedStringKey, destination: Destination, isActive: Binding<Bool>)

    /// Creates a navigation link that presents a destination view when active, with a
    /// text label that the link generates from a title string.
    /// - Parameters:
    ///   - title: A string for creating a text label.
    ///   - destination: A view for the navigation link to present.
    ///   - isActive: A binding to a Boolean value that indicates whether
    ///   `destination` is currently presented.
    @available(iOS, introduced: 13.0, deprecated: 16.0, message: "use NavigationLink(value:label:), or navigationDestination(isPresented:destination:), inside a NavigationStack or NavigationSplitView")
    @available(macOS, introduced: 10.15, deprecated: 13.0, message: "use NavigationLink(value:label:), or navigationDestination(isPresented:destination:), inside a NavigationStack or NavigationSplitView")
    @available(tvOS, introduced: 13.0, deprecated: 16.0, message: "use NavigationLink(value:label:), or navigationDestination(isPresented:destination:), inside a NavigationStack or NavigationSplitView")
    @available(watchOS, introduced: 6.0, deprecated: 9.0, message: "use NavigationLink(value:label:), or navigationDestination(isPresented:destination:), inside a NavigationStack or NavigationSplitView")
    @available(visionOS, introduced: 1.0, deprecated: 1.0, message: "use NavigationLink(value:label:), or navigationDestination(isPresented:destination:), inside a NavigationStack or NavigationSplitView")
    nonisolated public init<S>(_ title: S, destination: Destination, isActive: Binding<Bool>) where S : StringProtocol

    /// Creates a navigation link that presents a destination view when a bound
    /// selection variable matches a value you provide, using a text label
    /// that the link generates from a localized string key.
    /// - Parameters:
    ///   - titleKey: A localized string key for creating a text label.
    ///   - destination: A view for the navigation link to present.
    ///   - tag: The value of `selection` that causes the link to present
    ///   `destination`.
    ///   - selection: A bound variable that causes the link to present
    ///   `destination` when `selection` becomes equal to `tag`.
    @available(iOS, introduced: 13.0, deprecated: 16.0, message: "use NavigationLink(value:label:), or navigationDestination(isPresented:destination:), inside a NavigationStack or NavigationSplitView")
    @available(macOS, introduced: 10.15, deprecated: 13.0, message: "use NavigationLink(value:label:), or navigationDestination(isPresented:destination:), inside a NavigationStack or NavigationSplitView")
    @available(tvOS, introduced: 13.0, deprecated: 16.0, message: "use NavigationLink(value:label:), or navigationDestination(isPresented:destination:), inside a NavigationStack or NavigationSplitView")
    @available(watchOS, introduced: 6.0, deprecated: 9.0, message: "use NavigationLink(value:label:), or navigationDestination(isPresented:destination:), inside a NavigationStack or NavigationSplitView")
    @available(visionOS, introduced: 1.0, deprecated: 1.0, message: "use NavigationLink(value:label:), or navigationDestination(isPresented:destination:), inside a NavigationStack or NavigationSplitView")
    nonisolated public init<V>(_ titleKey: LocalizedStringKey, destination: Destination, tag: V, selection: Binding<V?>) where V : Hashable

    /// Creates a navigation link that presents a destination view when a bound
    /// selection variable matches a value you provide, using a text label
    /// that the link generates from a title string.
    /// - Parameters:
    ///   - title: A string for creating a text label.
    ///   - destination: A view for the navigation link to present.
    ///   - tag: The value of `selection` that causes the link to present
    ///   `destination`.
    ///   - selection: A bound variable that causes the link to present
    ///   `destination` when `selection` becomes equal to `tag`.
    @available(iOS, introduced: 13.0, deprecated: 16.0, message: "use NavigationLink(value:label:), or navigationDestination(isPresented:destination:), inside a NavigationStack or NavigationSplitView")
    @available(macOS, introduced: 10.15, deprecated: 13.0, message: "use NavigationLink(value:label:), or navigationDestination(isPresented:destination:), inside a NavigationStack or NavigationSplitView")
    @available(tvOS, introduced: 13.0, deprecated: 16.0, message: "use NavigationLink(value:label:), or navigationDestination(isPresented:destination:), inside a NavigationStack or NavigationSplitView")
    @available(watchOS, introduced: 6.0, deprecated: 9.0, message: "use NavigationLink(value:label:), or navigationDestination(isPresented:destination:), inside a NavigationStack or NavigationSplitView")
    @available(visionOS, introduced: 1.0, deprecated: 1.0, message: "use NavigationLink(value:label:), or navigationDestination(isPresented:destination:), inside a NavigationStack or NavigationSplitView")
    nonisolated public init<S, V>(_ title: S, destination: Destination, tag: V, selection: Binding<V?>) where S : StringProtocol, V : Hashable
}

@available(iOS 13.0, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension NavigationLink {

    /// Sets the navigation link to present its destination as the detail
    /// component of the containing navigation view.
    ///
    /// This method sets the behavior when the navigation link is used in a
    /// ``NavigationSplitView``, or a
    /// multi-column navigation view, such as one using
    /// ``ColumnNavigationViewStyle``.
    ///
    /// For example, in a two-column navigation split view, if `isDetailLink` is
    /// `true`, triggering the link in the sidebar column sets the contents of
    /// the detail column to be the link's destination view. If `isDetailLink`
    /// is `false`, the link navigates to the destination view within the
    /// primary column.
    ///
    /// If you do not set the detail link behavior with this method, the
    /// behavior defaults to `true`.
    ///
    /// The `isDetailLink` modifier only affects view-destination links. Links
    /// that present data values always search for a matching navigation
    /// destination beginning in the column that contains the link.
    ///
    /// - Parameter isDetailLink: A Boolean value that specifies whether this
    /// link presents its destination as the detail component when used in a
    /// multi-column navigation view.
    /// - Returns: A view that applies the specified detail link behavior.
    @available(macOS, unavailable)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public func isDetailLink(_ isDetailLink: Bool) -> some View

}

/// A picker style represented by a navigation link that presents the options
/// by pushing a List-style picker view.
///
/// In navigation stacks, prefer the default ``PickerStyle/menu`` style.
/// Consider the navigation link style when you have a large number of
/// options or your design is better expressed by pushing onto a stack.
///
/// You can also use ``PickerStyle/navigationLink`` to construct this style.
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, *)
@available(macOS, unavailable)
public struct NavigationLinkPickerStyle : PickerStyle {

    /// Creates a navigation link picker style.
    public init()
}

/// A type-erased list of data representing the content of a navigation stack.
///
/// You can manage the state of a ``NavigationStack`` by initializing the stack
/// with a binding to a collection of data. The stack stores data items in the
/// collection for each view on the stack. You also can read and write the
/// collection to observe and alter the stack's state.
///
/// When a stack displays views that rely on only one kind of data, you can use
/// a standard collection, like an array, to hold the data. If you need to
/// present different kinds of data in a single stack, use a navigation path
/// instead. The path uses type erasure so you can manage a collection of
/// heterogeneous elements. The path also provides the usual collection
/// controls for adding, counting, and removing data elements.
///
/// ### Serialize the path
///
/// When the values you present on the navigation stack conform to
/// the <doc://com.apple.documentation/documentation/Swift/Codable> protocol,
/// you can use the path's ``codable`` property to get a serializable
/// representation of the path. Use that representation to save and restore
/// the contents of the stack. For example, you can define an
/// <doc://com.apple.documentation/documentation/Combine/ObservableObject>
/// that handles serializing and deserializing the path:
///
///     class MyModelObject: ObservableObject {
///         @Published var path: NavigationPath
///
///         static func readSerializedData() -> Data? {
///             // Read data representing the path from app's persistent storage.
///         }
///
///         static func writeSerializedData(_ data: Data) {
///             // Write data representing the path to app's persistent storage.
///         }
///
///         init() {
///             if let data = Self.readSerializedData() {
///                 do {
///                     let representation = try JSONDecoder().decode(
///                         NavigationPath.CodableRepresentation.self,
///                         from: data)
///                     self.path = NavigationPath(representation)
///                 } catch {
///                     self.path = NavigationPath()
///                 }
///             } else {
///                 self.path = NavigationPath()
///             }
///         }
///
///         func save() {
///             guard let representation = path.codable else { return }
///             do {
///                 let encoder = JSONEncoder()
///                 let data = try encoder.encode(representation)
///                 Self.writeSerializedData(data)
///             } catch {
///                 // Handle error.
///             }
///         }
///     }
///
/// Then, using that object in your view, you can save the state of
/// the navigation path when the ``Scene`` enters the ``ScenePhase/background``
/// state:
///
///     @StateObject private var pathState = MyModelObject()
///     @Environment(\.scenePhase) private var scenePhase
///
///     var body: some View {
///         NavigationStack(path: $pathState.path) {
///             // Add a root view here.
///         }
///         .onChange(of: scenePhase) { phase in
///             if phase == .background {
///                 pathState.save()
///             }
///         }
///     }
///
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct NavigationPath {

    /// The number of elements in this path.
    public var count: Int { get }

    /// A Boolean that indicates whether this path is empty.
    public var isEmpty: Bool { get }

    /// A value that describes the contents of this path in a serializable
    /// format.
    ///
    /// This value is `nil` if any of the type-erased elements of the path
    /// don't conform to the
    /// <doc://com.apple.documentation/documentation/Swift/Codable> protocol.
    public var codable: NavigationPath.CodableRepresentation? { get }

    /// Creates a new, empty navigation path.
    public init()

    /// Creates a new navigation path from the contents of a sequence.
    ///
    /// - Parameters:
    ///   - elements: A sequence used to create the navigation path.
    public init<S>(_ elements: S) where S : Sequence, S.Element : Hashable

    /// Creates a new navigation path from the contents of a sequence that
    /// contains codable elements.
    ///
    /// - Parameters:
    ///   - elements: A sequence used to create the navigation path.
    public init<S>(_ elements: S) where S : Sequence, S.Element : Decodable, S.Element : Encodable, S.Element : Hashable

    /// Creates a new navigation path from a serializable version.
    ///
    /// - Parameters:
    ///   - codable: A value describing the contents of the new path in a
    ///     serializable format.
    public init(_ codable: NavigationPath.CodableRepresentation)

    /// Appends a new value to the end of this path.
    public mutating func append<V>(_ value: V) where V : Hashable

    /// Appends a new codable value to the end of this path.
    public mutating func append<V>(_ value: V) where V : Decodable, V : Encodable, V : Hashable

    /// Removes values from the end of this path.
    ///
    /// - Parameters:
    ///   - k: The number of values to remove. The default value is `1`.
    ///
    /// - Precondition: The input parameter `k` must be greater than or equal
    ///   to zero, and must be less than or equal to the number of elements in
    ///   the path.
    public mutating func removeLast(_ k: Int = 1)

    /// A serializable representation of a navigation path.
    ///
    /// When a navigation path contains elements the conform to the
    /// <doc://com.apple.documentation/documentation/Swift/Codable> protocol,
    /// you can use the path's `CodableRepresentation` to convert the path to an
    /// external representation and to convert an external representation back
    /// into a navigation path.
    public struct CodableRepresentation : Codable {

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws
    }
}

@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension NavigationPath : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: NavigationPath, rhs: NavigationPath) -> Bool
}

@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension NavigationPath.CodableRepresentation : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: NavigationPath.CodableRepresentation, rhs: NavigationPath.CodableRepresentation) -> Bool
}

/// A view that presents views in two or three columns, where selections in
/// leading columns control presentations in subsequent columns.
///
/// You create a navigation split view with two or three columns, and typically
/// use it as the root view in a ``Scene``. People choose one or more
/// items in a leading column to display details about those items in
/// subsequent columns.
///
/// To create a two-column navigation split view, use the
/// ``init(sidebar:detail:)`` initializer:
///
///     @State private var employeeIds: Set<Employee.ID> = []
///
///     var body: some View {
///         NavigationSplitView {
///             List(model.employees, selection: $employeeIds) { employee in
///                 Text(employee.name)
///             }
///         } detail: {
///             EmployeeDetails(for: employeeIds)
///         }
///     }
///
/// In the above example, the navigation split view coordinates with the
/// ``List`` in its first column, so that when people make a selection, the
/// detail view updates accordingly. Programmatic changes that you make to the
/// selection property also affect both the list appearance and the presented
/// detail view.
///
/// To create a three-column view, use the ``init(sidebar:content:detail:)``
/// initializer. The selection in the first column affects the second, and the
/// selection in the second column affects the third. For example, you can show
/// a list of departments, the list of employees in the selected department,
/// and the details about all of the selected employees:
///
///     @State private var departmentId: Department.ID? // Single selection.
///     @State private var employeeIds: Set<Employee.ID> = [] // Multiple selection.
///
///     var body: some View {
///         NavigationSplitView {
///             List(model.departments, selection: $departmentId) { department in
///                 Text(department.name)
///             }
///         } content: {
///             if let department = model.department(id: departmentId) {
///                 List(department.employees, selection: $employeeIds) { employee in
///                     Text(employee.name)
///                 }
///             } else {
///                 Text("Select a department")
///             }
///         } detail: {
///             EmployeeDetails(for: employeeIds)
///         }
///     }
///
/// You can also embed a ``NavigationStack`` in a column. Tapping or clicking a
/// ``NavigationLink`` that appears in an earlier column sets the view that the
/// stack displays over its root view. Activating a link in the same column
/// adds a view to the stack. Either way, the link must present a data type
/// for which the stack has a corresponding
/// ``View/navigationDestination(for:destination:)`` modifier.
///
/// On watchOS and tvOS, and with narrow sizes like on iPhone or on iPad in
/// Slide Over, the navigation split view collapses all of its columns
/// into a stack, and shows the last column that displays useful information.
/// For example, the three-column example above shows the list of departments to
/// start, the employees in the department after someone selects a department,
/// and the employee details when someone selects an employee. For rows in a
/// list that have ``NavigationLink`` instances, the list draws disclosure
/// chevrons while in the collapsed state.
///
/// ### Control column visibility
///
/// You can programmatically control the visibility of navigation split view
/// columns by creating a ``State`` value of type
/// ``NavigationSplitViewVisibility``. Then pass a ``Binding`` to that state to
/// the appropriate initializer --- such as
/// ``init(columnVisibility:sidebar:detail:)`` for two columns, or
/// the ``init(columnVisibility:sidebar:content:detail:)`` for three columns.
///
/// The following code updates the first example above to always hide the
/// first column when the view appears:
///
///     @State private var employeeIds: Set<Employee.ID> = []
///     @State private var columnVisibility =
///         NavigationSplitViewVisibility.detailOnly
///
///     var body: some View {
///         NavigationSplitView(columnVisibility: $columnVisibility) {
///             List(model.employees, selection: $employeeIds) { employee in
///                 Text(employee.name)
///             }
///         } detail: {
///             EmployeeDetails(for: employeeIds)
///         }
///     }
///
/// The split view ignores the visibility control when it collapses its columns
/// into a stack.
///
/// ### Collapsed split views
///
/// At narrow size classes, such as on iPhone or Apple Watch, a navigation split
/// view collapses into a single stack. Typically SwiftUI automatically chooses
/// the view to show on top of this single stack, based on the content of the
/// split view's columns.
///
/// For custom navigation experiences, you can provide more information to help
/// SwiftUI choose the right column. Create a `State` value of type
/// ``NavigationSplitViewColumn``. Then pass a `Binding` to that state to the
/// appropriate initializer, such as
/// ``init(preferredCompactColumn:sidebar:detail:)`` or
/// ``init(preferredCompactColumn:sidebar:content:detail:)``.
///
/// The following code shows the blue detail view when run on iPhone. When the
/// person using the app taps the back button, they'll see the yellow view. The
/// value of `preferredPreferredCompactColumn` will change from `.detail` to
/// `.sidebar`:
///
///     @State private var preferredColumn =
///         NavigationSplitViewColumn.detail
///
///     var body: some View {
///         NavigationSplitView(preferredCompactColumn: $preferredColumn) {
///             Color.yellow
///         } detail: {
///             Color.blue
///         }
///     }
///
/// ### Customize a split view
///
/// To specify a preferred column width in a navigation split view, use the
/// ``View/navigationSplitViewColumnWidth(_:)`` modifier. To set minimum,
/// maximum, and ideal sizes for a column, use
/// ``View/navigationSplitViewColumnWidth(min:ideal:max:)``. You can specify a
/// different modifier in each column. The navigation split view does its
/// best to accommodate the preferences that you specify, but might make
/// adjustments based on other constraints.
///
/// To specify how columns in a navigation split view interact, use the
/// ``View/navigationSplitViewStyle(_:)`` modifier with a
/// ``NavigationSplitViewStyle`` value. For example, you can specify
/// whether to emphasize the detail column or to give all of the columns equal
/// prominence.
///
/// On some platforms, `NavigationSplitView` adds a
/// ``ToolbarDefaultItemKind/sidebarToggle`` toolbar item. Use the
/// ``View/toolbar(removing:)`` modifier to remove the default
/// item.
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct NavigationSplitView<Sidebar, Content, Detail> : View where Sidebar : View, Content : View, Detail : View {

    /// Creates a three-column navigation split view.
    ///
    /// - Parameters:
    ///   - sidebar: The view to show in the leading column.
    ///   - content: The view to show in the middle column.
    ///   - detail: The view to show in the detail area.
    public init(@ViewBuilder sidebar: () -> Sidebar, @ViewBuilder content: () -> Content, @ViewBuilder detail: () -> Detail)

    /// Creates a three-column navigation split view that enables programmatic
    /// control of leading columns' visibility.
    ///
    /// - Parameters:
    ///   - columnVisibility: A ``Binding`` to state that controls the
    ///     visibility of the leading columns.
    ///   - sidebar: The view to show in the leading column.
    ///   - content: The view to show in the middle column.
    ///   - detail: The view to show in the detail area.
    public init(columnVisibility: Binding<NavigationSplitViewVisibility>, @ViewBuilder sidebar: () -> Sidebar, @ViewBuilder content: () -> Content, @ViewBuilder detail: () -> Detail)

    /// Creates a two-column navigation split view.
    ///
    /// - Parameters:
    ///   - sidebar: The view to show in the leading column.
    ///   - detail: The view to show in the detail area.
    public init(@ViewBuilder sidebar: () -> Sidebar, @ViewBuilder detail: () -> Detail) where Content == EmptyView

    /// Creates a two-column navigation split view that enables programmatic
    /// control of the sidebar's visibility.
    ///
    /// - Parameters:
    ///   - columnVisibility: A ``Binding`` to state that controls the
    ///     visibility of the leading column.
    ///   - sidebar: The view to show in the leading column.
    ///   - detail: The view to show in the detail area.
    public init(columnVisibility: Binding<NavigationSplitViewVisibility>, @ViewBuilder sidebar: () -> Sidebar, @ViewBuilder detail: () -> Detail) where Content == EmptyView

    /// The content and behavior of the view.
    ///
    /// When you implement a custom view, you must implement a computed
    /// `body` property to provide the content for your view. Return a view
    /// that's composed of built-in views that SwiftUI provides, plus other
    /// composite views that you've already defined:
    ///
    ///     struct MyView: View {
    ///         var body: some View {
    ///             Text("Hello, World!")
    ///         }
    ///     }
    ///
    /// For more information about composing views and a view hierarchy,
    /// see <doc:Declaring-a-Custom-View>.
    @MainActor @preconcurrency public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
    public typealias Body = some View
}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension NavigationSplitView {

    /// Creates a three-column navigation split view that enables programmatic
    /// control over which column appears on top when the view collapses into a
    /// single column in narrow sizes.
    ///
    /// - Parameters:
    ///   - preferredCompactColumn: A ``Binding`` to state that controls which
    ///     column appears on top when the view collapses.
    ///   - sidebar: The view to show in the leading column.
    ///   - content: The view to show in the middle column.
    ///   - detail: The view to show in the detail area.
    nonisolated public init(preferredCompactColumn: Binding<NavigationSplitViewColumn>, @ViewBuilder sidebar: () -> Sidebar, @ViewBuilder content: () -> Content, @ViewBuilder detail: () -> Detail)

    /// Creates a three-column navigation split view that enables programmatic
    /// control of leading columns' visibility in regular sizes and which column
    /// appears on top when the view collapses into a single column in narrow
    /// sizes.
    ///
    /// - Parameters:
    ///   - columnVisibility: A ``Binding`` to state that controls the
    ///     visibility of the leading columns.
    ///   - preferredCompactColumn: A ``Binding`` to state that controls which
    ///     column appears on top when the view collapses.
    ///   - sidebar: The view to show in the leading column.
    ///   - content: The view to show in the middle column.
    ///   - detail: The view to show in the detail area.
    nonisolated public init(columnVisibility: Binding<NavigationSplitViewVisibility>, preferredCompactColumn: Binding<NavigationSplitViewColumn>, @ViewBuilder sidebar: () -> Sidebar, @ViewBuilder content: () -> Content, @ViewBuilder detail: () -> Detail)

    /// Creates a two-column navigation split view that enables programmatic
    /// control over which column appears on top when the view collapses into a
    /// single column in narrow sizes.
    ///
    /// - Parameters:
    ///   - preferredCompactColumn: A ``Binding`` to state that controls which
    ///     column appears on top when the view collapses.
    ///   - sidebar: The view to show in the leading column.
    ///   - detail: The view to show in the detail area.
    nonisolated public init(preferredCompactColumn: Binding<NavigationSplitViewColumn>, @ViewBuilder sidebar: () -> Sidebar, @ViewBuilder detail: () -> Detail) where Content == EmptyView

    /// Creates a two-column navigation split view that enables programmatic
    /// control of the sidebar's visibility in regular sizes and which column
    /// appears on top when the view collapses into a single column in narrow
    /// sizes.
    ///
    /// - Parameters:
    ///   - columnVisibility: A ``Binding`` to state that controls the
    ///     visibility of the leading column.
    ///   - preferredCompactColumn: A ``Binding`` to state that controls which
    ///     column appears on top when the view collapses.
    ///   - sidebar: The view to show in the leading column.
    ///   - detail: The view to show in the detail area.
    nonisolated public init(columnVisibility: Binding<NavigationSplitViewVisibility>, preferredCompactColumn: Binding<NavigationSplitViewColumn>, @ViewBuilder sidebar: () -> Sidebar, @ViewBuilder detail: () -> Detail) where Content == EmptyView
}

/// A view that represents a column in a navigation split view.
///
/// A ``NavigationSplitView`` collapses into a single stack in some contexts,
/// like on iPhone or Apple Watch. Use this type with the
/// `preferredCompactColumn` parameter to control which column of the navigation
/// split view appears on top of the collapsed stack.
@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
public struct NavigationSplitViewColumn : Hashable, Sendable {

    public static var sidebar: NavigationSplitViewColumn { get }

    public static var content: NavigationSplitViewColumn { get }

    public static var detail: NavigationSplitViewColumn { get }

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: NavigationSplitViewColumn, b: NavigationSplitViewColumn) -> Bool

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

/// A type that specifies the appearance and interaction of navigation split
/// views within a view hierarchy.
///
/// To configure the navigation split view style for a view hierarchy, use the
/// ``View/navigationSplitViewStyle(_:)`` modifier.
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
@MainActor @preconcurrency public protocol NavigationSplitViewStyle {

    /// A view that represents the body of a navigation split view.
    associatedtype Body : View

    /// Creates a view that represents the body of a navigation split view.
    ///
    /// SwiftUI calls this method for each instance of ``NavigationSplitView``,
    /// where this style is the current ``NavigationSplitViewStyle``.
    ///
    /// - Parameter configuration: The properties of the instance to create.
    @ViewBuilder @MainActor @preconcurrency func makeBody(configuration: Self.Configuration) -> Self.Body

    /// The properties of a navigation split view instance.
    typealias Configuration = NavigationSplitViewStyleConfiguration
}

@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension NavigationSplitViewStyle where Self == BalancedNavigationSplitViewStyle {

    /// A navigation split style that reduces the size of the detail content
    /// to make room when showing the leading column or columns.
    @MainActor @preconcurrency public static var balanced: BalancedNavigationSplitViewStyle { get }
}

@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension NavigationSplitViewStyle where Self == ProminentDetailNavigationSplitViewStyle {

    /// A navigation split style that attempts to maintain the size of the
    /// detail content when hiding or showing the leading columns.
    @MainActor @preconcurrency public static var prominentDetail: ProminentDetailNavigationSplitViewStyle { get }
}

@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension NavigationSplitViewStyle where Self == AutomaticNavigationSplitViewStyle {

    /// A navigation split style that resolves its appearance automatically
    /// based on the current context.
    @MainActor @preconcurrency public static var automatic: AutomaticNavigationSplitViewStyle { get }
}

/// The properties of a navigation split view instance.
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct NavigationSplitViewStyleConfiguration {
}

/// The visibility of the leading columns in a navigation split view.
///
/// Use a value of this type to control the visibility of the columns of a
/// ``NavigationSplitView``. Create a ``State`` property with a
/// value of this type, and pass a ``Binding`` to that state to the
/// ``NavigationSplitView/init(columnVisibility:sidebar:detail:)`` or
/// ``NavigationSplitView/init(columnVisibility:sidebar:content:detail:)``
/// initializer when you create the navigation split view. You can then
/// modify the value elsewhere in your code to:
///
/// * Hide all but the trailing column with ``detailOnly``.
/// * Hide the leading column of a three-column navigation split view
///   with ``doubleColumn``.
/// * Show all the columns with ``all``.
/// * Rely on the automatic behavior for the current context with ``automatic``.
///
/// >Note: Some platforms don't respect every option. For example, macOS always
/// displays the content column.
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct NavigationSplitViewVisibility : Equatable, Codable, Sendable {

    /// Hide the leading two columns of a three-column navigation split view, so
    /// that just the detail area shows.
    public static var detailOnly: NavigationSplitViewVisibility { get }

    /// Show the content column and detail area of a three-column navigation
    /// split view, or the sidebar column and detail area of a two-column
    /// navigation split view.
    ///
    /// For a two-column navigation split view, `doubleColumn` is equivalent
    /// to `all`.
    public static var doubleColumn: NavigationSplitViewVisibility { get }

    /// Show all the columns of a three-column navigation split view.
    public static var all: NavigationSplitViewVisibility { get }

    /// Use the default leading column visibility for the current device.
    ///
    /// This computed property returns one of the three concrete cases:
    /// ``detailOnly``, ``doubleColumn``, or ``all``.
    public static var automatic: NavigationSplitViewVisibility { get }

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: NavigationSplitViewVisibility, rhs: NavigationSplitViewVisibility) -> Bool

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

/// A view that displays a root view and enables you to present additional
/// views over the root view.
///
/// Use a navigation stack to present a stack of views over a root view.
/// People can add views to the top of the stack by clicking or tapping a
/// ``NavigationLink``, and remove views using built-in, platform-appropriate
/// controls, like a Back button or a swipe gesture. The stack always displays
/// the most recently added view that hasn't been removed, and doesn't allow
/// the root view to be removed.
///
/// To create navigation links, associate a view with a data type by adding a
/// ``View/navigationDestination(for:destination:)`` modifier inside
/// the stack's view hierarchy. Then initialize a ``NavigationLink`` that
/// presents an instance of the same kind of data. The following stack displays
/// a `ParkDetails` view for navigation links that present data of type `Park`:
///
///     NavigationStack {
///         List(parks) { park in
///             NavigationLink(park.name, value: park)
///         }
///         .navigationDestination(for: Park.self) { park in
///             ParkDetails(park: park)
///         }
///     }
///
/// In this example, the ``List`` acts as the root view and is always
/// present. Selecting a navigation link from the list adds a `ParkDetails`
/// view to the stack, so that it covers the list. Navigating back removes
/// the detail view and reveals the list again. The system disables backward
/// navigation controls when the stack is empty and the root view, namely
/// the list, is visible.
///
/// ### Manage navigation state
///
/// By default, a navigation stack manages state to keep track of the views on
/// the stack. However, your code can share control of the state by initializing
/// the stack with a binding to a collection of data values that you create.
/// The stack adds items to the collection as it adds views to the stack and
/// removes items when it removes views. For example, you can create a ``State``
/// property to manage the navigation for the park detail view:
///
///     @State private var presentedParks: [Park] = []
///
/// Initializing the state as an empty array indicates a stack with no views.
/// Provide a ``Binding`` to this state property using the dollar sign (`$`)
/// prefix when you create a stack using the ``init(path:root:)``
/// initializer:
///
///     NavigationStack(path: $presentedParks) {
///         List(parks) { park in
///             NavigationLink(park.name, value: park)
///         }
///         .navigationDestination(for: Park.self) { park in
///             ParkDetails(park: park)
///         }
///     }
///
/// Like before, when someone taps or clicks the navigation link for a
/// park, the stack displays the `ParkDetails` view using the associated park
/// data. However, now the stack also puts the park data in the `presentedParks`
/// array. Your code can observe this array to read the current stack state. It
/// can also modify the array to change the views on the stack. For example, you
/// can create a method that configures the stack with a specific set of parks:
///
///     func showParks() {
///         presentedParks = [Park("Yosemite"), Park("Sequoia")]
///     }
///
/// The `showParks` method replaces the stack's display with a view that shows
/// details for Sequoia, the last item in the new `presentedParks` array.
/// Navigating back from that view removes Sequoia from the array, which
/// reveals a view that shows details for Yosemite. Use a path to support
/// deep links, state restoration, or other kinds of programmatic navigation.
///
/// ### Navigate to different view types
///
/// To create a stack that can present more than one kind of view, you can add
/// multiple ``View/navigationDestination(for:destination:)`` modifiers
/// inside the stack's view hierarchy, with each modifier presenting a
/// different data type. The stack matches navigation links with navigation
/// destinations based on their respective data types.
///
/// To create a path for programmatic navigation that contains more than one
/// kind of data, you can use a ``NavigationPath`` instance as the path.
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
@MainActor @preconcurrency public struct NavigationStack<Data, Root> : View where Root : View {

    /// Creates a navigation stack that manages its own navigation state.
    ///
    /// - Parameters:
    ///   - root: The view to display when the stack is empty.
    @MainActor @preconcurrency public init(@ViewBuilder root: () -> Root) where Data == NavigationPath

    /// Creates a navigation stack with heterogeneous navigation state that you
    /// can control.
    ///
    /// If you don't need access to the navigation state, use ``init(root:)``.
    ///
    /// - Parameters:
    ///   - path: A ``Binding`` to the navigation state for this stack.
    ///   - root: The view to display when the stack is empty.
    @MainActor @preconcurrency public init(path: Binding<NavigationPath>, @ViewBuilder root: () -> Root) where Data == NavigationPath

    /// Creates a navigation stack with homogeneous navigation state that you
    /// can control.
    ///
    /// If you don't need access to the navigation state, use ``init(root:)``.
    ///
    /// - Parameters:
    ///   - path: A ``Binding`` to the navigation state for this stack.
    ///   - root: The view to display when the stack is empty.
    @MainActor @preconcurrency public init(path: Binding<Data>, @ViewBuilder root: () -> Root) where Data : MutableCollection, Data : RandomAccessCollection, Data : RangeReplaceableCollection, Data.Element : Hashable

    /// The content and behavior of the view.
    ///
    /// When you implement a custom view, you must implement a computed
    /// `body` property to provide the content for your view. Return a view
    /// that's composed of built-in views that SwiftUI provides, plus other
    /// composite views that you've already defined:
    ///
    ///     struct MyView: View {
    ///         var body: some View {
    ///             Text("Hello, World!")
    ///         }
    ///     }
    ///
    /// For more information about composing views and a view hierarchy,
    /// see <doc:Declaring-a-Custom-View>.
    @MainActor @preconcurrency public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
    public typealias Body = some View
}

/// A type that defines the transition to use when navigating to a view.
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public protocol NavigationTransition {
}

/// A style that automatically chooses the appropriate presentation
/// transition for the current context.
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension NavigationTransition where Self == AutomaticNavigationTransition {

    /// A style that automatically chooses the appropriate presentation
    /// transition for the current context.
    public static var automatic: AutomaticNavigationTransition { get }
}

@available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
@available(macOS, unavailable)
extension NavigationTransition where Self == ZoomNavigationTransition {

    /// A navigation transition that zooms the appearing view from a
    /// given source view.
    ///
    /// Indicate the source view using the
    /// ``View/matchedTransitionSource(id:namespace:)`` modifier.
    ///
    /// - Parameters:
    ///   - sourceID: The identifier you provide to a corresponding
    ///     `matchedTransitionSource` modifier.
    ///   - namespace: The namespace where you define the `id`. You can create
    ///     new namespaces by adding the ``Namespace`` attribute
    ///     to a ``View`` type, then reading its value in the view's body
    ///     method.
    public static func zoom(sourceID: some Hashable, in namespace: Namespace.ID) -> ZoomNavigationTransition
}

/// A view for presenting a stack of views that represents a visible path in a
/// navigation hierarchy.
///
/// Use a `NavigationView` to create a navigation-based app in which the user
/// can traverse a collection of views. Users navigate to a destination view
/// by selecting a ``NavigationLink`` that you provide. On iPadOS and macOS, the
/// destination content appears in the next column. Other platforms push a new
/// view onto the stack, and enable removing items from the stack with
/// platform-specific controls, like a Back button or a swipe gesture.
///
/// ![A diagram showing a multicolumn navigation view on
/// macOS, and a stack of views on iOS.](NavigationView-1)
///
/// Use the ``init(content:)`` initializer to create a
/// navigation view that directly associates navigation links and their
/// destination views:
///
///     NavigationView {
///         List(model.notes) { note in
///             NavigationLink(note.title, destination: NoteEditor(id: note.id))
///         }
///         Text("Select a Note")
///     }
///
/// Style a navigation view by modifying it with the
/// ``View/navigationViewStyle(_:)`` view modifier. Use other modifiers, like
/// ``View/navigationTitle(_:)``, on views presented by the navigation
/// view to customize the navigation interface for the presented view.
@available(iOS, introduced: 13.0, deprecated: 100000.0, message: "use NavigationStack or NavigationSplitView instead")
@available(macOS, introduced: 10.15, deprecated: 100000.0, message: "use NavigationStack or NavigationSplitView instead")
@available(tvOS, introduced: 13.0, deprecated: 100000.0, message: "use NavigationStack or NavigationSplitView instead")
@available(watchOS, introduced: 7.0, deprecated: 100000.0, message: "use NavigationStack or NavigationSplitView instead")
@available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "use NavigationStack or NavigationSplitView instead")
public struct NavigationView<Content> : View where Content : View {

    /// Creates a destination-based navigation view.
    ///
    /// Perform navigation by initializing a link with a destination view.
    /// For example, consider a `ColorDetail` view that displays a color sample:
    ///
    ///     struct ColorDetail: View {
    ///         var color: Color
    ///
    ///         var body: some View {
    ///             color
    ///                 .frame(width: 200, height: 200)
    ///                 .navigationTitle(color.description.capitalized)
    ///         }
    ///     }
    ///
    /// The following ``NavigationView`` presents three links to color detail
    /// views:
    ///
    ///     NavigationView {
    ///         List {
    ///             NavigationLink("Purple", destination: ColorDetail(color: .purple))
    ///             NavigationLink("Pink", destination: ColorDetail(color: .pink))
    ///             NavigationLink("Orange", destination: ColorDetail(color: .orange))
    ///         }
    ///         .navigationTitle("Colors")
    ///
    ///         Text("Select a Color") // A placeholder to show before selection.
    ///     }
    ///
    /// When the horizontal size class is ``UserInterfaceSizeClass/regular``,
    /// like on an iPad in landscape mode, or on a Mac,
    /// the navigation view presents itself as a multicolumn view,
    /// using its second and later content views --- a single ``Text``
    /// view in the example above --- as a placeholder for the corresponding
    /// column:
    ///
    /// ![A screenshot of a Mac window showing a multicolumn navigation view.
    /// The left column lists the colors Purple, Pink, and Orange, with
    /// none selected. The right column presents a placeholder view that says
    /// Select a Color.](NavigationView-init-content-1)
    ///
    /// When the user selects one of the navigation links from the
    /// list, the linked destination view replaces the placeholder
    /// text in the detail column:
    ///
    /// ![A screenshot of a Mac window showing a multicolumn navigation view.
    /// The left column lists the colors Purple, Pink, and Orange, with
    /// Purple selected. The right column presents a detail view that shows a
    /// purple square.](NavigationView-init-content-2)
    ///
    /// When the size class is ``UserInterfaceSizeClass/compact``, like
    /// on an iPhone in portrait orientation, the navigation view presents
    /// itself as a single column that the user navigates as a stack. Tapping
    /// one of the links replaces the list with the detail view, which
    /// provides a back button to return to the list:
    ///
    /// ![Two screenshots of an iPhone in portrait orientation connected by an
    /// arrow. The first screenshot shows a single column consisting of a list
    /// of colors with the names Purple, Pink, and Orange. The second
    /// screenshot has the title Purple, and contains a purple square.
    /// The arrow connects the Purple item in the list on the left to the
    /// screenshot on the right.](NavigationView-init-content-3)
    ///
    /// - Parameter content: A ``ViewBuilder`` that produces the content that
    ///   the navigation view wraps. Any views after the first act as
    ///   placeholders for corresponding columns in a multicolumn display.
    public init(@ViewBuilder content: () -> Content)

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, message: "use NavigationStack or NavigationSplitView instead")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, message: "use NavigationStack or NavigationSplitView instead")
    @available(watchOS, introduced: 7.0, deprecated: 100000.0, message: "use NavigationStack or NavigationSplitView instead")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "use NavigationStack or NavigationSplitView instead")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, message: "use NavigationStack or NavigationSplitView instead")
    public typealias Body = Never
}

/// A specification for the appearance and interaction of a `NavigationView`.
@available(iOS, introduced: 13.0, deprecated: 100000.0, message: "replace styled NavigationView with NavigationStack or NavigationSplitView instead")
@available(macOS, introduced: 10.15, deprecated: 100000.0, message: "replace styled NavigationView with NavigationStack or NavigationSplitView instead")
@available(tvOS, introduced: 13.0, deprecated: 100000.0, message: "replace styled NavigationView with NavigationStack or NavigationSplitView instead")
@available(watchOS, introduced: 7.0, deprecated: 100000.0, message: "replace styled NavigationView with NavigationStack or NavigationSplitView instead")
@available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "replace styled NavigationView with NavigationStack or NavigationSplitView instead")
public protocol NavigationViewStyle {
}

@available(iOS, introduced: 15.0, deprecated: 100000.0, message: "replace styled NavigationView with NavigationSplitView")
@available(macOS, introduced: 12.0, deprecated: 100000.0, message: "replace styled NavigationView with NavigationSplitView")
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "replace styled NavigationView with NavigationSplitView")
extension NavigationViewStyle where Self == ColumnNavigationViewStyle {

    /// A navigation view style represented by a series of views in columns.
    public static var columns: ColumnNavigationViewStyle { get }
}

@available(iOS, introduced: 13.0, deprecated: 100000.0, message: "replace styled NavigationView with NavigationStack or NavigationSplitView instead")
@available(macOS, introduced: 10.15, deprecated: 100000.0, message: "replace styled NavigationView with NavigationSplitView instead")
@available(tvOS, introduced: 13.0, deprecated: 100000.0, message: "replace styled NavigationView with NavigationStack or NavigationSplitView instead")
@available(watchOS, introduced: 7.0, deprecated: 100000.0, message: "replace styled NavigationView with NavigationStack or NavigationSplitView instead")
@available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "replace styled NavigationView with NavigationStack or NavigationSplitView instead")
extension NavigationViewStyle where Self == DefaultNavigationViewStyle {

    /// The default navigation view style in the current context of the view
    /// being styled.
    public static var automatic: DefaultNavigationViewStyle { get }
}

@available(iOS, introduced: 13.0, deprecated: 100000.0, message: "replace stack-styled NavigationView with NavigationStack")
@available(macOS, unavailable)
@available(tvOS, introduced: 13.0, deprecated: 100000.0, message: "replace stack-styled NavigationView with NavigationStack")
@available(watchOS, introduced: 7.0, deprecated: 100000.0, message: "replace stack-styled NavigationView with NavigationStack")
@available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "replace stack-styled NavigationView with NavigationStack")
extension NavigationViewStyle where Self == StackNavigationViewStyle {

    /// A navigation view style represented by a view stack that only shows a
    /// single top view at a time.
    public static var stack: StackNavigationViewStyle { get }
}

/// A button that creates and opens new documents.
///
/// Use a new document button to give people the option to create documents in your app.
/// In the following example, there are two new document buttons, both support ``Text`` labels.
/// When the user taps or clicks the first button, the system creates a new document in the directory
/// currently open in the document browser. The second button creates a new document from a template.
///
///     @State private var isTemplatePickerPresented = false
///     @State private var documentCreationContinuation:
///         CheckedContinuation<TextDocument?, any Error>?
///
///     var body: some Scene {
///         DocumentGroupLaunchScene("My Documents") {
///             NewDocumentButton("Start Writing")
///             NewDocumentButton("Choose a Template", for: MyDocument.self) {
///                 try await withCheckedThrowingContinuation { continuation in
///                     documentCreationContinuation = continuation
///                     isTemplatePickerPresented = true
///                 }
///             }
///             .fullScreenCover(isPresented: $isTemplatePickerPresented) {
///                 TemplatePicker(continuation: $documentCreationContinuation)
///             }
///         }
///     }
///
/// If you don't provide a custom label, the system provides a button with the default "Create Document" label.
@available(iOS 18.0, macOS 15.0, visionOS 2.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct NewDocumentButton<Label> : View where Label : View {

    /// The content and behavior of the view.
    ///
    /// When you implement a custom view, you must implement a computed
    /// `body` property to provide the content for your view. Return a view
    /// that's composed of built-in views that SwiftUI provides, plus other
    /// composite views that you've already defined:
    ///
    ///     struct MyView: View {
    ///         var body: some View {
    ///             Text("Hello, World!")
    ///         }
    ///     }
    ///
    /// For more information about composing views and a view hierarchy,
    /// see <doc:Declaring-a-Custom-View>.
    @MainActor @preconcurrency public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    @available(iOS 18.0, visionOS 2.0, macOS 15.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias Body = some View
}

@available(iOS 18.0, macOS 15.0, visionOS 2.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension NewDocumentButton where Label == Text {

    /// Creates and opens new documents.
    ///
    /// - Parameters:
    ///   - label: A label to use for the button.
    ///   - contentType: An optional content type of the document to create.
    public init(_ label: Text? = nil, contentType: UTType? = nil)

    /// Creates and opens new documents.
    ///
    /// - Parameters:
    ///   - title: A title key to use as the button title.
    ///   - contentType: An optional content type of the document to create.
    public init(_ title: LocalizedStringKey, contentType: UTType? = nil)

    /// Creates and opens new documents.
    ///
    /// - Parameters:
    ///   - title: A title to use as the button title.
    ///   - contentType: An optional content type of the document to create.
    public init(_ title: some StringProtocol, contentType: UTType? = nil)

    /// Creates and opens new documents.
    ///
    /// A button that presents a document template picker and creates documents
    /// can be implemented like this:
    ///
    ///        struct ChooseDocumentTemplateButton: View {
    ///            @State private var showTemplatePicker = false
    ///            @State private var documentCreationContinuation:
    ///                CheckedContinuation<TextDocument?, any Error>?
    ///
    ///            var body: some View {
    ///                NewDocumentButton(for: TextDocument.self) {
    ///                    try await withCheckedThrowingContinuation { continuation in
    ///                        documentCreationContinuation = continuation
    ///                        showTemplatePicker = true
    ///                    }
    ///                }
    ///                .fullScreenCover(isPresented: $showTemplatePicker) {
    ///                    TemplatePicker($documentCreationContinuation)
    ///                }
    ///            }
    ///        }
    ///
    ///        struct TemplatePicker: View {
    ///            @Binding var documentCreationContinuation:
    ///                CheckedContinuation<TextDocument?, any Error>?
    ///
    ///            ...
    ///
    ///            func present(document: TextDocument) {
    ///                documentCreationContinuation.resume(returning: document)
    ///                documentCreationContinuation = nil
    ///            }
    ///        }
    ///
    ///        struct TextDocument: FileDocument { ... }
    ///
    /// - Parameters:
    ///   - label: A label for the button.
    ///   - documentType: A type of the document to create.
    ///   - contentType: An optional content type of the document to create.
    ///   - prepareDocument: A closure is called when a user presses the button.
    ///   At this point, you can present a document template picker or another UI that allows
    ///   users to choose a theme, configuration, or a template
    ///   to create a document from.
    ///   Return a prepared document, or throw an error if document creation failed.
    ///   Return `nil` to request creation of an empty document.
    public init<D>(_ label: Text? = nil, for documentType: D.Type = D.self, contentType: UTType? = nil, prepareDocument: @escaping () async throws -> D? = { nil }) where D : FileDocument

    /// Creates and opens new documents.
    ///
    /// A button that presents a document template picker and creates documents
    /// can be implemented like this:
    ///
    ///        struct ChooseDocumentTemplateButton: View {
    ///            @State private var showTemplatePicker = false
    ///            @State private var documentCreationContinuation:
    ///                CheckedContinuation<TextDocument?, any Error>?
    ///
    ///            var body: some View {
    ///                NewDocumentButton(for: TextDocument.self) {
    ///                    try await withCheckedThrowingContinuation { continuation in
    ///                        documentCreationContinuation = continuation
    ///                        showTemplatePicker = true
    ///                    }
    ///                }
    ///                .fullScreenCover(isPresented: $showTemplatePicker) {
    ///                    TemplatePicker($documentCreationContinuation)
    ///                }
    ///            }
    ///        }
    ///
    ///        struct TemplatePicker: View {
    ///            @Binding var documentCreationContinuation:
    ///                CheckedContinuation<TextDocument?, any Error>?
    ///
    ///            ...
    ///
    ///            func present(document: TextDocument) {
    ///                documentCreationContinuation.resume(returning: document)
    ///                documentCreationContinuation = nil
    ///            }
    ///        }
    ///
    ///        struct TextDocument: FileDocument { ... }
    ///
    /// - Parameters:
    ///   - title: A title key for the button.
    ///   - documentType: A type of the document to create.
    ///   - contentType: An optional content type of the document to create.
    ///   - prepareDocument: A closure is called when a user presses the button.
    ///   At this point, you can present a document template picker or another UI that allows
    ///   users to choose a theme, configuration, or a template
    ///   to create a document from.
    ///   Return a prepared document, or throw an error if document creation failed.
    ///   Return `nil` to request creation of an empty document.
    public init<D>(_ title: LocalizedStringKey, for documentType: D.Type = D.self, contentType: UTType? = nil, prepareDocument: @escaping () async throws -> D? = { nil }) where D : FileDocument

    /// Creates and opens new documents.
    ///
    /// A button that presents a document template picker and creates documents
    /// can be implemented like this:
    ///
    ///        struct ChooseDocumentTemplateButton: View {
    ///            @State private var showTemplatePicker = false
    ///            @State private var documentCreationContinuation:
    ///                CheckedContinuation<TextDocument?, any Error>?
    ///
    ///            var body: some View {
    ///                NewDocumentButton(for: TextDocument.self) {
    ///                    try await withCheckedThrowingContinuation { continuation in
    ///                        documentCreationContinuation = continuation
    ///                        showTemplatePicker = true
    ///                    }
    ///                }
    ///                .fullScreenCover(isPresented: $showTemplatePicker) {
    ///                    TemplatePicker($documentCreationContinuation)
    ///                }
    ///            }
    ///        }
    ///
    ///        struct TemplatePicker: View {
    ///            @Binding var documentCreationContinuation:
    ///                CheckedContinuation<TextDocument?, any Error>?
    ///
    ///            ...
    ///
    ///            func present(document: TextDocument) {
    ///                documentCreationContinuation.resume(returning: document)
    ///                documentCreationContinuation = nil
    ///            }
    ///        }
    ///
    ///        struct TextDocument: FileDocument { ... }
    ///
    /// - Parameters:
    ///   - title: A title for the button title.
    ///   - documentType: A type of the document to create.
    ///   - contentType: An optional content type of the document to create.
    ///   - prepareDocument: A closure is called when a user presses the button.
    ///   At this point, you can present a document template picker or another UI that allows
    ///   users to choose a theme, configuration, or a template
    ///   to create a document from.
    ///   Return a prepared document, or throw an error if document creation failed.
    ///   Return `nil` to request creation of an empty document.
    public init<D>(_ title: some StringProtocol, for documentType: D.Type = D.self, contentType: UTType? = nil, prepareDocument: @escaping () async throws -> D? = { nil }) where D : FileDocument

    /// Creates and opens new documents.
    ///
    /// A button that presents a document template picker and creates documents
    /// can be implemented like this:
    ///
    ///        struct ChooseDocumentTemplateButton: View {
    ///            @State private var showTemplatePicker = false
    ///            @State private var documentCreationContinuation:
    ///                CheckedContinuation<TextDocument?, any Error>?
    ///
    ///            var body: some View {
    ///                NewDocumentButton(for: TextDocument.self) {
    ///                    try await withCheckedThrowingContinuation { continuation in
    ///                        documentCreationContinuation = continuation
    ///                        showTemplatePicker = true
    ///                    }
    ///                }
    ///                .fullScreenCover(isPresented: $showTemplatePicker) {
    ///                    TemplatePicker($documentCreationContinuation)
    ///                }
    ///            }
    ///        }
    ///
    ///        struct TemplatePicker: View {
    ///            @Binding var documentCreationContinuation:
    ///                CheckedContinuation<TextDocument?, any Error>?
    ///
    ///            ...
    ///
    ///            func present(document: TextDocument) {
    ///                documentCreationContinuation.resume(returning: document)
    ///                documentCreationContinuation = nil
    ///            }
    ///        }
    ///
    ///        struct TextDocument: ReferenceFileDocument { ... }
    ///
    /// - Parameters:
    ///   - title: A label for the button.
    ///   - documentType: A type of the document to create.
    ///   - contentType: An optional content type of the document to create.
    ///   - prepareDocument: A closure is called when a user presses the button.
    ///   At this point, you can present a document template picker or another UI that allows
    ///   users to choose a theme, configuration, or a template
    ///   to create a document from.
    ///   Return a prepared document, or throw an error if document creation failed.
    ///   Return `nil` to request creation of an empty document.
    public init<D>(_ label: Text? = nil, for documentType: D.Type = D.self, contentType: UTType? = nil, prepareDocument: @escaping () async throws -> D? = { nil }) where D : ReferenceFileDocument

    /// Creates and opens new documents.
    ///
    /// A button that presents a document template picker and creates documents
    /// can be implemented like this:
    ///
    ///        struct ChooseDocumentTemplateButton: View {
    ///            @State private var showTemplatePicker = false
    ///            @State private var documentCreationContinuation:
    ///                CheckedContinuation<TextDocument?, any Error>?
    ///
    ///            var body: some View {
    ///                NewDocumentButton(for: TextDocument.self) {
    ///                    try await withCheckedThrowingContinuation { continuation in
    ///                        documentCreationContinuation = continuation
    ///                        showTemplatePicker = true
    ///                    }
    ///                }
    ///                .fullScreenCover(isPresented: $showTemplatePicker) {
    ///                    TemplatePicker($documentCreationContinuation)
    ///                }
    ///            }
    ///        }
    ///
    ///        struct TemplatePicker: View {
    ///            @Binding var documentCreationContinuation:
    ///                CheckedContinuation<TextDocument?, any Error>?
    ///
    ///            ...
    ///
    ///            func present(document: TextDocument) {
    ///                documentCreationContinuation.resume(returning: document)
    ///                documentCreationContinuation = nil
    ///            }
    ///        }
    ///
    ///        struct ReferenceFileDocument: FileDocument { ... }
    ///
    /// - Parameters:
    ///   - title: A title key for the button.
    ///   - documentType: A type of the document to create.
    ///   - contentType: An optional content type of the document to create.
    ///   - prepareDocument: A closure is called when a user presses the button.
    ///   At this point, you can present a document template picker or another UI that allows
    ///   users to choose a theme, configuration, or a template
    ///   to create a document from.
    ///   Return a prepared document, or throw an error if document creation failed.
    ///   Return `nil` to request creation of an empty document.
    public init<D>(_ title: LocalizedStringKey, for documentType: D.Type = D.self, contentType: UTType? = nil, prepareDocument: @escaping () async throws -> D? = { nil }) where D : ReferenceFileDocument

    /// Creates and opens new documents.
    ///
    /// A button that presents a document template picker and creates documents
    /// can be implemented like this:
    ///
    ///        struct ChooseDocumentTemplateButton: View {
    ///            @State private var showTemplatePicker = false
    ///            @State private var documentCreationContinuation:
    ///                CheckedContinuation<TextDocument?, any Error>?
    ///
    ///            var body: some View {
    ///                NewDocumentButton(for: TextDocument.self) {
    ///                    try await withCheckedThrowingContinuation { continuation in
    ///                        documentCreationContinuation = continuation
    ///                        showTemplatePicker = true
    ///                    }
    ///                }
    ///                .fullScreenCover(isPresented: $showTemplatePicker) {
    ///                    TemplatePicker($documentCreationContinuation)
    ///                }
    ///            }
    ///        }
    ///
    ///        struct TemplatePicker: View {
    ///            @Binding var documentCreationContinuation:
    ///                CheckedContinuation<TextDocument?, any Error>?
    ///
    ///            ...
    ///
    ///            func present(document: TextDocument) {
    ///                documentCreationContinuation.resume(returning: document)
    ///                documentCreationContinuation = nil
    ///            }
    ///        }
    ///
    ///        struct TextDocument: ReferenceFileDocument { ... }
    ///
    /// - Parameters:
    ///   - title: A title for the button.
    ///   - documentType: A type of the document to create.
    ///   - contentType: An optional content type of the document to create.
    ///   - prepareDocument: A closure is called when a user presses the button.
    ///   At this point, you can present a document template picker or another UI that allows
    ///   users to choose a theme, configuration, or a template
    ///   to create a document from.
    ///   Return a prepared document, or throw an error if document creation failed.
    ///   Return `nil` to request creation of an empty document.
    public init<D>(_ title: some StringProtocol, for documentType: D.Type = D.self, contentType: UTType? = nil, prepareDocument: @escaping () async throws -> D? = { nil }) where D : ReferenceFileDocument

    /// Creates and opens new documents.
    ///
    /// A button that presents a document template picker and creates documents
    /// can be implemented like this:
    ///
    ///        struct ChooseDocumentTemplateButton: View {
    ///            @State private var showTemplatePicker = false
    ///            @State private var documentCreationContinuation:
    ///                CheckedContinuation<URL?, any Error>?
    ///
    ///            var body: some View {
    ///                NewDocumentButton(contentType: .text) {
    ///                    try await withCheckedThrowingContinuation { continuation in
    ///                        documentCreationContinuation = continuation
    ///                        showTemplatePicker = true
    ///                    }
    ///                }
    ///                .fullScreenCover(isPresented: $showTemplatePicker) {
    ///                    TemplatePicker($documentCreationContinuation)
    ///                }
    ///            }
    ///        }
    ///
    ///        struct TemplatePicker: View {
    ///            @Binding var documentCreationContinuation:
    ///                CheckedContinuation<URL?, any Error>?
    ///
    ///            ...
    ///
    ///            func present(document: URL) {
    ///                documentCreationContinuation.resume(returning: document)
    ///                documentCreationContinuation = nil
    ///            }
    ///        }
    ///
    /// - Parameters:
    ///   - label: A label for the button.
    ///   - contentType: A content type of the document to create.
    ///   - prepareDocumentURL: A closure that is called when a user presses the button.
    ///   At this point, you can present a document template picker or another UI that allows
    ///   users to choose a theme, configuration, or a template
    ///   to create a document from.
    ///   Return a prepared document, or throw an error if document creation failed.
    ///   Return `nil` to request creation of an empty document.
    public init(_ label: Text? = nil, contentType: UTType, prepareDocumentURL: @escaping () async throws -> URL? = { nil })

    /// Creates and opens new documents.
    ///
    /// A button that presents a document template picker and creates documents
    /// can be implemented like this:
    ///
    ///        struct ChooseDocumentTemplateButton: View {
    ///            @State private var showTemplatePicker = false
    ///            @State private var documentCreationContinuation:
    ///                CheckedContinuation<URL?, any Error>?
    ///
    ///            var body: some View {
    ///                NewDocumentButton(contentType: .text) {
    ///                    try await withCheckedThrowingContinuation { continuation in
    ///                        documentCreationContinuation = continuation
    ///                        showTemplatePicker = true
    ///                    }
    ///                }
    ///                .fullScreenCover(isPresented: $showTemplatePicker) {
    ///                    TemplatePicker($documentCreationContinuation)
    ///                }
    ///            }
    ///        }
    ///
    ///        struct TemplatePicker: View {
    ///            @Binding var documentCreationContinuation:
    ///                CheckedContinuation<URL?, any Error>?
    ///
    ///            ...
    ///
    ///            func present(document: URL) {
    ///                documentCreationContinuation.resume(returning: document)
    ///                documentCreationContinuation = nil
    ///            }
    ///        }
    ///
    /// - Parameters:
    ///   - label: A title key for the button title.
    ///   - contentType: A content type of the document to create.
    ///   - prepareDocumentURL: A closure that is called when a user presses the button.
    ///   At this point, you can present a document template picker or another UI that allows
    ///   users to choose a theme, configuration, or a template
    ///   to create a document from.
    ///   Return a prepared document, or throw an error if document creation failed.
    ///   Return `nil` to request creation of an empty document.
    public init(_ title: LocalizedStringKey, contentType: UTType, prepareDocumentURL: @escaping () async throws -> URL? = { nil })

    /// Creates and opens new documents.
    ///
    /// A button that presents a document template picker and creates documents
    /// can be implemented like this:
    ///
    ///        struct ChooseDocumentTemplateButton: View {
    ///            @State private var showTemplatePicker = false
    ///            @State private var documentCreationContinuation:
    ///                CheckedContinuation<URL?, any Error>?
    ///
    ///            var body: some View {
    ///                NewDocumentButton(contentType: .text) {
    ///                    try await withCheckedThrowingContinuation { continuation in
    ///                        documentCreationContinuation = continuation
    ///                        showTemplatePicker = true
    ///                    }
    ///                }
    ///                .fullScreenCover(isPresented: $showTemplatePicker) {
    ///                    TemplatePicker($documentCreationContinuation)
    ///                }
    ///            }
    ///        }
    ///
    ///        struct TemplatePicker: View {
    ///            @Binding var documentCreationContinuation:
    ///                CheckedContinuation<URL?, any Error>?
    ///
    ///            ...
    ///
    ///            func present(document: URL) {
    ///                documentCreationContinuation.resume(returning: document)
    ///                documentCreationContinuation = nil
    ///            }
    ///        }
    ///
    /// - Parameters:
    ///   - label: A title key for the button title.
    ///   - contentType: A content type of the document to create.
    ///   - prepareDocumentURL: A closure that is called when a user presses the button.
    ///   At this point, you can present a document template picker or another UI that allows
    ///   users to choose a theme, configuration, or a template
    ///   to create a document from.
    ///   Return a prepared document, or throw an error if document creation failed.
    ///   Return `nil` to request creation of an empty document.
    public init(_ title: some StringProtocol, contentType: UTType, prepareDocumentURL: @escaping () async throws -> URL? = { nil })
}

/// A table row modifier that adds the ability to insert data in some base
/// row content.
@available(iOS 16.0, macOS 12.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@MainActor @preconcurrency public struct OnInsertTableRowModifier {

    @MainActor @preconcurrency public var body: some _TableRowContentModifier { get }

    @available(iOS 16.0, macOS 12.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias Body = some _TableRowContentModifier
}

/// An action that presents a window.
///
/// Use the ``EnvironmentValues/openWindow`` environment value to get the
/// instance of this structure for a given ``Environment``. Then call the
/// instance to open a window. You call the instance directly because it
/// defines a ``OpenWindowAction/callAsFunction(id:)`` method that Swift calls
/// when you call the instance.
///
/// For example, you can define a button that opens a new mail viewer
/// window:
///
///     @main
///     struct Mail: App {
///         var body: some Scene {
///             WindowGroup(id: "mail-viewer") {
///                 MailViewer()
///             }
///         }
///     }
///
///     struct NewViewerButton: View {
///         @Environment(\.openWindow) private var openWindow
///
///         var body: some View {
///             Button("Open new mail viewer") {
///                 openWindow(id: "mail-viewer")
///             }
///         }
///     }
///
/// You indicate which scene to open by providing one of the following:
///  * A string identifier that you pass through the `id` parameter,
///    as in the above example.
///  * A `value` parameter that has a type that matches the type that
///    you specify in the scene's initializer.
///  * Both an identifier and a value. This enables you to define
///    multiple window groups that take input values of the same type, like a
///    <doc://com.apple.documentation/documentation/Foundation/UUID>.
///
/// Use the first option to target either a ``WindowGroup`` or a
/// ``Window`` scene in your app that has a matching identifier. For a
/// `WindowGroup`, the system creates a new window for the group. If
/// the window group presents data, the system provides the default value
/// or `nil` to the window's root view. If the targeted scene is a
/// `Window`, the system orders it to the front.
///
/// Use the other two options to target a `WindowGroup` and provide
/// a value to present. If the interface already has a window from
/// the group that's presenting the specified value, the system brings the
/// window to the front. Otherwise, the system creates a new window and
/// passes a binding to the specified value.
@available(iOS 16.0, macOS 13.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@MainActor @preconcurrency public struct OpenWindowAction {

    /// Opens a window defined by a window group that presents the type of
    /// the specified value.
    ///
    /// Don't call this method directly. SwiftUI calls it when you
    /// call the ``EnvironmentValues/openWindow`` action with a value:
    ///
    ///     openWindow(value: message.id)
    ///
    /// For information about how Swift uses the `callAsFunction()` method to
    /// simplify call site syntax, see
    /// [Methods with Special Names](https://docs.swift.org/swift-book/ReferenceManual/Declarations.html#ID622)
    /// in *The Swift Programming Language*.
    ///
    /// - Parameter value: The value to present.
    @MainActor @preconcurrency public func callAsFunction<D>(value: D) where D : Decodable, D : Encodable, D : Hashable

    /// Opens a window that's associated with the specified identifier.
    ///
    /// Don't call this method directly. SwiftUI calls it when you
    /// call the ``EnvironmentValues/openWindow`` action with an identifier:
    ///
    ///     openWindow(id: "message")
    ///
    /// For information about how Swift uses the `callAsFunction()` method to
    /// simplify call site syntax, see
    /// [Methods with Special Names](https://docs.swift.org/swift-book/ReferenceManual/Declarations.html#ID622)
    /// in *The Swift Programming Language*.
    ///
    /// - Parameter id: The identifier of the scene to present.
    @MainActor @preconcurrency public func callAsFunction(id: String)

    /// Opens a window defined by the window group that presents the specified
    /// value type and that's associated with the specified identifier.
    ///
    /// Don't call this method directly. SwiftUI calls it when you
    /// call the ``EnvironmentValues/openWindow`` action with an identifier
    /// and a value:
    ///
    ///     openWindow(id: "message", value: message.id)
    ///
    /// For information about how Swift uses the `callAsFunction()` method to
    /// simplify call site syntax, see
    /// [Methods with Special Names](https://docs.swift.org/swift-book/ReferenceManual/Declarations.html#ID622)
    /// in *The Swift Programming Language*.
    ///
    /// - Parameters:
    ///   - id: The identifier of the scene to present.
    ///   - value: The value to present.
    @MainActor @preconcurrency public func callAsFunction<D>(id: String, value: D) where D : Decodable, D : Encodable, D : Hashable
}

@available(iOS 16.0, macOS 13.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension OpenWindowAction : Sendable {
}

/// A structure that computes views and disclosure groups on demand from an
/// underlying collection of tree-structured, identified data.
///
/// Use an outline group when you need a view that can represent a hierarchy
/// of data by using disclosure views. This allows the user to navigate the
/// tree structure by using the disclosure views to expand and collapse
/// branches.
///
/// In the following example, a tree structure of `FileItem` data offers a
/// simplified view of a file system. Passing the root of this tree and the
/// key path of its children allows you to quickly create a visual
/// representation of the file system.
///
///     struct FileItem: Hashable, Identifiable, CustomStringConvertible {
///         var id: Self { self }
///         var name: String
///         var children: [FileItem]? = nil
///         var description: String {
///             switch children {
///             case nil:
///                 return " \(name)"
///             case .some(let children):
///                 return children.isEmpty ? " \(name)" : " \(name)"
///             }
///         }
///     }
///
///     let data =
///       FileItem(name: "users", children:
///         [FileItem(name: "user1234", children:
///           [FileItem(name: "Photos", children:
///             [FileItem(name: "photo001.jpg"),
///              FileItem(name: "photo002.jpg")]),
///            FileItem(name: "Movies", children:
///              [FileItem(name: "movie001.mp4")]),
///               FileItem(name: "Documents", children: [])
///           ]),
///          FileItem(name: "newuser", children:
///            [FileItem(name: "Documents", children: [])
///            ])
///         ])
///
///     OutlineGroup(data, children: \.children) { item in
///         Text("\(item.description)")
///     }
///
/// ### Type parameters
///
/// Five generic type constraints define a specific `OutlineGroup` instance:
///
/// - `Data`: The type of a collection containing the children of an element in
///   the tree-shaped data.
/// - `ID`: The type of the identifier for an element.
/// - `Parent`: The type of the visual representation of an element whose
///   children property is non-`nil`
/// - `Leaf`: The type of the visual representation of an element whose
///   children property is `nil`.
/// - `Subgroup`: A type of a view that groups a parent view and a view
///   representing its children, typically with some mechanism for showing and
///   hiding the children
@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct OutlineGroup<Data, ID, Parent, Leaf, Subgroup> where Data : RandomAccessCollection, ID : Hashable {
}

@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension OutlineGroup where ID == Data.Element.ID, Parent : View, Parent == Leaf, Subgroup == DisclosureGroup<Parent, OutlineSubgroupChildren>, Data.Element : Identifiable {

    /// Creates an outline group from a root data element and a key path to
    /// its children.
    ///
    /// This initializer creates an instance that uniquely identifies views
    /// across updates based on the identity of the underlying data element.
    ///
    /// All generated disclosure groups begin in the collapsed state.
    ///
    /// Make sure that the identifier of a data element only changes if you
    /// mean to replace that element with a new element, one with a new
    /// identity. If the ID of an element changes, then the content view
    /// generated from that element will lose any current state and animations.
    ///
    /// - Parameters:
    ///   - root: The root of a collection of tree-structured, identified
    ///     data.
    ///   - children: A key path to a property whose non-`nil` value gives the
    ///     children of a data element. A non-`nil` but empty value denotes an
    ///     element capable of having children that's currently childless, such
    ///     as an empty directory in a file system. On the other hand, if the
    ///     property at the key path is `nil`, then the outline group treats the
    ///     data element as a leaf in the tree, like a regular file in a file
    ///     system.
    ///   - content: A view builder that produces a content view based on a
    ///     data element.
    public init<DataElement>(_ root: DataElement, children: KeyPath<DataElement, Data?>, @ViewBuilder content: @escaping (DataElement) -> Leaf) where ID == DataElement.ID, DataElement : Identifiable, DataElement == Data.Element

    /// Creates an outline group from a collection of root data elements and
    /// a key path to its children.
    ///
    /// This initializer creates an instance that uniquely identifies views
    /// across updates based on the identity of the underlying data element.
    ///
    /// All generated disclosure groups begin in the collapsed state.
    ///
    /// Make sure that the identifier of a data element only changes if you
    /// mean to replace that element with a new element, one with a new
    /// identity. If the ID of an element changes, then the content view
    /// generated from that element will lose any current state and animations.
    ///
    /// - Parameters:
    ///   - data: A collection of tree-structured, identified data.
    ///   - children: A key path to a property whose non-`nil` value gives the
    ///     children of `data`. A non-`nil` but empty value denotes an element
    ///     capable of having children that's currently childless, such as an
    ///     empty directory in a file system. On the other hand, if the property
    ///     at the key path is `nil`, then the outline group treats `data` as a
    ///     leaf in the tree, like a regular file in a file system.
    ///   - content: A view builder that produces a content view based on an
    ///     element in `data`.
    public init<DataElement>(_ data: Data, children: KeyPath<DataElement, Data?>, @ViewBuilder content: @escaping (DataElement) -> Leaf) where ID == DataElement.ID, DataElement : Identifiable, DataElement == Data.Element
}

@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension OutlineGroup where Parent : View, Parent == Leaf, Subgroup == DisclosureGroup<Parent, OutlineSubgroupChildren> {

    /// Creates an outline group from a root data element, the key path to its
    /// identifier, and a key path to its children.
    ///
    /// This initializer creates an instance that uniquely identifies views
    /// across updates based on the identity of the underlying data element.
    ///
    /// All generated disclosure groups begin in the collapsed state.
    ///
    /// Make sure that the identifier of a data element only changes if you
    /// mean to replace that element with a new element, one with a new
    /// identity. If the ID of an element changes, then the content view
    /// generated from that element will lose any current state and animations.
    ///
    /// - Parameters:
    ///   - root: The root of a collection of tree-structured, identified
    ///     data.
    ///   - id: The key path to a data element's identifier.
    ///   - children: A key path to a property whose non-`nil` value gives the
    ///     children of a data element. A non-`nil` but empty value denotes an
    ///     element capable of having children that's currently childless, such
    ///     as an empty directory in a file system. On the other hand, if the
    ///     property at the key path is `nil`, then the outline group treats the
    ///     data element as a leaf in the tree, like a regular file in a file
    ///     system.
    ///   - content: A view builder that produces a content view based on a
    ///     data element.
    public init<DataElement>(_ root: DataElement, id: KeyPath<DataElement, ID>, children: KeyPath<DataElement, Data?>, @ViewBuilder content: @escaping (DataElement) -> Leaf) where DataElement == Data.Element

    /// Creates an outline group from a collection of root data elements, the
    /// key path to a data element's identifier, and a key path to its children.
    ///
    /// This initializer creates an instance that uniquely identifies views
    /// across updates based on the identity of the underlying data element.
    ///
    /// All generated disclosure groups begin in the collapsed state.
    ///
    /// Make sure that the identifier of a data element only changes if you
    /// mean to replace that element with a new element, one with a new
    /// identity. If the ID of an element changes, then the content view
    /// generated from that element will lose any current state and animations.
    ///
    /// - Parameters:
    ///   - data: A collection of tree-structured, identified data.
    ///   - id: The key path to a data element's identifier.
    ///   - children: A key path to a property whose non-`nil` value gives the
    ///     children of `data`. A non-`nil` but empty value denotes an element
    ///     capable of having children that's currently childless, such as an
    ///     empty directory in a file system. On the other hand, if the property
    ///     at the key path is `nil`, then the outline group treats `data` as a
    ///     leaf in the tree, like a regular file in a file system.
    ///   - content: A view builder that produces a content view based on an
    ///     element in `data`.
    public init<DataElement>(_ data: Data, id: KeyPath<DataElement, ID>, children: KeyPath<DataElement, Data?>, @ViewBuilder content: @escaping (DataElement) -> Leaf) where DataElement == Data.Element
}

@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension OutlineGroup : View where Parent : View, Leaf : View, Subgroup : View {

    /// The content and behavior of the view.
    ///
    /// When you implement a custom view, you must implement a computed
    /// `body` property to provide the content for your view. Return a view
    /// that's composed of built-in views that SwiftUI provides, plus other
    /// composite views that you've already defined:
    ///
    ///     struct MyView: View {
    ///         var body: some View {
    ///             Text("Hello, World!")
    ///         }
    ///     }
    ///
    /// For more information about composing views and a view hierarchy,
    /// see <doc:Declaring-a-Custom-View>.
    @MainActor @preconcurrency public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    @available(iOS 14.0, macOS 11.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias Body = some View
}

@available(iOS 15.0, macOS 12.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension OutlineGroup where ID == Data.Element.ID, Parent : View, Parent == Leaf, Subgroup == DisclosureGroup<Parent, OutlineSubgroupChildren>, Data.Element : Identifiable {

    /// Creates an outline group from a binding to a root data element and a key
    /// path to its children.
    ///
    /// This initializer creates an instance that uniquely identifies views
    /// across updates based on the identity of the underlying data element.
    ///
    /// All generated disclosure groups begin in the collapsed state.
    ///
    /// Make sure that the identifier of a data element only changes if you
    /// mean to replace that element with a new element, one with a new
    /// identity. If the ID of an element changes, then the content view
    /// generated from that element will lose any current state and animations.
    ///
    /// - Parameters:
    ///   - root: The root of a collection of tree-structured, identified
    ///     data.
    ///   - children: A key path to a property whose non-`nil` value gives the
    ///     children of a data element. A non-`nil` but empty value denotes an
    ///     element capable of having children that's currently childless, such
    ///     as an empty directory in a file system. On the other hand, if the
    ///     property at the key path is `nil`, then the outline group treats the
    ///     data element as a leaf in the tree, like a regular file in a file
    ///     system.
    ///   - content: A view builder that produces a content view based on a
    ///     data element.
    public init<C, E>(_ root: Binding<E>, children: WritableKeyPath<E, C?>, @ViewBuilder content: @escaping (Binding<E>) -> Leaf) where Data == Binding<C>, ID == E.ID, C : MutableCollection, C : RandomAccessCollection, E : Identifiable, E == C.Element

    /// Creates an outline group from a binding to a collection of root data
    /// elements and a key path to its children.
    ///
    /// This initializer creates an instance that uniquely identifies views
    /// across updates based on the identity of the underlying data element.
    ///
    /// All generated disclosure groups begin in the collapsed state.
    ///
    /// Make sure that the identifier of a data element only changes if you
    /// mean to replace that element with a new element, one with a new
    /// identity. If the ID of an element changes, then the content view
    /// generated from that element will lose any current state and animations.
    ///
    /// - Parameters:
    ///   - data: A collection of tree-structured, identified data.
    ///   - children: A key path to a property whose non-`nil` value gives the
    ///     children of `data`. A non-`nil` but empty value denotes an element
    ///     capable of having children that's currently childless, such as an
    ///     empty directory in a file system. On the other hand, if the property
    ///     at the key path is `nil`, then the outline group treats `data` as a
    ///     leaf in the tree, like a regular file in a file system.
    ///   - content: A view builder that produces a content view based on an
    ///     element in `data`.
    public init<C, E>(_ data: Binding<C>, children: WritableKeyPath<E, C?>, @ViewBuilder content: @escaping (Binding<E>) -> Leaf) where Data == Binding<C>, ID == E.ID, C : MutableCollection, C : RandomAccessCollection, E : Identifiable, E == C.Element
}

@available(iOS 15.0, macOS 12.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension OutlineGroup where Parent : View, Parent == Leaf, Subgroup == DisclosureGroup<Parent, OutlineSubgroupChildren> {

    /// Creates an outline group from a binding to a root data element, the key
    /// path to its identifier, and a key path to its children.
    ///
    /// This initializer creates an instance that uniquely identifies views
    /// across updates based on the identity of the underlying data element.
    ///
    /// All generated disclosure groups begin in the collapsed state.
    ///
    /// Make sure that the identifier of a data element only changes if you
    /// mean to replace that element with a new element, one with a new
    /// identity. If the ID of an element changes, then the content view
    /// generated from that element will lose any current state and animations.
    ///
    /// - Parameters:
    ///   - root: The root of a collection of tree-structured, identified
    ///     data.
    ///   - id: The key path to a data element's identifier.
    ///   - children: A key path to a property whose non-`nil` value gives the
    ///     children of a data element. A non-`nil` but empty value denotes an
    ///     element capable of having children that's currently childless, such
    ///     as an empty directory in a file system. On the other hand, if the
    ///     property at the key path is `nil`, then the outline group treats the
    ///     data element as a leaf in the tree, like a regular file in a file
    ///     system.
    ///   - content: A view builder that produces a content view based on a
    ///     data element.
    public init<C, E>(_ root: Binding<E>, id: KeyPath<E, ID>, children: WritableKeyPath<E, C?>, @ViewBuilder content: @escaping (Binding<E>) -> Leaf) where Data == Binding<C>, C : MutableCollection, C : RandomAccessCollection, E == C.Element

    /// Creates an outline group from a binding to a collection of root data
    /// elements, the key path to a data element's identifier, and a key path to
    /// its children.
    ///
    /// This initializer creates an instance that uniquely identifies views
    /// across updates based on the identity of the underlying data element.
    ///
    /// All generated disclosure groups begin in the collapsed state.
    ///
    /// Make sure that the identifier of a data element only changes if you
    /// mean to replace that element with a new element, one with a new
    /// identity. If the ID of an element changes, then the content view
    /// generated from that element will lose any current state and animations.
    ///
    /// - Parameters:
    ///   - data: A collection of tree-structured, identified data.
    ///   - id: The key path to a data element's identifier.
    ///   - children: A key path to a property whose non-`nil` value gives the
    ///     children of `data`. A non-`nil` but empty value denotes an element
    ///     capable of having children that's currently childless, such as an
    ///     empty directory in a file system. On the other hand, if the property
    ///     at the key path is `nil`, then the outline group treats `data` as a
    ///     leaf in the tree, like a regular file in a file system.
    ///   - content: A view builder that produces a content view based on an
    ///     element in `data`.
    public init<C, E>(_ data: Binding<C>, id: KeyPath<E, ID>, children: WritableKeyPath<E, C?>, @ViewBuilder content: @escaping (Binding<E>) -> Leaf) where Data == Binding<C>, C : MutableCollection, C : RandomAccessCollection, E == C.Element
}

@available(iOS 17.0, macOS 14.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension OutlineGroup where ID == Data.Element.ID, Parent : TableRowContent, Parent == Leaf, Leaf == Subgroup, Data.Element == Parent.TableRowValue {

    /// Creates an outline group from a root data element and a key path to
    /// its children.
    ///
    /// This initializer provides a default `TableRowBuilder` using `TableRow`
    /// for each data element.
    ///
    /// This initializer creates an instance that uniquely identifies table rows
    /// across updates based on the identity of the underlying data element.
    ///
    /// All generated disclosure groups begin in the collapsed state.
    ///
    /// - Parameters:
    ///   - root: The root of a collection of tree-structured, identified
    ///     data.
    ///   - children: A key path to a property whose non-`nil` value gives the
    ///     children of `data`. A non-`nil` but empty value denotes an element
    ///     capable of having children that's currently childless, such as an
    ///     empty directory in a file system. On the other hand, if the property
    ///     at the key path is `nil`, then the outline group treats `data` as a
    ///     leaf in the tree, like a regular file in a file system.
    public init<DataElement>(_ root: DataElement, children: KeyPath<DataElement, Data?>) where ID == DataElement.ID, Parent == TableRow<DataElement>, Leaf == TableRow<DataElement>, Subgroup == TableRow<DataElement>, DataElement : Identifiable, DataElement == Data.Element

    /// Creates an outline group from a collection of root data elements and
    /// a key path to element's children.
    ///
    /// This initializer provides a default `TableRowBuilder` using `TableRow`
    /// for each data element.
    ///
    /// This initializer creates an instance that uniquely identifies table rows
    /// across updates based on the identity of the underlying data element.
    ///
    /// All generated disclosure groups begin in the collapsed state.
    ///
    /// - Parameters:
    ///   - data: A collection of tree-structured, identified data.
    ///   - children: A key path to a property whose non-`nil` value gives the
    ///     children of `data`. A non-`nil` but empty value denotes an element
    ///     capable of having children that's currently childless, such as an
    ///     empty directory in a file system. On the other hand, if the property
    ///     at the key path is `nil`, then the outline group treats `data` as a
    ///     leaf in the tree, like a regular file in a file system.
    public init<DataElement>(_ data: Data, children: KeyPath<DataElement, Data?>) where ID == DataElement.ID, Parent == TableRow<DataElement>, Leaf == TableRow<DataElement>, Subgroup == TableRow<DataElement>, DataElement : Identifiable, DataElement == Data.Element

    /// Creates an outline group from a root data element and a key path to
    /// its children.
    ///
    /// This initializer exposes `content` as a `TableRowBuilder` to allow
    /// custom table row content for each data element.
    ///
    /// This initializer creates an instance that uniquely identifies table rows
    /// across updates based on the identity of the underlying data element.
    ///
    /// All generated disclosure groups begin in the collapsed state.
    ///
    /// - Parameters:
    ///   - root: The root of a collection of tree-structured, identified
    ///     data.
    ///   - children: A key path to a property whose non-`nil` value gives the
    ///     children of `data`. A non-`nil` but empty value denotes an element
    ///     capable of having children that's currently childless, such as an
    ///     empty directory in a file system. On the other hand, if the property
    ///     at the key path is `nil`, then the outline group treats `data` as a
    ///     leaf in the tree, like a regular file in a file system.
    ///   - content: A table row builder that produces a row based on an
    ///     element in `data`.
    public init<DataElement>(_ root: DataElement, children: KeyPath<DataElement, Data?>, @TableRowBuilder<DataElement> content: @escaping (DataElement) -> Leaf) where ID == DataElement.ID, DataElement == Data.Element

    /// Creates an outline group from a root data element, a key path to the its
    /// identifier, as well as a key path to its children.
    ///
    /// This initializer exposes `content` as a `TableRowBuilder` to allow
    /// custom table row content for each data element.
    ///
    /// This initializer creates an instance that uniquely identifies views
    /// across updates based on the identity of the underlying data element.
    ///
    /// All generated disclosure groups begin in the collapsed state.
    ///
    /// Make sure that the identifier of a data element only changes if you
    /// mean to replace that element with a new element, one with a new
    /// identity. If the ID of an element changes, then the content view
    /// generated from that element will lose any current state and animations.
    ///
    /// - Parameters:
    ///   - root: The root of a collection of tree-structured, identified
    ///     data.
    ///   - id: The key path to a data element's identifier.
    ///   - children: A key path to a property whose non-`nil` value gives the
    ///     children of `data`. A non-`nil` but empty value denotes an element
    ///     capable of having children that's currently childless, such as an
    ///     empty directory in a file system. On the other hand, if the property
    ///     at the key path is `nil`, then the outline group treats `data` as a
    ///     leaf in the tree, like a regular file in a file system.
    ///   - content: A view builder that produces a content view based on an
    ///    element in `data`.
    public init<DataElement>(_ root: DataElement, id: KeyPath<DataElement, ID>, children: KeyPath<DataElement, Data?>, @TableRowBuilder<DataElement> content: @escaping (DataElement) -> Leaf) where ID == DataElement.ID, DataElement == Data.Element

    /// Creates an outline group from a collection of root data elements and
    /// a key path to element's children.
    ///
    /// This initializer exposes `content` as a `TableRowBuilder` to allow
    /// custom table row content for each data element.
    ///
    /// This initializer creates an instance that uniquely identifies table rows
    /// across updates based on the identity of the underlying data element.
    ///
    /// All generated disclosure groups begin in the collapsed state.
    ///
    /// - Parameters:
    ///   - data: A collection of tree-structured, identified data.
    ///   - children: A key path to a property whose non-`nil` value gives the
    ///     children of `data`. A non-`nil` but empty value denotes an element
    ///     capable of having children that's currently childless, such as an
    ///     empty directory in a file system. On the other hand, if the property
    ///     at the key path is `nil`, then the outline group treats `data` as a
    ///     leaf in the tree, like a regular file in a file system.
    ///   - content: A table row builder that produces a row based on an
    ///     element in `data`.
    public init<DataElement>(_ data: Data, children: KeyPath<DataElement, Data?>, @TableRowBuilder<DataElement> content: @escaping (DataElement) -> Leaf) where ID == DataElement.ID, DataElement == Data.Element

    /// Creates an outline group from a collection of root data elements, a key
    /// path to the element's identifier, as well as a key path to element's
    /// children.
    ///
    /// This initializer exposes `content` as a `TableRowBuilder` to allow
    /// custom table row content for each data element.
    ///
    /// This initializer creates an instance that uniquely identifies table rows
    /// across updates based on the identity of the underlying data element.
    ///
    /// All generated disclosure groups begin in the collapsed state.
    ///
    /// - Parameters:
    ///   - data: A collection of tree-structured, identified data.
    ///   - id: The key path to a data element's identifier.
    ///   - children: A key path to a property whose non-`nil` value gives the
    ///     children of `data`. A non-`nil` but empty value denotes an element
    ///     capable of having children that's currently childless, such as an
    ///     empty directory in a file system. On the other hand, if the property
    ///     at the key path is `nil`, then the outline group treats `data` as a
    ///     leaf in the tree, like a regular file in a file system.
    ///   - content: A table row builder that produces a row based on an
    ///     element in `data`.
    public init<DataElement>(_ data: Data, id: KeyPath<DataElement, ID>, children: KeyPath<DataElement, Data?>, @TableRowBuilder<DataElement> content: @escaping (DataElement) -> Leaf) where ID == DataElement.ID, DataElement == Data.Element
}

@available(iOS 17.0, macOS 14.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension OutlineGroup : TableRowContent where ID == Data.Element.ID, Parent : TableRowContent, Parent == Leaf, Leaf == Subgroup, Data.Element == Parent.TableRowValue {

    /// The type of value represented by this table row content.
    public typealias TableRowValue = Leaf.TableRowValue

    /// The composition of content that comprise the table row content.
    @MainActor @preconcurrency public var tableRowBody: some TableRowContent { get }

    /// The type of content representing the body of this table row content.
    @available(iOS 17.0, macOS 14.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias TableRowBody = some TableRowContent
}

/// A type-erased view representing the children in an outline subgroup.
///
/// ``OutlineGroup`` uses this type as a generic constraint for the `Content`
/// of the ``DisclosureGroup`` instances it creates.
@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct OutlineSubgroupChildren : View {

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    @available(iOS 14.0, macOS 11.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias Body = Never
}

/// An index view style that places a page index view over its content.
///
/// You can also use ``IndexViewStyle/page`` to construct this style.
@available(iOS 14.0, tvOS 14.0, watchOS 8.0, *)
@available(macOS, unavailable)
public struct PageIndexViewStyle : IndexViewStyle {

    /// The background style for the page index view.
    public struct BackgroundDisplayMode : Sendable {

        /// Background will use the default for the platform.
        public static let automatic: PageIndexViewStyle.BackgroundDisplayMode

        /// Background is only shown while the index view is interacted with.
        @available(watchOS, unavailable)
        public static let interactive: PageIndexViewStyle.BackgroundDisplayMode

        /// Background is always displayed behind the page index view.
        @available(watchOS, unavailable)
        public static let always: PageIndexViewStyle.BackgroundDisplayMode

        /// Background is never displayed behind the page index view.
        public static let never: PageIndexViewStyle.BackgroundDisplayMode
    }

    /// Creates a page index view style.
    ///
    /// - Parameter backgroundDisplayMode: The display mode of the background of any
    /// page index views receiving this style
    public init(backgroundDisplayMode: PageIndexViewStyle.BackgroundDisplayMode = .automatic)
}

/// The size is roughly the size of a page of paper, appropriate for
/// informational or compositional content.
///
/// On iOS, `.page` sizing enforces a platform-defined floor for the vertical
/// and horizontal dimensions. On macOS, no floor is enforced, however a maximum
/// proposed height is derived from the presenter height. To achieve
/// presentations outside of these bounds, see ``PresentationSizing.fitted``
/// or implement your own custom ``PresentationSizing``.
///
/// - Seealso: ``PresentationSizing/page``
@available(iOS 18.0, macOS 15.0, tvOS 18.0, visionOS 2.0, watchOS 11.0, *)
public struct PagePresentationSizing : PresentationSizing, Sendable {

    public func proposedSize(for root: PresentationSizingRoot, context: PresentationSizingContext) -> ProposedViewSize
}

/// A `TabViewStyle` that displays a paged scrolling `TabView`.
///
/// Use ``TabViewStyle/page`` or
/// ``TabViewStyle/page(indexDisplayMode:)`` to construct this style.
///
/// To apply this style to a tab view, or to a view that contains tab views, use
/// the ``View/tabViewStyle(_:)`` modifier.
@available(iOS 14.0, tvOS 14.0, watchOS 7.0, *)
@available(macOS, unavailable)
public struct PageTabViewStyle : TabViewStyle {

    /// A style for displaying the page index view
    public struct IndexDisplayMode : Sendable {

        /// Displays an index view when there are more than one page
        public static let automatic: PageTabViewStyle.IndexDisplayMode

        /// Always display an index view regardless of page count
        @available(watchOS 8.0, *)
        public static let always: PageTabViewStyle.IndexDisplayMode

        /// Never display an index view
        @available(watchOS 8.0, *)
        public static let never: PageTabViewStyle.IndexDisplayMode
    }

    /// Creates a new `PageTabViewStyle` with an index display mode
    public init(indexDisplayMode: PageTabViewStyle.IndexDisplayMode = .automatic)
}

/// The scroll behavior that aligns scroll targets to container-based geometry.
///
/// In the following example, every view in the lazy stack is flexible
/// in both directions and the scroll view settles to container-aligned
/// boundaries.
///
///     ScrollView {
///         LazyVStack(spacing: 0.0) {
///             ForEach(items) { item in
///                 FullScreenItem(item)
///             }
///         }
///     }
///     .scrollTargetBehavior(.paging)
///
@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
public struct PagingScrollTargetBehavior : ScrollTargetBehavior {

    /// Creates a paging scroll behavior.
    public init()

    /// Updates the proposed target that a scrollable view should scroll to.
    ///
    /// The system calls this method in two main cases:
    /// - When a scroll gesture ends, it calculates where it would naturally
    ///   scroll to using its deceleration rate. The system
    ///   provides this calculated value as the target of this method.
    /// - When a scrollable view's size changes, it calculates where it should
    ///   be scrolled given the new size and provides this calculates value
    ///   as the target of this method.
    ///
    /// You can implement this method to override the calculated target
    /// which will have the scrollable view scroll to a different position
    /// than it would otherwise.
    public func updateTarget(_ target: inout ScrollTarget, context: PagingScrollTargetBehavior.TargetContext)
}

/// A control group style that presents its content as a palette.
///
/// Use ``ControlGroupStyle/palette`` to construct this style.
@available(iOS 17.0, macOS 14.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct PaletteControlGroupStyle : ControlGroupStyle {

    /// Creates a palette control group style.
    public init()

    /// Creates a view representing the body of a control group.
    ///
    /// - Parameter configuration: The properties of the control group instance
    ///   being created.
    ///
    /// This method will be called for each instance of ``ControlGroup`` created
    /// within a view hierarchy where this style is the current
    /// `ControlGroupStyle`.
    @MainActor @preconcurrency public func makeBody(configuration: PaletteControlGroupStyle.Configuration) -> some View


    /// A view representing the body of a control group.
    @available(iOS 17.0, macOS 14.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias Body = some View
}

/// A picker style that presents the options as a row of compact elements.
///
/// You can also use ``PickerStyle/palette`` to construct this style.
@available(iOS 17.0, macOS 14.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct PalettePickerStyle : PickerStyle {

    /// Creates a palette picker style.
    public init()
}

/// The selection effect to apply to a palette item.
///
/// You can configure the selection effect of a palette item by using the
/// ``View/paletteSelectionEffect(_:)`` view modifier.
@available(iOS 17.0, macOS 14.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct PaletteSelectionEffect : Sendable, Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: PaletteSelectionEffect, rhs: PaletteSelectionEffect) -> Bool

    /// Applies the system's default effect when selected.
    ///
    /// When using un-tinted SF Symbols or template images, the current tint
    /// color is applied to the selected items' image.
    /// If the provided SF Symbols have custom tints, a stroke is drawn around selected items.
    public static let automatic: PaletteSelectionEffect

    /// Applies the specified symbol variant when selected.
    ///
    /// - Note: This effect only applies to SF Symbols.
    public static func symbolVariant(_ variant: SymbolVariants) -> PaletteSelectionEffect

    /// Does not apply any system effect when selected.
    ///
    /// - Note: Make sure to manually implement a way to indicate selection when
    /// using this case. For example, you could dynamically resolve the item's
    /// image based on the selection state.
    public static let custom: PaletteSelectionEffect
}

/// A system button that reads items from the pasteboard and delivers it to a
/// closure.
///
/// Use a paste button when you want to provide a button for pasting items from
/// the system pasteboard into your app. The system provides a button
/// appearance and label appropriate to the current environment. However, you
/// can use view modifiers like ``View/buttonBorderShape(_:)``,
/// ``View/labelStyle(_:)``, and ``View/tint(_:)`` to customize the button
/// in some contexts.
///
/// You declare what type of items your app will accept; use a type that
/// conforms to the
/// <doc://com.apple.documentation/documentation/coretransferable/transferable>
/// protocol. When the user taps or clicks the button, your closure receives the
/// pasteboard items in the specified type.
///
/// In the following example, a paste button declares that it accepts a string.
/// When the user taps or clicks the button, the sample's closure receives an
/// array of strings and sets the first as the value of `pastedText`, which
/// updates a nearby ``Text`` view.
///
///     @State private var pastedText: String = ""
///
///     var body: some View {
///         HStack {
///             PasteButton(payloadType: String.self) { strings in
///                 pastedText = strings[0]
///             }
///             Divider()
///             Text(pastedText)
///             Spacer()
///         }
///     }
///
/// ![macOS window titled PasteButton Demo showing (from left to right) a button
/// labeled Paste, a vertical divider, and some pasted
/// text.](SwiftUI-PasteButton-pastedText.png)
///
/// A paste button automatically validates and invalidates based on changes to
/// the pasteboard on iOS, but not on macOS.
@available(iOS 16.0, macOS 10.15, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@MainActor @preconcurrency public struct PasteButton : View {

    /// Creates a Paste button that accepts specific types of data from the
    /// pasteboard.
    ///
    /// Set the contents of `supportedContentTypes` in order of your app's
    /// preference for its supported types. The Paste button takes the
    /// most-preferred type that the pasteboard source supports and delivers
    /// this to the `payloadAction` closure.
    ///
    /// - Parameters:
    ///   - supportedContentTypes: The exact uniform type identifiers supported
    ///     by the button. If the pasteboard doesn't contain any of the
    ///     supported types, the button becomes disabled.
    ///   - payloadAction: The handler to call when the user clicks the Paste
    ///     button and the pasteboard has items that conform to
    ///     `supportedContentTypes`. This closure receives an array of
    ///     item providers that you use to inspect and load the pasteboard data.
    @available(iOS 16.0, macOS 11.0, *)
    @MainActor @preconcurrency public init(supportedContentTypes: [UTType], payloadAction: @escaping ([NSItemProvider]) -> Void)

    /// Creates an instance that accepts values of the specified type.
    /// - Parameters:
    ///   - type: The type that you want to paste via the `PasteButton`.
    ///   - onPaste: The handler to call on trigger of the button with at least
    ///     one item of the specified `Transferable` type from the pasteboard.
    @available(iOS 16.0, macOS 13.0, *)
    @MainActor @preconcurrency public init<T>(payloadType: T.Type, onPaste: @escaping ([T]) -> Void) where T : Transferable

    /// The content and behavior of the view.
    ///
    /// When you implement a custom view, you must implement a computed
    /// `body` property to provide the content for your view. Return a view
    /// that's composed of built-in views that SwiftUI provides, plus other
    /// composite views that you've already defined:
    ///
    ///     struct MyView: View {
    ///         var body: some View {
    ///             Text("Hello, World!")
    ///         }
    ///     }
    ///
    /// For more information about composing views and a view hierarchy,
    /// see <doc:Declaring-a-Custom-View>.
    @MainActor @preconcurrency public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    @available(iOS 16.0, macOS 10.15, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias Body = some View
}

/// Describes the value of an Apple Pencil double-tap gesture.
@available(iOS 17.5, macOS 14.5, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
@available(visionOS, unavailable)
public struct PencilDoubleTapGestureValue : Hashable {

    /// The location and distance of an Apple Pencil hovering in the area above
    /// the views bounds when the double-tap gesture occurred.
    ///
    /// If the Apple Pencil was hovering in the area above the views bounds
    /// when the user double-tapped their Apple Pencil, this property describes
    /// its pose relative to that view.
    ///
    /// Conversely, if the Apple Pencil wasnt hovering in the area above the
    /// views bounds or if the device cant detect a hovering Apple Pencil,
    /// this property is `nil`.
    public let hoverPose: PencilHoverPose?

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: PencilDoubleTapGestureValue, b: PencilDoubleTapGestureValue) -> Bool

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

/// A value describing the location and distance of an Apple Pencil hovering in
/// the area above a views bounds.
@available(iOS 17.5, macOS 14.5, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
@available(visionOS, unavailable)
public struct PencilHoverPose : Hashable {

    /// The location of an Apple Pencil hovering in the area above the views
    /// bounds, expressed as a point in that views coordinate space.
    ///
    /// Use the ``anchor`` property if you require a normalized anchor point for
    /// use with a presentation modifier instead.
    public let location: CGPoint

    /// The location of an Apple Pencil hovering in the area above the views
    /// bounds, expressed as a normalized anchor point relative to that view.
    ///
    /// You can pass this anchor point directly to a presentation modifier like
    /// ``View/popover(isPresented:attachmentAnchor:arrowEdge:content:)`` or use
    /// the ``location`` property if you require an absolute point instead.
    public let anchor: UnitPoint

    /// The normalized distance between the screen and a hovering Apple Pencil.
    ///
    /// This value is `1` at the maximum distance from the screen and approaches
    /// `0` as the Apple Pencil gets closer to the screen.
    public let zDistance: CGFloat

    /// A value that represents the altitude angle of the hovering Apple Pencil.
    ///
    /// This value is `.zero` when the Apple Pencil is parallel to the views
    /// surface, and is 90 degrees (/2 radians) when the Apple Pencil is
    /// perpendicular to the views surface.
    public let altitude: Angle

    /// A value that represents the azimuth angle of a hovering Apple Pencil.
    ///
    /// This value is `.zero` when the Apple Pencil points along the views
    /// positive x-axis.
    public let azimuth: Angle

    /// A value that represents the barrel roll angle of the hovering Apple
    /// Pencil.
    ///
    /// This value is `.zero` when the user starts using their Apple Pencil, and
    /// changes relative to that initial angle as the user rolls the Apple
    /// Pencil alongside its barrel. If the Apple Pencil doesn't support
    /// detecting its barrel roll angle, this property is always `.zero`.
    public let roll: Angle

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: PencilHoverPose, b: PencilHoverPose) -> Bool

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

/// An action that the user prefers to perform after double-tapping their
/// Apple Pencil.
@available(iOS 17.5, macOS 14.5, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
@available(visionOS, unavailable)
public struct PencilPreferredAction : Hashable {

    /// An action that switches between the current tool and the eraser.
    public static let switchEraser: PencilPreferredAction

    /// An action that switches between the current tool and the last used tool.
    public static let switchPrevious: PencilPreferredAction

    /// An action that toggles the display of the color palette.
    public static let showColorPalette: PencilPreferredAction

    /// An action that toggles the display of the current tools ink attributes.
    public static let showInkAttributes: PencilPreferredAction

    /// An action that toggles the display of the contextual palette, or the
    /// undo/redo panel if contextual palette is not available.
    public static let showContextualPalette: PencilPreferredAction

    /// An action that runs a system shortcut.
    ///
    /// If the user selects this as their preferred action to perform after
    /// double-tapping or squeezing their Apple Pencil, your app will never be
    /// notified when they do. Instead, you should only use this information to
    /// remind the user about their preference in your apps UI.
    public static let runSystemShortcut: PencilPreferredAction

    /// An action that does nothing.
    public static let ignore: PencilPreferredAction

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: PencilPreferredAction, b: PencilPreferredAction) -> Bool

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

/// Describes the phase and value of an Apple Pencil squeeze gesture.
///
/// When you use the ``View/onPencilSqueeze(perform:)`` view modifier, you can
/// handle the Apple Pencil squeeze gestures phase in the `action` closure.
@available(iOS 17.5, macOS 14.5, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
@available(visionOS, unavailable)
@frozen public enum PencilSqueezeGesturePhase : Equatable {

    /// The user started squeezing their Apple Pencil.
    case active(PencilSqueezeGestureValue)

    /// The user successfully completed a squeeze gesture.
    case ended(PencilSqueezeGestureValue)

    /// The user started squeezing their Apple Pencil but failed to successfully
    /// complete the gesture.
    case failed

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: PencilSqueezeGesturePhase, b: PencilSqueezeGesturePhase) -> Bool
}

/// Describes the value of an Apple Pencil squeeze gesture.
@available(iOS 17.5, macOS 14.5, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
@available(visionOS, unavailable)
public struct PencilSqueezeGestureValue : Hashable {

    /// The location and distance of an Apple Pencil hovering in the area above
    /// the views bounds when the squeeze gesture occurred.
    ///
    /// If the Apple Pencil was hovering in the area above the views bounds
    /// when the user squeezed their Apple Pencil, this property describes
    /// its pose relative to that view.
    ///
    /// Conversely, if the Apple Pencil wasnt hovering in the area above the
    /// views bounds or if the device cant detect a hovering Apple Pencil,
    /// this property is `nil`.
    public let hoverPose: PencilHoverPose?

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: PencilSqueezeGestureValue, b: PencilSqueezeGestureValue) -> Bool

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

/// A control for selecting from a set of mutually exclusive values.
///
/// You create a picker by providing a selection binding, a label, and the
/// content for the picker to display. Set the `selection` parameter to a bound
/// property that provides the value to display as the current selection. Set
/// the label to a view that visually describes the purpose of selecting content
/// in the picker, and then provide the content for the picker to display.
///
/// For example, consider an enumeration of ice cream flavors and a ``State``
/// variable to hold the selected flavor:
///
///     enum Flavor: String, CaseIterable, Identifiable {
///         case chocolate, vanilla, strawberry
///         var id: Self { self }
///     }
///
///     @State private var selectedFlavor: Flavor = .chocolate
///
/// You can create a picker to select among the values by providing a label, a
/// binding to the current selection, and a collection of views for the picker's
/// content. Append a tag to each of these content views using the
/// ``View/tag(_:)`` view modifier so that the type of each selection matches
/// the type of the bound state variable:
///
///     List {
///         Picker("Flavor", selection: $selectedFlavor) {
///             Text("Chocolate").tag(Flavor.chocolate)
///             Text("Vanilla").tag(Flavor.vanilla)
///             Text("Strawberry").tag(Flavor.strawberry)
///         }
///     }
///
/// If you provide a string label for the picker, as the example above does,
/// the picker uses it to initialize a ``Text`` view as a
/// label. Alternatively, you can use the ``init(selection:content:label:)``
/// initializer to compose the label from other views. The exact appearance
/// of the picker depends on the context. If you use a picker in a ``List``
/// in iOS, it appears in a row with the label and selected value, and a
/// chevron to indicate that you can tap the row to select a new value:
///
/// ![A screenshot of a list row that has the string Flavor on the left side,
/// and the string Chocolate on the right. The word Chocolate appears in a less
/// prominent color than the word Flavor. A right facing chevron appears to the
/// right of the word Chocolate.](Picker-1-iOS)
///
/// For cases where adding a subtitle to the label is desired, use a view
/// builder that creates multiple `Text` views where the first text represents
/// the title and the second text represents the subtitle:
///
///     List {
///         Picker(selection: $selectedFlavor) {
///             Text("Chocolate").tag(Flavor.chocolate)
///             Text("Vanilla").tag(Flavor.vanilla)
///             Text("Strawberry").tag(Flavor.strawberry)
///         } label: {
///             Text("Flavor")
///             Text("Choose your favorite flavor")
///         }
///     }
///
/// ### Iterating over a pickers options
///
/// To provide selection values for the `Picker` without explicitly listing
/// each option, you can create the picker with a ``ForEach``:
///
///     Picker("Flavor", selection: $selectedFlavor) {
///         ForEach(Flavor.allCases) { flavor in
///             Text(flavor.rawValue.capitalized)
///         }
///     }
///
/// ``ForEach`` automatically assigns a tag to the selection views using
/// each option's `id`. This is possible because `Flavor` conforms to the
/// <doc://com.apple.documentation/documentation/Swift/Identifiable>
/// protocol.
///
/// The example above relies on the fact that `Flavor` defines the type of its
/// `id` parameter to exactly match the selection type. If that's not the case,
/// you need to override the tag. For example, consider a `Topping` type
/// and a suggested topping for each flavor:
///
///     enum Topping: String, CaseIterable, Identifiable {
///         case nuts, cookies, blueberries
///         var id: Self { self }
///     }
///
///     extension Flavor {
///         var suggestedTopping: Topping {
///             switch self {
///             case .chocolate: return .nuts
///             case .vanilla: return .cookies
///             case .strawberry: return .blueberries
///             }
///         }
///     }
///
///     @State private var suggestedTopping: Topping = .nuts
///
/// The following example shows a picker that's bound to a `Topping` type,
/// while the options are all `Flavor` instances. Each option uses the tag
/// modifier to associate the suggested topping with the flavor it displays:
///
///     List {
///         Picker("Flavor", selection: $suggestedTopping) {
///             ForEach(Flavor.allCases) { flavor in
///                 Text(flavor.rawValue.capitalized)
///                     .tag(flavor.suggestedTopping)
///             }
///         }
///         HStack {
///             Text("Suggested Topping")
///             Spacer()
///             Text(suggestedTopping.rawValue.capitalized)
///                 .foregroundStyle(.secondary)
///         }
///     }
///
/// When the user selects chocolate, the picker sets `suggestedTopping`
/// to the value in the associated tag:
///
/// ![A screenshot of two list rows. The first has the string Flavor on the left
/// side, and the string Chocolate on the right. A right facing chevron appears
/// to the right of the word Chocolate. The second row has the string Suggested
/// Topping on the left, and the string Nuts on the right. Both words on the
/// right use a less prominent color than those on the left.](Picker-2-iOS)
///
/// Another example of when the views in a picker's ``ForEach`` need an explicit
/// tag modifier is when you select over the cases of an enumeration that
/// conforms to the
/// <doc://com.apple.documentation/documentation/Swift/Identifiable> protocol
/// by using anything besides `Self` as the `id` parameter type. For example,
/// a string enumeration might use the case's `rawValue` string as the `id`.
/// That identifier type doesn't match the selection type, which is the type
/// of the enumeration itself.
///
/// ### Styling pickers
///
/// You can customize the appearance and interaction of pickers using
/// styles that conform to the ``PickerStyle`` protocol, like
/// ``PickerStyle/segmented`` or ``PickerStyle/menu``. To set a specific style
/// for all picker instances within a view, use the ``View/pickerStyle(_:)``
/// modifier. The following example applies the ``PickerStyle/segmented``
/// style to two pickers that independently select a flavor and a topping:
///
///     VStack {
///         Picker("Flavor", selection: $selectedFlavor) {
///             ForEach(Flavor.allCases) { flavor in
///                 Text(flavor.rawValue.capitalized)
///             }
///         }
///         Picker("Topping", selection: $selectedTopping) {
///             ForEach(Topping.allCases) { topping in
///                 Text(topping.rawValue.capitalized)
///             }
///         }
///     }
///     .pickerStyle(.segmented)
///
/// ![A screenshot of two segmented controls. The first has segments labeled
/// Chocolate, Vanilla, and Strawberry, with the first of these selected.
/// The second control has segments labeled Nuts, Cookies, and Blueberries,
/// with the second of these selected.](Picker-3-iOS)
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public struct Picker<Label, SelectionValue, Content> : View where Label : View, SelectionValue : Hashable, Content : View {

    /// The content and behavior of the view.
    ///
    /// When you implement a custom view, you must implement a computed
    /// `body` property to provide the content for your view. Return a view
    /// that's composed of built-in views that SwiftUI provides, plus other
    /// composite views that you've already defined:
    ///
    ///     struct MyView: View {
    ///         var body: some View {
    ///             Text("Hello, World!")
    ///         }
    ///     }
    ///
    /// For more information about composing views and a view hierarchy,
    /// see <doc:Declaring-a-Custom-View>.
    @MainActor @preconcurrency public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    public typealias Body = some View
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Picker {

    /// Creates a picker that displays a custom label.
    ///
    /// If the wrapped values of the collection passed to `sources` are not all
    /// the same, some styles render the selection in a mixed state. The
    /// specific presentation depends on the style.  For example, a Picker
    /// with a menu style uses dashes instead of checkmarks to indicate the
    /// selected values.
    ///
    /// In the following example, a picker in a document inspector controls the
    /// thickness of borders for the currently-selected shapes, which can be of
    /// any number.
    ///
    ///     enum Thickness: String, CaseIterable, Identifiable {
    ///         case thin
    ///         case regular
    ///         case thick
    ///
    ///         var id: String { rawValue }
    ///     }
    ///
    ///     struct Border {
    ///         var color: Color
    ///         var thickness: Thickness
    ///     }
    ///
    ///     @State private var selectedObjectBorders = [
    ///         Border(color: .black, thickness: .thin),
    ///         Border(color: .red, thickness: .thick)
    ///     ]
    ///
    ///     Picker(
    ///         sources: $selectedObjectBorders,
    ///         selection: \.thickness
    ///     ) {
    ///         ForEach(Thickness.allCases) { thickness in
    ///             Text(thickness.rawValue)
    ///         }
    ///     } label: {
    ///         Text("Border Thickness")
    ///     }
    ///
    /// - Parameters:
    ///     - sources: A collection of values used as the source for displaying
    ///       the Picker's selection.
    ///     - selection: The key path of the values that determines the
    ///       currently-selected options. When a user selects an option from the
    ///       picker, the values at the key path of all items in the `sources`
    ///       collection are updated with the selected option.
    ///     - content: A view that contains the set of options.
    ///     - label: A view that describes the purpose of selecting an option.
    @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
    nonisolated public init<C>(sources: C, selection: KeyPath<C.Element, Binding<SelectionValue>>, @ViewBuilder content: () -> Content, @ViewBuilder label: () -> Label) where C : RandomAccessCollection

    /// Creates a picker that displays a custom label.
    ///
    /// - Parameters:
    ///     - selection: A binding to a property that determines the
    ///       currently-selected option.
    ///     - content: A view that contains the set of options.
    ///     - label: A view that describes the purpose of selecting an option.
    nonisolated public init(selection: Binding<SelectionValue>, @ViewBuilder content: () -> Content, @ViewBuilder label: () -> Label)
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Picker where Label == Text {

    /// Creates a picker that generates its label from a localized string key.
    ///
    /// - Parameters:
    ///     - titleKey: A localized string key that describes the purpose of
    ///       selecting an option.
    ///     - selection: A binding to a property that determines the
    ///       currently-selected option.
    ///     - content: A view that contains the set of options.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    nonisolated public init(_ titleKey: LocalizedStringKey, selection: Binding<SelectionValue>, @ViewBuilder content: () -> Content)

    /// Creates a picker that generates its label from a localized string key.
    ///
    /// If the wrapped values of the collection passed to `sources` are not all
    /// the same, some styles render the selection in a mixed state. The
    /// specific presentation depends on the style.  For example, a Picker
    /// with a menu style uses dashes instead of checkmarks to indicate the
    /// selected values.
    ///
    /// In the following example, a picker in a document inspector controls the
    /// thickness of borders for the currently-selected shapes, which can be of
    /// any number.
    ///
    ///     enum Thickness: String, CaseIterable, Identifiable {
    ///         case thin
    ///         case regular
    ///         case thick
    ///
    ///         var id: String { rawValue }
    ///     }
    ///
    ///     struct Border {
    ///         var color: Color
    ///         var thickness: Thickness
    ///     }
    ///
    ///     @State private var selectedObjectBorders = [
    ///         Border(color: .black, thickness: .thin),
    ///         Border(color: .red, thickness: .thick)
    ///     ]
    ///
    ///     Picker(
    ///         "Border Thickness",
    ///         sources: $selectedObjectBorders,
    ///         selection: \.thickness
    ///     ) {
    ///         ForEach(Thickness.allCases) { thickness in
    ///             Text(thickness.rawValue)
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///     - titleKey: A localized string key that describes the purpose of
    ///       selecting an option.
    ///     - sources: A collection of values used as the source for displaying
    ///       the Picker's selection.
    ///     - selection: The key path of the values that determines the
    ///       currently-selected options. When a user selects an option from the
    ///       picker, the values at the key path of all items in the `sources`
    ///       collection are updated with the selected option.
    ///     - content: A view that contains the set of options.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
    nonisolated public init<C>(_ titleKey: LocalizedStringKey, sources: C, selection: KeyPath<C.Element, Binding<SelectionValue>>, @ViewBuilder content: () -> Content) where C : RandomAccessCollection

    /// Creates a picker that generates its label from a string.
    ///
    /// - Parameters:
    ///     - title: A string that describes the purpose of selecting an option.
    ///     - selection: A binding to a property that determines the
    ///       currently-selected option.
    ///     - content: A view that contains the set of options.
    ///
    /// This initializer creates a ``Text`` view on your behalf. See ``Text`` for more
    /// information about localizing strings.
    nonisolated public init<S>(_ title: S, selection: Binding<SelectionValue>, @ViewBuilder content: () -> Content) where S : StringProtocol

    /// Creates a picker bound to a collection of bindings that generates its
    /// label from a string.
    ///
    /// If the wrapped values of the collection passed to `sources` are not all
    /// the same, some styles render the selection in a mixed state. The
    /// specific presentation depends on the style.  For example, a Picker
    /// with a menu style uses dashes instead of checkmarks to indicate the
    /// selected values.
    ///
    /// In the following example, a picker in a document inspector controls the
    /// thickness of borders for the currently-selected shapes, which can be of
    /// any number.
    ///
    ///     enum Thickness: String, CaseIterable, Identifiable {
    ///         case thin
    ///         case regular
    ///         case thick
    ///
    ///         var id: String { rawValue }
    ///     }
    ///
    ///     struct Border {
    ///         var color: Color
    ///         var thickness: Thickness
    ///     }
    ///
    ///     @State private var selectedObjectBorders = [
    ///         Border(color: .black, thickness: .thin),
    ///         Border(color: .red, thickness: .thick)
    ///     ]
    ///
    ///     Picker(
    ///         "Border Thickness",
    ///         sources: $selectedObjectBorders,
    ///         selection: \.thickness
    ///     ) {
    ///         ForEach(Thickness.allCases) { thickness in
    ///             Text(thickness.rawValue)
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///     - title: A string that describes the purpose of selecting an option.
    ///     - sources: A collection of values used as the source for displaying
    ///       the Picker's selection.
    ///     - selection: The key path of the values that determines the
    ///       currently-selected options. When a user selects an option from the
    ///       picker, the values at the key path of all items in the `sources`
    ///       collection are updated with the selected option.
    ///     - content: A view that contains the set of options.
    ///
    /// This initializer creates a ``Text`` view on your behalf. See ``Text`` for more
    /// information about localizing strings.
    @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
    nonisolated public init<C, S>(_ title: S, sources: C, selection: KeyPath<C.Element, Binding<SelectionValue>>, @ViewBuilder content: () -> Content) where C : RandomAccessCollection, S : StringProtocol
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension Picker where Label == Label<Text, Image> {

    /// Creates a picker that generates its label from a localized string key
    /// and system image.
    ///
    /// - Parameters:
    ///     - titleKey: A localized string key that describes the purpose of
    ///       selecting an option.
    ///     - systemImage: The name of the image resource to lookup.
    ///     - selection: A binding to a property that determines the
    ///       currently-selected option.
    ///     - content: A view that contains the set of options.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    nonisolated public init(_ titleKey: LocalizedStringKey, systemImage: String, selection: Binding<SelectionValue>, @ViewBuilder content: () -> Content)

    /// Creates a picker that generates its label from a localized string key.
    ///
    /// If the wrapped values of the collection passed to `sources` are not all
    /// the same, some styles render the selection in a mixed state. The
    /// specific presentation depends on the style.  For example, a Picker
    /// with a menu style uses dashes instead of checkmarks to indicate the
    /// selected values.
    ///
    /// In the following example, a picker in a document inspector controls the
    /// thickness of borders for the currently-selected shapes, which can be of
    /// any number.
    ///
    ///     enum Thickness: String, CaseIterable, Identifiable {
    ///         case thin
    ///         case regular
    ///         case thick
    ///
    ///         var id: String { rawValue }
    ///     }
    ///
    ///     struct Border {
    ///         var color: Color
    ///         var thickness: Thickness
    ///     }
    ///
    ///     @State private var selectedObjectBorders = [
    ///         Border(color: .black, thickness: .thin),
    ///         Border(color: .red, thickness: .thick)
    ///     ]
    ///
    ///     Picker(
    ///         "Border Thickness",
    ///         sources: $selectedObjectBorders,
    ///         selection: \.thickness
    ///     ) {
    ///         ForEach(Thickness.allCases) { thickness in
    ///             Text(thickness.rawValue)
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///     - titleKey: A localized string key that describes the purpose of
    ///       selecting an option.
    ///     - systemImage: The name of the image resource to lookup.
    ///     - sources: A collection of values used as the source for displaying
    ///       the Picker's selection.
    ///     - selection: The key path of the values that determines the
    ///       currently-selected options. When a user selects an option from the
    ///       picker, the values at the key path of all items in the `sources`
    ///       collection are updated with the selected option.
    ///     - content: A view that contains the set of options.
    @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
    nonisolated public init<C>(_ titleKey: LocalizedStringKey, systemImage: String, sources: C, selection: KeyPath<C.Element, Binding<SelectionValue>>, @ViewBuilder content: () -> Content) where C : RandomAccessCollection, C.Element == Binding<SelectionValue>

    /// Creates a picker that generates its label from a string and
    /// system image.
    ///
    /// - Parameters:
    ///     - title: A string that describes the purpose of selecting an option.
    ///     - systemImage: The name of the image resource to lookup.
    ///     - selection: A binding to a property that determines the
    ///       currently-selected option.
    ///     - content: A view that contains the set of options.
    nonisolated public init<S>(_ title: S, systemImage: String, selection: Binding<SelectionValue>, @ViewBuilder content: () -> Content) where S : StringProtocol

    /// Creates a picker bound to a collection of bindings that generates its
    /// label from a string.
    ///
    /// If the wrapped values of the collection passed to `sources` are not all
    /// the same, some styles render the selection in a mixed state. The
    /// specific presentation depends on the style.  For example, a Picker
    /// with a menu style uses dashes instead of checkmarks to indicate the
    /// selected values.
    ///
    /// In the following example, a picker in a document inspector controls the
    /// thickness of borders for the currently-selected shapes, which can be of
    /// any number.
    ///
    ///     enum Thickness: String, CaseIterable, Identifiable {
    ///         case thin
    ///         case regular
    ///         case thick
    ///
    ///         var id: String { rawValue }
    ///     }
    ///
    ///     struct Border {
    ///         var color: Color
    ///         var thickness: Thickness
    ///     }
    ///
    ///     @State private var selectedObjectBorders = [
    ///         Border(color: .black, thickness: .thin),
    ///         Border(color: .red, thickness: .thick)
    ///     ]
    ///
    ///     Picker(
    ///         "Border Thickness",
    ///         sources: $selectedObjectBorders,
    ///         selection: \.thickness
    ///     ) {
    ///         ForEach(Thickness.allCases) { thickness in
    ///             Text(thickness.rawValue)
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///     - title: A string that describes the purpose of selecting an option.
    ///     - systemImage: The name of the image resource to lookup.
    ///     - sources: A collection of values used as the source for displaying
    ///       the Picker's selection.
    ///     - selection: The key path of the values that determines the
    ///       currently-selected options. When a user selects an option from the
    ///       picker, the values at the key path of all items in the `sources`
    ///       collection are updated with the selected option.
    ///     - content: A view that contains the set of options.
    @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
    nonisolated public init<C, S>(_ title: S, systemImage: String, sources: C, selection: KeyPath<C.Element, Binding<SelectionValue>>, @ViewBuilder content: () -> Content) where C : RandomAccessCollection, S : StringProtocol, C.Element == Binding<SelectionValue>
}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension Picker where Label == Label<Text, Image> {

    /// Creates a picker that generates its label from a localized string key
    /// and image resource
    ///
    /// - Parameters:
    ///   - titleKey: A localized string key that describes the purpose of
    ///     selecting an option.
    ///   - image: The name of the image resource to lookup.
    ///   - selection: A binding to a property that determines the
    ///     currently-selected option.
    ///   - content: A view that contains the set of options.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    nonisolated public init(_ titleKey: LocalizedStringKey, image: ImageResource, selection: Binding<SelectionValue>, @ViewBuilder content: () -> Content)

    /// Creates a picker that generates its label from a localized string key
    /// and image resource.
    ///
    /// If the wrapped values of the collection passed to `sources` are not all
    /// the same, some styles render the selection in a mixed state. The
    /// specific presentation depends on the style.  For example, a Picker
    /// with a menu style uses dashes instead of checkmarks to indicate the
    /// selected values.
    ///
    /// In the following example, a picker in a document inspector controls the
    /// thickness of borders for the currently-selected shapes, which can be of
    /// any number.
    ///
    ///     enum Thickness: String, CaseIterable, Identifiable {
    ///         case thin
    ///         case regular
    ///         case thick
    ///
    ///         var id: String { rawValue }
    ///     }
    ///
    ///     struct Border {
    ///         var color: Color
    ///         var thickness: Thickness
    ///     }
    ///
    ///     @State private var selectedObjectBorders = [
    ///         Border(color: .black, thickness: .thin),
    ///         Border(color: .red, thickness: .thick)
    ///     ]
    ///
    ///     Picker(
    ///         "Border Thickness",
    ///         sources: $selectedObjectBorders,
    ///         selection: \.thickness
    ///     ) {
    ///         ForEach(Thickness.allCases) { thickness in
    ///             Text(thickness.rawValue)
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - titleKey: A localized string key that describes the purpose of
    ///     selecting an option.
    ///   - image: The name of the image resource to lookup.
    ///   - sources: A collection of values used as the source for displaying
    ///      he Picker's selection.
    ///   - selection: The key path of the values that determines the
    ///     currently-selected options. When a user selects an option from the
    ///     picker, the values at the key path of all items in the `sources`
    ///     collection are updated with the selected option.
    ///   - content: A view that contains the set of options.
    nonisolated public init<C>(_ titleKey: LocalizedStringKey, image: ImageResource, sources: C, selection: KeyPath<C.Element, Binding<SelectionValue>>, @ViewBuilder content: () -> Content) where C : RandomAccessCollection, C.Element == Binding<SelectionValue>

    /// Creates a picker that generates its label from a string and
    /// image resource.
    ///
    /// - Parameters:
    ///   - title: A string that describes the purpose of selecting an option.
    ///   - systemImage: The name of the image resource to lookup.
    ///   - selection: A binding to a property that determines the
    ///     currently-selected option.
    ///   - content: A view that contains the set of options.
    nonisolated public init<S>(_ title: S, image: ImageResource, selection: Binding<SelectionValue>, @ViewBuilder content: () -> Content) where S : StringProtocol

    /// Creates a picker bound to a collection of bindings that generates its
    /// label from a string and image resource.
    ///
    /// If the wrapped values of the collection passed to `sources` are not all
    /// the same, some styles render the selection in a mixed state. The
    /// specific presentation depends on the style.  For example, a Picker
    /// with a menu style uses dashes instead of checkmarks to indicate the
    /// selected values.
    ///
    /// In the following example, a picker in a document inspector controls the
    /// thickness of borders for the currently-selected shapes, which can be of
    /// any number.
    ///
    ///     enum Thickness: String, CaseIterable, Identifiable {
    ///         case thin
    ///         case regular
    ///         case thick
    ///
    ///         var id: String { rawValue }
    ///     }
    ///
    ///     struct Border {
    ///         var color: Color
    ///         var thickness: Thickness
    ///     }
    ///
    ///     @State private var selectedObjectBorders = [
    ///         Border(color: .black, thickness: .thin),
    ///         Border(color: .red, thickness: .thick)
    ///     ]
    ///
    ///     Picker(
    ///         "Border Thickness",
    ///         sources: $selectedObjectBorders,
    ///         selection: \.thickness
    ///     ) {
    ///         ForEach(Thickness.allCases) { thickness in
    ///             Text(thickness.rawValue)
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - title: A string that describes the purpose of selecting an option.
    ///   - image: The name of the image resource to lookup.
    ///   - sources: A collection of values used as the source for displaying
    ///     the Picker's selection.
    ///   - selection: The key path of the values that determines the
    ///     currently-selected options. When a user selects an option from the
    ///     picker, the values at the key path of all items in the `sources`
    ///     collection are updated with the selected option.
    ///   - content: A view that contains the set of options.
    nonisolated public init<C, S>(_ title: S, image: ImageResource, sources: C, selection: KeyPath<C.Element, Binding<SelectionValue>>, @ViewBuilder content: () -> Content) where C : RandomAccessCollection, S : StringProtocol, C.Element == Binding<SelectionValue>
}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Picker {

    /// Creates a picker that displays a custom label and a custom value
    /// label where applicable.
    ///
    /// The following example shows a picker with a current value label that
    /// only displays the title of the currently selected song:
    ///
    ///     struct Song: Identifiable, Hashable {
    ///         let id = UUID()
    ///         let title: String
    ///         let artist: String
    ///         let genre: String
    ///     }
    ///
    ///     private let songs: [Song] = [ /* songs */]
    ///
    ///     @State private var selectedSong: Song? = nil
    ///
    ///     var body: some View {
    ///         NavigationStack {
    ///             List {
    ///                 Picker(selection: $selectedSong) {
    ///                     ForEach(songs) { song in
    ///                         VStack(alignment: .leading) {
    ///                             Text(song.title)
    ///                                 .bold()
    ///                             Text(song.artist)
    ///                             Text(song.genre)
    ///                                 .foregroundColor(.secondary)
    ///                                 .font(.caption)
    ///                         }
    ///                         .tag(song as Song?)
    ///                     }
    ///                 } label: {
    ///                     Text("Request a song")
    ///                 } currentValueLabel: {
    ///                     Text(selectedSong?.title ?? "No selection")
    ///                 }
    ///             }
    ///             .pickerStyle(.navigationLink)
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///    - selection: A binding to a property that determines the
    ///       currently-selected option.
    ///    - content: A view that contains the set of options.
    ///    - label: A view that describes the purpose of selecting an option.
    ///    - currentValueLabel: A view that represents the current value of the picker.
    nonisolated public init(selection: Binding<SelectionValue>, @ViewBuilder content: () -> Content, @ViewBuilder label: () -> Label, @ViewBuilder currentValueLabel: () -> some View)

    /// Creates a picker that displays a custom label and current value label
    /// where applicable.
    ///
    /// If the wrapped values of the collection passed to `sources` are not all
    /// the same, some styles render the selection in a mixed state. The
    /// specific presentation depends on the style.  For example, a Picker
    /// with a menu style uses dashes instead of checkmarks to indicate the
    /// selected values.
    ///
    /// In the following example, a picker in a document inspector controls the
    /// thickness of borders for the currently selected shapes.
    ///
    ///     enum Thickness: String, CaseIterable, Identifiable {
    ///         case thin
    ///         case regular
    ///         case thick
    ///
    ///         var id: String { rawValue }
    ///     }
    ///
    ///     struct Border {
    ///         var color: Color
    ///         var thickness: Thickness
    ///     }
    ///
    ///     @State private var selectedObjectBorders = [
    ///         Border(color: .black, thickness: .thin),
    ///         Border(color: .red, thickness: .thick)
    ///     ]
    ///
    ///     Picker(
    ///         sources: $selectedObjectBorders,
    ///         selection: \.thickness
    ///     ) {
    ///         ForEach(Thickness.allCases) { thickness in
    ///             Text(thickness.rawValue)
    ///         }
    ///     } currentValueLabel: {
    ///          switch selectedObjectBorders.count {
    ///             case 0: Text("None")
    ///             case 1: Text(selectedObjectBorders[0].thickness.rawValue)
    ///             default: Text("Multiple")
    ///          }
    ///     } label: {
    ///         Text("Border Thickness")
    ///     }
    ///
    /// - Parameters:
    ///    - sources: A collection of values used as the source for displaying
    ///      the Picker's selection.
    ///    - selection: The key path of the values that determines the
    ///      currently-selected options. When a user selects an option from the
    ///      picker, the values at the key path of all items in the `sources`
    ///      collection are updated with the selected option.
    ///    - content: A view that contains the set of options.
    ///    - currentValueLabel: A view that represents the current value of the picker.
    ///    - label: A view that describes the purpose of selecting an option.
    nonisolated public init<C>(sources: C, selection: KeyPath<C.Element, Binding<SelectionValue>>, @ViewBuilder content: () -> Content, @ViewBuilder label: () -> Label, @ViewBuilder currentValueLabel: () -> some View) where C : RandomAccessCollection
}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Picker where Label == Text {

    /// Creates a picker that generates its label from a localized string key
    /// and accepts a custom current value label.
    ///
    /// - Parameters:
    ///    - titleKey: A localized string key that describes the purpose of
    ///      selecting an option.
    ///    - selection: A binding to a property that determines the
    ///      currently-selected option.
    ///    - content: A view that contains the set of options.
    ///    - currentValueLabel: A view that represents the current value of the picker.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    nonisolated public init(_ titleKey: LocalizedStringKey, selection: Binding<SelectionValue>, @ViewBuilder content: () -> Content, @ViewBuilder currentValueLabel: () -> some View)

    /// Creates a picker that generates its label from a localized string key
    /// and accepts a custom current value label.
    ///
    /// If the wrapped values of the collection passed to `sources` are not all
    /// the same, some styles render the selection in a mixed state. The
    /// specific presentation depends on the style.  For example, a Picker
    /// with a menu style uses dashes instead of checkmarks to indicate the
    /// selected values.
    ///
    /// In the following example, a picker in a document inspector controls the
    /// thickness of borders for the currently-selected shapes.
    ///
    ///     enum Thickness: String, CaseIterable, Identifiable {
    ///         case thin
    ///         case regular
    ///         case thick
    ///
    ///         var id: String { rawValue }
    ///     }
    ///
    ///     struct Border {
    ///         var color: Color
    ///         var thickness: Thickness
    ///     }
    ///
    ///     @State private var selectedObjectBorders = [
    ///         Border(color: .black, thickness: .thin),
    ///         Border(color: .red, thickness: .thick)
    ///     ]
    ///
    ///     Picker(
    ///         "Border Thickness",
    ///         sources: $selectedObjectBorders,
    ///         selection: \.thickness
    ///     ) {
    ///         ForEach(Thickness.allCases) { thickness in
    ///             Text(thickness.rawValue)
    ///         }
    ///     } currentValueLabel: {
    ///          switch selectedObjectBorders.count {
    ///             case 0: Text("None")
    ///             case 1: Text(selectedObjectBorders[0].thickness.rawValue)
    ///             default: Text("Multiple")
    ///          }
    ///     }
    ///
    /// - Parameters:
    ///    - titleKey: A localized string key that describes the purpose of
    ///      selecting an option.
    ///    - sources: A collection of values used as the source for displaying
    ///      the Picker's selection.
    ///    - selection: The key path of the values that determines the
    ///      currently-selected options. When a user selects an option from the
    ///      picker, the values at the key path of all items in the `sources`
    ///      collection are updated with the selected option.
    ///    - content: A view that contains the set of options.
    ///    - currentValueLabel: A view that represents the current value of the picker.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    nonisolated public init<C>(_ titleKey: LocalizedStringKey, sources: C, selection: KeyPath<C.Element, Binding<SelectionValue>>, @ViewBuilder content: () -> Content, @ViewBuilder currentValueLabel: () -> some View) where C : RandomAccessCollection

    /// Creates a picker that generates its label from a string and accepts a
    /// custom current value label.
    ///
    /// - Parameters:
    ///    - title: A string that describes the purpose of selecting an option.
    ///    - selection: A binding to a property that determines the
    ///      currently-selected option.
    ///    - content: A view that contains the set of options.
    ///    - currentValueLabel: A view that represents the current value of the picker.
    ///
    /// This initializer creates a ``Text`` view on your behalf. See ``Text`` for more
    /// information about localizing strings.
    nonisolated public init<S>(_ title: S, selection: Binding<SelectionValue>, @ViewBuilder content: () -> Content, @ViewBuilder currentValueLabel: () -> some View) where S : StringProtocol

    /// Creates a picker bound to a collection of bindings that generates its
    /// label from a string and accepts a custom current value label.
    ///
    /// If the wrapped values of the collection passed to `sources` are not all
    /// the same, some styles render the selection in a mixed state. The
    /// specific presentation depends on the style.  For example, a Picker
    /// with a menu style uses dashes instead of checkmarks to indicate the
    /// selected values.
    ///
    /// In the following example, a picker in a document inspector controls the
    /// thickness of borders for the currently-selected shapes, which can be of
    /// any number.
    ///
    ///     enum Thickness: String, CaseIterable, Identifiable {
    ///         case thin
    ///         case regular
    ///         case thick
    ///
    ///         var id: String { rawValue }
    ///     }
    ///
    ///     struct Border {
    ///         var color: Color
    ///         var thickness: Thickness
    ///     }
    ///
    ///     @State private var selectedObjectBorders = [
    ///         Border(color: .black, thickness: .thin),
    ///         Border(color: .red, thickness: .thick)
    ///     ]
    ///
    ///     Picker(
    ///         "Border Thickness",
    ///         sources: $selectedObjectBorders,
    ///         selection: \.thickness
    ///     ) {
    ///         ForEach(Thickness.allCases) { thickness in
    ///             Text(thickness.rawValue)
    ///         }
    ///     } currentValueLabel: {
    ///          switch selectedObjectBorders.count {
    ///             case 0: Text("None")
    ///             case 1: Text(selectedObjectBorders[0].thickness.rawValue)
    ///             default: Text("Multiple")
    ///          }
    ///     }
    ///
    /// - Parameters:
    ///    - title: A string that describes the purpose of selecting an option.
    ///    - sources: A collection of values used as the source for displaying
    ///      the Picker's selection.
    ///    - selection: The key path of the values that determines the
    ///      currently-selected options. When a user selects an option from the
    ///      picker, the values at the key path of all items in the `sources`
    ///      collection are updated with the selected option.
    ///    - content: A view that contains the set of options.
    ///    - currentValueLabel: A view that represents the current value of the picker.
    ///
    /// This initializer creates a ``Text`` view on your behalf. See ``Text`` for more
    /// information about localizing strings.
    nonisolated public init<C, S>(_ title: S, sources: C, selection: KeyPath<C.Element, Binding<SelectionValue>>, @ViewBuilder content: () -> Content, @ViewBuilder currentValueLabel: () -> some View) where C : RandomAccessCollection, S : StringProtocol
}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Picker where Label == Label<Text, Image> {

    /// Creates a picker that accepts a custom current value label and
    /// generates its label from a localized string key and system image.
    ///
    /// - Parameters:
    ///    - titleKey: A localized string key that describes the purpose of
    ///      selecting an option.
    ///    - systemImage: The name of the image resource to lookup.
    ///    - selection: A binding to a property that determines the
    ///      currently-selected option.
    ///    - content: A view that contains the set of options.
    ///    - currentValueLabel: A view that represents the current value of the picker.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    nonisolated public init(_ titleKey: LocalizedStringKey, systemImage: String, selection: Binding<SelectionValue>, @ViewBuilder content: () -> Content, @ViewBuilder currentValueLabel: () -> some View)

    /// Creates a picker that accepts a custom current value label and
    /// generates its label from a localized string key.
    ///
    /// - Parameters:
    ///    - titleKey: A localized string key that describes the purpose of
    ///      selecting an option.
    ///    - systemImage: The name of the image resource to lookup.
    ///    - sources: A collection of values used as the source for displaying
    ///      the Picker's selection.
    ///    - selection: The key path of the values that determines the
    ///      currently-selected options. When a user selects an option from the
    ///      picker, the values at the key path of all items in the `sources`
    ///      collection are updated with the selected option.
    ///    - content: A view that contains the set of options.
    ///    - currentValueLabel: A view that represents the current value of the picker.
    nonisolated public init<C>(_ titleKey: LocalizedStringKey, systemImage: String, sources: C, selection: KeyPath<C.Element, Binding<SelectionValue>>, @ViewBuilder content: () -> Content, @ViewBuilder currentValueLabel: () -> some View) where C : RandomAccessCollection, C.Element == Binding<SelectionValue>

    /// Creates a picker that accepts a custom current value and generates its
    /// label from a string and system image.
    ///
    /// - Parameters:
    ///    - title: A string that describes the purpose of selecting an option.
    ///    - systemImage: The name of the image resource to lookup.
    ///    - selection: A binding to a property that determines the
    ///      currently-selected option.
    ///    - content: A view that contains the set of options.
    ///    - currentValueLabel: A view that represents the current value of the picker.
    nonisolated public init<S>(_ title: S, systemImage: String, selection: Binding<SelectionValue>, @ViewBuilder content: () -> Content, @ViewBuilder currentValueLabel: () -> some View) where S : StringProtocol

    /// Creates a picker bound to a collection of bindings that accepts a
    /// custom current value label and generates its label from a string.
    ///
    /// - Parameters:
    ///    - title: A string that describes the purpose of selecting an option.
    ///    - systemImage: The name of the image resource to lookup.
    ///    - sources: A collection of values used as the source for displaying
    ///      the Picker's selection.
    ///    - selection: The key path of the values that determines the
    ///      currently-selected options. When a user selects an option from the
    ///      picker, the values at the key path of all items in the `sources`
    ///      collection are updated with the selected option.
    ///    - content: A view that contains the set of options.
    ///    - currentValueLabel: A view that represents the current value of the picker.
    nonisolated public init<C, S>(_ title: S, systemImage: String, sources: C, selection: KeyPath<C.Element, Binding<SelectionValue>>, @ViewBuilder content: () -> Content, @ViewBuilder currentValueLabel: () -> some View) where C : RandomAccessCollection, S : StringProtocol, C.Element == Binding<SelectionValue>
}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Picker where Label == Label<Text, Image> {

    /// Creates a picker that accepts a custom current value label and
    /// generates its label from a localized string key and image resource
    ///
    /// - Parameters:
    ///   - titleKey: A localized string key that describes the purpose of
    ///     selecting an option.
    ///   - image: The name of the image resource to lookup.
    ///   - selection: A binding to a property that determines the
    ///     currently-selected option.
    ///   - content: A view that contains the set of options.
    ///   - currentValueLabel: A view that represents the current value of the picker.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    nonisolated public init(_ titleKey: LocalizedStringKey, image: ImageResource, selection: Binding<SelectionValue>, @ViewBuilder content: () -> Content, @ViewBuilder currentValueLabel: () -> some View)

    /// Creates a picker that accepts a custom current value label generates
    /// its label from a localized string key and image resource.
    ///
    /// - Parameters:
    ///   - titleKey: A localized string key that describes the purpose of
    ///     selecting an option.
    ///   - image: The name of the image resource to lookup.
    ///   - sources: A collection of values used as the source for displaying
    ///      he Picker's selection.
    ///   - selection: The key path of the values that determines the
    ///     currently-selected options. When a user selects an option from the
    ///     picker, the values at the key path of all items in the `sources`
    ///     collection are updated with the selected option.
    ///   - content: A view that contains the set of options.
    ///   - currentValueLabel: A view that represents the current value of the picker.
    nonisolated public init<C>(_ titleKey: LocalizedStringKey, image: ImageResource, sources: C, selection: KeyPath<C.Element, Binding<SelectionValue>>, @ViewBuilder content: () -> Content, @ViewBuilder currentValueLabel: () -> some View) where C : RandomAccessCollection, C.Element == Binding<SelectionValue>

    /// Creates a picker that accepts a custom current value and generates its
    /// label from a string and image resource.
    ///
    /// - Parameters:
    ///   - title: A string that describes the purpose of selecting an option.
    ///   - systemImage: The name of the image resource to lookup.
    ///   - selection: A binding to a property that determines the
    ///     currently-selected option.
    ///   - content: A view that contains the set of options.
    ///   - currentValueLabel: A view that represents the current value of the picker.
    nonisolated public init<S>(_ title: S, image: ImageResource, selection: Binding<SelectionValue>, @ViewBuilder content: () -> Content, @ViewBuilder currentValueLabel: () -> some View) where S : StringProtocol

    /// Creates a picker bound to a collection of bindings that accepts a
    /// custom current value label and generates its label from a string and
    /// image resource.
    ///
    /// - Parameters:
    ///   - title: A string that describes the purpose of selecting an option.
    ///   - image: The name of the image resource to lookup.
    ///   - sources: A collection of values used as the source for displaying
    ///     the Picker's selection.
    ///   - selection: The key path of the values that determines the
    ///     currently-selected options. When a user selects an option from the
    ///     picker, the values at the key path of all items in the `sources`
    ///     collection are updated with the selected option.
    ///   - content: A view that contains the set of options.
    ///   - currentValueLabel: A view that represents the current value of the picker.
    nonisolated public init<C, S>(_ title: S, image: ImageResource, sources: C, selection: KeyPath<C.Element, Binding<SelectionValue>>, @ViewBuilder content: () -> Content, @ViewBuilder currentValueLabel: () -> some View) where C : RandomAccessCollection, S : StringProtocol, C.Element == Binding<SelectionValue>
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Picker {

    /// Creates a picker that displays a custom label.
    ///
    /// - Parameters:
    ///     - selection: A binding to a property that determines the
    ///       currently-selected option.
    ///     - label: A view that describes the purpose of selecting an option.
    ///     - content: A view that contains the set of options.
    @available(iOS, deprecated: 100000.0, renamed: "Picker(selection:content:label:)")
    @available(macOS, deprecated: 100000.0, renamed: "Picker(selection:content:label:)")
    @available(tvOS, deprecated: 100000.0, renamed: "Picker(selection:content:label:)")
    @available(watchOS, deprecated: 100000.0, renamed: "Picker(selection:content:label:)")
    @available(visionOS, deprecated: 100000.0, renamed: "Picker(selection:content:label:)")
    nonisolated public init(selection: Binding<SelectionValue>, label: Label, @ViewBuilder content: () -> Content)
}

/// A type that specifies the appearance and interaction of all pickers within
/// a view hierarchy.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public protocol PickerStyle {
}

@available(iOS 13.0, watchOS 6.0, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
extension PickerStyle where Self == WheelPickerStyle {

    /// A picker style that presents the options in a scrollable wheel that
    /// shows the selected option and a few neighboring options.
    ///
    /// Because most options aren't visible, organize them in a predictable
    /// order, such as alphabetically.
    ///
    /// To apply this style to a picker, or to a view that contains pickers, use
    /// the ``View/pickerStyle(_:)`` modifier.
    public static var wheel: WheelPickerStyle { get }
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension PickerStyle where Self == InlinePickerStyle {

    /// A `PickerStyle` where each option is displayed inline with other views
    /// in the current container.
    public static var inline: InlinePickerStyle { get }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension PickerStyle where Self == DefaultPickerStyle {

    /// The default picker style, based on the picker's context.
    ///
    /// How a picker using the default picker style appears largely depends on
    /// the platform and the view type in which it appears. For example, in a
    /// standard view, the default picker styles by platform are:
    ///
    /// * On iOS and watchOS the default is a wheel.
    /// * On macOS, the default is a pop-up button.
    /// * On tvOS, the default is a segmented control.
    ///
    /// The default picker style may also take into account other factors  like
    /// whether the picker appears in a container view  when setting the
    /// appearance of a picker.
    ///
    /// You can override a pickers style. To apply the default style to a
    /// picker, or to a view that contains pickers, use the
    /// ``View/pickerStyle(_:)`` modifier.
    public static var automatic: DefaultPickerStyle { get }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
@available(watchOS, unavailable)
extension PickerStyle where Self == SegmentedPickerStyle {

    /// A picker style that presents the options in a segmented control.
    ///
    /// Use this style when there are two to five options. Consider using
    /// ``PickerStyle/menu`` when there are more than five options.
    ///
    /// For each option's label, use sentence-style capitalization without
    /// ending punctuation, like a period or colon.
    ///
    /// To apply this style to a picker, or to a view that contains pickers, use
    /// the ``View/pickerStyle(_:)`` modifier.
    public static var segmented: SegmentedPickerStyle { get }
}

@available(iOS 17.0, macOS 14.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension PickerStyle where Self == PalettePickerStyle {

    /// A picker style that presents the options as a row of compact elements.
    ///
    /// - Note: When used outside of menus, this style is rendered as a
    /// segmented picker. If that is the intended usage, consider
    /// ``PickerStyle/segmented`` instead.
    ///
    /// For each option's label, use one symbol per item, if you add more than 6 options, the picker scrolls horizontally on iOS.
    ///
    /// The following example creates a palette picker:
    ///
    ///     enum Reaction: Identifiable, CaseIterable {
    ///         case thumbsup, thumbsdown, heart, questionMark
    ///         var id: Self { self }
    ///     }
    ///
    ///     @State private var selection: Reaction? = .none
    ///
    ///     var body: some View {
    ///         Menu("Reactions") {
    ///             Picker("Palette", selection: $selection) {
    ///                 Label("Thumbs up", systemImage: "hand.thumbsup")
    ///                     .tag(Reaction.thumbsup)
    ///                 Label("Thumbs down", systemImage: "hand.thumbsdown")
    ///                     .tag(Reaction.thumbsdown)
    ///                 Label("Like", systemImage: "heart")
    ///                     .tag(Reaction.heart)
    ///                 Label("Question mark", systemImage: "questionmark")
    ///                     .tag(Reaction.questionMark)
    ///             }
    ///             .pickerStyle(.palette)
    ///             Button("Reply...") { ... }
    ///         }
    ///     }
    ///
    /// Palette pickers will display the selection of untinted SF Symbols or
    /// template images by applying the system tint. For tinted SF Symbols, a
    /// stroke is outlined around the symbol upon selection. If you would like
    /// to supply a particular image (or SF Symbol) to signify selection, we
    /// suggest using ``PaletteSelectionEffect/custom``.
    /// This deactivates any system selection behavior, allowing the provided
    /// image to solely indicate selection instead.
    ///
    /// The following example creates a palette picker that disables the
    /// system selection behaviour:
    ///
    ///     Menu {
    ///         Picker("Palettes", selection: $selection) {
    ///             ForEach(palettes) { palette in
    ///                 Label(palette.title, systemImage: selection == palette ?
    ///                       "circle.dashed.inset.filled" : "circle.fill")
    ///                 .tint(palette.tint)
    ///                 .tag(palette)
    ///             }
    ///         }
    ///         .pickerStyle(.palette)
    ///         .paletteSelectionEffect(.custom)
    ///     } label: {
    ///         ...
    ///     }
    ///
    /// If a specific SF Symbol variant is preferable instead, use
    /// ``PaletteSelectionEffect/symbolVariant(_:)``:
    ///
    ///     Menu {
    ///         Picker("Flags", selection: $selectedFlag) {
    ///             ForEach(flags) { flag in
    ///                 Label(flag.title, systemImage: "flag")
    ///                     .tint(flag.color)
    ///                     .tag(flag)
    ///             }
    ///         }
    ///         .pickerStyle(.palette)
    ///         .paletteSelectionEffect(.symbolVariant(.slash))
    ///     } label: {
    ///         ...
    ///     }
    ///
    /// To apply this style to a picker, or to a view that contains pickers, use
    /// the ``View/pickerStyle(_:)`` modifier.
    public static var palette: PalettePickerStyle { get }
}

@available(iOS 16.0, tvOS 16.0, watchOS 9.0, *)
@available(macOS, unavailable)
extension PickerStyle where Self == NavigationLinkPickerStyle {

    /// A picker style represented by a navigation link that presents the options
    /// by pushing a List-style picker view.
    ///
    /// In navigation stacks, prefer the default ``PickerStyle/menu`` style.
    /// Consider the navigation link style when you have a large number of
    /// options or your design is better expressed by pushing onto a stack.
    ///
    /// To apply this style to a picker, or to a view that contains pickers,
    /// use the ``View/pickerStyle(_:)`` modifier.
    public static var navigationLink: NavigationLinkPickerStyle { get }
}

@available(iOS 14.0, macOS 11.0, tvOS 17.0, *)
@available(watchOS, unavailable)
extension PickerStyle where Self == MenuPickerStyle {

    /// A picker style that presents the options as a menu when the user presses a
    /// button, or as a submenu when nested within a larger menu.
    ///
    /// Use this style when there are more than five options. Consider using
    /// ``PickerStyle/inline`` when there are fewer than five options.
    ///
    /// The button itself indicates the selected option. You can include additional
    /// controls in the set of options, such as a button to customize the list of
    /// options.
    ///
    /// To apply this style to a picker, or to a view that contains pickers, use the
    /// ``View/pickerStyle(_:)`` modifier.
    public static var menu: MenuPickerStyle { get }
}

/// A style appropriate for placeholder text.
@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
@frozen public struct PlaceholderTextShapeStyle : ShapeStyle {

    /// Creates a new placeholder text shape style.
    public init()

    /// The type of shape style this will resolve to.
    ///
    /// When you create a custom shape style, Swift infers this type
    /// from your implementation of the required `resolve` function.
    @available(iOS 17.0, tvOS 17.0, watchOS 10.0, macOS 14.0, *)
    public typealias Resolved = Never
}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension PlaceholderTextShapeStyle : BitwiseCopyable {
}

/// A button style that doesn't style or decorate its content while idle, but
/// may apply a visual effect to indicate the pressed, focused, or enabled state
/// of the button.
///
/// You can also use ``PrimitiveButtonStyle/plain`` to construct this style.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public struct PlainButtonStyle : PrimitiveButtonStyle {

    /// Creates a plain button style.
    public init()

    /// Creates a view that represents the body of a button.
    ///
    /// The system calls this method for each ``Button`` instance in a view
    /// hierarchy where this style is the current button style.
    ///
    /// - Parameter configuration : The properties of the button.
    @MainActor @preconcurrency public func makeBody(configuration: PlainButtonStyle.Configuration) -> some View


    /// A view that represents the body of a button.
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    public typealias Body = some View
}

/// The list style that describes the behavior and appearance of a plain list.
///
/// You can also use ``ListStyle/plain`` to construct this style.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public struct PlainListStyle : ListStyle {

    /// Creates a plain list style.
    public init()
}

/// A text editor style with no decoration.
///
/// You can also use ``TextEditorStyle/plain`` to create this style.
@available(iOS 17.0, macOS 14.0, visionOS 1.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct PlainTextEditorStyle : TextEditorStyle {

    /// Creates a view that represents the body of a text editor.
    ///
    /// The system calls this method for each ``TextEditor`` instance in a view
    /// hierarchy where this style is the current text editor style.
    ///
    /// - Parameter configuration: The properties of the text editor.
    @MainActor @preconcurrency public func makeBody(configuration: PlainTextEditorStyle.Configuration) -> some View


    public init()

    /// A view that represents the body of a text editor.
    @available(iOS 17.0, visionOS 1.0, macOS 14.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias Body = some View
}

/// A text field style with no decoration.
///
/// You can also use ``TextFieldStyle/plain`` to construct this style.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public struct PlainTextFieldStyle : TextFieldStyle {

    public init()
}

/// An attachment anchor for a popover.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public enum PopoverAttachmentAnchor {

    /// The anchor point for the popover relative to the source's frame.
    case rect(Anchor<CGRect>.Source)

    /// The anchor point for the popover expressed as a unit point  that
    /// describes possible alignments relative to a SwiftUI view.
    case point(UnitPoint)
}

/// Strategies for adapting a presentation to a different size class.
///
/// Use values of this type with the ``View/presentationCompactAdaptation(_:)``
/// and ``View/presentationCompactAdaptation(horizontal:vertical:)`` modifiers.
@available(iOS 16.4, macOS 13.3, tvOS 16.4, watchOS 9.4, *)
public struct PresentationAdaptation : Sendable {

    /// Use the default presentation adaptation.
    public static var automatic: PresentationAdaptation { get }

    /// Don't adapt for the size class, if possible.
    public static var none: PresentationAdaptation { get }

    /// Prefer a popover appearance when adapting for size classes.
    public static var popover: PresentationAdaptation { get }

    /// Prefer a sheet appearance when adapting for size classes.
    public static var sheet: PresentationAdaptation { get }

    /// Prefer a full-screen-cover appearance when adapting for size classes.
    public static var fullScreenCover: PresentationAdaptation { get }
}

/// The kinds of interaction available to views behind a presentation.
///
/// Use values of this type with the
/// ``View/presentationBackgroundInteraction(_:)`` modifier.
@available(iOS 16.4, macOS 13.3, tvOS 16.4, watchOS 9.4, *)
public struct PresentationBackgroundInteraction : Sendable {

    /// The default background interaction for the presentation.
    public static var automatic: PresentationBackgroundInteraction { get }

    /// People can interact with the view behind a presentation.
    public static var enabled: PresentationBackgroundInteraction { get }

    /// People can interact with the view behind a presentation up through a
    /// specified detent.
    ///
    /// At detents larger than the one you specify, SwiftUI disables
    /// interaction.
    ///
    /// - Parameter detent: The largest detent at which people can interact with
    ///   the view behind the presentation.
    public static func enabled(upThrough detent: PresentationDetent) -> PresentationBackgroundInteraction

    /// People can't interact with the view behind a presentation.
    public static var disabled: PresentationBackgroundInteraction { get }
}

/// A behavior that you can use to influence how a presentation responds to
/// swipe gestures.
///
/// Use values of this type with the
/// ``View/presentationContentInteraction(_:)`` modifier.
@available(iOS 16.4, macOS 13.3, tvOS 16.4, watchOS 9.4, *)
public struct PresentationContentInteraction : Equatable, Sendable {

    /// The default swipe behavior for the presentation.
    public static var automatic: PresentationContentInteraction { get }

    /// A behavior that prioritizes resizing a presentation when swiping, rather
    /// than scrolling the content of the presentation.
    public static var resizes: PresentationContentInteraction { get }

    /// A behavior that prioritizes scrolling the content of a presentation when
    /// swiping, rather than resizing the presentation.
    public static var scrolls: PresentationContentInteraction { get }

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: PresentationContentInteraction, b: PresentationContentInteraction) -> Bool
}

/// A type that represents a height where a sheet naturally rests.
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct PresentationDetent : Hashable, Sendable {

    /// The system detent for a sheet that's approximately half the height of
    /// the screen, and is inactive in compact height.
    public static let medium: PresentationDetent

    /// The system detent for a sheet at full height.
    public static let large: PresentationDetent

    /// A custom detent with the specified fractional height.
    public static func fraction(_ fraction: CGFloat) -> PresentationDetent

    /// A custom detent with the specified height.
    public static func height(_ height: CGFloat) -> PresentationDetent

    /// A custom detent with a calculated height.
    public static func custom<D>(_ type: D.Type) -> PresentationDetent where D : CustomPresentationDetent

    /// Information that you use to calculate the presentation's height.
    @dynamicMemberLookup public struct Context {

        /// The height that the presentation appears in.
        public var maxDetentValue: CGFloat { get }

        /// Returns the value specified by the keyPath from the environment.
        ///
        /// This uses the environment from where the sheet is shown, not the
        /// environment where the presentation modifier is applied.
        public subscript<T>(dynamicMember keyPath: KeyPath<EnvironmentValues, T>) -> T { get }
    }

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: PresentationDetent, b: PresentationDetent) -> Bool

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

/// An indication whether a view is currently presented by another view.
@available(iOS, introduced: 13.0, deprecated: 100000.0, message: "Use EnvironmentValues.isPresented or EnvironmentValues.dismiss")
@available(macOS, introduced: 10.15, deprecated: 100000.0, message: "Use EnvironmentValues.isPresented or EnvironmentValues.dismiss")
@available(tvOS, introduced: 13.0, deprecated: 100000.0, message: "Use EnvironmentValues.isPresented or EnvironmentValues.dismiss")
@available(watchOS, introduced: 6.0, deprecated: 100000.0, message: "Use EnvironmentValues.isPresented or EnvironmentValues.dismiss")
@available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Use EnvironmentValues.isPresented or EnvironmentValues.dismiss")
public struct PresentationMode {

    /// Indicates whether a view is currently presented.
    public var isPresented: Bool { get }

    /// Dismisses the view if it is currently presented.
    ///
    /// If `isPresented` is false, `dismiss()` is a no-op.
    public mutating func dismiss()
}

/// A type that defines the size of the presentation content and how the
/// presentation size adjusts to its content's size changing.
///
/// You don't need to define your own version of this protocol. The system
/// implementations of ``PresentationSizing/form``, ``PresentationSizing/page``,
/// and ``PresentationSizing/fitted`` are conveniences that automatically
/// adapt to different device and screen sizes. If you do want to define your own
/// sizing, first consider using the modifiers
/// ``PresenationSizing/sticky(horizontal:vertical:)`` and
/// ``PresentationSizing/fitted(horizontal:vertical:)``. For example, to
/// define your own sizing that proposes a 400x400 square size:
///
///     protocol SquareSizing: PresentationSizing {
///         func proposedSize(
///             for subview: PresentationSizingRoot,
///             context: PresentationSizingContext
///         ) {
///             .init(width: 400, height: 400)
///         }
///     }
///
///     extension PresentationSizing where Self == SquareSizing {
///         public static var square: Self { SquareSizing() }
///     }
///
/// Then, at the callsite, you can modify `.square` just like system sizings,
/// for example, to fit its content vertically:
///
///     .presentationSizing(.square.fitted(horizontal: false, vertical: true))
///
/// - Seealso: ``View/presentationSizing(_:)``
@available(iOS 18.0, macOS 15.0, tvOS 18.0, visionOS 2.0, watchOS 11.0, *)
public protocol PresentationSizing {

    func proposedSize(for root: PresentationSizingRoot, context: PresentationSizingContext) -> ProposedViewSize
}

extension PresentationSizing {

    /// Modifies self to be sticky in the specified dimensions growing, but
    /// not shrinking.
    ///
    /// If `sticky` is `.vertical`, the presentation can grow in the vertical
    /// and horizontal dimensions when its content size grows, but will not
    /// shrink in the vertical dimension when content size shrinks.
    ///
    ///     ContentView()
    ///       .sheet(isPresented: $presentSheet) {
    ///         MyDynamicSheetContent()
    ///           .presentationSizing(
    ///             .form.sticky(horizontal: false, vertical: true))
    ///       }
    ///
    /// - Seealso: ``PresentationSizing/fitted(horizontal:vertical:)``
    ///
    /// - Parameters:
    ///   - horizontal: A boolean indicating whether to maintain the largest
    ///     size horizontally
    ///   - vertical: A boolean indicating whether to maintain the largest size
    ///     vertically
    /// - Returns: a modified version of self sticking to dimensions specified
    @available(iOS 18.0, macOS 15.0, tvOS 18.0, visionOS 2.0, watchOS 11.0, *)
    public func sticky(horizontal: Bool = false, vertical: Bool = false) -> some PresentationSizing

}

extension PresentationSizing {

    @available(iOS 18.0, macOS 15.0, tvOS 18.0, visionOS 2.0, watchOS 11.0, *)
    public func fitted(horizontal: Bool, vertical: Bool) -> some PresentationSizing

}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, visionOS 2.0, watchOS 11.0, *)
extension PresentationSizing where Self == FormPresentationSizing {

    /// The size is appropriate for forms and slightly less wide than`.page`
    public static var form: FormPresentationSizing { get }
}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, visionOS 2.0, watchOS 11.0, *)
extension PresentationSizing where Self == PagePresentationSizing {

    /// The size is roughly the size of a page of paper, appropriate for
    /// informational or compositional content.
    public static var page: PagePresentationSizing { get }
}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, visionOS 2.0, watchOS 11.0, *)
extension PresentationSizing where Self == FittedPresentationSizing {

    /// The presentation sizing is dictated by the ideal size of the content
    ///
    /// On macOS, presentations with `.fitted` sizing are user-resizable
    /// by default. Because of this, is best practice to define a presentation
    /// frame with any of the `frame` modifiers, either specifying a fixed
    /// frame or minimum/maximum bounds. If you specify a ``View/fixedSize()``
    /// or a frame with fixed dimensions on the content, the sheet will not be
    /// user resizable.
    ///
    ///     @State private var present = true
    ///
    ///     ContentView().sheet(isPresented: $present) {
    ///       ScrollView {
    ///         LazyVGrid(columns: columns) {
    ///           ForEach(0x1f600...0x1f679, id: \.self) { value in
    ///             Text(String(format: "%x", value))
    ///             Text(emoji(value))
    ///               .font(.largeTitle)
    ///             }
    ///           }
    ///       }
    ///       .presentationSizing(.fitted)
    ///       .frame(
    ///         minWidth: 200, idealWidth: 300, maxWidth: 500,
    ///         minHeight: 100, maxHeight: 600)
    ///     }
    ///
    /// To create a view that fits the view's size in either the horizontal or
    /// vertical dimensions, see
    /// ``PresentationSizing/fitted(horizontal:vertical:)``.
    public static var fitted: FittedPresentationSizing { get }
}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, visionOS 2.0, watchOS 11.0, *)
extension PresentationSizing where Self == AutomaticPresentationSizing {

    /// The default presentation sizing, appropriate for the platform.
    ///
    /// On macOS, `.automatic` resolves to
    /// `.form.fitted(horizontal: false, vertical: true)`. On all other
    /// platforms, including Mac Catalyst, it resolves to `.form`.
    ///
    /// - Seealso: ``AutomaticPresentationSizing``
    public static var automatic: AutomaticPresentationSizing { get }
}

/// Contextual information about a presentation.
///
/// The properties of a `PresentationSizingContext` can influence
/// what size is proposed to a presentation.
///
/// - Note: Currently has no public members.
@available(iOS 18.0, macOS 15.0, tvOS 18.0, visionOS 2.0, watchOS 11.0, *)
public struct PresentationSizingContext {
}

/// A proxy to a view provided to the presentation with a
/// defined presentation size.
@available(iOS 18.0, macOS 15.0, tvOS 18.0, visionOS 2.0, watchOS 11.0, *)
public struct PresentationSizingRoot {

    /// Asks the subview for its size.
    ///
    /// - Returns: the size of the presentation's content view given `proposal`
    public func sizeThatFits(_ proposal: ProposedViewSize) -> CGSize
}

/// A view that represents the content of a presented window.
///
/// You don't create this type directly. ``WindowGroup`` creates values for you.
@available(iOS 16.0, macOS 13.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct PresentedWindowContent<Data, Content> : View where Data : Decodable, Data : Encodable, Data : Hashable, Content : View {

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    @available(iOS 16.0, macOS 13.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias Body = Never
}

/// Creates a preview of a SwiftUI view using the specified traits.
///
/// This macro behaves like ``Preview(_:body:)`` except that it also
/// enables you to customize the appearance of the preview by adding
/// one or more traits, which are instances of
/// <doc://com.apple.documentation/documentation/developertoolssupport/previewtrait>.
/// For example, you can display a preview at a fixed size using the
/// <doc://com.apple.documentation/documentation/developertoolssupport/previewtrait/fixedlayout(width:height:)>
/// trait:
///
///     #Preview(
///         "Content",
///         traits: .fixedLayout(width: 100, height: 100)
///     ) {
///         ContentView()
///     }
///
/// The macro ignores traits that don't apply to the current context.
/// For example, the
/// <doc://com.apple.documentation/documentation/developertoolssupport/previewtrait/portrait>
/// trait has no impact on a visionOS preview.
///
/// Other preview macros provide different customization options. For example,
/// if you want to specify a custom viewpoint for the preview, use ``Preview(_:traits:body:cameras:)``.
///
/// - Parameters:
///   - name: An optional display name for the preview. If you don't specify a
///     name, the canvas labels the preview using the line number where the
///     preview appears in source.
///   - traits: A
///     <doc://com.apple.documentation/documentation/developertoolssupport/previewtrait>
///     instance that customizes the appearance of the preview.
///   - additionalTraits: Optional additional traits that further customize
///     the preview.
///   - body: A ``ViewBuilder`` that produces a SwiftUI view to preview. You
///     typically specify one of your app's custom views and optionally any
///     inputs, model data, modifiers, and enclosing views that the custom
///     view needs for normal operation.
@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
@freestanding(declaration) public macro Preview(_ name: String? = nil, traits: PreviewTrait<Preview.ViewTraits>, _ additionalTraits: PreviewTrait<Preview.ViewTraits>..., @ViewBuilder body: @escaping @MainActor () -> any View) = #externalMacro(module: "PreviewsMacros", type: "SwiftUIView")

/// Creates a preview of a SwiftUI view.
///
/// Use this macro to display a SwiftUI preview in the canvas.
/// You typically specify at least one preview macro for every ``View``
/// that your app defines to help you develop, test, and debug the view:
///
///     struct ContentView: View {
///         var body: some View {
///             // ...
///         }
///     }
///
///     #Preview {
///         ContentView()
///     }
///
/// If you include more than one preview in a source file, the canvas provides
/// controls that enable you to select which to display when that source file
/// is active. The canvas labels the different previews with the line number
/// where the preview appears in source. To better identify the previews in
/// the canvas, you can give them names. For example if your `ContentView`
/// takes a Boolean input, you can create named previews for each input state:
///
///     #Preview("Input true") {
///         ContentView(someInput: true)
///     }
///
///     #Preview("Input false") {
///         ContentView(someInput: false)
///     }
///
/// Inside the preview, you can provide different inputs, model data,
/// and other infrastructure that the view needs for normal operation.
/// For example, you can present a custom view as the sidebar inside a
/// ``NavigationSplitView`` if that's how your app uses the view.
///
/// Other preview macros provide different customization options. For example,
/// if you need to modify the appearance of a preview using one or more
/// <doc://com.apple.documentation/documentation/developertoolssupport/previewtrait>,
/// instances, use the ``Preview(_:traits:_:body:)`` macro.
///
/// - Parameters:
///   - name: An optional display name for the preview. If you don't specify a
///     name, the canvas labels the preview using the line number where the
///     preview appears in source.
///   - body: A ``ViewBuilder`` that produces a SwiftUI view to preview. You
///     typically specify one of your app's custom views and optionally any
///     inputs, model data, modifiers, and enclosing views that the custom
///     view needs for normal operation.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@freestanding(declaration) public macro Preview(_ name: String? = nil, @ViewBuilder body: @escaping @MainActor () -> any View) = #externalMacro(module: "PreviewsMacros", type: "SwiftUIView")

/// A context type for use with a preview.
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public protocol PreviewContext {

    /// Returns the context's value for a key, or a the key's default value
    /// if the context doesn't define a value for the key.
    subscript<Key>(key: Key.Type) -> Key.Value where Key : PreviewContextKey { get }
}

/// A key type for a preview context.
///
/// The default value is `nil`.
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public protocol PreviewContextKey {

    /// The type of the value returned by the key.
    associatedtype Value

    /// The default value of the key.
    static var defaultValue: Self.Value { get }
}

/// A simulator device that runs a preview.
///
/// Create a preview device by name, like "iPhone X", or by model number,
/// like "iPad8,1". Use the device in a call to the ``View/previewDevice(_:)``
/// modifier to set a preview device that doesn't change when you change the
/// run destination in Xcode:
///
///     struct CircleImage_Previews: PreviewProvider {
///         static var previews: some View {
///             CircleImage()
///                 .previewDevice(PreviewDevice(rawValue: "iPad Pro (11-inch)"))
///         }
///     }
///
/// You can get a list of supported preview device names by using the
/// `xcrun` command in the Terminal app:
///
///     % xcrun simctl list devicetypes
///
/// Additionally, you can use the following values for macOS platform
/// development:
/// - "Mac"
/// - "Mac Catalyst"
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public struct PreviewDevice : RawRepresentable, ExpressibleByStringLiteral, Sendable {

    /// The corresponding value of the raw type.
    ///
    /// A new instance initialized with `rawValue` will be equivalent to this
    /// instance. For example:
    ///
    ///     enum PaperSize: String {
    ///         case A4, A5, Letter, Legal
    ///     }
    ///
    ///     let selectedSize = PaperSize.Letter
    ///     print(selectedSize.rawValue)
    ///     // Prints "Letter"
    ///
    ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
    ///     // Prints "true"
    public let rawValue: String

    /// Creates a new instance with the specified raw value.
    ///
    /// If there is no value of the type that corresponds with the specified raw
    /// value, this initializer returns `nil`. For example:
    ///
    ///     enum PaperSize: String {
    ///         case A4, A5, Letter, Legal
    ///     }
    ///
    ///     print(PaperSize(rawValue: "Legal"))
    ///     // Prints "Optional("PaperSize.Legal")"
    ///
    ///     print(PaperSize(rawValue: "Tabloid"))
    ///     // Prints "nil"
    ///
    /// - Parameter rawValue: The raw value to use for the new instance.
    public init(rawValue: String)

    /// Creates an instance initialized to the given string value.
    ///
    /// - Parameter value: The value of the new instance.
    public init(stringLiteral: String)

    /// A type that represents an extended grapheme cluster literal.
    ///
    /// Valid types for `ExtendedGraphemeClusterLiteralType` are `Character`,
    /// `String`, and `StaticString`.
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    public typealias ExtendedGraphemeClusterLiteralType = String

    /// The raw type that can be used to represent all values of the conforming
    /// type.
    ///
    /// Every distinct value of the conforming type has a corresponding unique
    /// value of the `RawValue` type, but there may be values of the `RawValue`
    /// type that don't have a corresponding value of the conforming type.
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    public typealias RawValue = String

    /// A type that represents a string literal.
    ///
    /// Valid types for `StringLiteralType` are `String` and `StaticString`.
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    public typealias StringLiteralType = String

    /// A type that represents a Unicode scalar literal.
    ///
    /// Valid types for `UnicodeScalarLiteralType` are `Unicode.Scalar`,
    /// `Character`, `String`, and `StaticString`.
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    public typealias UnicodeScalarLiteralType = String
}

/// A type that defines an environment in which previews can appear.
///
/// Conforming types can define shared contexts that will be cached by the
/// preview system, then reused across participating previews. For example,
/// you might create a model container here and populate it with sample data;
/// in your `body` method you would then apply it to the preview using the
/// `.modelContainer` view modifier.
///
/// ```
/// struct SampleData: PreviewModifier {
///     static func makeSharedContext() throws -> ModelContainer {
///         let container = try ModelContainer(for: Snack.self)
///         container.mainContext.insert(Snack.potatoChips)
///         return container
///     }
///
///     func body(content: Content, context: ModelContainer) -> some View {
///         content.modelContainer(context)
///     }
///  }
///```
/// Use the `.modifier` preview trait to attach modifiers to a preview.
///```
/// #Preview(traits: .modifier(SampleData())) {
///     @Previewable @Query var snacks: [Snack]
///     return SnackView(snack: snacks.first!)
/// }
///```
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
@MainActor public protocol PreviewModifier {

    associatedtype Context = Void

    associatedtype Body : View

    /// The type-erased content of a preview.
    typealias Content = PreviewModifierContent

    /// Create shared context to apply to previews. The context returned
    /// here will be cached and passed into the `body` method for every
    /// preview that applies a modifier of this type.
    @MainActor static func makeSharedContext() async throws -> Self.Context

    /// Modify a preview by applying the shared context.
    ///
    /// - Parameters:
    ///   - content: A proxy for the preview being modified.
    ///   - context: The shared context to apply.
    @ViewBuilder @MainActor func body(content: Self.Content, context: Self.Context) -> Self.Body
}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension PreviewModifier where Self.Context == () {

    /// Create shared context to apply to previews. The context returned
    /// here will be cached and passed into the `body` method for every
    /// preview that applies a modifier of this type.
    @MainActor public static func makeSharedContext() async throws -> Self.Context
}

/// The type-erased content of a preview.
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct PreviewModifierContent : View {

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias Body = Never
}

/// Platforms that can run the preview.
///
/// Xcode infers the platform for a preview based on the currently
/// selected target. If you have a multiplatform target and want to
/// suggest a particular target for a preview, implement the
/// ``PreviewProvider/platform-75xu4`` computed property as a hint,
/// and specify one of the preview platforms:
///
///     struct CircleImage_Previews: PreviewProvider {
///         static var previews: some View {
///             CircleImage()
///         }
///
///         static var platform: PreviewPlatform? {
///             PreviewPlatform.tvOS
///         }
///     }
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public enum PreviewPlatform : Sendable {

    /// Specifies iOS as the preview platform.
    case iOS

    /// Specifies macOS as the preview platform.
    case macOS

    /// Specifies tvOS as the preview platform.
    case tvOS

    /// Specifies watchOS as the preview platform.
    case watchOS

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: PreviewPlatform, b: PreviewPlatform) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension PreviewPlatform : Equatable {
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension PreviewPlatform : Hashable {
}

/// A type that produces view previews in Xcode.
///
/// > Important: You can use this protocol to define a preview manually, but
///   you typically use a preview macro like ``Preview(_:body:)`` instead.
///
/// You can create an Xcode preview by declaring a structure that conforms to
/// the `PreviewProvider` protocol. Implement the required
/// ``PreviewProvider/previews-swift.type.property`` computed property,
/// and return the view to display:
///
///     struct CircleImage_Previews: PreviewProvider {
///         static var previews: some View {
///             CircleImage()
///         }
///     }
///
/// Xcode statically discovers preview providers in your project and generates
/// previews for any providers currently open in the source editor.
/// Xcode generates the preview using the current run destination as a hint
/// for which device to display. For example, Xcode shows the following preview
/// if you've selected an iOS target to run on the iPhone 12 Pro Max simulator:
///
/// ![A screenshot of the Xcode canvas previewing a circular image on an
/// iPhone in the portrait orientation.](PreviewProvider-1)
///
/// When you create a new file (File > New > File)
/// and choose the SwiftUI view template, Xcode automatically inserts a
/// preview structure at the bottom of the file that you can configure.
/// You can also create new preview structures in an existing SwiftUI
/// view file by choosing Editor > Create Preview.
///
/// Customize the preview's appearance by adding view modifiers, just like you
/// do when building a custom ``View``. This includes preview-specific
/// modifiers that let you control aspects of the preview, like the device
/// orientation:
///
///     struct CircleImage_Previews: PreviewProvider {
///         static var previews: some View {
///             CircleImage()
///                 .previewInterfaceOrientation(.landscapeLeft)
///         }
///     }
///
/// ![A screenshot of the Xcode canvas previewing a circular image on an
/// iPhone in the landscape left orientation.](PreviewProvider-2)
///
/// For the complete list of preview customizations,
/// see <doc:Previews-in-Xcode>.
///
/// Xcode creates different previews for each view in your preview,
/// so you can see variations side by side. For example, you
/// might want to see a view's light and dark appearances simultaneously:
///
///     struct CircleImage_Previews: PreviewProvider {
///         static var previews: some View {
///             CircleImage()
///             CircleImage()
///                 .preferredColorScheme(.dark)
///         }
///     }
///
/// Use a ``Group`` when you want to maintain different previews, but apply a
/// single modifier to all of them:
///
///     struct CircleImage_Previews: PreviewProvider {
///         static var previews: some View {
///             Group {
///                 CircleImage()
///                 CircleImage()
///                     .preferredColorScheme(.dark)
///             }
///             .previewLayout(.sizeThatFits)
///         }
///     }
///
/// ![A screenshot of the Xcode canvas previewing a circular image twice,
/// once with a light appearance and once with a dark appearance. Both
/// previews take up only as much room as they need to fit the circular
/// image.](PreviewProvider-3)
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@MainActor @preconcurrency public protocol PreviewProvider : _PreviewProvider {

    /// The type to preview.
    ///
    /// When you create a preview, Swift infers this type from your
    /// implementation of the required
    /// ``PreviewProvider/previews-swift.type.property`` property.
    associatedtype Previews : View

    /// A collection of views to preview.
    ///
    /// Implement a computed `previews` property to indicate the content to
    /// preview. Xcode generates a preview for each view that you list. You
    /// can apply ``View`` modifiers to the views, like you do
    /// when creating a custom view. For a preview, you can also use
    /// various preview-specific modifiers that customize the preview.
    /// For example, you can choose a specific device for the preview
    /// by adding the ``View/previewDevice(_:)`` modifier:
    ///
    ///     struct CircleImage_Previews: PreviewProvider {
    ///         static var previews: some View {
    ///             CircleImage()
    ///                 .previewDevice(PreviewDevice(rawValue: "iPad Pro (11-inch)"))
    ///         }
    ///     }
    ///
    /// For the full list of preview-specific modifiers,
    /// see <doc:Previews-in-Xcode>.
    @ViewBuilder @MainActor @preconcurrency static var previews: Self.Previews { get }

    /// The platform on which to run the provider.
    ///
    /// Xcode infers the platform for a preview based on the currently
    /// selected target. If you have a multiplatform target and want to
    /// suggest a particular target for a preview, implement the
    /// `platform` computed property to provide a hint,
    /// and specify one of the ``PreviewPlatform`` values:
    ///
    ///     struct CircleImage_Previews: PreviewProvider {
    ///         static var previews: some View {
    ///             CircleImage()
    ///         }
    ///
    ///         static var platform: PreviewPlatform? {
    ///             PreviewPlatform.tvOS
    ///         }
    ///     }
    ///
    /// Xcode ignores this value unless you have a multiplatform target.
    @MainActor @preconcurrency static var platform: PreviewPlatform? { get }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension PreviewProvider {

    /// The platform to run the provider on.
    ///
    /// This default implementation of the ``PreviewProvider/platform-75xu4``
    /// computed property returns `nil`. Rely on this implementation unless
    /// you have a multiplatform target and want to suggest a particular
    /// platform for a preview.
    @MainActor @preconcurrency public static var platform: PreviewPlatform? { get }
}

/// Tag allowing a dynamic property to appear inline in a preview.
///
/// Tagging a variable declaration at root scope in your `#Preview` body
/// with '@Previewable' allows you to use dynamic properties inline in previews.
/// The `#Preview` macro will generate an embedded SwiftUI view; tagged
/// declarations become properties on the view, and all remaining statements
/// form the view's body.
///
/// ```
/// #Preview("toggle") {
///     @Previewable @State var toggled = true
///     return Toggle("Loud Noises", isOn: $toggled)
/// }
/// ```
///
/// It is an error to use `@Previewable` outside of a `#Preview` body closure.
@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, visionOS 1.0, *)
@attached(peer) public macro Previewable() = #externalMacro(module: "PreviewsMacros", type: "Previewable")

/// A type that applies custom interaction behavior and a custom appearance to
/// all buttons within a view hierarchy.
///
/// To configure the current button style for a view hierarchy, use the
/// ``View/buttonStyle(_:)`` modifier. Specify a style that conforms to
/// `PrimitiveButtonStyle` to create a button with custom interaction
/// behavior. To create a button with the standard button interaction behavior
/// defined for each platform, use ``ButtonStyle`` instead.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@MainActor @preconcurrency public protocol PrimitiveButtonStyle {

    /// A view that represents the body of a button.
    associatedtype Body : View

    /// Creates a view that represents the body of a button.
    ///
    /// The system calls this method for each ``Button`` instance in a view
    /// hierarchy where this style is the current button style.
    ///
    /// - Parameter configuration : The properties of the button.
    @ViewBuilder @MainActor @preconcurrency func makeBody(configuration: Self.Configuration) -> Self.Body

    /// The properties of a button.
    typealias Configuration = PrimitiveButtonStyleConfiguration
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension PrimitiveButtonStyle where Self == DefaultButtonStyle {

    /// The default button style, based on the button's context.
    ///
    /// If you create a button directly on a blank canvas, the style varies by
    /// platform. iOS uses the borderless button style by default, whereas macOS,
    /// tvOS, and watchOS use the bordered button style.
    ///
    /// If you create a button inside a container, like a ``List``, the style
    /// resolves to the recommended style for buttons inside that container for
    /// that specific platform.
    ///
    /// You can override a button's style. To apply the default style to a
    /// button, or to a view that contains buttons, use the
    /// ``View/buttonStyle(_:)`` modifier.
    @MainActor @preconcurrency public static var automatic: DefaultButtonStyle { get }
}

@available(iOS 13.0, macOS 10.15, tvOS 17.0, watchOS 8.0, *)
extension PrimitiveButtonStyle where Self == BorderlessButtonStyle {

    /// A button style that doesn't apply a border.
    ///
    /// To apply this style to a button, or to a view that contains buttons, use
    /// the ``View/buttonStyle(_:)`` modifier.
    ///
    /// On tvOS, this button style adds a default hover effect to the first
    /// image of the button's content, if one exists. You can supply a different
    /// hover effect by using the ``View/hoverEffect(_:)`` modifier in the
    /// button's label.
    @MainActor @preconcurrency public static var borderless: BorderlessButtonStyle { get }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension PrimitiveButtonStyle where Self == PlainButtonStyle {

    /// A button style that doesn't style or decorate its content while idle,
    /// but may apply a visual effect to indicate the pressed, focused, or
    /// enabled state of the button.
    ///
    /// To apply this style to a button, or to a view that contains buttons, use
    /// the ``View/buttonStyle(_:)`` modifier.
    @MainActor @preconcurrency public static var plain: PlainButtonStyle { get }
}

@available(iOS 15.0, macOS 10.15, tvOS 13.0, watchOS 7.0, *)
extension PrimitiveButtonStyle where Self == BorderedButtonStyle {

    /// A button style that applies standard border artwork based on the
    /// button's context.
    ///
    /// To apply this style to a button, or to a view that contains buttons, use
    /// the ``View/buttonStyle(_:)`` modifier.
    @MainActor @preconcurrency public static var bordered: BorderedButtonStyle { get }
}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension PrimitiveButtonStyle where Self == BorderedProminentButtonStyle {

    /// A button style that applies standard border prominent artwork based on
    /// the button's context.
    ///
    /// To apply this style to a button, or to a view that contains buttons, use
    /// the ``View/buttonStyle(_:)`` modifier.
    @MainActor @preconcurrency public static var borderedProminent: BorderedProminentButtonStyle { get }
}

/// The properties of a button.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public struct PrimitiveButtonStyleConfiguration {

    /// A type-erased label of a button.
    @MainActor @preconcurrency public struct Label : View {

        /// The type of view representing the body of this view.
        ///
        /// When you create a custom view, Swift infers this type from your
        /// implementation of the required ``View/body-swift.property`` property.
        @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
        public typealias Body = Never
    }

    /// An optional semantic role describing the button's purpose.
    ///
    /// A value of `nil` means that the Button has no assigned role. If the
    /// button does have a role, use it to make adjustments to the button's
    /// appearance. The following example shows a custom style that uses
    /// bold text when the role is ``ButtonRole/cancel``,
    /// ``ShapeStyle/red`` text when the role is ``ButtonRole/destructive``,
    /// and adds no special styling otherwise:
    ///
    ///     struct MyButtonStyle: PrimitiveButtonStyle {
    ///         func makeBody(configuration: Configuration) -> some View {
    ///             configuration.label
    ///                 .onTapGesture {
    ///                     configuration.trigger()
    ///                 }
    ///                 .font(
    ///                     configuration.role == .cancel ? .title2.bold() : .title2)
    ///                 .foregroundColor(
    ///                     configuration.role == .destructive ? Color.red : nil)
    ///         }
    ///     }
    ///
    /// You can create one of each button using this style to see the effect:
    ///
    ///     VStack(spacing: 20) {
    ///         Button("Cancel", role: .cancel) {}
    ///         Button("Delete", role: .destructive) {}
    ///         Button("Continue") {}
    ///     }
    ///     .buttonStyle(MyButtonStyle())
    ///
    /// ![A screenshot of three buttons stacked vertically. The first says
    /// Cancel in black, bold letters. The second says Delete in red, regular
    /// weight letters. The third says Continue in black, regular weight
    /// letters.](PrimitiveButtonStyleConfiguration-role-1)
    @available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
    public let role: ButtonRole?

    /// A view that describes the effect of calling the button's action.
    public let label: PrimitiveButtonStyleConfiguration.Label

    /// Performs the button's action.
    public func trigger()
}

/// A view that shows the progress toward completion of a task.
///
/// Use a progress view to show that a task is incomplete but advancing toward
/// completion. A progress view can show both determinate (percentage complete)
/// and indeterminate (progressing or not) types of progress.
///
/// Create a determinate progress view by initializing a `ProgressView` with
/// a binding to a numeric value that indicates the progress, and a `total`
/// value that represents completion of the task. By default, the progress is
/// `0.0` and the total is `1.0`.
///
/// The example below uses the state property `progress` to show progress in
/// a determinate `ProgressView`. The progress view uses its default total of
/// `1.0`, and because `progress` starts with an initial value of `0.5`,
/// the progress view begins half-complete. A "More" button below the progress
/// view allows people to increment the progress in increments of five percent:
///
///     struct LinearProgressDemoView: View {
///         @State private var progress = 0.5
///
///         var body: some View {
///             VStack {
///                 ProgressView(value: progress)
///                 Button("More") { progress += 0.05 }
///             }
///         }
///     }
///
/// ![A horizontal barthat represents progress, with a More button
/// placed underneath. The progress bar is at 50 percent from the leading
/// edge.](ProgressView-1-macOS)
///
/// To create an indeterminate progress view, use an initializer that doesn't
/// take a progress value:
///
///     var body: some View {
///         ProgressView()
///     }
///
/// ![An indeterminate progress view, presented as a spinning set of gray lines
/// emanating from the center of a circle, with opacity varying from fully
/// opaque to transparent. An animation rotates which line is most opaque,
/// creating the spinning effect.](ProgressView-2-macOS)
///
/// You can also create a progress view that covers a closed range of
/// <doc://com.apple.documentation/documentation/Foundation/Date> values. As long
/// as the current date is within the range, the progress view automatically
/// updates, filling or depleting the progress view as it nears the end of the
/// range. The following example shows a five-minute timer whose start time is
/// that of the progress view's initialization:
///
///     struct DateRelativeProgressDemoView: View {
///         let workoutDateRange = Date()...Date().addingTimeInterval(5*60)
///
///         var body: some View {
///              ProgressView(timerInterval: workoutDateRange) {
///                  Text("Workout")
///              }
///         }
///     }
///
/// ![A horizontal progress view that shows a bar partially filled with as it
/// counts a five-minute duration.](ProgressView-3-macOS)
///
/// ### Styling progress views
///
/// You can customize the appearance and interaction of progress views by
/// creating styles that conform to the ``ProgressViewStyle`` protocol. To set a
/// specific style for all progress view instances within a view, use the
/// ``View/progressViewStyle(_:)`` modifier. In the following example, a custom
/// style adds a rounded pink border to all progress views within the enclosing
/// ``VStack``:
///
///     struct BorderedProgressViews: View {
///         var body: some View {
///             VStack {
///                 ProgressView(value: 0.25) { Text("25% progress") }
///                 ProgressView(value: 0.75) { Text("75% progress") }
///             }
///             .progressViewStyle(PinkBorderedProgressViewStyle())
///         }
///     }
///
///     struct PinkBorderedProgressViewStyle: ProgressViewStyle {
///         func makeBody(configuration: Configuration) -> some View {
///             ProgressView(configuration)
///                 .padding(4)
///                 .border(.pink, width: 3)
///                 .cornerRadius(4)
///         }
///     }
///
/// ![Two horizontal progress views, one at 25 percent complete and the other at 75 percent,
/// each rendered with a rounded pink border.](ProgressView-4-macOS)
///
/// SwiftUI provides two built-in progress view styles,
/// ``ProgressViewStyle/linear`` and ``ProgressViewStyle/circular``, as well as
/// an automatic style that defaults to the most appropriate style in the
/// current context. The following example shows a circular progress view that
/// starts at 60 percent completed.
///
///     struct CircularProgressDemoView: View {
///         @State private var progress = 0.6
///
///         var body: some View {
///             VStack {
///                 ProgressView(value: progress)
///                     .progressViewStyle(.circular)
///             }
///         }
///     }
///
/// ![A ring shape, filled to 60 percent completion with a blue
/// tint.](ProgressView-5-macOS)
///
/// On platforms other than macOS, the circular style may appear as an
/// indeterminate indicator instead.
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public struct ProgressView<Label, CurrentValueLabel> : View where Label : View, CurrentValueLabel : View {

    /// The content and behavior of the view.
    ///
    /// When you implement a custom view, you must implement a computed
    /// `body` property to provide the content for your view. Return a view
    /// that's composed of built-in views that SwiftUI provides, plus other
    /// composite views that you've already defined:
    ///
    ///     struct MyView: View {
    ///         var body: some View {
    ///             Text("Hello, World!")
    ///         }
    ///     }
    ///
    /// For more information about composing views and a view hierarchy,
    /// see <doc:Declaring-a-Custom-View>.
    @MainActor @preconcurrency public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
    public typealias Body = some View
}

@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension ProgressView {

    /// Creates a progress view for showing continuous progress as time passes,
    /// with descriptive and current progress labels.
    ///
    /// Use this initializer to create a view that shows continuous progress
    /// within a date range. The following example initializes a progress view
    /// with a range of `start...end`, where `start` is 30 seconds in the past
    /// and `end` is 90 seconds in the future. As a result, the progress view
    /// begins at 25 percent complete. This example also provides custom views
    /// for a descriptive label (Progress) and a current value label that shows
    /// the date range.
    ///
    ///     struct ContentView: View {
    ///         let start = Date().addingTimeInterval(-30)
    ///         let end = Date().addingTimeInterval(90)
    ///
    ///         var body: some View {
    ///             ProgressView(interval: start...end,
    ///                          countsDown: false) {
    ///                 Text("Progress")
    ///             } currentValueLabel: {
    ///                 Text(start...end)
    ///              }
    ///          }
    ///     }
    ///
    /// ![A horizontal bar that represents progress, partially filled in from
    /// the leading edge. The title, Progress, appears above the bar, and the
    /// date range, 1:43 to 1:45 PM, appears below the bar. These values represent
    /// the time progress began and when it ends, given a current time of
    /// 1:44.](ProgressView-6-macOS)
    ///
    /// By default, the progress view empties as time passes from the start of
    /// the date range to the end, but you can use the `countsDown` parameter to
    /// create a progress view that fills as time passes, as the above example
    /// demonstrates.
    ///
    /// > Note: Date-relative progress views, such as those created with this
    ///   initializer, don't support custom styles.
    ///
    /// - Parameters:
    ///     - timerInterval: The date range over which the view should progress.
    ///     - countsDown: A Boolean value that determines whether the view
    ///       empties or fills as time passes. If `true` (the default), the
    ///       view empties.
    ///     - label: An optional view that describes the purpose of the progress
    ///       view.
    ///     - currentValueLabel: A view that displays the current value of the
    ///       timer.
    nonisolated public init(timerInterval: ClosedRange<Date>, countsDown: Bool = true, @ViewBuilder label: () -> Label, @ViewBuilder currentValueLabel: () -> CurrentValueLabel)
}

@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension ProgressView where CurrentValueLabel == DefaultDateProgressLabel {

    /// Creates a progress view for showing continuous progress as time passes,
    /// with a descriptive label.
    ///
    /// Use this initializer to create a view that shows continuous progress
    /// within a date range. The following example initializes a progress view
    /// with a range of `start...end`, where `start` is 30 seconds in the past
    /// and `end` is 90 seconds in the future. As a result, the progress view
    /// begins at 25 percent complete. This example also provides a custom
    /// descriptive label.
    ///
    ///     struct ContentView: View {
    ///         let start = Date().addingTimeInterval(-30)
    ///         let end = Date().addingTimeInterval(90)
    ///
    ///         var body: some View {
    ///             ProgressView(interval: start...end,
    ///                          countsDown: false) {
    ///                 Text("Progress")
    ///              }
    ///         }
    ///     }
    ///
    /// ![A horizontal bar that represents progress, partially filled in from
    /// the leading edge. The title, Progress, appears above the bar, and the
    /// elapsed time, 0:34, appears below the bar.](ProgressView-7-macOS)
    ///
    /// By default, the progress view empties as time passes from the start of
    /// the date range to the end, but you can use the `countsDown` parameter to
    /// create a progress view that fills as time passes, as the above example
    /// demonstrates.
    ///
    /// The progress view provided by this initializer uses a text label that
    /// automatically updates to describe the current time remaining. To provide
    /// a custom label to show the current value, use
    /// ``init(value:total:label:currentValueLabel:)`` instead.
    ///
    /// > Note: Date-relative progress views, such as those created with this
    ///   initializer, don't support custom styles.
    ///
    /// - Parameters:
    ///     - timerInterval: The date range over which the view progresses.
    ///     - countsDown: A Boolean value that determines whether the view
    ///       empties or fills as time passes. If `true` (the default), the
    ///       view empties.
    ///     - label: An optional view that describes the purpose of the progress
    ///       view.
    nonisolated public init(timerInterval: ClosedRange<Date>, countsDown: Bool = true, @ViewBuilder label: () -> Label)
}

@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension ProgressView where Label == EmptyView, CurrentValueLabel == DefaultDateProgressLabel {

    /// Creates a progress view for showing continuous progress as time passes.
    ///
    /// Use this initializer to create a view that shows continuous progress
    /// within a date range. The following example initializes a progress view
    /// with a range of `start...end`, where `start` is 30 seconds in the past
    /// and `end` is 90 seconds in the future. As a result, the progress view
    /// begins at 25 percent complete.
    ///
    ///     struct ContentView: View {
    ///         let start = Date().addingTimeInterval(-30)
    ///         let end = Date().addingTimeInterval(90)
    ///
    ///         var body: some View {
    ///             ProgressView(interval: start...end
    ///                          countsDown: false)
    ///         }
    ///     }
    ///
    /// ![A horizontal bar that represents progress, partially filled in from
    /// the leading edge. The elapsed time, 0:34, appears below the
    /// bar.](ProgressView-8-macOS)
    ///
    /// By default, the progress view empties as time passes from the start of
    /// the date range to the end, but you can use the `countsDown` parameter to
    /// create a progress view that fills as time passes, as the above example
    /// demonstrates.
    ///
    /// The progress view provided by this initializer omits a descriptive
    /// label and provides a text label that automatically updates to describe
    /// the current time remaining. To provide custom views for these labels,
    /// use ``init(value:total:label:currentValueLabel:)`` instead.
    ///
    /// > Note: Date-relative progress views, such as those created with this
    ///   initializer, don't support custom styles.
    ///
    /// - Parameters:
    ///     - timerInterval: The date range over which the view progresses.
    ///     - countsDown: If `true` (the default), the view empties as time passes.
    nonisolated public init(timerInterval: ClosedRange<Date>, countsDown: Bool = true)
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ProgressView where CurrentValueLabel == EmptyView {

    /// Creates a progress view for showing indeterminate progress, without a
    /// label.
    nonisolated public init() where Label == EmptyView

    /// Creates a progress view for showing indeterminate progress that displays
    /// a custom label.
    ///
    /// - Parameters:
    ///     - label: A view builder that creates a view that describes the task
    ///       in progress.
    nonisolated public init(@ViewBuilder label: () -> Label)

    /// Creates a progress view for showing indeterminate progress that
    /// generates its label from a localized string.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings. To initialize a
    /// indeterminate progress view with a string variable, use
    /// the corresponding initializer that takes a `StringProtocol` instance.
    ///
    /// - Parameters:
    ///     - titleKey: The key for the progress view's localized title that
    ///       describes the task in progress.
    nonisolated public init(_ titleKey: LocalizedStringKey) where Label == Text

    /// Creates a progress view for showing indeterminate progress that
    /// generates its label from a string.
    ///
    /// - Parameters:
    ///     - title: A string that describes the task in progress.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// title similar to ``Text/init(verbatim:)``. See ``Text`` for more
    /// information about localizing strings. To initialize a progress view with
    /// a localized string key, use the corresponding initializer that takes a
    /// `LocalizedStringKey` instance.
    nonisolated public init<S>(_ title: S) where Label == Text, S : StringProtocol
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ProgressView {

    /// Creates a progress view for showing determinate progress.
    ///
    /// If the value is non-`nil`, but outside the range of `0.0` through
    /// `total`, the progress view pins the value to those limits, rounding to
    /// the nearest possible bound. A value of `nil` represents indeterminate
    /// progress, in which case the progress view ignores `total`.
    ///
    /// - Parameters:
    ///     - value: The completed amount of the task to this point, in a range
    ///       of `0.0` to `total`, or `nil` if the progress is indeterminate.
    ///     - total: The full amount representing the complete scope of the
    ///       task, meaning the task is complete if `value` equals `total`. The
    ///       default value is `1.0`.
    nonisolated public init<V>(value: V?, total: V = 1.0) where Label == EmptyView, CurrentValueLabel == EmptyView, V : BinaryFloatingPoint

    /// Creates a progress view for showing determinate progress, with a
    /// custom label.
    ///
    /// If the value is non-`nil`, but outside the range of `0.0` through
    /// `total`, the progress view pins the value to those limits, rounding to
    /// the nearest possible bound. A value of `nil` represents indeterminate
    /// progress, in which case the progress view ignores `total`.
    ///
    /// - Parameters:
    ///     - value: The completed amount of the task to this point, in a range
    ///       of `0.0` to `total`, or `nil` if the progress is indeterminate.
    ///     - total: The full amount representing the complete scope of the
    ///       task, meaning the task is complete if `value` equals `total`. The
    ///       default value is `1.0`.
    ///     - label: A view builder that creates a view that describes the task
    ///       in progress.
    nonisolated public init<V>(value: V?, total: V = 1.0, @ViewBuilder label: () -> Label) where CurrentValueLabel == EmptyView, V : BinaryFloatingPoint

    /// Creates a progress view for showing determinate progress, with a
    /// custom label.
    ///
    /// If the value is non-`nil`, but outside the range of `0.0` through
    /// `total`, the progress view pins the value to those limits, rounding to
    /// the nearest possible bound. A value of `nil` represents indeterminate
    /// progress, in which case the progress view ignores `total`.
    ///
    /// - Parameters:
    ///     - value: The completed amount of the task to this point, in a range
    ///       of `0.0` to `total`, or `nil` if the progress is indeterminate.
    ///     - total: The full amount representing the complete scope of the
    ///       task, meaning the task is complete if `value` equals `total`. The
    ///       default value is `1.0`.
    ///     - label: A view builder that creates a view that describes the task
    ///       in progress.
    ///     - currentValueLabel: A view builder that creates a view that
    ///       describes the level of completed progress of the task.
    nonisolated public init<V>(value: V?, total: V = 1.0, @ViewBuilder label: () -> Label, @ViewBuilder currentValueLabel: () -> CurrentValueLabel) where V : BinaryFloatingPoint

    /// Creates a progress view for showing determinate progress that generates
    /// its label from a localized string.
    ///
    /// If the value is non-`nil`, but outside the range of `0.0` through
    /// `total`, the progress view pins the value to those limits, rounding to
    /// the nearest possible bound. A value of `nil` represents indeterminate
    /// progress, in which case the progress view ignores `total`.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings. To initialize a
    ///  determinate progress view with a string variable, use
    ///  the corresponding initializer that takes a `StringProtocol` instance.
    ///
    /// - Parameters:
    ///     - titleKey: The key for the progress view's localized title that
    ///       describes the task in progress.
    ///     - value: The completed amount of the task to this point, in a range
    ///       of `0.0` to `total`, or `nil` if the progress is
    ///       indeterminate.
    ///     - total: The full amount representing the complete scope of the
    ///       task, meaning the task is complete if `value` equals `total`. The
    ///       default value is `1.0`.
    nonisolated public init<V>(_ titleKey: LocalizedStringKey, value: V?, total: V = 1.0) where Label == Text, CurrentValueLabel == EmptyView, V : BinaryFloatingPoint

    /// Creates a progress view for showing determinate progress that generates
    /// its label from a string.
    ///
    /// If the value is non-`nil`, but outside the range of `0.0` through
    /// `total`, the progress view pins the value to those limits, rounding to
    /// the nearest possible bound. A value of `nil` represents indeterminate
    /// progress, in which case the progress view ignores `total`.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// title similar to ``Text/init(verbatim:)``. See ``Text`` for more
    /// information about localizing strings. To initialize a determinate
    /// progress view with a localized string key, use the corresponding
    /// initializer that takes a `LocalizedStringKey` instance.
    ///
    /// - Parameters:
    ///     - title: The string that describes the task in progress.
    ///     - value: The completed amount of the task to this point, in a range
    ///       of `0.0` to `total`, or `nil` if the progress is
    ///       indeterminate.
    ///     - total: The full amount representing the complete scope of the
    ///       task, meaning the task is complete if `value` equals `total`. The
    ///       default value is `1.0`.
    nonisolated public init<S, V>(_ title: S, value: V?, total: V = 1.0) where Label == Text, CurrentValueLabel == EmptyView, S : StringProtocol, V : BinaryFloatingPoint
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ProgressView {

    /// Creates a progress view for visualizing the given progress instance.
    ///
    /// The progress view synthesizes a default label using the
    /// `localizedDescription` of the given progress instance.
    nonisolated public init(_ progress: Progress) where Label == EmptyView, CurrentValueLabel == EmptyView
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ProgressView {

    /// Creates a progress view based on a style configuration.
    ///
    /// You can use this initializer within the
    /// ``ProgressViewStyle/makeBody(configuration:)`` method of a
    /// ``ProgressViewStyle`` to create an instance of the styled progress view.
    /// This is useful for custom progress view styles that only modify the
    /// current progress view style, as opposed to implementing a brand new
    /// style. Because this modifier style can't know how the current style
    /// represents progress, avoid making assumptions about the view's contents,
    /// such as whether it uses bars or other shapes.
    ///
    /// The following example shows a style that adds a rounded pink border to a
    /// progress view, but otherwise preserves the progress view's current
    /// style:
    ///
    ///     struct PinkBorderedProgressViewStyle: ProgressViewStyle {
    ///         func makeBody(configuration: Configuration) -> some View {
    ///             ProgressView(configuration)
    ///                 .padding(4)
    ///                 .border(.pink, width: 3)
    ///                 .cornerRadius(4)
    ///         }
    ///     }
    ///
    /// ![Two horizontal progress views, one at 25 percent complete and the
    /// other at 75 percent, each rendered with a rounded pink
    /// border.](ProgressView-4-macOS)
    ///
    /// - Note: Progress views in widgets don't apply custom styles.
    nonisolated public init(_ configuration: ProgressViewStyleConfiguration) where Label == ProgressViewStyleConfiguration.Label, CurrentValueLabel == ProgressViewStyleConfiguration.CurrentValueLabel
}

/// A type that applies standard interaction behavior to all progress views
/// within a view hierarchy.
///
/// To configure the current progress view style for a view hierarchy, use the
/// ``View/progressViewStyle(_:)`` modifier.
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
@MainActor @preconcurrency public protocol ProgressViewStyle {

    /// A view representing the body of a progress view.
    associatedtype Body : View

    /// Creates a view representing the body of a progress view.
    ///
    /// - Parameter configuration: The properties of the progress view being
    ///   created.
    ///
    /// The view hierarchy calls this method for each progress view where this
    /// style is the current progress view style.
    ///
    /// - Parameter configuration: The properties of the progress view, such as
    ///  its preferred progress type.
    @ViewBuilder @MainActor @preconcurrency func makeBody(configuration: Self.Configuration) -> Self.Body

    /// A type alias for the properties of a progress view instance.
    typealias Configuration = ProgressViewStyleConfiguration
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ProgressViewStyle where Self == LinearProgressViewStyle {

    /// A progress view that visually indicates its progress using a horizontal
    /// bar.
    @MainActor @preconcurrency public static var linear: LinearProgressViewStyle { get }
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ProgressViewStyle where Self == CircularProgressViewStyle {

    /// The style of a progress view that uses a circular gauge to indicate the
    /// partial completion of an activity.
    ///
    /// On watchOS, and in widgets and complications, a circular progress view
    /// appears as a gauge with the ``GaugeStyle/accessoryCircularCapacity``
    /// style. If the progress view is indeterminate, the gauge is empty.
    ///
    /// In cases where no determinate circular progress view style is available,
    /// circular progress views use an indeterminate style.
    @MainActor @preconcurrency public static var circular: CircularProgressViewStyle { get }
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ProgressViewStyle where Self == DefaultProgressViewStyle {

    /// The default progress view style in the current context of the view being
    /// styled.
    ///
    /// The default style represents the recommended style based on the original
    /// initialization parameters of the progress view, and the progress view's
    /// context within the view hierarchy.
    @MainActor @preconcurrency public static var automatic: DefaultProgressViewStyle { get }
}

/// The properties of a progress view instance.
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public struct ProgressViewStyleConfiguration {

    /// A type-erased label describing the task represented by the progress
    /// view.
    @MainActor @preconcurrency public struct Label : View {

        /// The type of view representing the body of this view.
        ///
        /// When you create a custom view, Swift infers this type from your
        /// implementation of the required ``View/body-swift.property`` property.
        @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
        public typealias Body = Never
    }

    /// A type-erased label that describes the current value of a progress view.
    @MainActor @preconcurrency public struct CurrentValueLabel : View {

        /// The type of view representing the body of this view.
        ///
        /// When you create a custom view, Swift infers this type from your
        /// implementation of the required ``View/body-swift.property`` property.
        @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
        public typealias Body = Never
    }

    /// The completed fraction of the task represented by the progress view,
    /// from `0.0` (not yet started) to `1.0` (fully complete), or `nil` if the
    /// progress is indeterminate or relative to a date interval.
    public let fractionCompleted: Double?

    /// A view that describes the task represented by the progress view.
    ///
    /// If `nil`, then the task is self-evident from the surrounding context,
    /// and the style does not need to provide any additional description.
    ///
    /// If the progress view is defined using a `Progress` instance, then this
    /// label is equivalent to its `localizedDescription`.
    public var label: ProgressViewStyleConfiguration.Label?

    /// A view that describes the current value of a progress view.
    ///
    /// If `nil`, then the value of the progress view is either self-evident
    /// from the surrounding context or unknown, and the style does not need to
    /// provide any additional description.
    ///
    /// If the progress view is defined using a `Progress` instance, then this
    /// label is equivalent to its `localizedAdditionalDescription`.
    public var currentValueLabel: ProgressViewStyleConfiguration.CurrentValueLabel?
}

/// A navigation split style that attempts to maintain the size of the
/// detail content when hiding or showing the leading columns.
///
/// Use ``NavigationSplitViewStyle/prominentDetail`` to construct this style.
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
@MainActor @preconcurrency public struct ProminentDetailNavigationSplitViewStyle : NavigationSplitViewStyle {

    /// Creates an instance of ``ProminentDetailNavigationSplitViewStyle``.
    ///
    /// You can also use ``NavigationSplitViewStyle/prominentDetail`` to
    /// construct this style.
    @MainActor @preconcurrency public init()

    /// Creates a view that represents the body of a navigation split view.
    ///
    /// SwiftUI calls this method for each instance of ``NavigationSplitView``,
    /// where this style is the current ``NavigationSplitViewStyle``.
    ///
    /// - Parameter configuration: The properties of the instance to create.
    @MainActor @preconcurrency public func makeBody(configuration: ProminentDetailNavigationSplitViewStyle.Configuration) -> some View


    /// A view that represents the body of a navigation split view.
    @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
    public typealias Body = some View
}

/// A type that you use to serialize reference type documents to and from file.
///
/// To store a document as a reference type --- like a class --- create a type
/// that conforms to the `ReferenceFileDocument` protocol and implement the
/// required methods and properties. Your implementation:
///
/// * Provides a list of the content types that the document can read from and
///   write to by defining ``readableContentTypes``. If the list of content
///   types that the document can write to is different from those that it reads
///   from, you can optionally also define ``writableContentTypes-6x6w9``.
/// * Loads documents from file in the ``init(configuration:)`` initializer.
/// * Stores documents to file by providing a snapshot of the document's
///   content in the ``snapshot(contentType:)`` method, and then serializing
///   that content in the ``fileWrapper(snapshot:configuration:)`` method.
///
/// Ensure that types that conform to this protocol are ``Sendable``.
/// In particular, SwiftUI calls the protocol's methods from different isolation domains.
/// Don't perform serialization and deserialization on ``MainActor``.
///
///     final class PDFDocument: ReferenceFileDocument {
///         struct Storage {
///             var contents: Data
///         }
///
///         static let readableContentTypes: [UTType] = [.pdf]
///         let storage: OSAllocatedUnfairLock<Storage>
///
///         required init(configuration: ReadConfiguration) throws {
///            guard let data = configuration.file.regularFileContents else {
///                throw CocoaError(.fileReadCorruptFile)
///            }
///             self.storage = .init(initialState: .init(contents: data))
///         }
///
///         func snapshot(contentType: UTType) throws -> Data {
///             storage.withLock { $0.contents }
///         }
///
///         func fileWrapper(snapshot: Data, configuration: WriteConfiguration) throws -> FileWrapper {
///             return FileWrapper(regularFileWithContents: snapshot)
///         }
///     }
///
/// > Important: If you store your document as a value type --- like a
///   structure --- use ``FileDocument`` instead.
///
@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@preconcurrency public protocol ReferenceFileDocument : ObservableObject, Sendable {

    /// A type that represents the document's stored content.
    ///
    /// Define this type to represent all the data that your document stores.
    /// When someone issues a Save command, SwiftUI asks your document for a
    /// value of this type by calling the document's ``snapshot(contentType:)``
    /// method. SwiftUI sends the snapshot that you provide to the document's
    /// ``fileWrapper(snapshot:configuration:)`` method, where you serialize
    /// the contents of the snapshot into a file wrapper.
    associatedtype Snapshot

    /// The file and data types that the document reads from.
    ///
    /// Define this list to indicate the content types that your document can
    /// read. By default, SwiftUI assumes that your document can also write
    /// the same set of content types. If you need to indicate a different set
    /// of types for writing files, define the ``writableContentTypes-6x6w9``
    /// property in addition to this property.
    static var readableContentTypes: [UTType] { get }

    /// The file types that the document supports saving or exporting to.
    ///
    /// By default, SwiftUI assumes that your document reads and writes the
    /// same set of content types. Only define this property if you need to
    /// indicate a different set of types for writing files. Otherwise, the
    /// default implementation of this property returns the list that you
    /// specify in your implementation of ``readableContentTypes``.
    static var writableContentTypes: [UTType] { get }

    /// Creates a document and initializes it with the contents of a file.
    ///
    /// SwiftUI calls this initializer when someone opens a file type
    /// that matches one of those that your document type supports.
    /// Use the ``FileDocumentReadConfiguration/file`` property of the
    /// `configuration` input to get document's data. Deserialize the data,
    /// and store it in your document's data structure:
    ///
    ///     init(configuration: ReadConfiguration) throws {
    ///         guard let data = configuration.file.regularFileContents
    ///         else { /* Throw an error. */ }
    ///         model = try JSONDecoder().decode(Model.self, from: data)
    ///     }
    ///
    /// The above example assumes that you define `Model` to contain
    /// the document's data, that `Model` conforms to the
    /// <doc://com.apple.documentation/documentation/Swift/Codable> protocol,
    /// and that you store a `model` property of that type inside your document.
    ///
    /// > Note: SwiftUI calls this method on a background thread. Don't
    ///   make user interface changes from that thread.
    ///
    /// - Parameter configuration: Information about the file that you read
    ///   document data from.
    init(configuration: Self.ReadConfiguration) throws

    /// The configuration for reading document contents.
    ///
    /// This type is an alias for ``FileDocumentReadConfiguration``, which
    /// contains a content type and a file wrapper that you use to access the
    /// contents of a document file. You get a value of this type as an input
    /// to the ``init(configuration:)`` initializer. Use it to load a
    /// document from a file.
    typealias ReadConfiguration = FileDocumentReadConfiguration

    /// Creates a snapshot that represents the current state of the document.
    ///
    /// To store a document --- for example, in response to a Save command ---
    /// SwiftUI begins by calling this method. Return a copy of the document's
    /// content from your implementation of the method. For example, you might
    /// define an initializer for your document's model object that copies the
    /// contents of the document's instance, and return that:
    ///
    ///     func snapshot(contentType: UTType) throws -> Snapshot {
    ///         Model(from: model) // Creates a copy.
    ///     }
    ///
    /// SwiftUI prevents document edits during the snapshot operation to ensure
    /// that the model state remains coherent. After the call completes, SwiftUI
    /// reenables edits, and then calls the
    /// ``fileWrapper(snapshot:configuration:)`` method, where you serialize
    /// the snapshot and store it to a file.
    ///
    /// > Note: SwiftUI calls this method on a background thread. Don't
    ///   make user interface changes from that thread.
    ///
    /// - Parameter contentType: The content type that you create the
    ///   document snapshot for.
    ///
    /// - Returns: A snapshot of the document content that the system
    ///   provides to the ``fileWrapper(snapshot:configuration:)`` method
    ///   for serialization.
    func snapshot(contentType: UTType) throws -> Self.Snapshot

    /// Serializes a document snapshot to a file wrapper.
    ///
    /// To store a document --- for example, in response to a Save command ---
    /// SwiftUI begins by calling the ``snapshot(contentType:)`` method to get
    /// a copy of the document data in its current state. Then SwiftUI passes
    /// that snapshot to this method, where you serialize it and create or
    /// modify a file wrapper with the serialized data:
    ///
    ///     func fileWrapper(snapshot: Snapshot, configuration: WriteConfiguration) throws -> FileWrapper {
    ///         let data = try JSONEncoder().encode(snapshot)
    ///         return FileWrapper(regularFileWithContents: data)
    ///     }
    ///
    /// SwiftUI disables document edits during the snapshot to ensure that the
    /// document's data remains coherent, but reenables edits during the
    /// serialization operation.
    ///
    /// > Note: SwiftUI calls this method on a background thread. Don't
    ///   make user interface changes from that thread.
    ///
    /// - Parameters:
    ///   - snapshot: The document snapshot to save.
    ///   - configuration: Information about a file that already exists for the
    ///     document, if any.
    ///
    /// - Returns: The destination to serialize the document contents to. The
    ///   value can be a newly created
    ///   <doc://com.apple.documentation/documentation/Foundation/FileWrapper>
    ///   or an update of the one provided in the `configuration` input.
    func fileWrapper(snapshot: Self.Snapshot, configuration: Self.WriteConfiguration) throws -> FileWrapper

    /// The configuration for writing document contents.
    ///
    /// This type is an alias for ``FileDocumentWriteConfiguration``, which
    /// contains a content type and a file wrapper that you use to access the
    /// contents of a document file, if one already exists. You get a value
    /// of this type as an input to the ``fileWrapper(snapshot:configuration:)``
    /// method.
    typealias WriteConfiguration = FileDocumentWriteConfiguration
}

@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension ReferenceFileDocument {

    /// The file types that the document supports saving or exporting to.
    ///
    /// By default, SwiftUI assumes that your document reads and writes the
    /// same set of content types. Only define this property if you need to
    /// indicate a different set of types for writing files. Otherwise, the
    /// default implementation of this property returns the list that you
    /// specify in your implementation of ``readableContentTypes``.
    public static var writableContentTypes: [UTType] { get }
}

/// The properties of an open reference file document.
///
/// You receive an instance of this structure when you create a
/// ``DocumentGroup`` with a reference file type. Use it to access the
/// document in your viewer or editor.
@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@MainActor @preconcurrency public struct ReferenceFileDocumentConfiguration<Document> where Document : ReferenceFileDocument {

    /// The current document model.
    ///
    /// Changes to the document dirty the document state, indicating that it
    /// needs to be saved. SwiftUI doesn't automatically register undo actions.
    @ObservedObject @MainActor @preconcurrency public var document: Document

    @MainActor @preconcurrency public var $document: ObservedObject<Document>.Wrapper { get }

    /// The URL of the open file document.
    @MainActor @preconcurrency public var fileURL: URL?

    /// A Boolean that indicates whether you can edit the document.
    ///
    /// The value is `false` if the document is in viewing mode, or if the
    /// file is not writable.
    @MainActor @preconcurrency public var isEditable: Bool
}

/// An action that initiates a refresh operation.
///
/// When the ``EnvironmentValues/refresh`` environment value contains an
/// instance of this structure, certain built-in views in the corresponding
/// ``Environment`` begin offering a refresh capability. They apply the
/// instance's handler to any refresh operation that the user initiates.
/// By default, the environment value is `nil`, but you can use the
/// ``View/refreshable(action:)`` modifier to create and store a new
/// refresh action that uses the handler that you specify:
///
///     List(mailbox.conversations) { conversation in
///         ConversationCell(conversation)
///     }
///     .refreshable {
///         await mailbox.fetch()
///     }
///
/// On iOS and iPadOS, the ``List`` in the example above offers a
/// pull to refresh gesture because it detects the refresh action. When
/// the user drags the list down and releases, the list calls the action's
/// handler. Because SwiftUI declares the handler as asynchronous, it can
/// safely make long-running asynchronous calls, like fetching network data.
///
/// ### Refreshing custom views
///
/// You can also offer refresh capability in your custom views.
/// Read the ``EnvironmentValues/refresh`` environment value to get the
/// `RefreshAction` instance for a given ``Environment``. If you find
/// a non-`nil` value, change your view's appearance or behavior to offer
/// the refresh to the user, and call the instance to conduct the
/// refresh. You can call the refresh instance directly because it defines
/// a ``RefreshAction/callAsFunction()`` method that Swift calls
/// when you call the instance:
///
///     struct RefreshableView: View {
///         @Environment(\.refresh) private var refresh
///
///         var body: some View {
///             Button("Refresh") {
///                 Task {
///                     await refresh?()
///                 }
///             }
///             .disabled(refresh == nil)
///         }
///     }
///
/// Be sure to call the handler asynchronously by preceding it
/// with `await`. Because the call is asynchronous, you can use
/// its lifetime to indicate progress to the user. For example,
/// you might reveal an indeterminate ``ProgressView`` before
/// calling the handler, and hide it when the handler completes.
///
/// If your code isn't already in an asynchronous context, create a
/// <doc://com.apple.documentation/documentation/Swift/Task> for the
/// method to run in. If you do this, consider adding a way for the
/// user to cancel the task. For more information, see
/// [Concurrency](https://docs.swift.org/swift-book/LanguageGuide/Concurrency.html)
/// in *The Swift Programming Language*.
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public struct RefreshAction : Sendable {

    /// Initiates a refresh action.
    ///
    /// Don't call this method directly. SwiftUI calls it when you
    /// call the ``RefreshAction`` structure that you get from the
    /// ``Environment``:
    ///
    ///     struct RefreshableView: View {
    ///         @Environment(\.refresh) private var refresh
    ///
    ///         var body: some View {
    ///             Button("Refresh") {
    ///                 Task {
    ///                     await refresh?()  // Implicitly calls refresh.callAsFunction()
    ///                 }
    ///             }
    ///             .disabled(refresh == nil)
    ///         }
    ///     }
    ///
    /// For information about how Swift uses the `callAsFunction()` method to
    /// simplify call site syntax, see
    /// [Methods with Special Names](https://docs.swift.org/swift-book/ReferenceManual/Declarations.html#ID622)
    /// in *The Swift Programming Language*.
    /// For information about asynchronous operations in Swift, see
    /// [Concurrency](https://docs.swift.org/swift-book/LanguageGuide/Concurrency.html).
    public func callAsFunction() async
}

/// An action that activates a standard rename interaction.
///
/// Use the ``View/renameAction(_:)`` modifier to configure the rename
/// action in the environment.
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct RenameAction {

    /// Triggers the standard rename action provided through the environment.
    public func callAsFunction()
}

/// A button that triggers a standard rename action.
///
/// A rename button receives its action from the environment. Use the
/// ``View/renameAction(_:)`` modifier to set the action. The
/// system disables the button if you don't define an action.
///
///     struct RowView: View {
///         @State private var text = ""
///         @FocusState private var isFocused: Bool
///
///         var body: some View {
///             TextField(text: $item.name) {
///                 Text("Prompt")
///             }
///             .focused($isFocused)
///             .contextMenu {
///                 RenameButton()
///                 // ... your own custom actions
///             }
///             .renameAction { $isFocused = true }
///     }
///
/// When someone taps the rename button in the context menu, the rename
/// action focuses the text field by setting the `isFocused`
/// property to true.
///
/// You can use this button inside of a navigation title menu and the
/// navigation title modifier automatically configures the environment
/// with the appropriate rename action.
///
///     ContentView()
///         .navigationTitle($contentTitle) {
///             // ... your own custom actions
///             RenameButton()
///         }
///
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct RenameButton<Label> : View where Label : View {

    /// Creates a rename button.
    public init() where Label == Label<Text, Image>

    /// The content and behavior of the view.
    ///
    /// When you implement a custom view, you must implement a computed
    /// `body` property to provide the content for your view. Return a view
    /// that's composed of built-in views that SwiftUI provides, plus other
    /// composite views that you've already defined:
    ///
    ///     struct MyView: View {
    ///         var body: some View {
    ///             Text("Hello, World!")
    ///         }
    ///     }
    ///
    /// For more information about composing views and a view hierarchy,
    /// see <doc:Declaring-a-Custom-View>.
    @MainActor @preconcurrency public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
    public typealias Body = some View
}

/// A gesture that recognizes a rotation motion and tracks the angle of the
/// rotation.
///
/// A rotate gesture tracks how a rotation event sequence changes. To
/// recognize a rotate gesture on a view, create and configure the gesture,
/// and then add it to the view using the ``View/gesture(_:including:)``
/// modifier.
///
/// Add a rotate gesture to a ``Rectangle`` and apply a rotation effect:
///
///     struct RotateGestureView: View {
///         @State private var angle = Angle(degrees: 0.0)
///
///         var rotation: some Gesture {
///             RotateGesture()
///                 .onChanged { value in
///                     angle = value.rotation
///                 }
///         }
///
///         var body: some View {
///             Rectangle()
///                 .frame(width: 200, height: 200, alignment: .center)
///                 .rotationEffect(angle)
///                 .gesture(rotation)
///         }
///     }
@available(iOS 17.0, macOS 14.0, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
public struct RotateGesture : Gesture {

    /// The type representing the gesture's value.
    public struct Value : Equatable, Sendable {

        /// The time associated with the gesture's current event.
        public var time: Date

        /// The relative amount that the gesture has rotated by.
        ///
        /// A value of 30 degrees means that the user has interacted with the
        /// gesture to rotate by 30 degrees relative to the amount before the
        /// gesture.
        public var rotation: Angle

        /// The current rotation velocity.
        public var velocity: Angle

        /// The initial anchor point of the gesture in the modified view's
        /// coordinate space.
        public var startAnchor: UnitPoint

        /// The initial center of the gesture in the modified view's coordinate
        /// space.
        public var startLocation: CGPoint

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: RotateGesture.Value, b: RotateGesture.Value) -> Bool
    }

    /// The minimum delta required before the gesture succeeds.
    public var minimumAngleDelta: Angle

    /// Creates a rotation gesture with a minimum delta for the gesture to
    /// start.
    ///
    /// - Parameter minimumAngleDelta: The minimum delta required before the
    ///   gesture starts. The default value is a one-degree angle.
    public init(minimumAngleDelta: Angle = .degrees(1))

    /// The type of gesture representing the body of `Self`.
    @available(iOS 17.0, macOS 14.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias Body = Never
}

/// A gesture that recognizes a rotation motion and tracks the angle of the
/// rotation.
///
/// A rotation gesture tracks how a rotation event sequence changes. To
/// recognize a rotation gesture on a view, create and configure the gesture,
/// and then add it to the view using the ``View/gesture(_:including:)``
/// modifier.
///
/// Add a rotation gesture to a ``Rectangle`` and apply a rotation effect:
///
///     struct RotationGestureView: View {
///         @State private var angle = Angle(degrees: 0.0)
///
///         var rotation: some Gesture {
///             RotationGesture()
///                 .onChanged { angle in
///                     self.angle = angle
///                 }
///         }
///
///         var body: some View {
///             Rectangle()
///                 .frame(width: 200, height: 200, alignment: .center)
///                 .rotationEffect(self.angle)
///                 .gesture(rotation)
///         }
///     }
@available(iOS, introduced: 13.0, deprecated: 100000.0, renamed: "RotateGesture")
@available(macOS, introduced: 10.15, deprecated: 100000.0, renamed: "RotateGesture")
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@available(visionOS, introduced: 1.0, deprecated: 100000.0, renamed: "RotateGesture")
public struct RotationGesture : Gesture {

    /// The minimum delta required before the gesture succeeds.
    public var minimumAngleDelta: Angle

    /// Creates a rotation gesture with a minimum delta for the gesture to
    /// start.
    ///
    /// - Parameter minimumAngleDelta: The minimum delta required before the
    ///   gesture starts. The default value is a one-degree angle.
    public init(minimumAngleDelta: Angle = .degrees(1))

    /// The type representing the gesture's value.
    public typealias Value = Angle

    /// The type of gesture representing the body of `Self`.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, renamed: "RotateGesture")
    @available(tvOS, unavailable, renamed: "RotateGesture")
    @available(watchOS, unavailable, renamed: "RotateGesture")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, renamed: "RotateGesture")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, renamed: "RotateGesture")
    public typealias Body = Never
}

/// A text field style with a system-defined rounded border.
///
/// You can also use ``TextFieldStyle/roundedBorder`` to construct this style.
@available(iOS 13.0, macOS 10.15, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct RoundedBorderTextFieldStyle : TextFieldStyle {

    public init()
}

/// A part of an app's user interface with a life cycle managed by the
/// system.
///
/// You create an ``SwiftUI/App`` by combining one or more instances
/// that conform to the `Scene` protocol in the app's
/// ``SwiftUI/App/body-swift.property``. You can use the built-in scenes that
/// SwiftUI provides, like ``SwiftUI/WindowGroup``, along with custom scenes
/// that you compose from other scenes. To create a custom scene, declare a
/// type that conforms to the `Scene` protocol. Implement the required
/// ``SwiftUI/Scene/body-swift.property`` computed property and provide the
/// content for your custom scene:
///
///     struct MyScene: Scene {
///         var body: some Scene {
///             WindowGroup {
///                 MyRootView()
///             }
///         }
///     }
///
/// A scene acts as a container for a view hierarchy that you want to display
/// to the user. The system decides when and how to present the view hierarchy
/// in the user interface in a way that's platform-appropriate and dependent
/// on the current state of the app. For example, for the window group shown
/// above, the system lets the user create or remove windows that contain
/// `MyRootView` on platforms like macOS and iPadOS. On other platforms, the
/// same view hierarchy might consume the entire display when active.
///
/// Read the ``SwiftUI/EnvironmentValues/scenePhase`` environment
/// value from within a scene or one of its views to check whether a scene is
/// active or in some other state. You can create a property that contains the
/// scene phase, which is one of the values in the ``SwiftUI/ScenePhase``
/// enumeration, using the ``SwiftUI/Environment`` attribute:
///
///     struct MyScene: Scene {
///         @Environment(\.scenePhase) private var scenePhase
///
///         // ...
///     }
///
/// The `Scene` protocol provides scene modifiers, defined as protocol methods
/// with default implementations, that you use to configure a scene. For
/// example, you can use the ``SwiftUI/Scene/onChange(of:perform:)`` modifier to
/// trigger an action when a value changes. The following code empties a cache
/// when all of the scenes in the window group have moved to the background:
///
///     struct MyScene: Scene {
///         @Environment(\.scenePhase) private var scenePhase
///         @StateObject private var cache = DataCache()
///
///         var body: some Scene {
///             WindowGroup {
///                 MyRootView()
///             }
///             .onChange(of: scenePhase) { newScenePhase in
///                 if newScenePhase == .background {
///                     cache.empty()
///                 }
///             }
///         }
///     }
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
@MainActor @preconcurrency public protocol Scene {

    /// The type of scene that represents the body of this scene.
    ///
    /// When you create a custom scene, Swift infers this type from your
    /// implementation of the required ``SwiftUI/Scene/body-swift.property``
    /// property.
    associatedtype Body : Scene

    /// The content and behavior of the scene.
    ///
    /// For any scene that you create, provide a computed `body` property that
    /// defines the scene as a composition of other scenes. You can assemble a
    /// scene from built-in scenes that SwiftUI provides, as well as other
    /// scenes that you've defined.
    ///
    /// Swift infers the scene's ``SwiftUI/Scene/Body-swift.associatedtype``
    /// associated type based on the contents of the `body` property.
    @SceneBuilder @MainActor @preconcurrency var body: Self.Body { get }
}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Scene {

    /// Sets the restoration behavior for this scene.
    ///
    /// Use this scene modifier to apply a value of this type to a ``Scene`` you
    /// define in your ``App`` declaration. The value you specify determines how
    /// the system will restore windows from a previous run of your application.
    ///
    /// For example, you may have a scene that you do not wish to be restored on
    /// launch:
    ///
    ///     @main
    ///     struct MyApp: App {
    ///         var body: some Scene {
    ///             WindowGroup {
    ///                 ContentView()
    ///             }
    ///             Window(id: "network-test", "Network Connection Test") {
    ///                 NetworkTestView()
    ///             }
    ///             .restorationBehavior(.disabled)
    ///         }
    ///     }
    ///
    /// The default value for all scenes if you do not apply the modifier is
    /// ``SceneRestorationBehavior/automatic``. With that strategy, scenes will
    /// restore themselves depending on the default behavior for the platform.
    nonisolated public func restorationBehavior(_ behavior: SceneRestorationBehavior) -> some Scene

}

@available(iOS 17.0, macOS 13.0, visionOS 1.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension Scene {

    /// Sets the kind of resizability to use for a window.
    ///
    /// Use this scene modifier to apply a value of type ``WindowResizability``
    /// to a ``Scene`` that you define in your ``App`` declaration.
    /// The value that you specify indicates the strategy the system uses to
    /// place minimum and maximum size restrictions on windows that it creates
    /// from that scene.
    ///
    /// For example, you can create a window group that people can resize to
    /// between 100 and 400 points in both dimensions by applying both a frame
    /// with those constraints to the scene's content, and the
    /// ``WindowResizability/contentSize`` resizability to the scene:
    ///
    ///     @main
    ///     struct MyApp: App {
    ///         var body: some Scene {
    ///             WindowGroup {
    ///                 ContentView()
    ///                     .frame(
    ///                         minWidth: 100, maxWidth: 400,
    ///                         minHeight: 100, maxHeight: 400)
    ///             }
    ///             .windowResizability(.contentSize)
    ///         }
    ///     }
    ///
    /// The default value for all scenes if you don't apply the modifier is
    /// ``WindowResizability/automatic``. With that strategy, ``Settings``
    /// windows use the ``WindowResizability/contentSize`` strategy, while
    /// all others use ``WindowResizability/contentMinSize``.
    ///
    /// - Parameter resizability: The resizability to use for windows created by
    ///   this scene.
    ///
    /// - Returns: A scene that uses the specified resizability strategy.
    nonisolated public func windowResizability(_ resizability: WindowResizability) -> some Scene

}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Scene {

    /// Configures the role for windows derived from `self` when
    /// participating in a managed window context, such as full screen or
    /// Stage Manager.
    ///
    /// By default, the type of `Scene` and its placement within the app's
    /// definition will determine the behavior of its windows within a window
    /// management context.
    ///
    /// You can use this modifier to override the default behaivor.
    ///
    /// For example, you can specify that a secondary `Window` scene should use
    /// the principal behavior for full screen and Stage Manager:
    ///
    ///     struct MyApp: App {
    ///         var body: some Scene {
    ///             WindowGroup {
    ///                 ContentView()
    ///             }
    ///             Window("Organizer", id: "organizer") {
    ///                 OrganizerView()
    ///             }
    ///             .windowManagerRole(.principal)
    ///         }
    ///     }
    ///
    nonisolated public func windowManagerRole(_ role: WindowManagerRole) -> some Scene

}

@available(iOS 17.0, macOS 13.0, visionOS 1.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension Scene {

    /// Sets a default size for a window.
    ///
    /// Use this scene modifier to indicate a default initial size for a new
    /// window that the system creates from a ``Scene`` declaration. For
    /// example, you can request that new windows that a ``WindowGroup``
    /// generates occupy 600 points in the x-dimension and 400 points in
    /// the y-dimension:
    ///
    ///     @main
    ///     struct MyApp: App {
    ///         var body: some Scene {
    ///             WindowGroup {
    ///                 ContentView()
    ///             }
    ///             .defaultSize(CGSize(width: 600, height: 400))
    ///         }
    ///     }
    ///
    /// The size that you specify acts only as a default for when the window
    /// first appears. People can later resize the window using interface
    /// controls that the system provides. Also, during state restoration,
    /// the system restores windows to their most recent size rather than
    /// the default size.
    ///
    /// If you specify a default size that's outside the range of the window's
    /// inherent resizability in one or both dimensions, the system clamps the
    /// affected dimension to keep it in range. You can configure the
    /// resizability of a scene using the ``Scene/windowResizability(_:)``
    /// modifier.
    ///
    /// The default size modifier affects any scene type that creates windows
    /// in macOS, namely:
    ///
    ///  * ``WindowGroup``
    ///  * ``Window``
    ///  * ``DocumentGroup``
    ///  * ``Settings``
    ///
    /// If you want to specify the input directly in terms of width and height,
    /// use ``Scene/defaultSize(width:height:)`` instead.
    ///
    /// - Parameter size: The default size for new windows created from a scene.
    ///
    /// - Returns: A scene that uses a default size for new windows.
    nonisolated public func defaultSize(_ size: CGSize) -> some Scene


    /// Sets a default width and height for a window.
    ///
    /// Use this scene modifier to indicate a default initial size for a new
    /// window that the system creates from a ``Scene`` declaration. For
    /// example, you can request that new windows that a ``WindowGroup``
    /// generates occupy 600 points in the x-dimension and 400 points in
    /// the y-dimension:
    ///
    ///     @main
    ///     struct MyApp: App {
    ///         var body: some Scene {
    ///             WindowGroup {
    ///                 ContentView()
    ///             }
    ///             .defaultSize(width: 600, height: 400)
    ///         }
    ///     }
    ///
    /// The size that you specify acts only as a default for when the window
    /// first appears. People can later resize the window using interface
    /// controls that the system provides. Also, during state restoration,
    /// the system restores windows to their most recent size rather than
    /// the default size.
    ///
    /// If you specify a default size that's outside the range of the window's
    /// inherent resizability in one or both dimensions, the system clamps the
    /// affected dimension to keep it in range. You can configure the
    /// resizability of a scene using the ``Scene/windowResizability(_:)``
    /// modifier.
    ///
    /// The default size modifier affects any scene type that creates windows
    /// in macOS, namely:
    ///
    ///  * ``WindowGroup``
    ///  * ``Window``
    ///  * ``DocumentGroup``
    ///  * ``Settings``
    ///
    /// If you want to specify the size input in terms of size instance,
    /// use ``Scene/defaultSize(_:)`` instead.
    ///
    /// - Parameter width: The default width for windows created from a scene.
    /// - Parameter height: The default height for windows created from a scene.
    ///
    /// - Returns: A scene that uses a default size for new windows.
    nonisolated public func defaultSize(width: CGFloat, height: CGFloat) -> some Scene

}

extension Scene {

    /// Sets the environment value of the specified key path to the given value.
    ///
    /// Use this modifier to set one of the writable properties of the
    /// ``EnvironmentValues`` structure, including custom values that you
    /// create. For example, you can create a custom environment key
    /// `styleOverrides` to set a value that represents style settings that for
    /// the entire app:
    ///
    ///     WindowGroup {
    ///         ContentView()
    ///     }
    ///     .environment(\.styleOverrides, StyleOverrides())
    ///
    /// You then read the value inside `ContentView` or one of its descendants
    /// using the ``Environment`` property wrapper:
    ///
    ///     struct MyView: View {
    ///         @Environment(\.styleOverrides) var styleOverrides: StyleOverrides
    ///
    ///         var body: some View { ... }
    ///     }
    ///
    /// This modifier affects the given scene,
    /// as well as that scene's descendant views. It has no effect
    /// outside the view hierarchy on which you call it.
    ///
    /// - Parameters:
    ///   - keyPath: A key path that indicates the property of the
    ///     ``EnvironmentValues`` structure to update.
    ///   - value: The new value to set for the item specified by `keyPath`.
    ///
    /// - Returns: A view that has the given value set in its environment.
    @available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
    nonisolated public func environment<V>(_ keyPath: WritableKeyPath<EnvironmentValues, V>, _ value: V) -> some Scene

}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension Scene {

    /// Transforms the environment value of the specified key path with the
    /// given function.
    nonisolated public func transformEnvironment<V>(_ keyPath: WritableKeyPath<EnvironmentValues, V>, transform: @escaping (inout V) -> Void) -> some Scene

}

extension Scene {

    /// Places an observable object in the scene's environment.
    ///
    /// Use this modifier to place an object that you declare with the
    /// <doc://com.apple.documentation/documentation/Observation/Observable()>
    /// macro into a scene's environment. For example, you can add an instance
    /// of a custom observable `Profile` class to the environment of a
    /// ``WindowGroup`` scene:
    ///
    ///     @Observable class Profile { ... }
    ///
    ///     @main
    ///     struct MyApp: App {
    ///         var body: some View {
    ///             WindowGroup {
    ///                 ContentView()
    ///             }
    ///             .environment(Profile.currentProfile)
    ///         }
    ///     }
    ///
    /// You then read the object inside `ContentView` or one of its descendants
    /// using the ``Environment`` property wrapper:
    ///
    ///     struct ContentView: View {
    ///         @Environment(Profile.self) private var currentProfile: Profile
    ///
    ///         var body: some View { ... }
    ///     }
    ///
    /// This modifier affects the given scene, as well as the scene's descendant
    /// views. It has no effect outside the view hierarchy on which you call it.
    /// The environment of a given view hierarchy holds only one observable
    /// object of a given type.
    ///
    /// - Note: This modifier takes an object that conforms to the
    ///   <doc://com.apple.documentation/documentation/Observation/Observable>
    ///   protocol. To add environment objects that conform to the
    ///   <doc://com.apple.documentation/documentation/Combine/ObservableObject>
    ///   protocol, use ``Scene/environmentObject(_:)`` instead.
    ///
    /// - Parameter object: The object to set for this object's type in the
    ///   environment, or `nil` to clear an object of this type from the
    ///   environment.
    ///
    /// - Returns: A scene that has the specified object in its environment.
    @available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
    nonisolated public func environment<T>(_ object: T?) -> some Scene where T : AnyObject, T : Observable

}

extension Scene {

    /// Supplies an `ObservableObject` to a view subhierarchy.
    ///
    /// The object can be read by any child by using `EnvironmentObject`:
    ///
    ///     final class Profile: ObservableObject { ... }
    ///
    ///     @main
    ///     struct MyApp: App {
    ///         var body: some View {
    ///             WindowGroup {
    ///                 ContentView()
    ///             }
    ///             .environment(ProfileService.currentProfile)
    ///         }
    ///     }
    ///
    /// You then read the object inside `ContentView` or one of its descendants
    /// using the ``EnvironmentObject`` property wrapper:
    ///
    ///     struct ContentView: View {
    ///         @EnvironmentObject private var currentAccount: Account
    ///
    ///         var body: some View { ... }
    ///     }
    ///
    /// - Parameter object: the object to store and make available to
    ///   the scene's subhierarchy.
    @available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
    nonisolated public func environmentObject<T>(_ object: T) -> some Scene where T : ObservableObject

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension Scene {

    /// The default store used by `AppStorage` contained within the scene and
    /// its view content.
    ///
    /// If unspecified, the default store for a view hierarchy is
    /// `UserDefaults.standard`, but can be set a to a custom one. For example,
    /// sharing defaults between an app and an extension can override the
    /// default store to one created with `UserDefaults.init(suiteName:_)`.
    ///
    /// - Parameter store: The user defaults to use as the default
    ///   store for `AppStorage`.
    nonisolated public func defaultAppStorage(_ store: UserDefaults) -> some Scene

}

@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension Scene {

    /// Specifies the external events for which SwiftUI opens a new instance
    /// of the modified scene.
    ///
    /// When your app receives an external event like a user activity or a
    /// URL, SwiftUI routes the event to a scene for processing. SwiftUI
    /// selects the scene that receives the event according to the following
    /// rules, which it evaluates in order until it finds a destination scene:
    ///
    /// * On platforms that support only a single scene per app, send
    ///   the event to the one open scene.
    /// * Find an open scene that indicates it prefers to or can handle the
    ///   event, if any, and send the event to that scene. You use the
    ///   ``View/handlesExternalEvents(preferring:allowing:)`` view modifier
    ///   on a view inside the scene to register this preference.
    /// * Find a scene declaration with a `handlesExternalEvents(matching:)`
    ///   scene modifier containing `conditions` that match the external event.
    ///   Create a new instance of the first scene that matches and route the
    ///   event there.
    /// * Find the first scene declaration that doesn't have the scene modifier.
    ///   Create a new instance of this scene and route the event there.
    ///
    /// Make sure that at least one of these rules succeeds in your app for all
    /// events that your app claims to handle. Also, make sure
    /// that the scene that receives an event actually handles it. For example,
    /// be sure that a scene that receives user activities handles them with an
    /// appropriate ``View/onContinueUserActivity(_:perform:)`` view modifier.
    ///
    /// Don't confuse the `handlesExternalEvents(matching:)` scene
    /// modifier with the ``View/handlesExternalEvents(preferring:allowing:)``
    /// _view_ modifier. You use the scene modifier to help SwiftUI choose a
    /// new scene to open when no open scene handles an external event,
    /// whereas you use the view modifier to indicate that an open scene can
    /// or prefers to handle certain events.
    ///
    /// ### Matching an event
    ///
    /// To find a scene type that handles a particular external event, SwiftUI
    /// compares a property of the event against the strings that you specify
    /// in the `conditions` set. SwiftUI examines the following event
    /// properties to perform the comparison:
    ///
    /// * For an
    ///   <doc://com.apple.documentation/documentation/Foundation/NSUserActivity>,
    ///   like when your app handles Handoff, SwiftUI uses the activity's
    ///   <doc://com.apple.documentation/documentation/Foundation/NSUserActivity/3238062-targetContentIdentifier>
    ///   property, or if that's `nil`, its
    ///   <doc://com.apple.documentation/documentation/Foundation/NSUserActivity/1418086-webpageurl>
    ///   property rendered as an
    ///   <doc://com.apple.documentation/documentation/Foundation/URL/1779984-absoluteString>.
    /// * For a
    ///   <doc://com.apple.documentation/documentation/Foundation/URL>,
    ///   like when another process opens a URL that your app handles,
    ///   SwiftUI uses the URL's
    ///   <doc://com.apple.documentation/documentation/Foundation/URL/1779984-absoluteString>.
    ///
    /// An empty set of strings never matches. Similarly, empty strings never
    /// match. Conversely, as a special case, the string that contains only an
    /// asterisk (`*`) matches anything. The modifier performs string
    /// comparisons that are case and diacritic insensitive.
    ///
    /// > Important: ``DocumentGroup`` scenes ignore this modifier. Instead,
    ///   document scenes decide whether to open a new scene to handle an
    ///   external event by comparing the incoming URL or user activity's
    ///   <doc://com.apple.documentation/documentation/Foundation/NSUserActivity/1418086-webpageurl>
    ///   against the document group's supported types.
    ///
    /// ### Choosing a window to open
    ///
    /// The following example shows an app with a photo browser scene
    /// that displays a collection of photos, and a photo detail scene that
    /// enables closer examination of a particular photo:
    ///
    ///     @main
    ///     struct MyPhotos: App {
    ///         var body: some Scene {
    ///             WindowGroup {
    ///                 PhotosBrowser()
    ///             }
    ///
    ///             WindowGroup("Photo") {
    ///                 PhotoDetail()
    ///             }
    ///             .handlesExternalEvents(matching: ["photoIdentifier="])
    ///         }
    ///     }
    ///
    /// The app uses the `handlesExternalEvents(matching:)` modifier on the
    /// second scene to ensure that an external event with an identifier
    /// that contains the string `photoIdentifier=` creates a new scene of
    /// the second type. Other events, if not handled by an open scene,
    /// cause the creation of a new browser window instead.
    ///
    /// - Parameter conditions: A set of strings that SwiftUI compares against
    ///   the incoming user activity or URL to see if SwiftUI
    ///   can open a new scene instance to handle the external event.
    ///
    /// - Returns: A scene type that limits the kinds of external events for
    ///   which SwiftUI opens a new instance.
    nonisolated public func handlesExternalEvents(matching conditions: Set<String>) -> some Scene

}

extension Scene {

    /// Sets the preferred visibility of the non-transient system views
    /// overlaying the app.
    ///
    /// Use this modifier to influence the appearance of system overlays
    /// in your app. The behavior varies by platform.
    ///
    /// In iOS, the following example hides every persistent system overlay.
    /// In visionOS 2 and later, the SharePlay Indicator hides if the
    /// scene is shared through SharePlay, or not shared at all.
    /// During screen sharing, the indicator always remains visible.
    /// The Home indicator doesn't appear without specific user intent
    /// when you set visibility to ``hidden``. For a ``WindowGroup``,
    /// the modifier affects the visibility of the window chrome. For an
    /// ``ImmersiveSpace``, it affects the Home indicator.
    ///
    ///     struct ImmersiveView: View {
    ///         var body: some View {
    ///             Text("Maximum immersion")
    ///                 .persistentSystemOverlays(.hidden)
    ///         }
    ///     }
    ///
    /// > Note: You can indicate a preference with this modifier, but the system
    /// might or might not be able to honor that preference.
    ///
    /// Affected non-transient system views can include, but are not limited to:
    /// - The Home indicator.
    /// - The SharePlay indicator.
    /// - The Multitasking Controls button and Picture in Picture on iPad.
    ///
    /// - Parameter visibility: A value that indicates the visibility of the
    /// non-transient system views overlaying the app.
    @available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
    nonisolated public func persistentSystemOverlays(_ preferredVisibility: Visibility) -> some Scene

}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension Scene {

    /// Adds an action to perform when the given value changes.
    ///
    /// Use this modifier to trigger a side effect when a value changes, like
    /// the value associated with an ``SwiftUI/Environment`` key or a
    /// ``SwiftUI/Binding``. For example, you can clear a cache when you notice
    /// that a scene moves to the background:
    ///
    ///     struct MyScene: Scene {
    ///         @Environment(\.scenePhase) private var scenePhase
    ///         @StateObject private var cache = DataCache()
    ///
    ///         var body: some Scene {
    ///             WindowGroup {
    ///                 MyRootView(cache: cache)
    ///             }
    ///             .onChange(of: scenePhase) { oldScenePhase, newScenePhase in
    ///                 if newScenePhase == .background {
    ///                     cache.empty()
    ///                 }
    ///             }
    ///         }
    ///     }
    ///
    /// The system may call the action closure on the main actor, so avoid
    /// long-running tasks in the closure. If you need to perform such tasks,
    /// detach an asynchronous background task:
    ///
    ///     .onChange(of: scenePhase) { oldScenePhase, newScenePhase in
    ///         if newScenePhase == .background {
    ///             Task.detached(priority: .background) {
    ///                 // ...
    ///             }
    ///         }
    ///     }
    ///
    /// When the value changes, the new version of the closure will be called,
    /// so any captured values will have their values from the time that the
    /// observed value has its new value. The system passes the old and new
    /// observed values into the closure.
    ///
    /// - Parameters:
    ///   - value: The value to check when determining whether to run the
    ///     closure. The value must conform to the
    ///     <doc://com.apple.documentation/documentation/Swift/Equatable>
    ///     protocol.
    ///   - initial: Whether the action should be run when this scene initially
    ///     appears.
    ///   - action: A closure to run when the value changes.
    ///   - oldValue: The old value that failed the comparison check (or the
    ///     initial value when requested).
    ///   - newValue: The new value that failed the comparison check.
    ///
    /// - Returns: A scene that triggers an action in response to a change.
    nonisolated public func onChange<V>(of value: V, initial: Bool = false, _ action: @escaping (_ oldValue: V, _ newValue: V) -> Void) -> some Scene where V : Equatable


    /// Adds an action to perform when the given value changes.
    ///
    /// Use this modifier to trigger a side effect when a value changes, like
    /// the value associated with an ``SwiftUI/Environment`` key or a
    /// ``SwiftUI/Binding``. For example, you can clear a cache when you notice
    /// that a scene moves to the background:
    ///
    ///     struct MyScene: Scene {
    ///         @Environment(\.locale) private var locale
    ///         @StateObject private var cache = LocalizationDataCache()
    ///
    ///         var body: some Scene {
    ///             WindowGroup {
    ///                 MyRootView(cache: cache)
    ///             }
    ///             .onChange(of: locale) {
    ///                 cache.empty()
    ///             }
    ///         }
    ///     }
    ///
    /// The system may call the action closure on the main actor, so avoid
    /// long-running tasks in the closure. If you need to perform such tasks,
    /// detach an asynchronous background task:
    ///
    ///     .onChange(of: locale) {
    ///         Task.detached(priority: .background) {
    ///             // ...
    ///         }
    ///     }
    ///
    /// When the value changes, the new version of the closure will be called,
    /// so any captured values will have their values from the time that the
    /// observed value has its new value.
    ///
    /// - Parameters:
    ///   - value: The value to check when determining whether to run the
    ///     closure. The value must conform to the
    ///     <doc://com.apple.documentation/documentation/Swift/Equatable>
    ///     protocol.
    ///   - initial: Whether the action should be run when this scene initially
    ///     appears.
    ///   - action: A closure to run when the value changes.
    ///
    /// - Returns: A scene that triggers an action in response to a change.
    nonisolated public func onChange<V>(of value: V, initial: Bool = false, _ action: @escaping () -> Void) -> some Scene where V : Equatable

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension Scene {

    /// Adds an action to perform when the given value changes.
    ///
    /// Use this modifier to trigger a side effect when a value changes, like
    /// the value associated with an ``SwiftUI/Environment`` value or a
    /// ``SwiftUI/Binding``. For example, you can clear a cache when you notice
    /// that a scene moves to the background:
    ///
    ///     struct MyScene: Scene {
    ///         @Environment(\.scenePhase) private var scenePhase
    ///         @StateObject private var cache = DataCache()
    ///
    ///         var body: some Scene {
    ///             WindowGroup {
    ///                 MyRootView()
    ///             }
    ///             .onChange(of: scenePhase) { newScenePhase in
    ///                 if newScenePhase == .background {
    ///                     cache.empty()
    ///                 }
    ///             }
    ///         }
    ///     }
    ///
    /// The system may call the action closure on the main actor, so avoid
    /// long-running tasks in the closure. If you need to perform such tasks,
    /// detach an asynchronous background task:
    ///
    ///     .onChange(of: scenePhase) { newScenePhase in
    ///         if newScenePhase == .background {
    ///             Task.detached(priority: .background) {
    ///                 // ...
    ///             }
    ///         }
    ///     }
    ///
    /// The system passes the new value into the closure. If you need the old
    /// value, capture it in the closure.
    ///
    /// Important: This modifier is deprecated and has been replaced with new
    /// versions that include either zero or two parameters within the closure,
    /// unlike this version that includes one parameter. This deprecated version
    /// and the new versions behave differently with respect to how they execute
    /// the action closure, specifically when the closure captures other values.
    /// Using the deprecated API, the closure is run with captured values that
    /// represent the "old" state. With the replacement API, the closure is run
    /// with captured values that represent the "new" state, which makes it
    /// easier to correctly perform updates that rely on supplementary values
    /// (that may or may not have changed) in addition to the changed value that
    /// triggered the action.
    ///
    /// - Important: This modifier is deprecated and has been replaced with new
    ///   versions that include either zero or two parameters within the
    ///   closure, unlike this version that includes one parameter. This
    ///   deprecated version and the new versions behave differently with
    ///   respect to how they execute the action closure, specifically when the
    ///   closure captures other values. Using the deprecated API, the closure
    ///   is run with captured values that represent the "old" state. With the
    ///   replacement API, the closure is run with captured values that
    ///   represent the "new" state, which makes it easier to correctly perform
    ///   updates that rely on supplementary values (that may or may not have
    ///   changed) in addition to the changed value that triggered the action.
    ///
    /// - Parameters:
    ///   - value: The value to check when determining whether to run the
    ///     closure. The value must conform to the
    ///     <doc://com.apple.documentation/documentation/Swift/Equatable>
    ///     protocol.
    ///   - action: A closure to run when the value changes. The closure
    ///     provides a single `newValue` parameter that indicates the changed
    ///     value.
    ///
    /// - Returns: A scene that triggers an action in response to a change.
    @available(iOS, deprecated: 17.0, message: "Use `onChange` with a two or zero parameter action closure instead.")
    @available(macOS, deprecated: 14.0, message: "Use `onChange` with a two or zero parameter action closure instead.")
    @available(tvOS, deprecated: 17.0, message: "Use `onChange` with a two or zero parameter action closure instead.")
    @available(watchOS, deprecated: 10.0, message: "Use `onChange` with a two or zero parameter action closure instead.")
    @available(visionOS, deprecated: 1.0, message: "Use `onChange` with a two or zero parameter action closure instead.")
    @inlinable nonisolated public func onChange<V>(of value: V, perform action: @escaping (_ newValue: V) -> Void) -> some Scene where V : Equatable

}

@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension Scene {

    /// Adds commands to the scene.
    ///
    /// Commands are realized in different ways on different platforms. On
    /// macOS, the main menu uses the available command menus and groups to
    /// organize its main menu items. Each menu is represented as a top-level
    /// menu bar menu, and each command group has a corresponding set of menu
    /// items in one of the top-level menus, delimited by separator menu items.
    ///
    /// On iPadOS, commands with keyboard shortcuts are exposed in the shortcut
    /// discoverability HUD that users see when they hold down the Command ()
    /// key.
    nonisolated public func commands<Content>(@CommandsBuilder content: () -> Content) -> some Scene where Content : Commands

}

@available(iOS 18.1, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension Scene {

    /// Adds to a `DocumentGroupLaunchScene` actions that accept
    /// a list of selected files as their parameter.
    ///
    /// The actions are displayed in the document browser navigation bar
    /// when a document browser is in Select mode, and also added to
    /// context menu for the file items.
    ///
    /// - Parameters:
    ///   - menu: Items representing the content of the menu.
    @MainActor @preconcurrency public func documentBrowserContextMenu(@ViewBuilder _ menu: @escaping ([URL]?) -> some View) -> some Scene

}

@available(iOS 16.0, macOS 13.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension Scene {

    /// Removes all commands defined by the modified scene.
    ///
    /// `WindowGroup`, `Window`, and other scene types all have an associated
    /// set of commands that they include by default. Apply this modifier to a
    /// scene to exclude those commands.
    ///
    /// For example, the following code adds a scene for presenting the details
    /// of an individual data model in a separate window. To ensure that the
    /// window can only appear programmatically, we remove the scene's commands,
    /// including File > New Note Window.
    ///
    ///     @main
    ///     struct Example: App {
    ///         var body: some Scene {
    ///             ...
    ///
    ///             WindowGroup("Note", id: "note", for: Note.ID.self) {
    ///                 NoteDetailView(id: $0)
    ///             }
    ///             .commandsRemoved()
    ///         }
    ///     }
    ///
    /// - Returns: A scene that excludes any commands defined by its children.
    nonisolated public func commandsRemoved() -> some Scene


    /// Replaces all commands defined by the modified scene with the commands
    /// from the builder.
    ///
    /// `WindowGroup`, `Window`, and other scene types all have an associated
    /// set of commands that they include by default. Apply this modifier to a
    /// scene to replace those commands with the output from the given builder.
    ///
    /// For example, the following code adds a scene for showing the contents of
    /// the pasteboard in a dedicated window. We replace the scene's default
    /// Window > Clipboard menu command with a custom Edit > Show Clipboard
    /// command that we place next to the other pasteboard commands.
    ///
    ///     @main
    ///     struct Example: App {
    ///         @Environment(\.openWindow) var openWindow
    ///
    ///         var body: some Scene {
    ///             ...
    ///
    ///             Window("Clipboard", id: "clipboard") {
    ///                 ClipboardContentView()
    ///             }
    ///             .commandsReplaced {
    ///                 CommandGroup(after: .pasteboard) {
    ///                     Section {
    ///                         Button("Show Clipboard") {
    ///                             openWindow(id: "clipboard")
    ///                         }
    ///                     }
    ///                 }
    ///             }
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - content: A `Commands` builder whose output will be used to replace
    ///     the commands normally provided by the modified scene.
    ///
    /// - Returns: A scene that replaces any commands defined by its children
    ///   with alternative content.
    nonisolated public func commandsReplaced<Content>(@CommandsBuilder content: () -> Content) -> some Scene where Content : Commands

}

@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Scene {

    /// Runs the specified action when the system provides a background task.
    ///
    /// When the system wakes your app or extension for one or more background
    /// tasks, it will call any actions associated with matching tasks. When
    /// your async actions return, the system put your app back into a suspended
    /// state. The system considers the task completed when the action closure
    /// that you provide returns. If the action closure has not returned when
    /// the task runs out of time to complete, the system cancels the task. Use
    /// <doc://com.apple.documentation/documentation/Swift/withTaskCancellationHandler(operation:onCancel:)>
    /// to observe whether the task is low on runtime.
    ///
    ///     /// An example of a Weather Application.
    ///     struct WeatherApp: App {
    ///         var body: some Scene {
    ///             WindowGroup {
    ///                 Text("Responds to App Refresh")
    ///             }
    ///             .backgroundTask(.appRefresh("WEATHER_DATA")) {
    ///                 await updateWeatherData()
    ///             }
    ///         }
    ///         func updateWeatherData() async {
    ///             // fetches new weather data and updates app state
    ///         }
    ///     }
    ///
    ///
    /// - Parameters:
    ///   - task: The type of task with which to associate the provided action.
    ///   - action: An async closure that the system runs for the specified task
    ///     type.
    nonisolated public func backgroundTask<D, R>(_ task: BackgroundTask<D, R>, action: @escaping @Sendable (D) async -> R) -> some Scene where D : Sendable, R : Sendable

}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Scene {

    /// Sets the label style of items in a toolbar.
    ///
    /// Use this modifier to set a static ``ToolbarLabelStyle`` the toolbar should use. The style will
    /// not be configurable by the user.
    ///
    ///         @main
    ///         struct MyApp: App {
    ///             var body: some Scene {
    ///                 WindowGroup {
    ///                     ContentView()
    ///                         .toolbar(id: "browserToolbar") {
    ///                             ...
    ///                         }
    ///                 }
    ///                 .windowToolbarLabelStyle(fixed: .iconOnly)
    ///             }
    ///         }
    ///
    /// - Parameter toolbarLabelStyle: The style to apply.
    nonisolated public func windowToolbarLabelStyle(fixed: ToolbarLabelStyle) -> some Scene


    /// Sets the label style of items in a toolbar and enables user customization.
    ///
    /// Use this modifier to bind a ``ToolbarLabelStyle`` to ``AppStorage``.
    /// The toolbar will default to the label style specified but will also be user configurable.
    ///
    ///         @main
    ///         struct MyApp: App {
    ///             @AppStorage("ToolbarLabelStyle")
    ///             private var labelStyle: ToolbarLabelStyle = .iconOnly
    ///
    ///             var body: some Scene {
    ///                 WindowGroup {
    ///                     ContentView()
    ///                         .toolbar(id: "browserToolbar") {
    ///                             ...
    ///                         }
    ///                 }
    ///                 .windowToolbarLabelStyle($labelStyle)
    ///             }
    ///         }
    ///
    /// - Parameter toolbarLabelStyle: The label style to apply.
    nonisolated public func windowToolbarLabelStyle(_ toolbarLabelStyle: Binding<ToolbarLabelStyle>) -> some Scene

}

/// A result builder for composing a collection of scenes into a single
/// composite scene.
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, visionOS 1.0, *)
@resultBuilder public struct SceneBuilder {

    /// Builds an expression within the builder.
    public static func buildExpression<Content>(_ content: Content) -> Content where Content : Scene

    /// Passes a single scene written as a child scene through unmodified.
    public static func buildBlock<Content>(_ content: Content) -> Content where Content : Scene

    public static func buildBlock<each Content>(_ content: repeat each Content) -> some Scene where repeat each Content : Scene

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, visionOS 1.0, *)
extension SceneBuilder {

    /// Produces an optional scene for conditional statements in multi-statement
    /// closures that's only visible when the condition evaluates to true.
    ///
    /// Conditional statements in a ``SceneBuilder`` can contain an `if` statement
    /// but not an `else` statement, and the condition can only perform a compiler
    /// check for availability, like in the following code:
    ///
    ///     var body: some Scene {
    ///         if #available(iOS 16, *) {
    ///             WindowGroup {
    ///                 ContentView()
    ///             }
    ///         }
    ///     }
    public static func buildOptional(_ scene: (any Scene & _LimitedAvailabilitySceneMarker)?) -> some Scene


    /// Processes scene content for a conditional compiler-control statement
    /// that performs an availability check.
    @available(iOS 16.1, macOS 13.0, watchOS 9.1, tvOS 16.1, visionOS 1.0, *)
    public static func buildLimitedAvailability(_ scene: some Scene) -> any Scene & _LimitedAvailabilitySceneMarker
}

/// The padding used to space a view from its containing scene.
///
/// Add scene padding to a view using the ``View/scenePadding(_:edges:)``
/// modifier.
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct ScenePadding : Equatable, Sendable {

    /// The minimum scene padding value.
    ///
    /// In macOS, this value represents the recommended spacing for the root
    /// view of a window. In watchOS, this represents the horizontal spacing
    /// that you use to align your view with the title of a navigation view.
    public static let minimum: ScenePadding

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ScenePadding, b: ScenePadding) -> Bool
}

/// An indication of a scene's operational state.
///
/// The system moves your app's ``Scene`` instances through phases that reflect
/// a scene's operational state. You can trigger actions when the phase changes.
/// Read the current phase by observing the ``EnvironmentValues/scenePhase``
/// value in the ``Environment``:
///
///     @Environment(\.scenePhase) private var scenePhase
///
/// How you interpret the value depends on where it's read from.
/// If you read the phase from inside a ``View`` instance, you obtain a value
/// that reflects the phase of the scene that contains the view. The following
/// example uses the ``SwiftUI/View/onChange(of:perform:)`` method to enable
/// a timer whenever the enclosing scene enters the ``ScenePhase/active`` phase
/// and disable the timer when entering any other phase:
///
///     struct MyView: View {
///         @ObservedObject var model: DataModel
///         @Environment(\.scenePhase) private var scenePhase
///
///         var body: some View {
///             TimerView()
///                 .onChange(of: scenePhase) { phase in
///                     model.isTimerRunning = (phase == .active)
///                 }
///         }
///     }
///
/// If you read the phase from within an ``App`` instance, you obtain an
/// aggregate value that reflects the phases of all the scenes in your app. The
/// app reports a value of ``ScenePhase/active`` if any scene is active, or a
/// value of ``ScenePhase/inactive`` when no scenes are active. This includes
/// multiple scene instances created from a single scene declaration; for
/// example, from a ``WindowGroup``. When an app enters the
/// ``ScenePhase/background`` phase, expect the app to terminate soon after.
/// You can use that opportunity to free any resources:
///
///     @main
///     struct MyApp: App {
///         @Environment(\.scenePhase) private var scenePhase
///
///         var body: some Scene {
///             WindowGroup {
///                 MyRootView()
///             }
///             .onChange(of: scenePhase) { phase in
///                 if phase == .background {
///                     // Perform cleanup when all scenes within
///                     // MyApp go to the background.
///                 }
///             }
///         }
///     }
///
/// If you read the phase from within a custom ``Scene`` instance, the value
/// similarly reflects an aggregation of all the scenes that make up the custom
/// scene:
///
///     struct MyScene: Scene {
///         @Environment(\.scenePhase) private var scenePhase
///
///         var body: some Scene {
///             WindowGroup {
///                 MyRootView()
///             }
///             .onChange(of: scenePhase) { phase in
///                 if phase == .background {
///                     // Perform cleanup when all scenes within
///                     // MyScene go to the background.
///                 }
///             }
///         }
///     }
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public enum ScenePhase : Comparable {

    /// The scene isn't currently visible in the UI.
    ///
    /// Do as little as possible in a scene that's in the `background` phase.
    /// The `background` phase can precede termination, so do any cleanup work
    /// immediately upon entering this state. For example, close any open files
    /// and network connections. However, a scene can also return to the
    /// ``ScenePhase/active`` phase from the background.
    ///
    /// Expect an app that enters the `background` phase to terminate.
    case background

    /// The scene is in the foreground but should pause its work.
    ///
    /// A scene in this phase doesn't receive events and should pause
    /// timers and free any unnecessary resources. The scene might be completely
    /// hidden in the user interface or otherwise unavailable to the user.
    /// In macOS, scenes only pass through this phase temporarily on their way
    /// to the ``ScenePhase/background`` phase.
    ///
    /// An app or custom scene in this phase contains no scene instances in the
    /// ``ScenePhase/active`` phase.
    case inactive

    /// The scene is in the foreground and interactive.
    ///
    /// An active scene isn't necessarily front-most. For example, a macOS
    /// window might be active even if it doesn't currently have focus.
    /// Nevertheless, all scenes should operate normally in this phase.
    ///
    /// An app or custom scene in this phase contains at least one active scene
    /// instance.
    case active

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ScenePhase, b: ScenePhase) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is less than that of the second argument.
    ///
    /// This function is the only requirement of the `Comparable` protocol. The
    /// remainder of the relational operator functions are implemented by the
    /// standard library for any type that conforms to `Comparable`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func < (a: ScenePhase, b: ScenePhase) -> Bool

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ScenePhase : Sendable {
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ScenePhase : Hashable {
}

/// The restoration behavior for a scene.
///
/// Use the ``Scene/restorationBehavior(_:)`` scene modifier to apply a
/// value of this type to a ``Scene`` you define in your ``App`` declaration.
/// The value you specify determines how the system will restore windows from a
/// previous run of your application.
///
/// For example, you may have a scene that you do not wish to be restored on
/// launch:
///
///     @main
///     struct MyApp: App {
///         var body: some Scene {
///             WindowGroup {
///                 ContentView()
///             }
///             Window(id: "network-test", "Network Connection Test") {
///                 NetworkTestView()
///             }
///             .restorationBehavior(.disabled)
///         }
///     }
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct SceneRestorationBehavior : Sendable {

    /// The automatic behavior. The scene's windows will be restored as defined
    /// by the underlying platform.
    ///
    /// On macOS, this behavior is governed by a system setting which can be
    /// toggled on and off by the user. On all other platforms, it is enabled by
    /// default.
    public static let automatic: SceneRestorationBehavior
}

/// A property wrapper type that reads and writes to persisted, per-scene
/// storage.
///
/// You use `SceneStorage` when you need automatic state restoration of the
/// value.  `SceneStorage` works very similar to `State`, except its initial
/// value is restored by the system if it was previously saved, and the value is
/// shared with other `SceneStorage` variables in the same scene.
///
/// The system manages the saving and restoring of `SceneStorage` on your
/// behalf. The underlying data that backs `SceneStorage` is not available to
/// you, so you must access it via the `SceneStorage` property wrapper. The
/// system makes no guarantees as to when and how often the data will be
/// persisted.
///
/// Each `Scene` has its own notion of `SceneStorage`, so data is not shared
/// between scenes.
///
/// Ensure that the data you use with `SceneStorage` is lightweight. Data of a
/// large size, such as model data, should not be stored in `SceneStorage`, as
/// poor performance may result.
///
/// If the `Scene` is explicitly destroyed (e.g. the switcher snapshot is
/// destroyed on iPadOS or the window is closed on macOS), the data is also
/// destroyed. Do not use `SceneStorage` with sensitive data.
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
@frozen @propertyWrapper public struct SceneStorage<Value> : DynamicProperty {

    /// The underlying value referenced by the state variable.
    ///
    /// This works identically to `State.wrappedValue`.
    ///
    /// - SeeAlso: State.wrappedValue
    public var wrappedValue: Value { get nonmutating set }

    /// A binding to the state value.
    ///
    /// This works identically to `State.projectedValue`.
    ///
    /// - SeeAlso: State.projectedValue
    public var projectedValue: Binding<Value> { get }
}

@available(iOS 17.0, macOS 14.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension SceneStorage {

    /// Creates a property that can save and restore table column state.
    ///
    /// - Parameter wrappedValue: The default value if table column state is not
    ///   available for the given key.
    /// - Parameter key: a key used to save and restore the value.
    public init<RowValue>(wrappedValue: Value = TableColumnCustomization<RowValue>(), _ key: String) where Value == TableColumnCustomization<RowValue>, RowValue : Identifiable
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension SceneStorage : @unchecked Sendable where Value : Sendable {
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension SceneStorage {

    /// Creates a property that can save and restore a boolean.
    ///
    /// - Parameter wrappedValue: The default value if a boolean is not
    ///   available for the given key.
    /// - Parameter key: a key used to save and restore the value.
    public init(wrappedValue: Value, _ key: String) where Value == Bool

    /// Creates a property that can save and restore an integer.
    ///
    /// - Parameter wrappedValue: The default value if an integer is not
    ///   available for the given key.
    /// - Parameter key: a key used to save and restore the value.
    public init(wrappedValue: Value, _ key: String) where Value == Int

    /// Creates a property that can save and restore a double.
    ///
    /// - Parameter wrappedValue: The default value if a double is not available
    ///   for the given key.
    /// - Parameter key: a key used to save and restore the value.
    public init(wrappedValue: Value, _ key: String) where Value == Double

    /// Creates a property that can save and restore a string.
    ///
    /// - Parameter wrappedValue: The default value if a string is not available
    ///   for the given key.
    /// - Parameter key: a key used to save and restore the value.
    public init(wrappedValue: Value, _ key: String) where Value == String

    /// Creates a property that can save and restore a URL.
    ///
    /// - Parameter wrappedValue: The default value if a URL is not available
    ///   for the given key.
    /// - Parameter key: a key used to save and restore the value.
    public init(wrappedValue: Value, _ key: String) where Value == URL

    /// Creates a property that can save and restore a Date.
    ///
    /// - Parameter wrappedValue: The default value if a Date is not available
    ///   for the given key.
    /// - Parameter key: a key used to save and restore the value.
    @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
    public init(wrappedValue: Value, _ key: String) where Value == Date

    /// Creates a property that can save and restore data.
    ///
    /// Avoid storing large data blobs, such as image data, as it can negatively
    /// affect performance of your app.
    ///
    /// - Parameter wrappedValue: The default value if data is not available
    ///   for the given key.
    /// - Parameter key: a key used to save and restore the value.
    public init(wrappedValue: Value, _ key: String) where Value == Data

    /// Creates a property that can save and restore an integer, transforming it
    /// to a `RawRepresentable` data type.
    ///
    /// A common usage is with enumerations:
    ///
    ///     enum MyEnum: Int {
    ///         case a
    ///         case b
    ///         case c
    ///     }
    ///     struct MyView: View {
    ///         @SceneStorage("MyEnumValue") private var value = MyEnum.a
    ///         var body: some View { ... }
    ///     }
    ///
    /// - Parameter wrappedValue: The default value if an integer value is not
    ///   available for the given key.
    /// - Parameter key: a key used to save and restore the value.
    public init(wrappedValue: Value, _ key: String) where Value : RawRepresentable, Value.RawValue == Int

    /// Creates a property that can save and restore a string, transforming it
    /// to a `RawRepresentable` data type.
    ///
    /// A common usage is with enumerations:
    ///
    ///     enum MyEnum: String {
    ///         case a
    ///         case b
    ///         case c
    ///     }
    ///     struct MyView: View {
    ///         @SceneStorage("MyEnumValue") private var value = MyEnum.a
    ///         var body: some View { ... }
    ///     }
    ///
    /// - Parameter wrappedValue: The default value if a String value is not
    ///   available for the given key.
    /// - Parameter key: a key used to save and restore the value.
    public init(wrappedValue: Value, _ key: String) where Value : RawRepresentable, Value.RawValue == String
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension SceneStorage where Value : ExpressibleByNilLiteral {

    /// Creates a property that can save and restore an Optional boolean.
    ///
    /// Defaults to nil if there is no restored value
    ///
    /// - Parameter key: a key used to save and restore the value.
    public init(_ key: String) where Value == Bool?

    /// Creates a property that can save and restore an Optional integer.
    ///
    /// Defaults to nil if there is no restored value
    ///
    /// - Parameter key: a key used to save and restore the value.
    public init(_ key: String) where Value == Int?

    /// Creates a property that can save and restore an Optional double.
    ///
    /// Defaults to nil if there is no restored value
    ///
    /// - Parameter key: a key used to save and restore the value.
    public init(_ key: String) where Value == Double?

    /// Creates a property that can save and restore an Optional string.
    ///
    /// Defaults to nil if there is no restored value
    ///
    /// - Parameter key: a key used to save and restore the value.
    public init(_ key: String) where Value == String?

    /// Creates a property that can save and restore an Optional URL.
    ///
    /// Defaults to nil if there is no restored value
    ///
    /// - Parameter key: a key used to save and restore the value.
    public init(_ key: String) where Value == URL?

    /// Creates a property that can save and restore an Optional Date.
    ///
    /// Defaults to nil if there is no restored value
    ///
    /// - Parameter key: a key used to save and restore the value.
    @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
    public init(_ key: String) where Value == Date?

    /// Creates a property that can save and restore an Optional data.
    ///
    /// Defaults to nil if there is no restored value
    ///
    /// - Parameter key: a key used to save and restore the value.
    public init(_ key: String) where Value == Data?
}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension SceneStorage {

    /// Creates a property that can save and restore an Optional string,
    /// transforming it to an Optional `RawRepresentable` data type.
    ///
    /// Defaults to nil if there is no restored value
    ///
    /// A common usage is with enumerations:
    ///
    ///     enum MyEnum: String {
    ///         case a
    ///         case b
    ///         case c
    ///     }
    ///     struct MyView: View {
    ///         @SceneStorage("MyEnumValue") private var value: MyEnum?
    ///         var body: some View { ... }
    ///     }
    ///
    /// - Parameter key: a key used to save and restore the value.
    public init<R>(_ key: String) where Value == R?, R : RawRepresentable, R.RawValue == String

    /// Creates a property that can save and restore an Optional integer,
    /// transforming it to an Optional `RawRepresentable` data type.
    ///
    /// Defaults to nil if there is no restored value
    ///
    /// A common usage is with enumerations:
    ///
    ///     enum MyEnum: Int {
    ///         case a
    ///         case b
    ///         case c
    ///     }
    ///     struct MyView: View {
    ///         @SceneStorage("MyEnumValue") private var value: MyEnum?
    ///         var body: some View { ... }
    ///     }
    ///
    /// - Parameter key: a key used to save and restore the value.
    public init<R>(_ key: String) where Value == R?, R : RawRepresentable, R.RawValue == Int
}

@available(iOS 18.0, macOS 15.0, visionOS 2.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension SceneStorage {

    /// Creates a property that can save and restore tab sidebar customizations.
    ///
    /// You can set this customization on the TabView using
    /// ``View/tabViewCustomization(_:)``.
    ///
    /// The tab view customization is typically not added to
    /// `SceneStorage`, but instead stored in `AppStorage` so the
    /// customizations are consistent across different scenes.
    ///
    /// - Parameter wrappedValue: The default value if the customization
    ///   is not available for the given key.
    /// - Parameter key: a key used to save and restore the value.
    public init(wrappedValue: Value = TabViewCustomization(), _ key: String, store: UserDefaults? = nil) where Value == TabViewCustomization
}

/// A type defining the role of a scroll anchor.
///
/// You can associate a ``UnitPoint`` to a ``ScrollView`` using the
/// ``View/defaultScrollAnchor(_:)`` modifier. By default, the system
/// uses this point for different kinds of behaviors including:
///   - Where the scroll view should initially be scrolled
///   - How the scroll view should handle content size or
///     container size changes
///   - How the scroll view should align content smaller than
///     its container size
///
/// You can further customize this behavior by assigning different unit
/// points for these different roles.
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct ScrollAnchorRole : Hashable, Sendable {

    /// The role that influences where a scroll view should be
    /// initially scrolled.
    public static var initialOffset: ScrollAnchorRole { get }

    /// The role that influences how a scroll view should adjust its
    /// content offset when the scroll view's content or container size
    /// changes.
    public static var sizeChanges: ScrollAnchorRole { get }

    /// The role that influences how a scroll view should align
    /// its content when the size of its content is smaller than the
    /// container size of the scroll view.
    public static var alignment: ScrollAnchorRole { get }

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ScrollAnchorRole, b: ScrollAnchorRole) -> Bool

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

/// The ways that a scrollable view can bounce when it reaches the end of its
/// content.
///
/// Use the ``View/scrollBounceBehavior(_:axes:)`` view modifier to set a value
/// of this type for a scrollable view, like a ``ScrollView`` or a ``List``.
/// The value configures the bounce behavior when people scroll to the end of
/// the view's content.
///
/// You can configure each scrollable axis to use a different bounce mode.
@available(iOS 16.4, macOS 13.3, tvOS 16.4, watchOS 9.4, *)
public struct ScrollBounceBehavior : Sendable {

    /// The automatic behavior.
    ///
    /// The scrollable view automatically chooses whether content bounces when
    /// people scroll to the end of the view's content. By default, scrollable
    /// views use the ``ScrollBounceBehavior/always`` behavior.
    public static var automatic: ScrollBounceBehavior { get }

    /// The scrollable view always bounces.
    ///
    /// The scrollable view always bounces along the specified axis,
    /// regardless of the size of the content.
    public static var always: ScrollBounceBehavior { get }

    /// The scrollable view bounces when its content is large enough to require
    /// scrolling.
    ///
    /// The scrollable view bounces along the specified axis if the size of
    /// the content exceeeds the size of the scrollable view in that axis.
    public static var basedOnSize: ScrollBounceBehavior { get }
}

/// A type that defines the different kinds of content offset adjusting
/// behaviors a scroll view can have.
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct ScrollContentOffsetAdjustmentBehavior {

    /// The automatic behavior.
    ///
    /// A scroll view may automatically adjust its content offset
    /// based on the current context. The absolute offset may be adjusted
    /// to keep content in relatively the same place. For example,
    /// when scrolled to the bottom, a scroll view may keep the bottom
    /// edge scrolled to the bottom when the overall size of its content
    /// changes.
    public static var automatic: ScrollContentOffsetAdjustmentBehavior { get }

    /// The disabled behavior.
    ///
    /// A scroll view will not adjust its content offset.
    public static var disabled: ScrollContentOffsetAdjustmentBehavior { get }
}

/// The ways that scrollable content can interact with the software keyboard.
///
/// Use this type in a call to the ``View/scrollDismissesKeyboard(_:)``
/// modifier to specify the dismissal behavior of scrollable views.
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
@available(visionOS, unavailable)
public struct ScrollDismissesKeyboardMode : Sendable {

    /// Determine the mode automatically based on the surrounding context.
    ///
    /// By default, a ``TextEditor`` is interactive while a ``List``
    /// of scrollable content always dismiss the keyboard on a scroll,
    /// when linked against iOS 16 or later.
    public static var automatic: ScrollDismissesKeyboardMode { get }

    /// Dismiss the keyboard as soon as scrolling starts.
    public static var immediately: ScrollDismissesKeyboardMode { get }

    /// Enable people to interactively dismiss the keyboard as part of the
    /// scroll operation.
    ///
    /// The software keyboard's position tracks the gesture that drives the
    /// scroll operation if the gesture crosses into the keyboard's area of the
    /// display. People can dismiss the keyboard by scrolling it off the
    /// display, or reverse the direction of the scroll to cancel the dismissal.
    public static var interactively: ScrollDismissesKeyboardMode { get }

    /// Never dismiss the keyboard automatically as a result of scrolling.
    public static var never: ScrollDismissesKeyboardMode { get }
}

/// The visibility of scroll indicators of a UI element.
///
/// Pass a value of this type to the ``View/scrollIndicators(_:axes:)`` method
/// to specify the preferred scroll indicator visibility of a view hierarchy.
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct ScrollIndicatorVisibility {

    /// Scroll indicator visibility depends on the
    /// policies of the component accepting the visibility configuration.
    public static var automatic: ScrollIndicatorVisibility { get }

    /// Show the scroll indicators.
    ///
    /// The actual visibility of the indicators depends on platform
    /// conventions like auto-hiding behaviors in iOS or user preference
    /// behaviors in macOS.
    public static var visible: ScrollIndicatorVisibility { get }

    /// Hide the scroll indicators.
    ///
    /// By default, scroll views in macOS show indicators when a
    /// mouse is connected. Use ``never`` to indicate
    /// a stronger preference that can override this behavior.
    public static var hidden: ScrollIndicatorVisibility { get }

    /// Scroll indicators should never be visible.
    ///
    /// This value behaves like ``hidden``, but
    /// overrides scrollable views that choose
    /// to keep their indidicators visible. When using this value,
    /// provide an alternative method of scrolling. The typical
    /// horizontal swipe gesture might not be available, depending on
    /// the current input device.
    public static var never: ScrollIndicatorVisibility { get }
}

@available(iOS 16.4, macOS 13.3, tvOS 16.4, watchOS 9.4, *)
extension ScrollIndicatorVisibility : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ScrollIndicatorVisibility, b: ScrollIndicatorVisibility) -> Bool
}

/// A type that defines whether input should scroll a view.
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct ScrollInputBehavior : Sendable, Equatable {

    /// Indicates that the system should determine whether the associated input
    /// scrolls a view.
    public static let automatic: ScrollInputBehavior

    /// Indicates that the associated input should scroll a view.
    public static let enabled: ScrollInputBehavior

    /// Indicates that the associated input should not scroll a view.
    public static let disabled: ScrollInputBehavior

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ScrollInputBehavior, b: ScrollInputBehavior) -> Bool
}

/// Inputs used to scroll views.
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct ScrollInputKind : Sendable, Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ScrollInputKind, b: ScrollInputKind) -> Bool
}

/// A type that provides you with more content when the phase of a scroll
/// view changes.
///
/// You don't create this type directly. Instead, SwiftUI provides an instance
/// of this type in the ``View/onScrollPhaseChange(_:)`` modifier.
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct ScrollPhaseChangeContext {

    /// The geometry of the scroll view at the time of the
    /// scroll phase change.
    public var geometry: ScrollGeometry { get }

    /// The velocity of the scroll view at the time of the
    /// scroll phase change.
    public var velocity: CGVector? { get }
}

/// A type that defines the scroll behavior of a scrollable view.
///
/// A scrollable view calculates where scroll gestures should end using its
/// deceleration rate and the state of its scroll gesture by default. A scroll
/// behavior allows for customizing this logic.
///
/// You define a scroll behavior using the
/// ``ScrollTargetBehavior/updateTarget(_:context:)`` method.
///
/// Using this method, you can control where someone can scroll in a scrollable
/// view. For example, you can create a custom scroll behavior
/// that aligns to every 10 points by doing the following:
///
///     struct BasicScrollTargetBehavior: ScrollTargetBehavior {
///         func updateTarget(_ target: inout Target, context: TargetContext) {
///             // Align to every 1/10 the size of the scroll view.
///             target.rect.x.round(
///                 toMultipleOf: round(context.containerSize.width / 10.0))
///         }
///     }
///
/// ### Paging Behavior
///
/// SwiftUI offers built in scroll behaviors. One such behavior
/// is the ``PagingScrollTargetBehavior`` which uses the geometry of the scroll
/// view to decide where to allow scrolls to end.
///
/// In the following example, every view in the lazy stack is flexible
/// in both directions and the scroll view will settle to container aligned
/// boundaries.
///
///     ScrollView {
///         LazyVStack(spacing: 0.0) {
///             ForEach(items) { item in
///                 FullScreenItem(item)
///             }
///         }
///     }
///     .scrollTargetBehavior(.paging)
///
/// ### View Aligned Behavior
///
/// SwiftUI also offers a ``ViewAlignedScrollTargetBehavior`` scroll behavior
/// that will always settle on the geometry of individual views.
///
///     ScrollView(.horizontal) {
///         LazyHStack(spacing: 10.0) {
///             ForEach(items) { item in
///                 ItemView(item)
///             }
///         }
///         .scrollTargetLayout()
///     }
///     .scrollTargetBehavior(.viewAligned)
///     .safeAreaPadding(.horizontal, 20.0)
///
/// You configure which views should be used for settling using the
/// ``View/scrollTargetLayout(isEnabled:)`` modifier. Apply this modifier to a
/// layout container like ``LazyVStack`` or ``HStack`` and each individual
/// view in that layout will be considered for alignment.
///
/// Use types conforming to this protocol with the
/// ``View/scrollTargetBehavior(_:)`` modifier.
@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
public protocol ScrollTargetBehavior {

    /// Updates the proposed target that a scrollable view should scroll to.
    ///
    /// The system calls this method in two main cases:
    /// - When a scroll gesture ends, it calculates where it would naturally
    ///   scroll to using its deceleration rate. The system
    ///   provides this calculated value as the target of this method.
    /// - When a scrollable view's size changes, it calculates where it should
    ///   be scrolled given the new size and provides this calculates value
    ///   as the target of this method.
    ///
    /// You can implement this method to override the calculated target
    /// which will have the scrollable view scroll to a different position
    /// than it would otherwise.
    func updateTarget(_ target: inout ScrollTarget, context: Self.TargetContext)

    /// The context in which a scroll behavior updates the scroll target.
    typealias TargetContext = ScrollTargetBehaviorContext
}

extension ScrollTargetBehavior where Self == PagingScrollTargetBehavior {

    /// The scroll behavior that aligns scroll targets to container-based
    /// geometry.
    ///
    /// In the following example, every view in the lazy stack is flexible
    /// in both directions and the scroll view settles to container-aligned
    /// boundaries.
    ///
    ///     ScrollView {
    ///         LazyVStack(spacing: 0.0) {
    ///             ForEach(items) { item in
    ///                 FullScreenItem(item)
    ///             }
    ///         }
    ///     }
    ///     .scrollTargetBehavior(.paging)
    ///
    @available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
    public static var paging: PagingScrollTargetBehavior { get }
}

extension ScrollTargetBehavior where Self == ViewAlignedScrollTargetBehavior {

    /// The scroll behavior that aligns scroll targets to view-based geometry.
    ///
    /// You use this behavior when a scroll view should always align its
    /// scroll targets to a rectangle that's aligned to the geometry of a view. In
    /// the following example, the scroll view always picks an item view
    /// to settle on.
    ///
    ///     ScrollView(.horizontal) {
    ///         LazyHStack(spacing: 10.0) {
    ///             ForEach(items) { item in
    ///                 ItemView(item)
    ///             }
    ///         }
    ///         .scrollTargetLayout()
    ///     }
    ///     .scrollTargetBehavior(.viewAligned)
    ///     .padding(.horizontal, 20.0)
    ///
    /// You configure which views should be used for settling using the
    /// ``View/scrollTargetLayout()`` modifier. Apply this modifier to a
    /// layout container like ``LazyVStack`` or ``HStack`` and each individual
    /// view in that layout will be considered for alignment.
    ///
    /// You can customize whether the view aligned behavior limits the
    /// number of views that can be scrolled at a time by using the
    /// ``ViewAlignedScrollTargetBehavior.LimitBehavior`` type. Provide a value
    /// of ``ViewAlignedScrollTargetBehavior.LimitBehavior/always`` to always
    /// have the behavior only allow a few views to be scrolled at a time.
    ///
    /// By default, the view aligned behavior limits the number of views
    /// it scrolls when in a compact horizontal size class when scrollable
    /// in the horizontal axis, when in a compact vertical size class when
    /// scrollable in the vertical axis, and otherwise doesn't impose any
    /// limit on the number of views that can be scrolled.
    @available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
    public static var viewAligned: ViewAlignedScrollTargetBehavior { get }

    /// The scroll behavior that aligns scroll targets to view-based geometry.
    ///
    /// You use this behavior when a scroll view should always align its
    /// scroll targets to a rectangle that's aligned to the geometry of a view. In
    /// the following example, the scroll view always picks an item view
    /// to settle on.
    ///
    ///     ScrollView(.horizontal) {
    ///         LazyHStack(spacing: 10.0) {
    ///             ForEach(items) { item in
    ///                 ItemView(item)
    ///             }
    ///         }
    ///         .scrollTargetLayout()
    ///     }
    ///     .scrollTargetBehavior(.viewAligned)
    ///     .padding(.horizontal, 20.0)
    ///
    /// You configure which views should be used for settling using the
    /// ``View/scrollTargetLayout()`` modifier. Apply this modifier to a
    /// layout container like ``LazyVStack`` or ``HStack`` and each individual
    /// view in that layout will be considered for alignment.
    ///
    /// You can customize whether the view aligned behavior limits the
    /// number of views that can be scrolled at a time by using the
    /// ``ViewAlignedScrollTargetBehavior.LimitBehavior`` type. Provide a value
    /// of ``ViewAlignedScrollTargetBehavior.LimitBehavior/always`` to always
    /// have the behavior only allow a few views to be scrolled at a time.
    ///
    /// By default, the view aligned behavior limits the number of views
    /// it scrolls when in a compact horizontal size class when scrollable
    /// in the horizontal axis, when in a compact vertical size class when
    /// scrollable in the vertical axis, and otherwise doesn't impose any
    /// limit on the number of views that can be scrolled.
    @available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
    public static func viewAligned(limitBehavior: ViewAlignedScrollTargetBehavior.LimitBehavior) -> Self
}

/// The context in which a scroll target behavior updates its scroll target.
@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
@dynamicMemberLookup public struct ScrollTargetBehaviorContext {

    /// The original target when the scroll gesture began.
    public var originalTarget: ScrollTarget { get }

    /// The current velocity of the scrollable view's scroll gesture.
    public var velocity: CGVector { get }

    /// The size of the content of the scrollable view.
    public var contentSize: CGSize { get }

    /// The size of the container of the scrollable view.
    ///
    /// This is the size of the bounds of the scroll view subtracting any
    /// insets applied to the scroll view (like the safe area).
    public var containerSize: CGSize { get }

    /// The axes in which the scrollable view is scrollable.
    public var axes: Axis.Set { get }

    public subscript<T>(dynamicMember keyPath: KeyPath<EnvironmentValues, T>) -> T { get }
}

/// The configuration of a scroll transition that controls how a transition
/// is applied as a view is scrolled through the visible region of a containing
/// scroll view or other container.
@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
public struct ScrollTransitionConfiguration {

    /// Creates a new configuration that discretely animates the transition
    /// when the view becomes visible.
    ///
    /// Unlike the interactive configuration, the transition isn't
    /// interpolated as the scroll view is scrolled. Instead, the transition
    /// phase only changes once the threshold has been reached, at which
    /// time the given animation is used to animate to the new phase.
    ///
    /// - Parameters:
    ///   - animation: The animation to use when transitioning between states.
    ///
    /// - Returns: A configuration that discretely animates between
    ///   transition phases.
    public static func animated(_ animation: Animation = .default) -> ScrollTransitionConfiguration

    /// Creates a new configuration that discretely animates the transition
    /// when the view becomes visible.
    public static let animated: ScrollTransitionConfiguration

    /// Creates a new configuration that interactively interpolates the
    /// transition's effect as the view is scrolled into the visible region
    /// of the container.
    ///
    /// - Parameters:
    ///   - timingCurve: The curve that adjusts the pace at which the effect
    ///     is interpolated between phases of the transition. For example, an
    ///     `.easeIn` curve causes interpolation to begin slowly as the view
    ///     reaches the edge of the scroll view, then speed up as it reaches
    ///     the visible threshold. The curve is applied 'forward' while the
    ///     view is appearing, meaning that time zero corresponds to the
    ///     view being just hidden, and time 1.0 corresponds to the pont at
    ///     which the view reaches the configuration threshold. This also means
    ///     that the timing curve is applied in reversed while the view
    ///     is moving away from the center of the scroll view.
    ///
    /// - Returns: A configuration that interactively interpolates between
    ///   transition phases based on the current scroll position.
    public static func interactive(timingCurve: UnitCurve = .easeInOut) -> ScrollTransitionConfiguration

    /// Creates a new configuration that interactively interpolates the
    /// transition's effect as the view is scrolled into the visible region
    /// of the container.
    public static let interactive: ScrollTransitionConfiguration

    /// Creates a new configuration that does not change the appearance of the view.
    public static let identity: ScrollTransitionConfiguration

    /// Sets the animation with which the transition will be applied.
    ///
    /// If the transition is interactive, the given animation will be used
    /// to animate the effect toward the current interpolated value, causing
    /// the effect to lag behind the current scroll position.
    ///
    /// - Parameter animation: An animation that will be used to apply the
    ///   transition to the view.
    ///
    /// - Returns: A copy of this configuration with the animation set to the
    ///   given value.
    public func animation(_ animation: Animation) -> ScrollTransitionConfiguration

    /// Sets the threshold at which the view will be considered fully visible.
    ///
    /// - Parameters:
    ///   - threshold: The threshold specifying how much of the view must
    ///     intersect with the container before it is treated as visible.
    ///
    /// - Returns: A copy of this configuration with the threshold set to the
    ///   given value.
    public func threshold(_ threshold: ScrollTransitionConfiguration.Threshold) -> ScrollTransitionConfiguration
}

extension ScrollTransitionConfiguration {

    /// Describes a specific point in the progression of a target view within a container
    /// from hidden (fully outside the container) to visible.
    @available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
    public struct Threshold {

        public static let visible: ScrollTransitionConfiguration.Threshold

        public static let hidden: ScrollTransitionConfiguration.Threshold

        /// The target view is centered within the container
        public static var centered: ScrollTransitionConfiguration.Threshold { get }

        /// The target view is visible by the given amount, where zero is fully
        /// hidden, and one is fully visible.
        ///
        /// Values less than zero or greater than one are clamped.
        public static func visible(_ amount: Double) -> ScrollTransitionConfiguration.Threshold

        /// Creates a new threshold that combines this threshold value with
        /// another threshold, interpolated by the given amount.
        ///
        /// - Parameters:
        ///   - other: The second threshold value.
        ///   - amount: The ratio with which this threshold is combined with
        ///     the given threshold, where zero is equal to this threshold,
        ///     1.0 is equal to `other`, and values in between combine the two
        ///     thresholds.
        public func interpolated(towards other: ScrollTransitionConfiguration.Threshold, amount: Double) -> ScrollTransitionConfiguration.Threshold

        /// Returns a threshold that is met when the target view is closer to the
        /// center of the container by `distance`. Use negative values to move
        /// the threshold away from the center.
        public func inset(by distance: Double) -> ScrollTransitionConfiguration.Threshold
    }
}

/// The phases that a view transitions between when it scrolls among other views.
///
/// When a view with a scroll transition modifier applied is approaching
/// the visible region of the containing scroll view or other container,
/// the effect  will first be applied with the `topLeading` or `bottomTrailing`
/// phase (depending on which edge the view is approaching), then will be
/// moved to the `identity` phase as the view moves into the visible area. The
/// timing and behavior that determines when a view is visible within the
/// container is controlled by the configuration that is provided to the
/// `scrollTransition` modifier.
///
/// In the `identity` phase, scroll transitions should generally not make any
/// visual change to the view they are applied to, since the transition's view
/// modifications in the `identity` phase will be applied to the view as long
/// as it is visible. In the `topLeading` and `bottomTrailing` phases,
/// transitions should apply a change that will be animated to create the
/// transition.
@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
@frozen public enum ScrollTransitionPhase {

    /// The scroll transition is being applied to a view that is about to
    /// move into the visible area at the top edge of a vertical scroll view,
    /// or the leading edge of a horizont scroll view.
    case topLeading

    /// The scroll transition is being applied to a view that is in the
    /// visible area.
    ///
    /// In this phase, a transition should show its steady state appearance,
    /// which will generally not make any visual change to the view.
    case identity

    /// The scroll transition is being applied to a view that is about to
    /// move into the visible area at the bottom edge of a vertical scroll
    /// view, or the trailing edge of a horizontal scroll view.
    case bottomTrailing

    public var isIdentity: Bool { get }

    /// A phase-derived value that can be used to scale or otherwise modify
    /// effects.
    ///
    /// Returns -1.0 when in the topLeading phase, zero when in the identity
    /// phase, and 1.0 when in the bottomTrailing phase.
    public var value: Double { get }

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ScrollTransitionPhase, b: ScrollTransitionPhase) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension ScrollTransitionPhase : Equatable {
}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension ScrollTransitionPhase : Hashable {
}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension ScrollTransitionPhase : BitwiseCopyable {
}

/// A scrollable view.
///
/// The scroll view displays its content within the scrollable content region.
/// As the user performs platform-appropriate scroll gestures, the scroll view
/// adjusts what portion of the underlying content is visible. `ScrollView` can
/// scroll horizontally, vertically, or both, but does not provide zooming
/// functionality.
///
/// In the following example, a `ScrollView` allows the user to scroll through
/// a ``VStack`` containing 100 ``Text`` views. The image after the listing
/// shows the scroll view's temporarily visible scrollbar at the right; you can
/// disable it with the `showsIndicators` parameter of the `ScrollView`
/// initializer.
///
///     var body: some View {
///         ScrollView {
///             VStack(alignment: .leading) {
///                 ForEach(0..<100) {
///                     Text("Row \($0)")
///                 }
///             }
///         }
///     }
/// ![A scroll view with a series of vertically arranged rows, reading
/// Row 1, Row 2, and so on. At the right, a scrollbar indicates that
/// this is the top of the scrollable
/// area.](SwiftUI-ScrollView-rows-with-indicator.png)
///
/// ### Controlling Scroll Position
///
/// You can influence where a scroll view is initially scrolled
/// by using the ``View/defaultScrollAnchor(_:)`` view modifier.
///
/// Provide a value of `UnitPoint/center`` to have the scroll
/// view start in the center of its content when a scroll view
/// is scrollable in both axes.
///
///     ScrollView([.horizontal, .vertical]) {
///         // initially centered content
///     }
///     .defaultScrollAnchor(.center)
///
/// Or provide an alignment of `UnitPoint/bottom`` to have the
/// scroll view start at the bottom of its content when a scroll
/// view is scrollable in its vertical axes.
///
///     ScrollView {
///         // initially bottom aligned content
///     }
///     .defaultScrollAnchor(.bottom)
///
/// After the scroll view initially renders, the user may scroll
/// the content of the scroll view.
///
/// To perform programmatic scrolling, wrap one or more scroll views with a
/// ``ScrollViewReader``.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public struct ScrollView<Content> : View where Content : View {

    /// The scroll view's content.
    public var content: Content

    /// The scrollable axes of the scroll view.
    ///
    /// The default value is ``Axis/vertical``.
    public var axes: Axis.Set

    /// A value that indicates whether the scroll view displays the scrollable
    /// component of the content offset, in a way that's suitable for the
    /// platform.
    ///
    /// The default is `true`.
    public var showsIndicators: Bool

    /// Creates a new instance that's scrollable in the direction of the given
    /// axis and can show indicators while scrolling.
    ///
    /// - Parameters:
    ///   - axes: The scroll view's scrollable axis. The default axis is the
    ///     vertical axis.
    ///   - showsIndicators: A Boolean value that indicates whether the scroll
    ///     view displays the scrollable component of the content offset, in a way
    ///     suitable for the platform. The default value for this parameter is
    ///     `true`.
    ///   - content: The view builder that creates the scrollable view.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, message: "Use the ScrollView(_:content:) initializer and the scrollIndicators(:_) modifier")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, message: "Use the ScrollView(_:content:) initializer and the scrollIndicators(:_) modifier")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, message: "Use the ScrollView(_:content:) initializer and the scrollIndicators(:_) modifier")
    @available(watchOS, introduced: 6.0, deprecated: 100000.0, message: "Use the ScrollView(_:content:) initializer and the scrollIndicators(:_) modifier")
    public init(_ axes: Axis.Set = .vertical, showsIndicators: Bool = true, @ViewBuilder content: () -> Content)

    /// The content and behavior of the scroll view.
    @MainActor @preconcurrency public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    public typealias Body = some View
}

extension ScrollView {

    /// Creates a new instance that's scrollable in the direction of the given
    /// axis and can show indicators while scrolling.
    ///
    /// - Parameters:
    ///   - axes: The scroll view's scrollable axis. The default axis is the
    ///     vertical axis.
    ///   - content: The view builder that creates the scrollable view.
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    nonisolated public init(_ axes: Axis.Set = .vertical, @ViewBuilder content: () -> Content)
}

/// A proxy value that supports programmatic scrolling of the scrollable
/// views within a view hierarchy.
///
/// You don't create instances of `ScrollViewProxy` directly. Instead, your
/// ``ScrollViewReader`` receives an instance of `ScrollViewProxy` in its
/// `content` view builder. You use actions within this view builder, such
/// as button and gesture handlers or the ``View/onChange(of:perform:)``
/// method, to call the proxy's ``ScrollViewProxy/scrollTo(_:anchor:)`` method.
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public struct ScrollViewProxy {

    /// Scans all scroll views contained by the proxy for the first
    /// with a child view with identifier `id`, and then scrolls to
    /// that view.
    ///
    /// If `anchor` is `nil`, this method finds the container of the identified
    /// view, and scrolls the minimum amount to make the identified view
    /// wholly visible.
    ///
    /// If `anchor` is non-`nil`, it defines the points in the identified
    /// view and the scroll view to align. For example, setting `anchor` to
    /// ``UnitPoint/top`` aligns the top of the identified view to the top of
    /// the scroll view. Similarly, setting `anchor` to ``UnitPoint/bottom``
    /// aligns the bottom of the identified view to the bottom of the scroll
    /// view, and so on.
    ///
    /// - Parameters:
    ///   - id: The identifier of a child view to scroll to.
    ///   - anchor: The alignment behavior of the scroll action.
    public func scrollTo<ID>(_ id: ID, anchor: UnitPoint? = nil) where ID : Hashable
}

/// A view that provides programmatic scrolling, by working with a proxy
/// to scroll to known child views.
///
/// The scroll view reader's content view builder receives a ``ScrollViewProxy``
/// instance; you use the proxy's ``ScrollViewProxy/scrollTo(_:anchor:)`` to
/// perform scrolling.
///
/// The following example creates a ``ScrollView`` containing 100 views that
/// together display a color gradient. It also contains two buttons, one each
/// at the top and bottom. The top button tells the ``ScrollViewProxy`` to
/// scroll to the bottom button, and vice versa.
///
///     @Namespace var topID
///     @Namespace var bottomID
///
///     var body: some View {
///         ScrollViewReader { proxy in
///             ScrollView {
///                 Button("Scroll to Bottom") {
///                     withAnimation {
///                         proxy.scrollTo(bottomID)
///                     }
///                 }
///                 .id(topID)
///
///                 VStack(spacing: 0) {
///                     ForEach(0..<100) { i in
///                         color(fraction: Double(i) / 100)
///                             .frame(height: 32)
///                     }
///                 }
///
///                 Button("Top") {
///                     withAnimation {
///                         proxy.scrollTo(topID)
///                     }
///                 }
///                 .id(bottomID)
///             }
///         }
///     }
///
///     func color(fraction: Double) -> Color {
///         Color(red: fraction, green: 1 - fraction, blue: 0.5)
///     }
///
/// ![A scroll view, with a button labeled "Scroll to Bottom" at top.
/// Below this, a series of vertically aligned rows, each filled with a
/// color, that are progressing from green to
/// red.](SwiftUI-ScrollViewReader-scroll-to-bottom-button.png)
///
/// > Important: You may not use the ``ScrollViewProxy``
/// during execution of the `content` view builder; doing so results in a
/// runtime error. Instead, only actions created within `content` can call
/// the proxy, such as gesture handlers or a view's `onChange(of:perform:)`
/// method.
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
@frozen public struct ScrollViewReader<Content> : View where Content : View {

    /// The view builder that creates the reader's content.
    public var content: (ScrollViewProxy) -> Content

    /// Creates an instance that can perform programmatic scrolling of its
    /// child scroll views.
    ///
    /// - Parameter content: The reader's content, containing one or more
    /// scroll views. This view builder receives a ``ScrollViewProxy``
    /// instance that you use to perform scrolling.
    @inlinable public init(@ViewBuilder content: @escaping (ScrollViewProxy) -> Content)

    /// The content and behavior of the view.
    ///
    /// When you implement a custom view, you must implement a computed
    /// `body` property to provide the content for your view. Return a view
    /// that's composed of built-in views that SwiftUI provides, plus other
    /// composite views that you've already defined:
    ///
    ///     struct MyView: View {
    ///         var body: some View {
    ///             Text("Hello, World!")
    ///         }
    ///     }
    ///
    /// For more information about composing views and a view hierarchy,
    /// see <doc:Declaring-a-Custom-View>.
    @MainActor @preconcurrency public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
    public typealias Body = some View
}

/// The placement of a search field in a view hierarchy.
///
/// You can give a preferred placement to any of the searchable modifiers, like
/// ``View/searchable(text:placement:prompt:)``:
///
///     var body: some View {
///         NavigationView {
///             PrimaryView()
///             SecondaryView()
///             Text("Select a primary and secondary item")
///         }
///         .searchable(text: $text, placement: .sidebar)
///     }
///
/// Depending on the containing view hierachy, SwiftUI might not be able to
/// fulfill your request.
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public struct SearchFieldPlacement : Sendable {

    /// SwiftUI places the search field automatically.
    ///
    /// Placement of the search field depends on the platform:
    /// * In iOS, iPadOS, and macOS, the search field appears in the toolbar.
    /// * In tvOS and watchOS, the search field appears inline with its
    ///   content.
    public static let automatic: SearchFieldPlacement

    /// The search field appears in the toolbar.
    ///
    /// The precise placement depends on the platform:
    /// * In iOS and watchOS, the search field appears below the
    ///   navigation bar and is revealed by scrolling.
    /// * In iPadOS, the search field appears in the trailing
    ///   navigation bar.
    /// * In macOS, the search field appears in the trailing toolbar.
    @available(tvOS, unavailable)
    public static let toolbar: SearchFieldPlacement

    /// The search field appears in the sidebar of a navigation view.
    ///
    /// The precise placement depends on the platform:
    /// * In iOS and iPadOS the search field appears in the section of
    ///   the navigation bar associated with the sidebar.
    /// * In macOS, the search field appears inline with the sidebar's content.
    ///
    /// If a sidebar isn't available, like when you apply the searchable
    /// modifier to a view other than a navigation split view, SwiftUI uses
    /// automatic placement instead.
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public static let sidebar: SearchFieldPlacement

    /// The search field appears in the navigation bar.
    ///
    /// The field appears below any navigation bar title and uses the
    /// ``NavigationBarDrawerDisplayMode/automatic`` display mode to configure
    /// when to hide the search field. To choose a different display mode,
    /// use ``navigationBarDrawer(displayMode:)`` instead.
    @available(iOS 15.0, watchOS 8.0, *)
    @available(macOS, unavailable)
    @available(tvOS, unavailable)
    public static let navigationBarDrawer: SearchFieldPlacement

    /// The search field appears in the navigation bar using the specified
    /// display mode.
    ///
    /// The field appears below any navigation bar title. The system can
    /// hide the field in response to scrolling, depending on the `displayMode`
    /// that you set.
    ///
    /// - Parameter displayMode: A control that indicates whether to hide
    ///   the search field in response to scrolling.
    @available(iOS 15.0, *)
    @available(macOS, unavailable)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public static func navigationBarDrawer(displayMode: SearchFieldPlacement.NavigationBarDrawerDisplayMode) -> SearchFieldPlacement
}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension SearchFieldPlacement {

    /// A mode that determines when to display a search field that appears in a
    /// navigation bar.
    @available(iOS 15.0, *)
    @available(macOS, unavailable)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public struct NavigationBarDrawerDisplayMode : Sendable {

        /// Enable hiding the search field in response to scrolling.
        public static let automatic: SearchFieldPlacement.NavigationBarDrawerDisplayMode

        /// Always display the search field regardless of the scroll activity.
        public static let always: SearchFieldPlacement.NavigationBarDrawerDisplayMode
    }
}

/// A type that defines how the toolbar behaves when presenting search.
///
/// Use this type in combination with the
/// ``View/searchPresentationToolbarBehavior(_:)``
@available(iOS 17.1, macOS 14.1, tvOS 17.1, watchOS 10.1, *)
public struct SearchPresentationToolbarBehavior {

    /// The automatic behavior.
    public static var automatic: SearchPresentationToolbarBehavior { get }

    /// The avoid hiding content behavior.
    ///
    /// In iOS, this will avoid hiding content in the toolbar as
    /// it adapts to a search presentation. This has no effect on other
    /// platforms.
    public static var avoidHidingContent: SearchPresentationToolbarBehavior { get }
}

/// The ways that searchable modifiers can show or hide search scopes.
@available(iOS 16.4, macOS 13.3, tvOS 16.4, watchOS 9.4, *)
public struct SearchScopeActivation {

    /// The automatic activation of the scope bar.
    ///
    /// By default, this is ``SearchScopeActivation/onTextEntry``
    /// in iOS and ``SearchScopeActivation/onSearchPresentation``
    /// in macOS.
    public static var automatic: SearchScopeActivation { get }

    /// An activation where the system shows search scopes
    /// when typing begins in the search field and hides
    /// search scopes after search cancellation.
    @available(tvOS, unavailable)
    public static var onTextEntry: SearchScopeActivation { get }

    /// An activation where the system shows search scopes after
    /// presenting search and hides search scopes after search
    /// cancellation.
    @available(tvOS, unavailable)
    public static var onSearchPresentation: SearchScopeActivation { get }
}

/// The ways that SwiftUI displays search suggestions.
///
/// You can influence which modes SwiftUI displays search suggestions for by
/// using the ``View/searchSuggestions(_:for:)`` modifier:
///
///     enum FruitSuggestion: String, Identifiable {
///         case apple, banana, orange
///         var id: Self { self }
///     }
///
///     @State private var text = ""
///     @State private var suggestions: [FruitSuggestion] = []
///
///     var body: some View {
///         MainContent()
///             .searchable(text: $text) {
///                 ForEach(suggestions) { suggestion in
///                     Text(suggestion.rawValue)
///                         .searchCompletion(suggestion.rawValue)
///                 }
///                 .searchSuggestions(.hidden, for: .content)
///             }
///     }
///
/// In the above example, SwiftUI only displays search suggestions in
/// a suggestions menu. You might want to do this when you want to
/// render search suggestions in a container, like inline with
/// your own set of search results.
///
/// You can get the current search suggestion placement by querying the
/// ``EnvironmentValues/searchSuggestionsPlacement`` environment value in your
/// search suggestions.
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct SearchSuggestionsPlacement : Equatable, Sendable {

    /// Search suggestions render automatically based on the surrounding
    /// context.
    ///
    /// The behavior varies by platform:
    /// * In iOS and iPadOS, suggestions render as a list overlaying the main
    ///   content of the app.
    /// * In macOS, suggestions render in a menu.
    /// * In tvOS, suggestions render as a row underneath the search field.
    /// * In watchOS, suggestions render in a list pushed onto the containing
    ///   navigation stack.
    public static var automatic: SearchSuggestionsPlacement { get }

    /// Search suggestions render inside of a menu attached to the search field.
    public static var menu: SearchSuggestionsPlacement { get }

    /// Search suggestions render in the main content of the app.
    public static var content: SearchSuggestionsPlacement { get }

    /// An efficient set of search suggestion display modes.
    public struct Set : OptionSet, Sendable {

        /// A type for the elements of the set.
        public typealias Element = SearchSuggestionsPlacement.Set

        /// The raw value that records the search suggestion display modes.
        public var rawValue: Int

        /// A set containing the menu display mode.
        public static var menu: SearchSuggestionsPlacement.Set { get }

        /// A set containing placements with the apps main content, excluding
        /// the menu placement.
        public static var content: SearchSuggestionsPlacement.Set { get }

        /// Creates a set of search suggestions from an integer.
        public init(rawValue: Int)

        /// The type of the elements of an array literal.
        @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
        public typealias ArrayLiteralElement = SearchSuggestionsPlacement.Set.Element

        /// The raw type that can be used to represent all values of the conforming
        /// type.
        ///
        /// Every distinct value of the conforming type has a corresponding unique
        /// value of the `RawValue` type, but there may be values of the `RawValue`
        /// type that don't have a corresponding value of the conforming type.
        @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
        public typealias RawValue = Int
    }

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: SearchSuggestionsPlacement, b: SearchSuggestionsPlacement) -> Bool
}

/// A structure that represents the body of a static placeholder search view.
///
/// You don't create this type directly. SwiftUI creates it when you build
/// a search``ContentUnavailableView``.
@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
public struct SearchUnavailableContent {

    /// A view that represents the label of a static placeholder search view.
    ///
    /// You don't create this type directly. SwiftUI creates it when you build
    /// a search``ContentUnavailableView``.
    @MainActor @preconcurrency public struct Label : View {

        /// The content and behavior of the view.
        ///
        /// When you implement a custom view, you must implement a computed
        /// `body` property to provide the content for your view. Return a view
        /// that's composed of built-in views that SwiftUI provides, plus other
        /// composite views that you've already defined:
        ///
        ///     struct MyView: View {
        ///         var body: some View {
        ///             Text("Hello, World!")
        ///         }
        ///     }
        ///
        /// For more information about composing views and a view hierarchy,
        /// see <doc:Declaring-a-Custom-View>.
        @MainActor @preconcurrency public var body: some View { get }

        /// The type of view representing the body of this view.
        ///
        /// When you create a custom view, Swift infers this type from your
        /// implementation of the required ``View/body-swift.property`` property.
        @available(iOS 17.0, tvOS 17.0, watchOS 10.0, macOS 14.0, *)
        public typealias Body = some View
    }

    /// A view that represents the description of a static `ContentUnavailableView.search` view.
    ///
    /// You don't create this type directly. SwiftUI creates it when you build
    /// a search``ContentUnavailableView`.
    @MainActor @preconcurrency public struct Description : View {

        /// The content and behavior of the view.
        ///
        /// When you implement a custom view, you must implement a computed
        /// `body` property to provide the content for your view. Return a view
        /// that's composed of built-in views that SwiftUI provides, plus other
        /// composite views that you've already defined:
        ///
        ///     struct MyView: View {
        ///         var body: some View {
        ///             Text("Hello, World!")
        ///         }
        ///     }
        ///
        /// For more information about composing views and a view hierarchy,
        /// see <doc:Declaring-a-Custom-View>.
        @MainActor @preconcurrency public var body: some View { get }

        /// The type of view representing the body of this view.
        ///
        /// When you create a custom view, Swift infers this type from your
        /// implementation of the required ``View/body-swift.property`` property.
        @available(iOS 17.0, tvOS 17.0, watchOS 10.0, macOS 14.0, *)
        public typealias Body = some View
    }

    /// A view that represents the actions of a static `ContentUnavailableView.search` view.
    ///
    /// You don't create this type directly. SwiftUI creates it when you build
    /// a search``ContentUnavailableView``.
    @MainActor @preconcurrency public struct Actions : View {

        /// The content and behavior of the view.
        ///
        /// When you implement a custom view, you must implement a computed
        /// `body` property to provide the content for your view. Return a view
        /// that's composed of built-in views that SwiftUI provides, plus other
        /// composite views that you've already defined:
        ///
        ///     struct MyView: View {
        ///         var body: some View {
        ///             Text("Hello, World!")
        ///         }
        ///     }
        ///
        /// For more information about composing views and a view hierarchy,
        /// see <doc:Declaring-a-Custom-View>.
        @MainActor @preconcurrency public var body: some View { get }

        /// The type of view representing the body of this view.
        ///
        /// When you create a custom view, Swift infers this type from your
        /// implementation of the required ``View/body-swift.property`` property.
        @available(iOS 17.0, tvOS 17.0, watchOS 10.0, macOS 14.0, *)
        public typealias Body = some View
    }
}

/// A container view that you can use to add hierarchy within certain views.
///
/// Use `Section` instances in views like ``List``, ``Picker``, and
/// ``Form`` to organize content into separate sections. Each section has
/// custom content that you provide on a per-instance basis. You can also
/// provide headers and footers for each section.
///
/// ### Collapsible sections
///
/// Create sections that expand and collapse by using an initializer that
/// accepts an `isExpanded` binding. A collapsible section in a ``List`` that
/// uses the ``ListStyle/sidebar`` style shows a disclosure indicator next to
/// the section's header. Tapping on the disclosure indicator toggles the
/// appearance of the section's content.
///
/// > Note: Not all contexts provide a default control to trigger collapse or
///   expansion.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public struct Section<Parent, Content, Footer> {
}

@available(iOS 16.0, macOS 13.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension Section : TableRowContent where Parent : TableRowContent, Content : TableRowContent, Footer : TableRowContent {

    /// The type of value represented by this table row content.
    public typealias TableRowValue = Content.TableRowValue

    /// The type of content representing the body of this table row content.
    public typealias TableRowBody = Never

    /// Creates a section with a header and the provided section content.
    /// - Parameters:
    ///   - content: The section's content.
    ///   - header: A view to use as the section's header.
    nonisolated public init<V, H>(@TableRowBuilder<V> content: () -> Content, @ViewBuilder header: () -> H) where Parent == TableHeaderRowContent<V, H>, Footer == EmptyTableRowContent<V>, V == Content.TableRowValue, H : View

    /// Creates a section with the provided section content.
    /// - Parameters:
    ///   - titleKey: The key for the section's localized title, which describes
    ///     the contents of the section.
    ///   - content: The section's content.
    nonisolated public init<V>(_ titleKey: LocalizedStringKey, @TableRowBuilder<V> content: () -> Content) where Parent == TableHeaderRowContent<V, Text>, Footer == EmptyTableRowContent<V>, V == Content.TableRowValue

    /// Creates a section with the provided section content.
    /// - Parameters:
    ///   - title: A string that describes the contents of the section.
    ///   - content: The section's content.
    nonisolated public init<V, S>(_ title: S, @TableRowBuilder<V> content: () -> Content) where Parent == TableHeaderRowContent<V, Text>, Footer == EmptyTableRowContent<V>, V == Content.TableRowValue, S : StringProtocol

    /// Creates a section with the provided section content.
    /// - Parameters:
    ///   - content: The section's content.
    nonisolated public init<V>(@TableRowBuilder<V> content: () -> Content) where Parent == EmptyTableRowContent<V>, Footer == EmptyTableRowContent<V>, V == Content.TableRowValue
}

@available(iOS 17.0, macOS 14.0, visionOS 1.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension Section where Parent : TableRowContent, Content : TableRowContent {

    /// Creates a section with a header and the provided section content.
    /// - Parameters:
    ///   - isExpanded: A binding to a Boolean value that determines the section's
    ///    expansion state (expanded or collapsed).
    ///   - content: The section's content.
    ///   - header: A view to use as the section's header.
    nonisolated public init<V, H>(isExpanded: Binding<Bool>, @TableRowBuilder<V> content: () -> Content, @ViewBuilder header: () -> H) where Parent == TableHeaderRowContent<V, H>, Footer == EmptyTableRowContent<V>, V == Content.TableRowValue, H : View

    /// Creates a section with the provided section content.
    /// - Parameters:
    ///   - titleKey: The key for the section's localized title, which describes
    ///     the contents of the section.
    ///   - isExpanded: A binding to a Boolean value that determines the section's
    ///    expansion state (expanded or collapsed).
    ///   - content: The section's content.
    nonisolated public init<V>(_ titleKey: LocalizedStringKey, isExpanded: Binding<Bool>, @TableRowBuilder<V> content: () -> Content) where Parent == TableHeaderRowContent<V, Text>, Footer == EmptyTableRowContent<V>, V == Content.TableRowValue

    /// Creates a section with the provided section content.
    /// - Parameters:
    ///   - title: A string that describes the contents of the section.
    ///   - isExpanded: A binding to a Boolean value that determines the section's
    ///    expansion state (expanded or collapsed).
    ///   - content: The section's content.
    nonisolated public init<V, S>(_ title: S, isExpanded: Binding<Bool>, @TableRowBuilder<V> content: () -> Content) where Parent == TableHeaderRowContent<V, Text>, Footer == EmptyTableRowContent<V>, V == Content.TableRowValue, S : StringProtocol
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Section : View where Parent : View, Content : View, Footer : View {

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    public typealias Body = Never
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Section where Parent : View, Content : View, Footer : View {

    /// Creates a section with a header, footer, and the provided section
    /// content.
    ///
    /// - Parameters:
    ///   - content: The section's content.
    ///   - header: A view to use as the section's header.
    ///   - footer: A view to use as the section's footer.
    public init(@ViewBuilder content: () -> Content, @ViewBuilder header: () -> Parent, @ViewBuilder footer: () -> Footer)
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Section where Parent == EmptyView, Content : View, Footer : View {

    /// Creates a section with a footer and the provided section content.
    /// - Parameters:
    ///   - content: The section's content.
    ///   - footer: A view to use as the section's footer.
    public init(@ViewBuilder content: () -> Content, @ViewBuilder footer: () -> Footer)
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Section where Parent : View, Content : View, Footer == EmptyView {

    /// Creates a section with a header and the provided section content.
    /// - Parameters:
    ///   - content: The section's content.
    ///   - header: A view to use as the section's header.
    public init(@ViewBuilder content: () -> Content, @ViewBuilder header: () -> Parent)
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Section where Parent == EmptyView, Content : View, Footer == EmptyView {

    /// Creates a section with the provided section content.
    /// - Parameters:
    ///   - content: The section's content.
    public init(@ViewBuilder content: () -> Content)
}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension Section where Parent == Text, Content : View, Footer == EmptyView {

    /// Creates a section with the provided section content.
    /// - Parameters:
    ///   - titleKey: The key for the section's localized title, which describes
    ///     the contents of the section.
    ///   - content: The section's content.
    public init(_ titleKey: LocalizedStringKey, @ViewBuilder content: () -> Content)

    /// Creates a section with the provided section content.
    /// - Parameters:
    ///   - title: A string that describes the contents of the section.
    ///   - content: The section's content.
    public init<S>(_ title: S, @ViewBuilder content: () -> Content) where S : StringProtocol
}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, visionOS 1.0, *)
extension Section where Parent == Text, Content : View, Footer == EmptyView {

    /// Creates a section with the provided section content.
    /// - Parameters:
    ///   - titleKey: The key for the section's localized title, which describes
    ///     the contents of the section.
    ///   - isExpanded: A binding to a Boolean value that determines the section's
    ///    expansion state (expanded or collapsed).
    ///   - content: The section's content.
    public init(_ titleKey: LocalizedStringKey, isExpanded: Binding<Bool>, @ViewBuilder content: () -> Content)

    /// Creates a section with the provided section content.
    /// - Parameters:
    ///   - title: A string that describes the contents of the section.
    ///   - isExpanded: A binding to a Boolean value that determines the section's
    ///    expansion state (expanded or collapsed).
    ///   - content: The section's content.
    public init<S>(_ title: S, isExpanded: Binding<Bool>, @ViewBuilder content: () -> Content) where S : StringProtocol
}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, visionOS 1.0, *)
extension Section where Parent : View, Content : View, Footer == EmptyView {

    /// Creates a section with a header, the provided section content, and a binding
    /// representing the section's expansion state.
    ///
    /// - Parameters:
    ///   - isExpanded: A binding to a Boolean value that determines the section's
    ///    expansion state (expanded or collapsed).
    ///   - content: The section's content.
    ///   - header: A view to use as the section's header.
    public init(isExpanded: Binding<Bool>, @ViewBuilder content: () -> Content, @ViewBuilder header: () -> Parent)
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Section where Parent : View, Content : View, Footer : View {

    /// Creates a section with a header, footer, and the provided section content.
    /// - Parameters:
    ///   - header: A view to use as the section's header.
    ///   - footer: A view to use as the section's footer.
    ///   - content: The section's content.
    @available(iOS, deprecated: 100000.0, renamed: "Section(content:header:footer:)")
    @available(macOS, deprecated: 100000.0, renamed: "Section(content:header:footer:)")
    @available(tvOS, deprecated: 100000.0, renamed: "Section(content:header:footer:)")
    @available(watchOS, deprecated: 100000.0, renamed: "Section(content:header:footer:)")
    @available(visionOS, deprecated: 100000.0, renamed: "Section(content:header:footer:)")
    public init(header: Parent, footer: Footer, @ViewBuilder content: () -> Content)
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Section where Parent == EmptyView, Content : View, Footer : View {

    /// Creates a section with a footer and the provided section content.
    /// - Parameters:
    ///   - footer: A view to use as the section's footer.
    ///   - content: The section's content.
    @available(iOS, deprecated: 100000.0, renamed: "Section(content:footer:)")
    @available(macOS, deprecated: 100000.0, renamed: "Section(content:footer:)")
    @available(tvOS, deprecated: 100000.0, renamed: "Section(content:footer:)")
    @available(watchOS, deprecated: 100000.0, renamed: "Section(content:footer:)")
    @available(visionOS, deprecated: 100000.0, renamed: "Section(content:footer:)")
    public init(footer: Footer, @ViewBuilder content: () -> Content)
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Section where Parent : View, Content : View, Footer == EmptyView {

    /// Creates a section with a header and the provided section content.
    /// - Parameters:
    ///   - header: A view to use as the section's header.
    ///   - content: The section's content.
    @available(iOS, deprecated: 100000.0, renamed: "Section(content:header:)")
    @available(macOS, deprecated: 100000.0, renamed: "Section(content:header:)")
    @available(tvOS, deprecated: 100000.0, renamed: "Section(content:header:)")
    @available(watchOS, deprecated: 100000.0, renamed: "Section(content:header:)")
    @available(visionOS, deprecated: 100000.0, renamed: "Section(content:header:)")
    public init(header: Parent, @ViewBuilder content: () -> Content)
}

/// An opaque collection representing the sections of view.
///
/// Sections are constructed lazily, on demand, so access only as much
/// of this collection as is necessary to create the resulting content.
///
/// You can get access to a view's ``SectionCollection`` by using the
/// ``Group/init(sectionsOf:transform:)`` initializer.
///
/// Any content of the given view which is not explicitly specified as a section
/// is grouped with its sibling content to form implicit sections, meaning the
/// minimum number of sections in a `SectionCollection` is one.
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct SectionCollection : RandomAccessCollection {

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    ///
    /// - Complexity: O(1)
    public subscript(index: Int) -> SectionConfiguration { get }

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: Int { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.firstIndex(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: Int { get }

    /// A type representing the sequence's elements.
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias Element = SectionConfiguration

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias Index = Int

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias Indices = Range<Int>

    /// A type that provides the collection's iteration interface and
    /// encapsulates its iteration state.
    ///
    /// By default, a collection conforms to the `Sequence` protocol by
    /// supplying `IndexingIterator` as its associated `Iterator`
    /// type.
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias Iterator = IndexingIterator<SectionCollection>

    /// A collection representing a contiguous subrange of this collection's
    /// elements. The subsequence shares indices with the original collection.
    ///
    /// The default subsequence type for collections that don't define their own
    /// is `Slice`.
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias SubSequence = Slice<SectionCollection>
}

/// Specifies the contents of a section.
///
/// A `SectionConfiguration` includes the content of the section, as well as
/// its header and footer.
///
/// A `SectionConfiguration` can represent either an explicit section,
/// or groups of sibling views that are not explicitly wrapped in a section.
///
/// Notably, the `header`, `footer` and `content` properties of a
/// `SectionConfiguration` are all `SubviewsCollection`s as they can be made up
/// of multiple subviews. That means in most cases, the subviews collection
/// should be treated as a collection (either indexed into, or used with a
/// `ForEach`), or the subviews collection should be wrapped in a container
/// view, like a layout, or other custom container:
///
///     PinboardSectionsLayout {
///         ForEach(sections: content) { section in
///             VStack {
///                 HStack { section.header }
///                 section.content
///                 HStack { section.footer }
///             }
///         }
///     }
///
/// Here, we want to create one view for `PinboardSectionsLayout` to place per
/// section in content. To do that, we surround the `ForEach` body in another
/// container, a `VStack` layout, ensuring the different subviews of
/// section.content are treated as a single view by the surrounding layout.
/// Additionally, surrounding the header and footer in an `HStack` layout
/// avoids vertically stacking subviews of the header and footer
/// which we want visually grouped together.
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct SectionConfiguration : Identifiable {

    /// A unique identifier for a section.
    public struct ID : Hashable {

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: SectionConfiguration.ID, b: SectionConfiguration.ID) -> Bool

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// A unique identifier representing the section.
    public var id: SectionConfiguration.ID { get }

    /// The container values associated with the given section.
    ///
    /// Only explicitly created sections are able to have container values,
    /// meaning this container values will be empty if the section is implicit.
    public var containerValues: ContainerValues { get }

    /// The contents of the section header.
    ///
    /// Notably, the section's header is a `SubviewsCollection`, not a
    /// `Subview`, as it can be made up of multiple subviews. That means in most
    /// cases, the subviews collection should be treated as a collection (either
    /// indexed into, or used with a `ForEach`), or the subviews collection
    /// should be wrapped in a container view, like a layout, or other custom
    /// container:
    ///
    ///     ForEach(sections: content) {
    ///         VStack {
    ///             HStack { section.header }
    ///             HStack { section.footer }
    ///         }
    ///     }
    ///
    /// Here, we surround the header and footer in an `HStack` layout to avoid
    /// vertically stacking the subviews of the header and footer which we want
    /// visually grouped together. Additionally, we surround the `ForEach` body
    /// in a VStack, so it is treated as a single view by containers it gets
    /// passed to.
    public var header: SubviewsCollection { get }

    /// The contents of the section footer.
    ///
    /// Notably, the section's footer is a `SubviewsCollection`, not a
    /// `Subview`, as it can be made up of multiple subviews. That means in most
    /// cases, the subviews collection should be treated as a collection (either
    /// indexed into, or used with a `ForEach`), or the subviews collection
    /// should be wrapped in a container view, like a layout, or other custom
    /// container:
    ///
    ///     ForEach(sections: content) {
    ///         VStack {
    ///             HStack { section.header }
    ///             HStack { section.footer }
    ///         }
    ///     }
    ///
    /// Here, we surround the header and footer in an `HStack` layout to avoid
    /// vertically stacking the subviews of the header and footer which we want
    /// visually grouped together. Additionally, we surround the `ForEach` body
    /// in a VStack, so it is treated as a single view by containers it gets
    /// passed to.
    public var footer: SubviewsCollection { get }

    /// The contents of the section body.
    ///
    /// Notably, the section's content is a `SubviewsCollection`, not a
    /// `Subview`, as it can be made up of multiple subviews. That means in most
    /// cases, the subviews collection should be treated as a collection (either
    /// indexed into, or used with a `ForEach`), or the subviews collection
    /// should be wrapped in a container view, like a layout, or other custom
    /// container:
    ///
    ///     PinboardSectionsLayout {
    ///         ForEach(sections: content) { section in
    ///             VStack {
    ///                 section.content
    ///             }
    ///         }
    ///     }
    ///
    /// Here, we want to create one view for `PinboardSectionsLayout` to place
    /// per section in content. To do that, we surround the `ForEach` body in
    /// another container, a `VStack` layout, ensuring the different subviews of
    /// section.content are treated as a single view by the surrounding layout.
    public var content: SubviewsCollection { get }
}

/// A property wrapper type that retrieves entities, grouped into sections,
/// from a Core Data persistent store.
///
/// Use a `SectionedFetchRequest` property wrapper to declare a
/// ``SectionedFetchResults`` property that provides a grouped collection of
/// Core Data managed objects to a SwiftUI view. If you don't need sectioning,
/// use ``FetchRequest`` instead.
///
/// Configure a sectioned fetch request with an optional predicate and sort
/// descriptors, and include a `sectionIdentifier` parameter to indicate how
/// to group the fetched results. Be sure that you choose sorting and sectioning
/// that work together to avoid discontiguous sections. For example, you can
/// request a list of earthquakes, composed of `Quake` managed objects that the
/// <doc://com.apple.documentation/documentation/CoreData/loading_and_displaying_a_large_data_feed>
/// sample code project defines to store earthquake data, sorted by time and
/// grouped by date:
///
///     @SectionedFetchRequest<String, Quake>(
///         sectionIdentifier: \.day,
///         sortDescriptors: [SortDescriptor(\.time, order: .reverse)]
///     )
///     private var quakes: SectionedFetchResults<String, Quake>
///
/// Always declare properties that have a sectioned fetch request wrapper as
/// private. This lets the compiler help you avoid accidentally setting
/// the property from the memberwise initializer of the enclosing view.
///
/// The request infers the entity type from the `Result` type that you specify,
/// which is `Quake` in the example above. Indicate a `SectionIdentifier` type
/// to declare the type found at the fetched object's `sectionIdentifier`
/// key path. The section identifier type must conform to the
/// <doc://com.apple.documentation/documentation/Swift/Hashable> protocol.
///
/// The example above depends on the `Quake` type having a `day` property that's
/// either a stored or computed string. Be sure to mark any computed property
/// with the `@objc` attribute for it to function as a section identifier.
/// For best performance with large data sets, use stored properties.
///
/// The sectioned fetch request and its results use the managed object context
/// stored in the environment, which you can access using the
/// ``EnvironmentValues/managedObjectContext`` environment value. To
/// support user interface activity, you typically rely on the
/// <doc://com.apple.documentation/documentation/CoreData/NSPersistentContainer/1640622-viewContext>
/// property of a shared
/// <doc://com.apple.documentation/documentation/CoreData/NSPersistentContainer>
/// instance. For example, you can set a context on your top-level content
/// view using a shared container that you define as part of your model:
///
///     ContentView()
///         .environment(
///             \.managedObjectContext,
///             QuakesProvider.shared.container.viewContext)
///
/// When you need to dynamically change the section identifier, predicate,
/// or sort descriptors, access the request's
/// ``SectionedFetchRequest/Configuration`` structure, either directly or with
/// a binding.
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
@MainActor @propertyWrapper @preconcurrency public struct SectionedFetchRequest<SectionIdentifier, Result> where SectionIdentifier : Hashable, Result : NSFetchRequestResult {

    /// The fetched results of the fetch request.
    ///
    /// This property behaves like the ``FetchRequest/wrappedValue`` of a
    /// ``FetchRequest``. In particular, SwiftUI returns the value associated
    /// with this property when you use ``SectionedFetchRequest`` as a property
    /// wrapper and then access the wrapped property by name. For example,
    /// consider the following `quakes` property declaration that fetches a
    /// `Quake` type that the
    /// <doc://com.apple.documentation/documentation/CoreData/loading_and_displaying_a_large_data_feed>
    /// sample code project defines:
    ///
    ///     @SectionedFetchRequest<String, Quake>(
    ///         sectionIdentifier: \.day,
    ///         sortDescriptors: [SortDescriptor(\.time, order: .reverse)]
    ///     )
    ///     private var quakes: SectionedFetchResults<String, Quake>
    ///
    /// You access the request's `wrappedValue`, which contains a
    /// ``SectionedFetchResults`` instance, by referring to the `quakes`
    /// property by name. That value is a collection
    /// of sections, each of which contains a group of managed objects:
    ///
    ///     Text("Found \(quakes.count) days of earthquakes")
    ///
    /// If you need to separate the request and the result
    /// entities, you can declare `quakes` in two steps by
    /// using the request's `wrappedValue` to obtain the results:
    ///
    ///     var fetchRequest = SectionedFetchRequest<String, Quake>(
    ///         fetchRequest: request,
    ///         sectionIdentifier: \.day)
    ///     var quakes: SectionedFetchedResults<String, Quake> { fetchRequest.wrappedValue }
    ///
    /// The `wrappedValue` property returns an empty array when there are no
    /// fetched results; for example, because no entities satisfy the
    /// predicate, or because the data store is empty.
    @MainActor @preconcurrency public var wrappedValue: SectionedFetchResults<SectionIdentifier, Result> { get }

    /// The request's configurable properties.
    ///
    /// You initialize a ``SectionedFetchRequest`` with a section identifier,
    /// an optional predicate, and sort descriptors, either explicitly or with
    /// a configured
    /// <doc://com.apple.documentation/documentation/CoreData/NSFetchRequest>.
    /// Later, you can dynamically update the identifier, predicate, and sort
    /// parameters using the request's configuration structure.
    ///
    /// You access or bind to a request's configuration components through
    /// properties on the associated ``SectionedFetchResults`` instance,
    /// just like you do for a ``FetchRequest`` using
    /// ``FetchRequest/Configuration``.
    ///
    /// When configuring a sectioned fetch request, ensure that the
    /// combination of the section identifier and the primary sort descriptor
    /// doesn't create discontiguous sections.
    public struct Configuration {

        /// The request's section identifier key path.
        ///
        /// Set this configuration value to cause a ``SectionedFetchRequest``
        /// to execute a fetch with a new section identifier. You can't change
        /// the section identifier type without creating a new fetch request.
        /// Use care to coordinate section and sort updates, as described
        /// in ``SectionedFetchRequest/Configuration``.
        ///
        /// Access this value for a given request by using the
        /// ``SectionedFetchResults/sectionIdentifier`` property on the
        /// associated ``SectionedFetchResults`` instance, either directly or
        /// with a ``Binding``.
        public var sectionIdentifier: KeyPath<Result, SectionIdentifier>

        /// The request's sort descriptors, accessed as reference types.
        ///
        /// Set this configuration value to cause a ``SectionedFetchRequest``
        /// to execute a fetch with a new collection of
        /// <doc://com.apple.documentation/documentation/Foundation/NSSortDescriptor>
        /// instances. If you want to use
        /// <doc://com.apple.documentation/documentation/Foundation/SortDescriptor>
        /// instances, set ``SectionedFetchRequest/Configuration/sortDescriptors``
        /// instead. Use care to coordinate section and sort updates, as
        /// described in ``SectionedFetchRequest/Configuration``.
        ///
        /// Access this value for a given request by using the
        /// ``SectionedFetchResults/nsSortDescriptors`` property on the
        /// associated ``SectionedFetchResults`` instance, either directly or
        /// with a ``Binding``.
        public var nsSortDescriptors: [NSSortDescriptor]

        /// The request's predicate.
        ///
        /// Set this configuration value to cause a ``SectionedFetchRequest``
        /// to execute a fetch with a new predicate.
        ///
        /// Access this value for a given request by using the
        /// ``SectionedFetchResults/nsPredicate`` property on the associated
        /// ``SectionedFetchResults`` instance, either directly or with a
        /// ``Binding``.
        public var nsPredicate: NSPredicate?
    }

    /// A binding to the request's mutable configuration properties.
    ///
    /// This property behaves like the ``FetchRequest/projectedValue``
    /// of a ``FetchRequest``. In particular,
    /// SwiftUI returns the value associated with this property when you use
    /// ``SectionedFetchRequest`` as a property wrapper on a
    /// ``SectionedFetchResults`` instance and then access the results with
    /// a dollar sign (`$`) prefix. The value that SwiftUI returns is a
    /// ``Binding`` to the request's ``SectionedFetchRequest/Configuration``
    /// structure, which dynamically configures the request.
    @MainActor @preconcurrency public var projectedValue: Binding<SectionedFetchRequest<SectionIdentifier, Result>.Configuration> { get }
}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension SectionedFetchRequest : DynamicProperty {

    /// Updates the fetched results.
    ///
    /// SwiftUI calls this function before rendering a view's
    /// ``View/body-swift.property`` to ensure the view has the most recent
    /// fetched results.
    @MainActor @preconcurrency public func update()
}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension SectionedFetchRequest {

    /// Creates a sectioned fetch request for a specified entity description,
    /// based on a section identifier, a predicate, and sort parameters.
    ///
    /// Use this initializer if you need to explicitly specify the entity type
    /// for the request. If you specify a placeholder `Result` type in the
    /// request declaration, use the
    /// ``init(sectionIdentifier:sortDescriptors:predicate:animation:)``
    /// initializer to let the request infer the entity type. If you need more
    /// control over the fetch request configuration, use
    /// ``init(fetchRequest:sectionIdentifier:animation:)``.
    ///
    /// - Parameters:
    ///   - entity: The description of the Core Data entity to fetch.
    ///   - sectionIdentifier: A key path that SwiftUI applies to the `Result`
    ///     type to get an object's section identifier.
    ///   - sortDescriptors: An array of sort descriptors that define the sort
    ///     order of the fetched results.
    ///   - predicate: An
    ///     <doc://com.apple.documentation/documentation/Foundation/NSPredicate>
    ///     instance that defines logical conditions used to filter the fetched
    ///     results.
    ///   - animation: The animation to use for user interface changes that
    ///     result from changes to the fetched results.
    @MainActor @preconcurrency public init(entity: NSEntityDescription, sectionIdentifier: KeyPath<Result, SectionIdentifier>, sortDescriptors: [NSSortDescriptor], predicate: NSPredicate? = nil, animation: Animation? = nil)

    /// Creates a fully configured sectioned fetch request that uses the
    /// specified animation when updating results.
    ///
    /// Use this initializer when you want to configure a fetch
    /// request with more than a predicate and sort descriptors.
    /// For example, you can vend a request from a `Quake` managed object
    /// that the
    /// <doc://com.apple.documentation/documentation/CoreData/loading_and_displaying_a_large_data_feed>
    /// sample code project defines to store earthquake data.
    /// Limit the number of results to `1000` by setting a
    /// <doc://com.apple.documentation/documentation/CoreData/NSFetchRequest/1506622-fetchLimit>
    /// for the request:
    ///
    ///     extension Quake {
    ///         var request: NSFetchRequest<Quake> {
    ///             let request = NSFetchRequest<Quake>(entityName: "Quake")
    ///             request.sortDescriptors = [
    ///                 NSSortDescriptor(
    ///                     keyPath: \Quake.time,
    ///                     ascending: true)]
    ///             request.fetchLimit = 1000
    ///             return request
    ///         }
    ///     }
    ///
    /// Use the request to define a ``SectionedFetchedResults`` property:
    ///
    ///     @SectionedFetchRequest<String, Quake>(
    ///         fetchRequest: Quake.request,
    ///         sectionIdentifier: \.day)
    ///     private var quakes: FetchedResults<String, Quake>
    ///
    /// If you only need to configure the request's section identifier,
    /// predicate, and sort descriptors, use
    /// ``init(sectionIdentifier:sortDescriptors:predicate:animation:)``
    /// instead. If you need to specify a ``Transaction`` rather than an
    /// optional ``Animation``, use
    /// ``init(fetchRequest:sectionIdentifier:transaction:)``.
    ///
    /// - Parameters:
    ///   - fetchRequest: An
    ///     <doc://com.apple.documentation/documentation/CoreData/NSFetchRequest>
    ///     instance that describes the search criteria for retrieving data
    ///     from the persistent store.
    ///   - sectionIdentifier: A key path that SwiftUI applies to the `Result`
    ///     type to get an object's section identifier.
    ///   - animation: The animation to use for user interface changes that
    ///     result from changes to the fetched results.
    @MainActor @preconcurrency public init(fetchRequest: NSFetchRequest<Result>, sectionIdentifier: KeyPath<Result, SectionIdentifier>, animation: Animation? = nil)

    /// Creates a fully configured sectioned fetch request that uses the
    /// specified transaction when updating results.
    ///
    /// Use this initializer if you need a fetch request with updates that
    /// affect the user interface based on a ``Transaction``. Otherwise, use
    /// ``init(fetchRequest:sectionIdentifier:animation:)``.
    ///
    /// - Parameters:
    ///   - fetchRequest: An
    ///     <doc://com.apple.documentation/documentation/CoreData/NSFetchRequest>
    ///     instance that describes the search criteria for retrieving data
    ///     from the persistent store.
    ///   - sectionIdentifier: A key path that SwiftUI applies to the `Result`
    ///     type to get an object's section identifier.
    ///   - transaction: A transaction to use for user interface changes that
    ///     result from changes to the fetched results.
    @MainActor @preconcurrency public init(fetchRequest: NSFetchRequest<Result>, sectionIdentifier: KeyPath<Result, SectionIdentifier>, transaction: Transaction)
}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension SectionedFetchRequest where Result : NSManagedObject {

    /// Creates a sectioned fetch request based on a section identifier, a
    /// predicate, and reference type sort parameters.
    ///
    /// The request gets the entity type from the `Result` instance by calling
    /// that managed object's
    /// <doc://com.apple.documentation/documentation/CoreData/NSManagedObject/1640588-entity>
    /// type method. If you need to specify the entity type explicitly, use the
    /// ``init(entity:sectionIdentifier:sortDescriptors:predicate:animation:)``
    /// initializer instead. If you need more control over the fetch request
    /// configuration, use ``init(fetchRequest:sectionIdentifier:animation:)``.
    /// For value type sort descriptors, use
    /// ``init(sectionIdentifier:sortDescriptors:predicate:animation:)``.
    ///
    /// - Parameters:
    ///   - sectionIdentifier: A key path that SwiftUI applies to the `Result`
    ///     type to get an object's section identifier.
    ///   - sortDescriptors: An array of sort descriptors that define the sort
    ///     order of the fetched results.
    ///   - predicate: An
    ///     <doc://com.apple.documentation/documentation/Foundation/NSPredicate>
    ///     instance that defines logical conditions used to filter the fetched
    ///     results.
    ///   - animation: The animation to use for user interface changes that
    ///     result from changes to the fetched results.
    @MainActor @preconcurrency public init(sectionIdentifier: KeyPath<Result, SectionIdentifier>, sortDescriptors: [NSSortDescriptor], predicate: NSPredicate? = nil, animation: Animation? = nil)

    /// Creates a sectioned fetch request based on a section identifier,
    /// a predicate, and value type sort parameters.
    ///
    /// The request gets the entity type from the `Result` instance by calling
    /// that managed object's
    /// <doc://com.apple.documentation/documentation/CoreData/NSManagedObject/1640588-entity>
    /// type method. If you need to specify the entity type explicitly, use the
    /// ``init(entity:sectionIdentifier:sortDescriptors:predicate:animation:)``
    /// initializer instead. If you need more control over the fetch request
    /// configuration, use ``init(fetchRequest:sectionIdentifier:animation:)``.
    /// For reference type sort descriptors, use
    /// ``init(sectionIdentifier:sortDescriptors:predicate:animation:)``.
    ///
    /// - Parameters:
    ///   - sectionIdentifier: A key path that SwiftUI applies to the `Result`
    ///     type to get an object's section identifier.
    ///   - sortDescriptors: An array of sort descriptors that define the sort
    ///     order of the fetched results.
    ///   - predicate: An
    ///     <doc://com.apple.documentation/documentation/Foundation/NSPredicate>
    ///     instance that defines logical conditions used to filter the fetched
    ///     results.
    ///   - animation: The animation to use for user interface changes that
    ///     result from changes to the fetched results.
    @MainActor @preconcurrency public init(sectionIdentifier: KeyPath<Result, SectionIdentifier>, sortDescriptors: [SortDescriptor<Result>], predicate: NSPredicate? = nil, animation: Animation? = nil)
}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension SectionedFetchRequest.Configuration where Result : NSManagedObject {

    /// The request's sort descriptors, accessed as value types.
    ///
    /// Set this configuration value to cause a ``SectionedFetchRequest`` to
    /// execute a fetch with a new collection of
    /// <doc://com.apple.documentation/documentation/Foundation/SortDescriptor>
    /// instances. If you want to use
    /// <doc://com.apple.documentation/documentation/Foundation/NSSortDescriptor>
    /// instances, set ``SectionedFetchRequest/Configuration/nsSortDescriptors``
    /// instead. Use care to coordinate section and sort updates, as described
    /// in ``SectionedFetchRequest/Configuration``.
    ///
    /// Access this value for a given request by using the
    /// ``SectionedFetchResults/sortDescriptors`` property on the associated
    /// ``SectionedFetchResults`` instance, either directly or with a
    /// ``Binding``.
    public var sortDescriptors: [SortDescriptor<Result>]
}

/// A collection of results retrieved from a Core Data persistent store,
/// grouped into sections.
///
/// Use a `SectionedFetchResults` instance to show or edit Core Data managed
/// objects, grouped into sections, in your app's user interface. If you
/// don't need sectioning, use ``FetchedResults`` instead.
///
/// You request a particular set of results by annotating the fetched results
/// property declaration with a ``SectionedFetchRequest`` property wrapper.
/// Indicate the type of the fetched entities with a `Results` type,
/// and the type of the identifier that distinguishes the sections with
/// a `SectionIdentifier` type. For example, you can create a request to list
/// all `Quake` managed objects that the
/// <doc://com.apple.documentation/documentation/CoreData/loading_and_displaying_a_large_data_feed>
/// sample code project defines to store earthquake data, sorted by their `time`
/// property and grouped by a string that represents the days when earthquakes
/// occurred:
///
///     @SectionedFetchRequest<String, Quake>(
///         sectionIdentifier: \.day,
///         sortDescriptors: [SortDescriptor(\.time, order: .reverse)]
///     )
///     private var quakes: SectionedFetchResults<String, Quake>
///
/// The `quakes` property acts as a collection of ``Section`` instances, each
/// containing a collection of `Quake` instances. The example above depends
/// on the `Quake` model object declaring both `time` and `day`
/// properties, either stored or computed. For best performance with large
/// data sets, use stored properties.
///
/// The collection of sections, as well as the collection of managed objects in
/// each section, conforms to the
/// <doc://com.apple.documentation/documentation/Swift/RandomAccessCollection>
/// protocol, so you can access them as you would any other collection. For
/// example, you can create nested ``ForEach`` loops inside a ``List`` to
/// iterate over the results:
///
///     List {
///         ForEach(quakes) { section in
///             Section(header: Text(section.id)) {
///                 ForEach(section) { quake in
///                     QuakeRow(quake: quake) // Displays information about a quake.
///                 }
///             }
///         }
///     }
///
/// Don't confuse the ``SwiftUI/Section`` view that you use to create a
/// hierarchical display with the ``SectionedFetchResults/Section``
/// instances that hold the fetched results.
///
/// When you need to dynamically change the request's section identifier,
/// predicate, or sort descriptors, set the result instance's
/// ``sectionIdentifier``, ``nsPredicate``, and ``sortDescriptors`` or
/// ``nsSortDescriptors`` properties, respectively. Be sure that the sorting
/// and sectioning work together to avoid discontinguous sections.
///
/// The fetch request and its results use the managed object context stored
/// in the environment, which you can access using the
/// ``EnvironmentValues/managedObjectContext`` environment value. To
/// support user interface activity, you typically rely on the
/// <doc://com.apple.documentation/documentation/CoreData/NSPersistentContainer/1640622-viewContext>
/// property of a shared
/// <doc://com.apple.documentation/documentation/CoreData/NSPersistentContainer>
/// instance. For example, you can set a context on your top-level content
/// view using a container that you define as part of your model:
///
///     ContentView()
///         .environment(
///             \.managedObjectContext,
///             QuakesProvider.shared.container.viewContext)
///
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
@MainActor @preconcurrency public struct SectionedFetchResults<SectionIdentifier, Result> : RandomAccessCollection where SectionIdentifier : Hashable, Result : NSFetchRequestResult {

    /// A collection of fetched results that share a specified identifier.
    ///
    /// Examine a `Section` instance to find the entities that satisfy a
    /// ``SectionedFetchRequest`` predicate, and that have a particular property
    /// with the value stored in the section's ``id-swift.property-1h7qm``
    /// parameter. You specify which property by setting the fetch request's
    /// `sectionIdentifier` parameter during initialization, or by modifying
    /// the corresponding ``SectionedFetchResults`` instance's
    /// ``SectionedFetchResults/sectionIdentifier`` property.
    ///
    /// Obtain specific sections by treating the fetch results as a collection.
    /// For example, consider the following property declaration
    /// that fetches `Quake` managed objects that the
    /// <doc://com.apple.documentation/documentation/CoreData/loading_and_displaying_a_large_data_feed>
    /// sample code project defines to store earthquake data:
    ///
    ///     @SectionedFetchRequest<String, Quake>(
    ///         sectionIdentifier: \.day,
    ///         sortDescriptors: [SortDescriptor(\.time, order: .reverse)]
    ///     )
    ///     private var quakes: SectionedFetchResults<String, Quake>
    ///
    /// Get the first section using a subscript:
    ///
    ///     let firstSection = quakes[0]
    ///
    /// Alternatively, you can loop over the sections to create a list of
    /// sections.
    ///
    ///     ForEach(quakes) { section in
    ///         Text("Section \(section.id) has \(section.count) elements")
    ///     }
    ///
    /// The sections also act as collections, which means
    /// you can use elements like the
    /// <doc://com.apple.documentation/documentation/Swift/Collection/count-4l4qk>
    /// property in the example above.
    @MainActor @preconcurrency public struct Section : @preconcurrency Identifiable, RandomAccessCollection {

        /// The index of the first entity in the section.
        nonisolated public var startIndex: Int { get }

        /// The index that's one greater than that of the last entity in the
        /// section.
        nonisolated public var endIndex: Int { get }

        /// Gets the entity at the specified index within the section.
        nonisolated public subscript(position: Int) -> Result { get }

        /// The value that all entities in the section share for a specified
        /// key path.
        ///
        /// Specify the key path that the entities share this value with
        /// by setting the ``SectionedFetchRequest``
        /// instance's `sectionIdentifier` parameter during initialization,
        /// or by modifying the corresponding ``SectionedFetchResults``
        /// instance's ``SectionedFetchResults/sectionIdentifier`` property.
        @MainActor @preconcurrency public let id: SectionIdentifier

        /// A type representing the sequence's elements.
        @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
        public typealias Element = Result

        /// A type representing the stable identity of the entity associated with
        /// an instance.
        @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
        public typealias ID = SectionIdentifier

        /// A type that represents a position in the collection.
        ///
        /// Valid indices consist of the position of every element and a
        /// "past the end" position that's not valid for use as a subscript
        /// argument.
        @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
        public typealias Index = Int

        /// A type that represents the indices that are valid for subscripting the
        /// collection, in ascending order.
        @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
        public typealias Indices = Range<Int>

        /// A type that provides the collection's iteration interface and
        /// encapsulates its iteration state.
        ///
        /// By default, a collection conforms to the `Sequence` protocol by
        /// supplying `IndexingIterator` as its associated `Iterator`
        /// type.
        @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
        public typealias Iterator = IndexingIterator<SectionedFetchResults<SectionIdentifier, Result>.Section>

        /// A collection representing a contiguous subrange of this collection's
        /// elements. The subsequence shares indices with the original collection.
        ///
        /// The default subsequence type for collections that don't define their own
        /// is `Slice`.
        @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
        public typealias SubSequence = Slice<SectionedFetchResults<SectionIdentifier, Result>.Section>
    }

    /// The request's sort descriptors, accessed as reference types.
    ///
    /// Set this value to cause the associated ``SectionedFetchRequest`` to
    /// execute a fetch with a new collection of
    /// <doc://com.apple.documentation/documentation/Foundation/NSSortDescriptor>
    /// instances.
    /// The order of managed objects stored in the results collection may change
    /// as a result. Use care to coordinate section and sort updates, as
    /// described in ``SectionedFetchRequest/Configuration``.
    ///
    /// If you want to use
    /// <doc://com.apple.documentation/documentation/Foundation/SortDescriptor>
    /// instances, set ``SectionedFetchResults/sortDescriptors`` instead.
    @MainActor @preconcurrency public var nsSortDescriptors: [NSSortDescriptor] { get nonmutating set }

    /// The request's predicate.
    ///
    /// Set this value to cause the associated ``SectionedFetchRequest`` to
    /// execute a fetch with a new predicate, producing an updated collection
    /// of results.
    @MainActor @preconcurrency public var nsPredicate: NSPredicate? { get nonmutating set }

    /// The key path that the system uses to group fetched results into sections.
    ///
    /// Set this value to cause the associated ``SectionedFetchRequest`` to
    /// execute a fetch with a new section identifier, producing an updated
    /// collection of results. Changing this value produces a new set of
    /// sections. Use care to coordinate section and sort updates, as described
    /// in ``SectionedFetchRequest/Configuration``.
    @MainActor @preconcurrency public var sectionIdentifier: KeyPath<Result, SectionIdentifier> { get nonmutating set }

    /// The index of the first section in the results collection.
    nonisolated public var startIndex: Int { get }

    /// The index that's one greater than that of the last section.
    nonisolated public var endIndex: Int { get }

    /// Gets the section at the specified index.
    nonisolated public subscript(position: Int) -> SectionedFetchResults<SectionIdentifier, Result>.Section { get }

    /// A type representing the sequence's elements.
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias Element = SectionedFetchResults<SectionIdentifier, Result>.Section

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias Index = Int

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias Indices = Range<Int>

    /// A type that provides the collection's iteration interface and
    /// encapsulates its iteration state.
    ///
    /// By default, a collection conforms to the `Sequence` protocol by
    /// supplying `IndexingIterator` as its associated `Iterator`
    /// type.
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias Iterator = IndexingIterator<SectionedFetchResults<SectionIdentifier, Result>>

    /// A collection representing a contiguous subrange of this collection's
    /// elements. The subsequence shares indices with the original collection.
    ///
    /// The default subsequence type for collections that don't define their own
    /// is `Slice`.
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias SubSequence = Slice<SectionedFetchResults<SectionIdentifier, Result>>
}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension SectionedFetchResults where Result : NSManagedObject {

    /// The request's sort descriptors, accessed as value types.
    ///
    /// Set this value to cause the associated ``SectionedFetchRequest`` to
    /// execute a fetch with a new collection of
    /// <doc://com.apple.documentation/documentation/Foundation/SortDescriptor>
    /// instances. The order of entities stored in the results collection may
    /// change as a result. Use care to coordinate section and sort updates, as
    /// described in ``SectionedFetchRequest/Configuration``.
    ///
    /// If you want to use
    /// <doc://com.apple.documentation/documentation/Foundation/NSSortDescriptor>
    /// instances, set ``SectionedFetchResults/nsSortDescriptors`` instead.
    @MainActor @preconcurrency public var sortDescriptors: [SortDescriptor<Result>] { get nonmutating set }
}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension SectionedFetchResults : Sendable {
}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension SectionedFetchResults.Section : Sendable {
}

/// A control into which people securely enter private text.
///
/// Use a secure field when you want the behavior of a ``TextField``, but
/// you want to hide the field's text. Typically, you use this for
/// entering passwords and other sensitive information, as the second field
/// in the following screenshot demonstrates:
///
/// @TabNavigator {
///     @Tab("macOS") {
///         @Image(source: "SecureField-1-macOS", alt: "Two vertically arranged wide rectangles filled with text. The first displays the email address mruiz2@icloud.com, and the second displays eight heavey dots in place of characters.")
///     }
///     @Tab("iOS") {
///         @Image(source: "SecureField-1-iOS", alt: "Two vertically arranged wide rectangles filled with text. The first displays the email address mruiz2@icloud.com, and the second displays eight heavey dots in place of characters.")
///     }
/// }
///
/// The field:
/// * Displays one dot for each character someone types.
/// * Hides the dots when someone takes a screenshot in iOS.
/// * Prevents anyone from cutting or copying the field's contents.
/// * Displays an indicator when Caps Lock is enabled.
///
/// ### Bind to a string
///
/// A secure field binds to a string value and updates the string on every
/// keystroke or other edit, so you can read its value at any time from
/// elsewhere in your code. The following code shows how to create the above
/// interface, with the secure field bound to a `password` string:
///
///     @State private var username: String = ""
///     @State private var password: String = ""
///
///     var body: some View {
///         VStack {
///             TextField("Username", text: $username)
///                 .autocorrectionDisabled(true)
///                 #if !os(macOS)
///                 .textInputAutocapitalization(.never)
///                 #endif
///
///             SecureField("Password", text: $password)
///                 .onSubmit {
///                     handleLogin(username: username, password: password)
///                 }
///         }
///         .textFieldStyle(.roundedBorder)
///     }
///
/// The field in the above example has an ``View/onSubmit(of:_:)``
/// modifier that sends the `username` and `password` strings to a custom
/// `handleLogin(username:password:)` method if someone presses the Return
/// key while the secure field has focus. You can alternatively
/// provide another mechanism --- like a button --- to do the same thing.
///
/// ### Guide people with a prompt
///
/// In addition to the string or view that you provide as a label,
/// you can also provide a ``Text`` view prompt to help guide someone who
/// uses the field, as the following ``Form`` does:
///
///     Form {
///         TextField(text: $username, prompt: Text("Required")) {
///             Text("Username")
///         }
///         .autocorrectionDisabled(true)
///         #if !os(macOS)
///         .textInputAutocapitalization(.never)
///         #endif
///
///         SecureField(text: $password, prompt: Text("Required")) {
///             Text("Password")
///         }
///     }
///
/// The system uses the label and prompt in different ways depending on the
/// context. For example, a form in macOS places the label against the leading
/// edge of the field and uses the prompt as placeholder text inside the field.
/// The same form in iOS also uses the prompt as placeholder text, but doesn't
/// display the label:
///
/// @TabNavigator {
///     @Tab("macOS") {
///         @Image(source: "SecureField-2-macOS", alt: "Two vertically wide rectangles filled with the string Required. The string appears in a secondary color. The word Username appear to the left of the top rectangle, and the word Password appears to the left of the bottom rectangle. The two words are right aligned with each other.")
///     }
///     @Tab("iOS") {
///         @Image(source: "SecureField-2-iOS", alt: "A wide rectangle that's divided in half vertically by a horizontal dividing line. The two halves of the rectangle, both top and bottom, have the word Required in them. The words are aligned with each other, and appear near the left side of the rectangle. The words and the dividing line appear in a light gray color.")
///     }
/// }
///
/// If you remove the prompt from the previous example, the field keeps the
/// label on the leading edge and omits the placeholder text in macOS, but
/// displays the label as a placeholder in iOS:
///
/// @TabNavigator {
///     @Tab("macOS") {
///         @Image(source: "SecureField-3-macOS", alt: "Two vertically wide, empty rectangles. The word Username appear to the left of the top rectangle, and the word Password appears to the left of the bottom rectangle. The two words are right aligned with each other.")
///     }
///     @Tab("iOS") {
///         @Image(source: "SecureField-3-iOS", alt: "A wide rectangle that's divided in half vertically by a horizontal dividing line. The two halves of the rectangle, both top and bottom, have a word in them. The top half has the word Username, and the bottom half has the word Password. The words are aligned with each other, and appear near the left side of the rectangle. The words and the dividing line appear in a light gray color.")
///     }
/// }
///
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public struct SecureField<Label> : View where Label : View {

    /// The content and behavior of the view.
    ///
    /// When you implement a custom view, you must implement a computed
    /// `body` property to provide the content for your view. Return a view
    /// that's composed of built-in views that SwiftUI provides, plus other
    /// composite views that you've already defined:
    ///
    ///     struct MyView: View {
    ///         var body: some View {
    ///             Text("Hello, World!")
    ///         }
    ///     }
    ///
    /// For more information about composing views and a view hierarchy,
    /// see <doc:Declaring-a-Custom-View>.
    @MainActor @preconcurrency public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    public typealias Body = some View
}

extension SecureField where Label == Text {

    /// Creates a secure field with a prompt generated from a `Text`.
    ///
    /// Use the ``View/onSubmit(of:_:)`` modifier to invoke an action
    /// whenever someone submits this secure field --- for example, by
    /// pressing the Return key.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the field's localized title. The title
    ///     describes the purpose of the field.
    ///   - text: A binding to the text that the field displays and edits.
    ///   - prompt: A ``Text`` view that represents the secure field's prompt.
    ///     The prompt provides guidance on what people should type into the
    ///     secure field.
    @available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
    nonisolated public init(_ titleKey: LocalizedStringKey, text: Binding<String>, prompt: Text?)

    /// Creates a secure field with a prompt generated from a `Text`.
    ///
    /// Use the ``View/onSubmit(of:_:)`` modifier to invoke an action
    /// whenever someone submits this secure field --- for example, by
    /// pressing the Return key.
    ///
    /// - Parameters:
    ///   - title: A string that describes the purpose of the field.
    ///   - text: A binding to the text that the field displays and edits.
    ///   - prompt: A ``Text`` view that represents the secure field's prompt.
    ///     The prompt provides guidance on what people should type into the
    ///     secure field.
    @available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
    nonisolated public init<S>(_ title: S, text: Binding<String>, prompt: Text?) where S : StringProtocol
}

extension SecureField {

    /// Creates a secure field with a prompt generated from a `Text`.
    ///
    /// Use the ``View/onSubmit(of:_:)`` modifier to invoke an action
    /// whenever someone submits this secure field --- for example, by
    /// pressing the Return key.
    ///
    /// - Parameters:
    ///   - text: A binding to the text that the field displays and edits.
    ///   - prompt: A ``Text`` view that represents the secure field's prompt.
    ///     The prompt provides guidance on what people should type into the
    ///     secure field.
    ///   - label: A view that describes the purpose of the secure field.
    @available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
    nonisolated public init(text: Binding<String>, prompt: Text? = nil, @ViewBuilder label: () -> Label)
}

extension SecureField where Label == Text {

    /// Creates a secure field with a prompt generated from a `Text`.
    ///
    /// Use the ``View/onSubmit(of:_:)`` modifier to invoke an action
    /// whenever someone submits this secure field --- for example, by
    /// pressing the Return key.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the field's localized title. The title
    ///     describes the purpose of the field.
    ///   - text: A binding to the text that the field displays and edits.
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    nonisolated public init(_ titleKey: LocalizedStringKey, text: Binding<String>)

    /// Creates a secure field with a prompt generated from a `Text`.
    ///
    /// Use the ``View/onSubmit(of:_:)`` modifier to invoke an action
    /// whenever someone submits this secure field --- for example, by
    /// pressing the Return key.
    ///
    /// - Parameters:
    ///   - title: A string that describes the purpose of the field.
    ///   - text: A binding to the text that the field displays and edits.
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    nonisolated public init<S>(_ title: S, text: Binding<String>) where S : StringProtocol
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension SecureField where Label == Text {

    /// Creates an instance.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the localized title of `self`, describing
    ///     its purpose.
    ///   - text: The text to display and edit.
    ///   - onCommit: The action to perform when the user performs an action
    ///     (usually pressing the Return key) while the secure field has focus.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, message: "Renamed SecureField.init(_:text:). Use View.onSubmit(of:_:) for functionality previously provided by the onCommit parameter.")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, message: "Renamed SecureField.init(_:text:). Use View.onSubmit(of:_:) for functionality previously provided by the onCommit parameter.")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, message: "Renamed SecureField.init(_:text:). Use View.onSubmit(of:_:) for functionality previously provided by the onCommit parameter.")
    @available(watchOS, introduced: 6.0, deprecated: 100000.0, message: "Renamed SecureField.init(_:text:). Use View.onSubmit(of:_:) for functionality previously provided by the onCommit parameter.")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Renamed SecureField.init(_:text:). Use View.onSubmit(of:_:) for functionality previously provided by the onCommit parameter.")
    nonisolated public init(_ titleKey: LocalizedStringKey, text: Binding<String>, onCommit: @escaping () -> Void)

    /// Creates an instance.
    ///
    /// - Parameters:
    ///   - title: The title of `self`, describing its purpose.
    ///   - text: The text to display and edit.
    ///   - onCommit: The action to perform when the user performs an action
    ///     (usually pressing the Return key) while the secure field has focus.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, message: "Renamed SecureField.init(_:text:). Use View.onSubmit(of:_:) for functionality previously provided by the onCommit parameter.")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, message: "Renamed SecureField.init(_:text:). Use View.onSubmit(of:_:) for functionality previously provided by the onCommit parameter.")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, message: "Renamed SecureField.init(_:text:). Use View.onSubmit(of:_:) for functionality previously provided by the onCommit parameter.")
    @available(watchOS, introduced: 6.0, deprecated: 100000.0, message: "Renamed SecureField.init(_:text:). Use View.onSubmit(of:_:) for functionality previously provided by the onCommit parameter.")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Renamed SecureField.init(_:text:). Use View.onSubmit(of:_:) for functionality previously provided by the onCommit parameter.")
    nonisolated public init<S>(_ title: S, text: Binding<String>, onCommit: @escaping () -> Void) where S : StringProtocol
}

/// A picker style that presents the options in a segmented control.
///
/// You can also use ``PickerStyle/segmented`` to construct this style.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
@available(watchOS, unavailable)
public struct SegmentedPickerStyle : PickerStyle {

    /// Creates a segmented picker style.
    public init()
}

/// A style used to visually indicate selection following platform conventional
/// colors and behaviors.
///
/// You can also use ``ShapeStyle/selection`` to construct this style.
@available(iOS 15.0, macOS 10.15, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct SelectionShapeStyle : ShapeStyle {

    /// Creates a selection shape style.
    @available(macOS 12.0, *)
    public init()

    /// The type of shape style this will resolve to.
    ///
    /// When you create a custom shape style, Swift infers this type
    /// from your implementation of the required `resolve` function.
    @available(iOS 17.0, macOS 14.0, *)
    @available(tvOS, unavailable, introduced: 17.0)
    @available(watchOS, unavailable, introduced: 10.0)
    public typealias Resolved = Never
}

/// Represents a type of haptic and/or audio feedback that can be played.
///
/// This feedback can be passed to `View.sensoryFeedback` to play it.
@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
@available(visionOS, unavailable)
public struct SensoryFeedback : Equatable, Sendable {

    /// Indicates that a task or action has completed.
    ///
    /// Only plays feedback on iOS and watchOS.
    public static let success: SensoryFeedback

    /// Indicates that a task or action has produced a warning of some kind.
    ///
    /// Only plays feedback on iOS and watchOS.
    public static let warning: SensoryFeedback

    /// Indicates that an error has occurred.
    ///
    /// Only plays feedback on iOS and watchOS.
    public static let error: SensoryFeedback

    /// Indicates that a UI elements values are changing.
    ///
    /// Only plays feedback on iOS and watchOS.
    public static let selection: SensoryFeedback

    /// Indicates that an important value increased above a significant
    /// threshold.
    ///
    /// Only plays feedback on watchOS.
    public static let increase: SensoryFeedback

    /// Indicates that an important value decreased below a significant
    /// threshold.
    ///
    /// Only plays feedback on watchOS.
    public static let decrease: SensoryFeedback

    /// Indicates that an activity started.
    ///
    /// Use this haptic when starting a timer or any other activity that can be
    /// explicitly started and stopped.
    ///
    /// Only plays feedback on watchOS.
    public static let start: SensoryFeedback

    /// Indicates that an activity stopped.
    ///
    /// Use this haptic when stopping a timer or other activity that was
    /// previously started.
    ///
    /// Only plays feedback on watchOS.
    public static let stop: SensoryFeedback

    /// Indicates the alignment of a dragged item.
    ///
    /// For example, use this pattern in a drawing app when the user drags a
    /// shape into alignment with another shape.
    ///
    /// Only plays feedback on iOS and macOS.
    public static let alignment: SensoryFeedback

    /// Indicates movement between discrete levels of pressure.
    ///
    /// For example, as the user presses a fast-forward button on a video
    /// player, playback could increase or decrease and haptic feedback could be
    /// provided as different levels of pressure are reached.
    ///
    /// Only plays feedback on macOS.
    public static let levelChange: SensoryFeedback

    /// Indicates a drawn path has completed and/or recognized.
    ///
    /// Use this to provide feedback for closed shape drawing or similar
    /// actions. It should supplement the user experience, since only some
    /// platforms will play feedback in response to it.
    ///
    /// Only plays feedback on iOS.
    @available(iOS 17.5, macOS 14.5, tvOS 17.5, watchOS 10.5, *)
    public static let pathComplete: SensoryFeedback

    /// Provides a physical metaphor you can use to complement a visual
    /// experience.
    ///
    /// Use this to provide feedback for UI elements colliding. It should
    /// supplement the user experience, since only some platforms will play
    /// feedback in response to it.
    ///
    /// Only plays feedback on iOS and watchOS.
    public static let impact: SensoryFeedback

    /// Provides a physical metaphor you can use to complement a visual
    /// experience.
    ///
    /// Use this to provide feedback for UI elements colliding. It should
    /// supplement the user experience, since only some platforms will play
    /// feedback in response to it.
    ///
    /// Not all platforms will play different feedback for different weights and
    /// intensities of impact.
    ///
    /// Only plays feedback on iOS and watchOS.
    public static func impact(weight: SensoryFeedback.Weight = .medium, intensity: Double = 1.0) -> SensoryFeedback

    /// Provides a physical metaphor you can use to complement a visual
    /// experience.
    ///
    /// Use this to provide feedback for UI elements colliding. It should
    /// supplement the user experience, since only some platforms will play
    /// feedback in response to it.
    ///
    /// Not all platforms will play different feedback for different
    /// flexibilities and intensities of impact.
    ///
    /// Only plays feedback on iOS and watchOS.
    public static func impact(flexibility: SensoryFeedback.Flexibility, intensity: Double = 1.0) -> SensoryFeedback

    /// The weight to be represented by a type of feedback.
    ///
    /// `Weight` values can be passed to
    /// `SensoryFeedback.impact(weight:intensity:)`.
    public struct Weight : Equatable, Sendable {

        /// Indicates a collision between small or lightweight UI objects.
        public static let light: SensoryFeedback.Weight

        /// Indicates a collision between medium-sized or medium-weight UI
        /// objects.
        public static let medium: SensoryFeedback.Weight

        /// Indicates a collision between large or heavyweight UI objects.
        public static let heavy: SensoryFeedback.Weight

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: SensoryFeedback.Weight, b: SensoryFeedback.Weight) -> Bool
    }

    /// The flexibility to be represented by a type of feedback.
    ///
    /// `Flexibility` values can be passed to
    /// `SensoryFeedback.impact(flexibility:intensity:)`.
    public struct Flexibility : Equatable, Sendable {

        /// Indicates a collision between hard or inflexible UI objects.
        public static let rigid: SensoryFeedback.Flexibility

        /// Indicates a collision between solid UI objects of medium
        /// flexibility.
        public static let solid: SensoryFeedback.Flexibility

        /// Indicates a collision between soft or flexible UI objects.
        public static let soft: SensoryFeedback.Flexibility

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: SensoryFeedback.Flexibility, b: SensoryFeedback.Flexibility) -> Bool
    }

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: SensoryFeedback, b: SensoryFeedback) -> Bool
}

/// A gesture that's a sequence of two gestures.
///
/// Read <doc:Composing-SwiftUI-Gestures> to learn how you can create a sequence
/// of two gestures.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@frozen public struct SequenceGesture<First, Second> : Gesture where First : Gesture, Second : Gesture {

    /// The value of a sequence gesture that helps to detect whether the first
    /// gesture succeeded, so the second gesture can start.
    @frozen public enum Value {

        /// The first gesture hasn't ended.
        case first(First.Value)

        /// The first gesture has ended.
        case second(First.Value, Second.Value?)
    }

    /// The first gesture in a sequence of two gestures.
    public var first: First

    /// The second gesture in a sequence of two gestures.
    public var second: Second

    /// Creates a sequence gesture with two gestures.
    ///
    /// - Parameters:
    ///   - first: The first gesture of the sequence.
    ///   - second: The second gesture of the sequence.
    @inlinable public init(_ first: First, _ second: Second)

    /// The type of gesture representing the body of `Self`.
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    public typealias Body = Never
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension SequenceGesture.Value : Sendable where First.Value : Sendable, Second.Value : Sendable {
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension SequenceGesture.Value : Equatable where First.Value : Equatable, Second.Value : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: SequenceGesture<First, Second>.Value, b: SequenceGesture<First, Second>.Value) -> Bool
}

/// A view that controls a sharing presentation.
///
/// People tap or click on a share link to present a share interface. The link
/// typically uses a system-standard appearance; you only need to supply the
/// content to share:
///
///     ShareLink(item: URL(string: "https://developer.apple.com/xcode/swiftui/")!)
///
/// You can control the appearance of the link by providing view content.
/// For example, you can use a ``Label`` to display a
/// link with a custom icon:
///
///     ShareLink(item: URL(string: "https://developer.apple.com/xcode/swiftui/")!) {
///         Label("Share", image: "MyCustomShareIcon")
///     }
///
/// If you only wish to customize the link's title, you can use one of the
/// convenience initializers that takes a string and creates a `Label` for you:
///
///     ShareLink("Share URL", item: URL(string: "https://developer.apple.com/xcode/swiftui/")!)
///
/// The link can share any content that is
/// <doc://com.apple.documentation/documentation/coretransferable/transferable>.
/// Many framework types, like
/// <doc://com.apple.documentation/documentation/Foundation/URL>,
/// already conform to this protocol. You can also make your own types
/// transferable.
///
/// For example, you can use
/// <doc://com.apple.documentation/documentation/coretransferable/proxyrepresentation>
/// to resolve your own type to a framework type:
///
///     struct Photo: Transferable {
///         static var transferRepresentation: some TransferRepresentation {
///             ProxyRepresentation(\.image)
///         }
///
///         public var image: Image
///         public var caption: String
///     }
///
///     struct PhotoView: View {
///         let photo: Photo
///
///         var body: View {
///             photo.image
///                 .toolbar {
///                     ShareLink(
///                         item: photo,
///                         preview: SharePreview(
///                             photo.caption,
///                             image: photo.image))
///                 }
///         }
///     }
///
/// Sometimes the content that your app shares isn't immediately available. You
/// can use
/// <doc://com.apple.documentation/documentation/coretransferable/filerepresentation>
/// or
/// <doc://com.apple.documentation/documentation/coretransferable/datarepresentation>
/// when you need an asynchronous operation, like a network request, to
/// retrieve and prepare the content.
///
/// A `Transferable` type also lets you provide multiple content types for a
/// single shareable item. The share interface shows relevant sharing services
/// based on the types that you provide.
///
/// The previous example also shows how you provide a preview of your content
/// to show in the share interface.
///
/// A preview isn't required when sharing URLs or non-attributed strings. When
/// sharing these types of content, the system can automatically determine a
/// preview.
///
/// You can provide a preview even when it's optional. For instance, when
/// sharing URLs, the automatic preview first shows a placeholder link icon
/// alongside the base URL while fetching the link's metadata over the network.
/// The preview updates once the link's icon and title become available. If you
/// provide a preview instead, the preview appears immediately
/// without fetching data over the network.
///
/// Some share activities support subject and message fields. You can
/// pre-populate these fields with the `subject` and `message` parameters:
///
///     ShareLink(
///         item: photo,
///         subject: Text("Cool Photo"),
///         message: Text("Check it out!")
///         preview: SharePreview(
///             photo.caption,
///             image: photo.image))
///
@available(iOS 16.0, macOS 13.0, watchOS 9.0, *)
@available(tvOS, unavailable)
public struct ShareLink<Data, PreviewImage, PreviewIcon, Label> : View where Data : RandomAccessCollection, PreviewImage : Transferable, PreviewIcon : Transferable, Label : View, Data.Element : Transferable {

    /// Creates an instance that presents the share interface.
    ///
    /// - Parameters:
    ///     - items: The items to share.
    ///     - subject: A title for the items to show when sharing to activities
    ///     that support a subject field.
    ///     - message: A description of the items to show when sharing to
    ///     activities that support a message field. Activities may
    ///     support attributed text or HTML strings.
    ///     - preview: A closure that returns a representation of each item to
    ///     render in a preview.
    ///     - label: A view builder that produces a label that describes the
    ///     share action.
    public init(items: Data, subject: Text? = nil, message: Text? = nil, preview: @escaping (Data.Element) -> SharePreview<PreviewImage, PreviewIcon>, @ViewBuilder label: () -> Label)

    /// The content and behavior of the view.
    ///
    /// When you implement a custom view, you must implement a computed
    /// `body` property to provide the content for your view. Return a view
    /// that's composed of built-in views that SwiftUI provides, plus other
    /// composite views that you've already defined:
    ///
    ///     struct MyView: View {
    ///         var body: some View {
    ///             Text("Hello, World!")
    ///         }
    ///     }
    ///
    /// For more information about composing views and a view hierarchy,
    /// see <doc:Declaring-a-Custom-View>.
    @MainActor @preconcurrency public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    @available(iOS 16.0, watchOS 9.0, macOS 13.0, *)
    @available(tvOS, unavailable)
    public typealias Body = some View
}

@available(iOS 16.0, macOS 13.0, watchOS 9.0, *)
@available(tvOS, unavailable)
extension ShareLink {

    /// Creates an instance that presents the share interface.
    ///
    /// - Parameters:
    ///     - item: The item to share.
    ///     - subject: A title for the item to show when sharing to activities
    ///     that support a subject field.
    ///     - message: A description of the item to show when sharing to
    ///     activities that support a message field. Activities may
    ///     support attributed text or HTML strings.
    ///     - preview: A representation of the item to render in a preview.
    ///     - label: A view builder that produces a label that describes the
    ///     share action.
    nonisolated public init<I>(item: I, subject: Text? = nil, message: Text? = nil, preview: SharePreview<PreviewImage, PreviewIcon>, @ViewBuilder label: () -> Label) where Data == CollectionOfOne<I>, I : Transferable
}

@available(iOS 16.0, macOS 13.0, watchOS 9.0, *)
@available(tvOS, unavailable)
extension ShareLink where PreviewImage == Never, PreviewIcon == Never, Data.Element == URL {

    /// Creates an instance that presents the share interface.
    ///
    /// - Parameters:
    ///     - items: The items to share.
    ///     - subject: A title for the items to show when sharing to activities
    ///     that support a subject field.
    ///     - message: A description of the items to show when sharing to
    ///     activities that support a message field. Activities may
    ///     support attributed text or HTML strings.
    ///     - label: A view builder that produces a label that describes the
    ///     share action.
    nonisolated public init(items: Data, subject: Text? = nil, message: Text? = nil, @ViewBuilder label: () -> Label)
}

@available(iOS 16.0, macOS 13.0, watchOS 9.0, *)
@available(tvOS, unavailable)
extension ShareLink where PreviewImage == Never, PreviewIcon == Never, Data.Element == String {

    /// Creates an instance that presents the share interface.
    ///
    /// - Parameters:
    ///     - items: The items to share.
    ///     - subject: A title for the items to show when sharing to activities
    ///     that support a subject field.
    ///     - message: A description of the items to show when sharing to
    ///     activities that support a message field. Activities may
    ///     support attributed text or HTML strings.
    ///     - label: A view builder that produces a label that describes the
    ///     share action.
    nonisolated public init(items: Data, subject: Text? = nil, message: Text? = nil, @ViewBuilder label: () -> Label)
}

@available(iOS 16.0, macOS 13.0, watchOS 9.0, *)
@available(tvOS, unavailable)
extension ShareLink where PreviewImage == Never, PreviewIcon == Never {

    /// Creates an instance that presents the share interface.
    ///
    /// - Parameters:
    ///     - item: The item to share.
    ///     - subject: A title for the item to show when sharing to activities
    ///     that support a subject field.
    ///     - message: A description of the item to show when sharing to
    ///     activities that support a message field. Activities may
    ///     support attributed text or HTML strings.
    ///     - label: A view builder that produces a label that describes the
    ///     share action.
    nonisolated public init(item: URL, subject: Text? = nil, message: Text? = nil, @ViewBuilder label: () -> Label) where Data == CollectionOfOne<URL>

    /// Creates an instance that presents the share interface.
    ///
    /// - Parameters:
    ///     - item: The item to share.
    ///     - subject: A title for the item to show when sharing to activities
    ///     that support a subject field.
    ///     - message: A description of the item to show when sharing to
    ///     activities that support a message field. Activities may
    ///     support attributed text or HTML strings.
    ///     - label: A view builder that produces a label that describes the
    ///     share action.
    nonisolated public init(item: String, subject: Text? = nil, message: Text? = nil, @ViewBuilder label: () -> Label) where Data == CollectionOfOne<String>
}

@available(iOS 16.0, macOS 13.0, watchOS 9.0, *)
@available(tvOS, unavailable)
extension ShareLink where Label == DefaultShareLinkLabel {

    /// Creates an instance that presents the share interface.
    ///
    /// Use this initializer when you want the system-standard appearance for
    /// `ShareLink`.
    ///
    /// - Parameters:
    ///     - items: The items to share.
    ///     - subject: A title for the items to show when sharing to activities
    ///     that support a subject field.
    ///     - message: A description of the items to show when sharing to
    ///     activities that support a message field. Activities may
    ///     support attributed text or HTML strings.
    ///     - preview: A closure that returns a representation of each item to
    ///     render in a preview.
    nonisolated public init(items: Data, subject: Text? = nil, message: Text? = nil, preview: @escaping (Data.Element) -> SharePreview<PreviewImage, PreviewIcon>)

    /// Creates an instance, with a custom label, that presents the share
    /// interface.
    ///
    /// - Parameters:
    ///     - titleKey: A key identifying the title of the share action.
    ///     - items: The items to share.
    ///     - subject: A title for the items to show when sharing to activities
    ///     that support a subject field.
    ///     - message: A description of the items to show when sharing to
    ///     activities that support a message field. Activities may
    ///     support attributed text or HTML strings.
    ///     - preview: A closure that returns a representation of each item to
    ///     render in a preview.
    nonisolated public init(_ titleKey: LocalizedStringKey, items: Data, subject: Text? = nil, message: Text? = nil, preview: @escaping (Data.Element) -> SharePreview<PreviewImage, PreviewIcon>)

    /// Creates an instance, with a custom label, that presents the share
    /// interface.
    ///
    /// - Parameters:
    ///     - title: The title of the share action.
    ///     - items: The item to share.
    ///     - subject: A title for the items to show when sharing to activities
    ///     that support a subject field.
    ///     - message: A description of the items to show when sharing to
    ///     activities that support a message field. Activities may
    ///     support attributed text or HTML strings.
    ///     - preview: A closure that returns a representation of each item to
    ///     render in a preview.
    nonisolated public init<S>(_ title: S, items: Data, subject: Text? = nil, message: Text? = nil, preview: @escaping (Data.Element) -> SharePreview<PreviewImage, PreviewIcon>) where S : StringProtocol

    /// Creates an instance, with a custom label, that presents the share
    /// interface.
    ///
    /// - Parameters:
    ///     - title: The title of the share action.
    ///     - items: The items to share.
    ///     - subject: A title for the items to show when sharing to activities
    ///     that support a subject field.
    ///     - message: A description of the items to show when sharing to
    ///     activities that support a message field. Activities may
    ///     support attributed text or HTML strings.
    ///     - preview: A closure that returns a representation of each item to
    ///     render in a preview.
    nonisolated public init(_ title: Text, items: Data, subject: Text? = nil, message: Text? = nil, preview: @escaping (Data.Element) -> SharePreview<PreviewImage, PreviewIcon>)
}

@available(iOS 16.0, macOS 13.0, watchOS 9.0, *)
@available(tvOS, unavailable)
extension ShareLink where Label == DefaultShareLinkLabel {

    /// Creates an instance that presents the share interface.
    ///
    /// Use this initializer when you want the system-standard appearance for
    /// `ShareLink`.
    ///
    /// - Parameters:
    ///     - item: The item to share.
    ///     - subject: A title for the item to show when sharing to activities
    ///     that support a subject field.
    ///     - message: A description of the item to show when sharing to
    ///     activities that support a message field. Activities may
    ///     support attributed text or HTML strings.
    ///     - preview: A representation of the item to render in a preview.
    nonisolated public init<I>(item: I, subject: Text? = nil, message: Text? = nil, preview: SharePreview<PreviewImage, PreviewIcon>) where Data == CollectionOfOne<I>, I : Transferable

    /// Creates an instance, with a custom label, that presents the share
    /// interface.
    ///
    /// - Parameters:
    ///     - titleKey: A key identifying the title of the share action.
    ///     - item: The item to share.
    ///     - subject: A title for the item to show when sharing to activities
    ///     that support a subject field.
    ///     - message: A description of the item to show when sharing to
    ///     activities that support a message field. Activities may
    ///     support attributed text or HTML strings.
    ///     - preview: A representation of the item to render in a preview.
    nonisolated public init<I>(_ titleKey: LocalizedStringKey, item: I, subject: Text? = nil, message: Text? = nil, preview: SharePreview<PreviewImage, PreviewIcon>) where Data == CollectionOfOne<I>, I : Transferable

    /// Creates an instance, with a custom label, that presents the share
    /// interface.
    ///
    /// - Parameters:
    ///     - title: The title of the share action.
    ///     - item: The item to share.
    ///     - subject: A title for the item to show when sharing to activities
    ///     that support a subject field.
    ///     - message: A description of the item to show when sharing to
    ///     activities that support a message field. Activities may
    ///     support attributed text or HTML strings.
    ///     - preview: A representation of the item to render in a preview.
    nonisolated public init<S, I>(_ title: S, item: I, subject: Text? = nil, message: Text? = nil, preview: SharePreview<PreviewImage, PreviewIcon>) where Data == CollectionOfOne<I>, S : StringProtocol, I : Transferable

    /// Creates an instance, with a custom label, that presents the share
    /// interface.
    ///
    /// - Parameters:
    ///     - title: The title of the share action.
    ///     - item: The item to share.
    ///     - subject: A title for the item to show when sharing to activities
    ///     that support a subject field.
    ///     - message: A description of the item to show when sharing to
    ///     activities that support a message field. Activities may
    ///     support attributed text or HTML strings.
    ///     - preview: A representation of the item to render in a preview.
    nonisolated public init<I>(_ title: Text, item: I, subject: Text? = nil, message: Text? = nil, preview: SharePreview<PreviewImage, PreviewIcon>) where Data == CollectionOfOne<I>, I : Transferable
}

@available(iOS 16.0, macOS 13.0, watchOS 9.0, *)
@available(tvOS, unavailable)
extension ShareLink where PreviewImage == Never, PreviewIcon == Never, Label == DefaultShareLinkLabel, Data.Element == URL {

    /// Creates an instance that presents the share interface.
    ///
    /// Use this initializer when you want the system-standard appearance for
    /// `ShareLink`.
    ///
    /// - Parameters:
    ///     - items: The items to share.
    ///     - subject: A title for the items to show when sharing to activities
    ///     that support a subject field.
    ///     - message: A description of the items to show when sharing to
    ///     activities that support a message field. Activities may
    ///     support attributed text or HTML strings.
    nonisolated public init(items: Data, subject: Text? = nil, message: Text? = nil)

    /// Creates an instance, with a custom label, that presents the share
    /// interface.
    ///
    /// - Parameters:
    ///     - titleKey: A key identifying the title of the share action.
    ///     - items: The items to share.
    ///     - subject: A title for the items to show when sharing to activities
    ///     that support a subject field.
    ///     - message: A description of the items to show when sharing to
    ///     activities that support a message field. Activities may
    ///     support attributed text or HTML strings.
    nonisolated public init(_ titleKey: LocalizedStringKey, items: Data, subject: Text? = nil, message: Text? = nil)

    /// Creates an instance, with a custom label, that presents the share
    /// interface.
    ///
    /// - Parameters:
    ///     - title: The title of the share action.
    ///     - items: The item to share.
    ///     - subject: A title for the items to show when sharing to activities
    ///     that support a subject field.
    ///     - message: A description of the items to show when sharing to
    ///     activities that support a message field. Activities may
    ///     support attributed text or HTML strings.
    nonisolated public init<S>(_ title: S, items: Data, subject: Text? = nil, message: Text? = nil) where S : StringProtocol

    /// Creates an instance, with a custom label, that presents the share
    /// interface.
    ///
    /// - Parameters:
    ///     - title: The title of the share action.
    ///     - items: The items to share.
    ///     - subject: A title for the items to show when sharing to activities
    ///     that support a subject field.
    ///     - message: A description of the items to show when sharing to
    ///     activities that support a message field. Activities may
    ///     support attributed text or HTML strings.
    nonisolated public init(_ title: Text, items: Data, subject: Text? = nil, message: Text? = nil)
}

@available(iOS 16.0, macOS 13.0, watchOS 9.0, *)
@available(tvOS, unavailable)
extension ShareLink where PreviewImage == Never, PreviewIcon == Never, Label == DefaultShareLinkLabel, Data.Element == String {

    /// Creates an instance that presents the share interface.
    ///
    /// Use this initializer when you want the system-standard appearance for
    /// `ShareLink`.
    ///
    /// - Parameters:
    ///     - items: The items to share.
    ///     - subject: A title for the items to show when sharing to activities
    ///     that support a subject field.
    ///     - message: A description of the items to show when sharing to
    ///     activities that support a message field. Activities may
    ///     support attributed text or HTML strings.
    nonisolated public init(items: Data, subject: Text? = nil, message: Text? = nil)

    /// Creates an instance, with a custom label, that presents the share
    /// interface.
    ///
    /// - Parameters:
    ///     - titleKey: A key identifying the title of the share action.
    ///     - items: The items to share.
    ///     - subject: A title for the items to show when sharing to activities
    ///     that support a subject field.
    ///     - message: A description of the items to show when sharing to
    ///     activities that support a message field. Activities may
    ///     support attributed text or HTML strings.
    nonisolated public init(_ titleKey: LocalizedStringKey, items: Data, subject: Text? = nil, message: Text? = nil)

    /// Creates an instance, with a custom label, that presents the share
    /// interface.
    ///
    /// - Parameters:
    ///     - title: The title of the share action.
    ///     - items: The item to share.
    ///     - subject: A title for the items to show when sharing to activities
    ///     that support a subject field.
    ///     - message: A description of the items to show when sharing to
    ///     activities that support a message field. Activities may
    ///     support attributed text or HTML strings.
    nonisolated public init<S>(_ title: S, items: Data, subject: Text? = nil, message: Text? = nil) where S : StringProtocol

    /// Creates an instance, with a custom label, that presents the share
    /// interface.
    ///
    /// - Parameters:
    ///     - title: The title of the share action.
    ///     - items: The items to share.
    ///     - subject: A title for the items to show when sharing to activities
    ///     that support a subject field.
    ///     - message: A description of the items to show when sharing to
    ///     activities that support a message field. Activities may
    ///     support attributed text or HTML strings.
    nonisolated public init(_ title: Text, items: Data, subject: Text? = nil, message: Text? = nil)
}

@available(iOS 16.0, macOS 13.0, watchOS 9.0, *)
@available(tvOS, unavailable)
extension ShareLink where PreviewImage == Never, PreviewIcon == Never, Label == DefaultShareLinkLabel {

    /// Creates an instance that presents the share interface.
    ///
    /// Use this initializer when you want the system-standard appearance for
    /// `ShareLink`.
    ///
    /// - Parameters:
    ///     - item: The item to share.
    ///     - subject: A title for the item to show when sharing to activities
    ///     that support a subject field.
    ///     - message: A description of the item to show when sharing to
    ///     activities that support a message field. Activities may
    ///     support attributed text or HTML strings.
    nonisolated public init(item: URL, subject: Text? = nil, message: Text? = nil) where Data == CollectionOfOne<URL>

    /// Creates an instance that presents the share interface.
    ///
    /// Use this initializer when you want the system-standard appearance for
    /// `ShareLink`.
    ///
    /// - Parameters:
    ///     - item: The item to share.
    ///     - subject: A title for the item to show when sharing to activities
    ///     that support a subject field.
    ///     - message: A description of the item to show when sharing to
    ///     activities that support a message field. Activities may
    ///     support attributed text or HTML strings.
    nonisolated public init(item: String, subject: Text? = nil, message: Text? = nil) where Data == CollectionOfOne<String>

    /// Creates an instance, with a custom label, that presents the share
    /// interface.
    ///
    /// - Parameters:
    ///     - titleKey: A key identifying the title of the share action.
    ///     - item: The item to share.
    ///     - subject: A title for the item to show when sharing to activities
    ///     that support a subject field.
    ///     - message: A description of the item to show when sharing to
    ///     activities that support a message field. Activities may
    ///     support attributed text or HTML strings.
    nonisolated public init(_ titleKey: LocalizedStringKey, item: URL, subject: Text? = nil, message: Text? = nil) where Data == CollectionOfOne<URL>

    /// Creates an instance, with a custom label, that presents the share
    /// interface.
    ///
    /// - Parameters:
    ///     - titleKey: A key identifying the title of the share action.
    ///     - item: The item to share.
    ///     - subject: A title for the item to show when sharing to activities
    ///     that support a subject field.
    ///     - message: A description of the item to show when sharing to
    ///     activities that support a message field. Activities may
    ///     support attributed text or HTML strings.
    nonisolated public init(_ titleKey: LocalizedStringKey, item: String, subject: Text? = nil, message: Text? = nil) where Data == CollectionOfOne<String>

    /// Creates an instance, with a custom label, that presents the share
    /// interface.
    ///
    /// - Parameters:
    ///     - title: The title of the share action.
    ///     - item: The item to share.
    ///     - subject: A title for the item to show when sharing to activities
    ///     that support a subject field.
    ///     - message: A description of the item to show when sharing to
    ///     activities that support a message field. Activities may
    ///     support attributed text or HTML strings.
    nonisolated public init<S>(_ title: S, item: URL, subject: Text? = nil, message: Text? = nil) where Data == CollectionOfOne<URL>, S : StringProtocol

    /// Creates an instance, with a custom label, that presents the share
    /// interface.
    ///
    /// - Parameters:
    ///     - title: The title of the share action.
    ///     - item: The item to share.
    ///     - subject: A title for the item to show when sharing to activities
    ///     that support a subject field.
    ///     - message: A description of the item to show when sharing to
    ///     activities that support a message field. Activities may
    ///     support attributed text or HTML strings.
    nonisolated public init<S>(_ title: S, item: String, subject: Text? = nil, message: Text? = nil) where Data == CollectionOfOne<String>, S : StringProtocol

    /// Creates an instance, with a custom label, that presents the share
    /// interface.
    ///
    /// - Parameters:
    ///     - title: The title of the share action.
    ///     - item: The item to share.
    ///     - subject: A title for the item to show when sharing to activities
    ///     that support a subject field.
    ///     - message: A description of the item to show when sharing to
    ///     activities that support a message field. Activities may
    ///     support attributed text or HTML strings.
    nonisolated public init(_ title: Text, item: URL, subject: Text? = nil, message: Text? = nil) where Data == CollectionOfOne<URL>

    /// Creates an instance, with a custom label, that presents the share
    /// interface.
    ///
    /// - Parameters:
    ///     - title: The title of the share action.
    ///     - item: The item to share.
    ///     - subject: A title for the item to show when sharing to activities
    ///     that support a subject field.
    ///     - message: A description of the item to show when sharing to
    ///     activities that support a message field. Activities may
    ///     support attributed text or HTML strings.
    nonisolated public init(_ title: Text, item: String, subject: Text? = nil, message: Text? = nil) where Data == CollectionOfOne<String>
}

/// A representation of a type to display in a share preview.
///
/// Use this type when sharing content that the system can't preview automatically:
///
///     struct Photo: Transferable {
///         static var transferRepresentation: some TransferRepresentation {
///             ProxyRepresentation(\.image)
///         }
///
///         public var image: Image
///         public var caption: String
///     }
///
///     struct PhotoView: View {
///         let photo: Photo
///
///         var body: View {
///             photo.image
///                 .toolbar {
///                     ShareLink(
///                         item: photo,
///                         preview: SharePreview(
///                             photo.caption,
///                             image: photo.image))
///                 }
///         }
///     }
///
/// You can also provide a preview to speed up the sharing process. In the
/// following example the preview appears immediately; if you omit the preview instead,
/// the system fetches the link's metadata over the network:
///
///     ShareLink(
///         item: URL(string: "https://developer.apple.com/xcode/swiftui/")!,
///         preview: SharePreview(
///             "SwiftUI",
///             image: Image("SwiftUI"))
///
/// You can provide unique previews for each item in a collection of items
/// that a `ShareLink` links to:
///
///     ShareLink(items: photos) { photo in
///         SharePreview(photo.caption, image: photo.image)
///     }
///
/// The share interface decides how to combine those previews.
///
/// Each preview specifies text and images that describe an item of the type.
/// The preview's `image` parameter is typically a full-size representation of the item.
/// For instance, if the system prepares a preview for a link to a webpage,
/// the image might be the hero image on that webpage.
///
/// The preview's `icon` parameter is typically a thumbnail-sized representation
/// of the source of the item. For instance, if the system prepares a preview
/// for a link to a webpage, the icon might be an image that represents
/// the website overall.
///
/// The system may reuse a single preview representation for multiple previews,
/// and show different images in each context. For more information and
/// recommended sizes for each image, see
/// [TN2444: Best Practices for Link Previews in Messages](https://developer.apple.com/library/archive/technotes/tn2444/_index.html).
@available(iOS 16.0, macOS 13.0, watchOS 9.0, *)
@available(tvOS, unavailable)
public struct SharePreview<Image, Icon> where Image : Transferable, Icon : Transferable {

    /// Creates a preview representation.
    ///
    /// - Parameters:
    ///     - titleKey: A key identifying a title to show in a preview.
    ///     - image: An image to show in a preview.
    ///     - icon: An icon to show in a preview.
    public init(_ titleKey: LocalizedStringKey, image: Image, icon: Icon)

    /// Creates a preview representation.
    ///
    /// - Parameters:
    ///     - title: A title to show in a preview.
    ///     - image: An image to show in a preview.
    ///     - icon: An icon to show in a preview.
    public init<S>(_ title: S, image: Image, icon: Icon) where S : StringProtocol

    /// Creates a preview representation.
    ///
    /// - Parameters:
    ///     - title: A title to show in a preview.
    ///     - image: An image to show in a preview.
    ///     - icon: An icon to show in a preview.
    public init(_ title: Text, image: Image, icon: Icon)
}

@available(iOS 16.0, macOS 13.0, watchOS 9.0, *)
@available(tvOS, unavailable)
extension SharePreview where Image == Never {

    /// Creates a preview representation.
    ///
    /// - Parameters:
    ///     - titleKey: A key identifying a title to show in a preview.
    ///     - icon: An icon to show in a preview.
    public init(_ titleKey: LocalizedStringKey, icon: Icon)

    /// Creates a preview representation.
    ///
    /// - Parameters:
    ///     - title: A title to show in a preview.
    ///     - icon: An icon to show in a preview.
    public init<S>(_ title: S, icon: Icon) where S : StringProtocol

    /// Creates a preview representation.
    ///
    /// - Parameters:
    ///     - title: A title to show in a preview.
    ///     - icon: An icon to show in a preview.
    public init(_ title: Text, icon: Icon)
}

@available(iOS 16.0, macOS 13.0, watchOS 9.0, *)
@available(tvOS, unavailable)
extension SharePreview where Icon == Never {

    /// Creates a preview representation.
    ///
    /// - Parameters:
    ///     - titleKey: A key identifying a title to show in a preview.
    ///     - image: An image to show in a preview.
    public init(_ titleKey: LocalizedStringKey, image: Image)

    /// Creates a preview representation.
    ///
    /// - Parameters:
    ///     - title: A title to show in a preview.
    ///     - image: An image to show in a preview.
    public init<S>(_ title: S, image: Image) where S : StringProtocol

    /// Creates a preview representation.
    ///
    /// - Parameters:
    ///     - title: A title to show in a preview.
    ///     - image: An image to show in a preview.
    public init(_ title: Text, image: Image)
}

@available(iOS 16.0, macOS 13.0, watchOS 9.0, *)
@available(tvOS, unavailable)
extension SharePreview where Image == Never, Icon == Never {

    /// Creates a preview representation.
    ///
    /// - Parameters:
    ///     - titleKey: A key identifying a title to show in a preview.
    public init(_ titleKey: LocalizedStringKey)

    /// Creates a preview representation.
    ///
    /// - Parameters:
    ///     - title: A title to show in a preview.
    public init<S>(_ title: S) where S : StringProtocol

    /// Creates a preview representation.
    ///
    /// - Parameters:
    ///     - title: A title to show in a preview.
    public init(_ title: Text)
}

/// A tab bar style that adapts to each platform.
///
/// Tab views using the sidebar adaptable style have an appearance
/// that varies depending on the platform:
/// * iPadOS displays a top tab bar that can adapt into a sidebar.
/// * iOS displays a bottom tab bar.
/// * macOS and tvOS always show a sidebar.
/// * visionOS shows an ornament and also shows a sidebar for secondary tabs within a ``TabSection``.
///
/// Use ``TabViewStyle/sidebarAdaptable`` to construct this style.
///
/// To apply this style to a tab view, or to a view that contains tab views, use
/// the ``View/tabViewStyle(_:)`` modifier.
@available(iOS 18.0, macOS 15.0, tvOS 18.0, visionOS 2.0, *)
@available(watchOS, unavailable)
public struct SidebarAdaptableTabViewStyle : TabViewStyle {

    public init()
}

/// A built-in set of commands for manipulating window sidebars.
///
/// These commands are optional and can be explicitly requested by passing a
/// value of this type to the ``Scene/commands(content:)`` modifier.
@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct SidebarCommands : Commands {

    /// A new value describing the built-in sidebar-related commands.
    public init()

    /// The contents of the command hierarchy.
    ///
    /// For any commands that you create, provide a computed `body` property
    /// that defines the scene as a composition of other scenes. You can
    /// assemble a command hierarchy from built-in commands that SwiftUI
    /// provides, as well as other commands that you've defined.
    @MainActor @preconcurrency public var body: some Commands { get }

    /// The type of commands that represents the body of this command hierarchy.
    ///
    /// When you create custom commands, Swift infers this type from your
    /// implementation of the required ``SwiftUI/Commands/body-swift.property``
    /// property.
    @available(iOS 14.0, macOS 11.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias Body = some Commands
}

/// The list style that describes the behavior and appearance of a
/// sidebar list.
///
/// You can also use ``ListStyle/sidebar`` to construct this style.
@available(iOS 14.0, macOS 10.15, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct SidebarListStyle : ListStyle {

    /// Creates a sidebar list style.
    public init()
}

/// The standard sizes of sidebar rows.
///
/// On macOS, sidebar rows have three different sizes: small, medium, and large.
/// The size is primarily controlled by the current users' "Sidebar Icon Size"
/// in Appearance settings, and applies to all applications.
///
/// On all other platforms, the only supported sidebar size is `.medium`.
///
/// This size can be read or written in the environment using
/// `EnvironmentValues.sidebarRowSize`.
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public enum SidebarRowSize : Sendable {

    /// The standard "small" row size
    case small

    /// The standard "medium" row size
    case medium

    /// The standard "large" row size
    case large

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: SidebarRowSize, b: SidebarRowSize) -> Bool
}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension SidebarRowSize : Hashable {

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

/// A control for selecting a value from a bounded linear range of values.
///
/// A slider consists of a "thumb" image that the user moves between two
/// extremes of a linear "track". The ends of the track represent the minimum
/// and maximum possible values. As the user moves the thumb, the slider
/// updates its bound value.
///
/// The following example shows a slider bound to the value `speed`. As the
/// slider updates this value, a bound ``Text`` view shows the value updating.
/// The `onEditingChanged` closure passed to the slider receives callbacks when
/// the user drags the slider. The example uses this to change the
/// color of the value text.
///
///     @State private var speed = 50.0
///     @State private var isEditing = false
///
///     var body: some View {
///         VStack {
///             Slider(
///                 value: $speed,
///                 in: 0...100,
///                 onEditingChanged: { editing in
///                     isEditing = editing
///                 }
///             )
///             Text("\(speed)")
///                 .foregroundColor(isEditing ? .red : .blue)
///         }
///     }
///
/// ![An unlabeled slider, with its thumb about one third of the way from the
/// minimum extreme. Below, a blue label displays the value
/// 33.045977.](SwiftUI-Slider-simple.png)
///
/// You can also use a `step` parameter to provide incremental steps along the
/// path of the slider. For example, if you have a slider with a range of `0` to
/// `100`, and you set the `step` value to `5`, the slider's increments would be
/// `0`, `5`, `10`, and so on. The following example shows this approach, and
/// also adds optional minimum and maximum value labels.
///
///     @State private var speed = 50.0
///     @State private var isEditing = false
///
///     var body: some View {
///         Slider(
///             value: $speed,
///             in: 0...100,
///             step: 5
///         ) {
///             Text("Speed")
///         } minimumValueLabel: {
///             Text("0")
///         } maximumValueLabel: {
///             Text("100")
///         } onEditingChanged: { editing in
///             isEditing = editing
///         }
///         Text("\(speed)")
///             .foregroundColor(isEditing ? .red : .blue)
///     }
///
/// ![A slider with labels show minimum and maximum values of 0 and 100,
/// respectively, with its thumb most of the way to the maximum extreme. Below,
/// a blue label displays the value
/// 85.000000.](SwiftUI-Slider-withStepAndLabels.png)
///
/// The slider also uses the `step` to increase or decrease the value when a
/// VoiceOver user adjusts the slider with voice commands.
@available(iOS 13.0, macOS 10.15, watchOS 6.0, *)
@available(tvOS, unavailable)
public struct Slider<Label, ValueLabel> : View where Label : View, ValueLabel : View {

    /// The content and behavior of the view.
    ///
    /// When you implement a custom view, you must implement a computed
    /// `body` property to provide the content for your view. Return a view
    /// that's composed of built-in views that SwiftUI provides, plus other
    /// composite views that you've already defined:
    ///
    ///     struct MyView: View {
    ///         var body: some View {
    ///             Text("Hello, World!")
    ///         }
    ///     }
    ///
    /// For more information about composing views and a view hierarchy,
    /// see <doc:Declaring-a-Custom-View>.
    @MainActor @preconcurrency public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    @available(iOS 13.0, watchOS 6.0, macOS 10.15, *)
    @available(tvOS, unavailable)
    public typealias Body = some View
}

@available(iOS 13.0, macOS 10.15, watchOS 6.0, *)
@available(tvOS, unavailable)
extension Slider {

    /// Creates a slider to select a value from a given range, which displays
    /// the provided labels.
    ///
    /// - Parameters:
    ///   - value: The selected value within `bounds`.
    ///   - bounds: The range of the valid values. Defaults to `0...1`.
    ///   - label: A `View` that describes the purpose of the instance. Not all
    ///     slider styles show the label, but even in those cases, SwiftUI
    ///     uses the label for accessibility. For example, VoiceOver uses the
    ///     label to identify the purpose of the slider.
    ///   - minimumValueLabel: A view that describes `bounds.lowerBound`.
    ///   - maximumValueLabel: A view that describes `bounds.lowerBound`.
    ///   - onEditingChanged: A callback for when editing begins and ends.
    ///
    /// The `value` of the created instance is equal to the position of
    /// the given value within `bounds`, mapped into `0...1`.
    ///
    /// The slider calls `onEditingChanged` when editing begins and ends. For
    /// example, on iOS, editing begins when the user starts to drag the thumb
    /// along the slider's track.
    nonisolated public init<V>(value: Binding<V>, in bounds: ClosedRange<V> = 0...1, @ViewBuilder label: () -> Label, @ViewBuilder minimumValueLabel: () -> ValueLabel, @ViewBuilder maximumValueLabel: () -> ValueLabel, onEditingChanged: @escaping (Bool) -> Void = { _ in }) where V : BinaryFloatingPoint, V.Stride : BinaryFloatingPoint

    /// Creates a slider to select a value from a given range, subject to a
    /// step increment, which displays the provided labels.
    ///
    /// - Parameters:
    ///   - value: The selected value within `bounds`.
    ///   - bounds: The range of the valid values.
    ///   - step: The distance between each valid value.
    ///   - label: A `View` that describes the purpose of the instance. Not all
    ///     slider styles show the label, but even in those cases, SwiftUI
    ///     uses the label for accessibility. For example, VoiceOver uses the
    ///     label to identify the purpose of the slider.
    ///   - minimumValueLabel: A view that describes `bounds.lowerBound`.
    ///   - maximumValueLabel: A view that describes `bounds.lowerBound`.
    ///   - onEditingChanged: A callback for when editing begins and ends.
    ///
    /// The `value` of the created instance is equal to the position of
    /// the given value within `bounds`, mapped into `0...1`.
    ///
    /// The slider calls `onEditingChanged` when editing begins and ends. For
    /// example, on iOS, editing begins when the user starts to drag the thumb
    /// along the slider's track.
    nonisolated public init<V>(value: Binding<V>, in bounds: ClosedRange<V>, step: V.Stride = 1, @ViewBuilder label: () -> Label, @ViewBuilder minimumValueLabel: () -> ValueLabel, @ViewBuilder maximumValueLabel: () -> ValueLabel, onEditingChanged: @escaping (Bool) -> Void = { _ in }) where V : BinaryFloatingPoint, V.Stride : BinaryFloatingPoint
}

@available(iOS 13.0, macOS 10.15, watchOS 6.0, *)
@available(tvOS, unavailable)
extension Slider where ValueLabel == EmptyView {

    /// Creates a slider to select a value from a given range, which displays
    /// the provided label.
    ///
    /// - Parameters:
    ///   - value: The selected value within `bounds`.
    ///   - bounds: The range of the valid values. Defaults to `0...1`.
    ///   - label: A `View` that describes the purpose of the instance. Not all
    ///     slider styles show the label, but even in those cases, SwiftUI
    ///     uses the label for accessibility. For example, VoiceOver uses the
    ///     label to identify the purpose of the slider.
    ///   - onEditingChanged: A callback for when editing begins and ends.
    ///
    /// The `value` of the created instance is equal to the position of
    /// the given value within `bounds`, mapped into `0...1`.
    ///
    /// The slider calls `onEditingChanged` when editing begins and ends. For
    /// example, on iOS, editing begins when the user starts to drag the thumb
    /// along the slider's track.
    nonisolated public init<V>(value: Binding<V>, in bounds: ClosedRange<V> = 0...1, @ViewBuilder label: () -> Label, onEditingChanged: @escaping (Bool) -> Void = { _ in }) where V : BinaryFloatingPoint, V.Stride : BinaryFloatingPoint

    /// Creates a slider to select a value from a given range, subject to a
    /// step increment, which displays the provided label.
    ///
    /// - Parameters:
    ///   - value: The selected value within `bounds`.
    ///   - bounds: The range of the valid values.
    ///   - step: The distance between each valid value.
    ///   - label: A `View` that describes the purpose of the instance. Not all
    ///     slider styles show the label, but even in those cases, SwiftUI
    ///     uses the label for accessibility. For example, VoiceOver uses the
    ///     label to identify the purpose of the slider.
    ///   - onEditingChanged: A callback for when editing begins and ends.
    ///
    /// The `value` of the created instance is equal to the position of
    /// the given value within `bounds`, mapped into `0...1`.
    ///
    /// The slider calls `onEditingChanged` when editing begins and ends. For
    /// example, on iOS, editing begins when the user starts to drag the thumb
    /// along the slider's track.
    nonisolated public init<V>(value: Binding<V>, in bounds: ClosedRange<V>, step: V.Stride = 1, @ViewBuilder label: () -> Label, onEditingChanged: @escaping (Bool) -> Void = { _ in }) where V : BinaryFloatingPoint, V.Stride : BinaryFloatingPoint
}

@available(iOS 13.0, macOS 10.15, watchOS 6.0, *)
@available(tvOS, unavailable)
extension Slider where Label == EmptyView, ValueLabel == EmptyView {

    /// Creates a slider to select a value from a given range.
    ///
    /// - Parameters:
    ///   - value: The selected value within `bounds`.
    ///   - bounds: The range of the valid values. Defaults to `0...1`.
    ///   - onEditingChanged: A callback for when editing begins and ends.
    ///
    /// The `value` of the created instance is equal to the position of
    /// the given value within `bounds`, mapped into `0...1`.
    ///
    /// The slider calls `onEditingChanged` when editing begins and ends. For
    /// example, on iOS, editing begins when the user starts to drag the thumb
    /// along the slider's track.
    nonisolated public init<V>(value: Binding<V>, in bounds: ClosedRange<V> = 0...1, onEditingChanged: @escaping (Bool) -> Void = { _ in }) where V : BinaryFloatingPoint, V.Stride : BinaryFloatingPoint

    /// Creates a slider to select a value from a given range, subject to a
    /// step increment.
    ///
    /// - Parameters:
    ///   - value: The selected value within `bounds`.
    ///   - bounds: The range of the valid values.
    ///   - step: The distance between each valid value.
    ///   - onEditingChanged: A callback for when editing begins and ends.
    ///
    /// The `value` of the created instance is equal to the position of
    /// the given value within `bounds`, mapped into `0...1`.
    ///
    /// The slider calls `onEditingChanged` when editing begins and ends. For
    /// example, on iOS, editing begins when the user starts to drag the thumb
    /// along the slider's track.
    nonisolated public init<V>(value: Binding<V>, in bounds: ClosedRange<V>, step: V.Stride = 1, onEditingChanged: @escaping (Bool) -> Void = { _ in }) where V : BinaryFloatingPoint, V.Stride : BinaryFloatingPoint
}

@available(iOS 13.0, macOS 10.15, watchOS 6.0, *)
@available(tvOS, unavailable)
extension Slider {

    /// Creates a slider to select a value from a given range, which displays
    /// the provided labels.
    ///
    /// - Parameters:
    ///   - value: The selected value within `bounds`.
    ///   - bounds: The range of the valid values. Defaults to `0...1`.
    ///   - onEditingChanged: A callback for when editing begins and ends.
    ///   - minimumValueLabel: A view that describes `bounds.lowerBound`.
    ///   - maximumValueLabel: A view that describes `bounds.lowerBound`.
    ///   - label: A `View` that describes the purpose of the instance. Not all
    ///     slider styles show the label, but even in those cases, SwiftUI
    ///     uses the label for accessibility. For example, VoiceOver uses the
    ///     label to identify the purpose of the slider.
    ///
    /// The `value` of the created instance is equal to the position of
    /// the given value within `bounds`, mapped into `0...1`.
    ///
    /// The slider calls `onEditingChanged` when editing begins and ends. For
    /// example, on iOS, editing begins when the user starts to drag the thumb
    /// along the slider's track.
    @available(tvOS, unavailable)
    @available(iOS, deprecated: 100000.0, renamed: "Slider(value:in:label:minimumValueLabel:maximumValueLabel:onEditingChanged:)")
    @available(macOS, deprecated: 100000.0, renamed: "Slider(value:in:label:minimumValueLabel:maximumValueLabel:onEditingChanged:)")
    @available(watchOS, deprecated: 100000.0, renamed: "Slider(value:in:label:minimumValueLabel:maximumValueLabel:onEditingChanged:)")
    @available(tvOS, deprecated: 100000.0, renamed: "Slider(value:in:label:minimumValueLabel:maximumValueLabel:onEditingChanged:)")
    @available(visionOS, deprecated: 100000.0, renamed: "Slider(value:in:label:minimumValueLabel:maximumValueLabel:onEditingChanged:)")
    nonisolated public init<V>(value: Binding<V>, in bounds: ClosedRange<V> = 0...1, onEditingChanged: @escaping (Bool) -> Void = { _ in }, minimumValueLabel: ValueLabel, maximumValueLabel: ValueLabel, @ViewBuilder label: () -> Label) where V : BinaryFloatingPoint, V.Stride : BinaryFloatingPoint

    /// Creates a slider to select a value from a given range, subject to a
    /// step increment, which displays the provided labels.
    ///
    /// - Parameters:
    ///   - value: The selected value within `bounds`.
    ///   - bounds: The range of the valid values.
    ///   - step: The distance between each valid value.
    ///   - onEditingChanged: A callback for when editing begins and ends.
    ///   - minimumValueLabel: A view that describes `bounds.lowerBound`.
    ///   - maximumValueLabel: A view that describes `bounds.lowerBound`.
    ///   - label: A `View` that describes the purpose of the instance. Not all
    ///     slider styles show the label, but even in those cases, SwiftUI
    ///     uses the label for accessibility. For example, VoiceOver uses the
    ///     label to identify the purpose of the slider.
    ///
    /// The `value` of the created instance is equal to the position of
    /// the given value within `bounds`, mapped into `0...1`.
    ///
    /// The slider calls `onEditingChanged` when editing begins and ends. For
    /// example, on iOS, editing begins when the user starts to drag the thumb
    /// along the slider's track.
    @available(tvOS, unavailable)
    @available(iOS, deprecated: 100000.0, renamed: "Slider(value:in:step:label:minimumValueLabel:maximumValueLabel:onEditingChanged:)")
    @available(macOS, deprecated: 100000.0, renamed: "Slider(value:in:step:label:minimumValueLabel:maximumValueLabel:onEditingChanged:)")
    @available(watchOS, deprecated: 100000.0, renamed: "Slider(value:in:step:label:minimumValueLabel:maximumValueLabel:onEditingChanged:)")
    @available(tvOS, deprecated: 100000.0, renamed: "Slider(value:in:step:label:minimumValueLabel:maximumValueLabel:onEditingChanged:)")
    @available(visionOS, deprecated: 100000.0, renamed: "Slider(value:in:step:label:minimumValueLabel:maximumValueLabel:onEditingChanged:)")
    nonisolated public init<V>(value: Binding<V>, in bounds: ClosedRange<V>, step: V.Stride = 1, onEditingChanged: @escaping (Bool) -> Void = { _ in }, minimumValueLabel: ValueLabel, maximumValueLabel: ValueLabel, @ViewBuilder label: () -> Label) where V : BinaryFloatingPoint, V.Stride : BinaryFloatingPoint
}

@available(iOS 13.0, macOS 10.15, watchOS 6.0, *)
@available(tvOS, unavailable)
extension Slider where ValueLabel == EmptyView {

    /// Creates a slider to select a value from a given range, which displays
    /// the provided label.
    ///
    /// - Parameters:
    ///   - value: The selected value within `bounds`.
    ///   - bounds: The range of the valid values. Defaults to `0...1`.
    ///   - onEditingChanged: A callback for when editing begins and ends.
    ///   - label: A `View` that describes the purpose of the instance. Not all
    ///     slider styles show the label, but even in those cases, SwiftUI
    ///     uses the label for accessibility. For example, VoiceOver uses the
    ///     label to identify the purpose of the slider.
    ///
    /// The `value` of the created instance is equal to the position of
    /// the given value within `bounds`, mapped into `0...1`.
    ///
    /// The slider calls `onEditingChanged` when editing begins and ends. For
    /// example, on iOS, editing begins when the user starts to drag the thumb
    /// along the slider's track.
    @available(tvOS, unavailable)
    @available(iOS, deprecated: 100000.0, renamed: "Slider(value:in:label:onEditingChanged:)")
    @available(macOS, deprecated: 100000.0, renamed: "Slider(value:in:label:onEditingChanged:)")
    @available(watchOS, deprecated: 100000.0, renamed: "Slider(value:in:label:onEditingChanged:)")
    @available(tvOS, deprecated: 100000.0, renamed: "Slider(value:in:label:onEditingChanged:)")
    @available(visionOS, deprecated: 100000.0, renamed: "Slider(value:in:label:onEditingChanged:)")
    nonisolated public init<V>(value: Binding<V>, in bounds: ClosedRange<V> = 0...1, onEditingChanged: @escaping (Bool) -> Void = { _ in }, @ViewBuilder label: () -> Label) where V : BinaryFloatingPoint, V.Stride : BinaryFloatingPoint

    /// Creates a slider to select a value from a given range, subject to a
    /// step increment, which displays the provided label.
    ///
    /// - Parameters:
    ///   - value: The selected value within `bounds`.
    ///   - bounds: The range of the valid values.
    ///   - step: The distance between each valid value.
    ///   - onEditingChanged: A callback for when editing begins and ends.
    ///   - label: A `View` that describes the purpose of the instance. Not all
    ///     slider styles show the label, but even in those cases, SwiftUI
    ///     uses the label for accessibility. For example, VoiceOver uses the
    ///     label to identify the purpose of the slider.
    ///
    /// The `value` of the created instance is equal to the position of
    /// the given value within `bounds`, mapped into `0...1`.
    ///
    /// The slider calls `onEditingChanged` when editing begins and ends. For
    /// example, on iOS, editing begins when the user starts to drag the thumb
    /// along the slider's track.
    @available(tvOS, unavailable)
    @available(iOS, deprecated: 100000.0, renamed: "Slider(value:in:step:label:onEditingChanged:)")
    @available(macOS, deprecated: 100000.0, renamed: "Slider(value:in:step:label:onEditingChanged:)")
    @available(watchOS, deprecated: 100000.0, renamed: "Slider(value:in:step:label:onEditingChanged:)")
    @available(tvOS, deprecated: 100000.0, renamed: "Slider(value:in:step:label:onEditingChanged:)")
    @available(visionOS, deprecated: 100000.0, renamed: "Slider(value:in:step:label:onEditingChanged:)")
    nonisolated public init<V>(value: Binding<V>, in bounds: ClosedRange<V>, step: V.Stride = 1, onEditingChanged: @escaping (Bool) -> Void = { _ in }, @ViewBuilder label: () -> Label) where V : BinaryFloatingPoint, V.Stride : BinaryFloatingPoint
}

/// A collection of spatial input events that target a specific view.
///
/// You receive a structure of this type as an input to the
/// ``Gesture/onChanged(_:)`` or ``Gesture/onEnded(_:)`` method of a
/// ``SpatialEventGesture``. The structure contains a collection of
/// ``SpatialEventCollection/Event`` values that correspond to ongoing
/// input events. You can look up a specific event in the collection by its
/// ``SpatialEventCollection/Event/id`` value or iterate over all events in
/// the collection to apply logic depending on the event's state.
@available(visionOS 1.0, iOS 18.0, macOS 15.0, watchOS 11.0, *)
@available(tvOS, unavailable)
public struct SpatialEventCollection : Collection {

    /// A spatial event generated from an input like a touch or click
    /// that can drive gestures in the system.
    ///
    /// You receive a collection of these events in the form of a
    /// ``SpatialEventCollection`` that's the input to the
    /// ``Gesture/onChanged(_:)`` or ``Gesture/onEnded(_:)``
    /// method of a ``SpatialEventGesture``. Inspect individual events to
    /// track interactions that enable you to create complex, multi-touch
    /// experiences in your app.
    @available(visionOS 1.0, iOS 18.0, macOS 15.0, watchOS 11.0, *)
    @available(tvOS, unavailable)
    public struct Event : Identifiable, Hashable {

        /// A value that uniquely identifies an event over the course of its lifetime.
        public struct ID : Hashable {

            /// Hashes the essential components of this value by feeding them into the
            /// given hasher.
            ///
            /// Implement this method to conform to the `Hashable` protocol. The
            /// components used for hashing must be the same as the components compared
            /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
            /// with each of these components.
            ///
            /// - Important: In your implementation of `hash(into:)`,
            ///   don't call `finalize()` on the `hasher` instance provided,
            ///   or replace it with a different instance.
            ///   Doing so may become a compile-time error in the future.
            ///
            /// - Parameter hasher: The hasher to use when combining the components
            ///   of this instance.
            public func hash(into hasher: inout Hasher)

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: SpatialEventCollection.Event.ID, b: SpatialEventCollection.Event.ID) -> Bool

            /// The hash value.
            ///
            /// Hash values are not guaranteed to be equal across different executions of
            /// your program. Do not save hash values to use during a future execution.
            ///
            /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
            ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
            ///   The compiler provides an implementation for `hashValue` for you.
            public var hashValue: Int { get }
        }

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The possible input sources or modes of an event.
        public enum Kind : Hashable {

            /// An event generated from a touch directly targeting content.
            case touch

            /// An event generated from a pencil making contact with content.
            @available(iOS 18.0, *)
            @available(macOS, unavailable)
            @available(tvOS, unavailable)
            @available(watchOS, unavailable)
            @available(visionOS, unavailable)
            case pencil

            /// An event representing a click-based, indirect input device
            /// describing the input sequence from click to click release.
            @available(visionOS 1.0, iOS 18.0, macOS 15.0, *)
            @available(tvOS, unavailable)
            @available(watchOS, unavailable)
            case pointer

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: SpatialEventCollection.Event.Kind, b: SpatialEventCollection.Event.Kind) -> Bool

            /// Hashes the essential components of this value by feeding them into the
            /// given hasher.
            ///
            /// Implement this method to conform to the `Hashable` protocol. The
            /// components used for hashing must be the same as the components compared
            /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
            /// with each of these components.
            ///
            /// - Important: In your implementation of `hash(into:)`,
            ///   don't call `finalize()` on the `hasher` instance provided,
            ///   or replace it with a different instance.
            ///   Doing so may become a compile-time error in the future.
            ///
            /// - Parameter hasher: The hasher to use when combining the components
            ///   of this instance.
            public func hash(into hasher: inout Hasher)

            /// The hash value.
            ///
            /// Hash values are not guaranteed to be equal across different executions of
            /// your program. Do not save hash values to use during a future execution.
            ///
            /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
            ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
            ///   The compiler provides an implementation for `hashValue` for you.
            public var hashValue: Int { get }
        }

        /// The states that an event can have.
        public enum Phase : Hashable {

            /// The phase is active and the state associated with it is
            /// guaranteed to produce at least one more update.
            case active

            /// The state associated with this phase ended normally
            /// and won't produce any more updates.
            case ended

            /// The state associated with this phase was canceled
            /// and won't produce any more updates.
            case cancelled

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: SpatialEventCollection.Event.Phase, b: SpatialEventCollection.Event.Phase) -> Bool

            /// Hashes the essential components of this value by feeding them into the
            /// given hasher.
            ///
            /// Implement this method to conform to the `Hashable` protocol. The
            /// components used for hashing must be the same as the components compared
            /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
            /// with each of these components.
            ///
            /// - Important: In your implementation of `hash(into:)`,
            ///   don't call `finalize()` on the `hasher` instance provided,
            ///   or replace it with a different instance.
            ///   Doing so may become a compile-time error in the future.
            ///
            /// - Parameter hasher: The hasher to use when combining the components
            ///   of this instance.
            public func hash(into hasher: inout Hasher)

            /// The hash value.
            ///
            /// Hash values are not guaranteed to be equal across different executions of
            /// your program. Do not save hash values to use during a future execution.
            ///
            /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
            ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
            ///   The compiler provides an implementation for `hashValue` for you.
            public var hashValue: Int { get }
        }

        /// A pose describing the input device like a hand controlling the event.
        public struct InputDevicePose : Hashable {

            /// The altitude angle.
            ///
            /// An angle of zero indicates that the device is parallel to the
            /// content, while 90 degrees indicates that it is normal to the
            /// content surface.
            public var altitude: Angle

            /// The azimuth angle.
            ///
            /// An angle of zero points along the content's positive x-axis.
            public var azimuth: Angle

            /// Hashes the essential components of this value by feeding them into the
            /// given hasher.
            ///
            /// Implement this method to conform to the `Hashable` protocol. The
            /// components used for hashing must be the same as the components compared
            /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
            /// with each of these components.
            ///
            /// - Important: In your implementation of `hash(into:)`,
            ///   don't call `finalize()` on the `hasher` instance provided,
            ///   or replace it with a different instance.
            ///   Doing so may become a compile-time error in the future.
            ///
            /// - Parameter hasher: The hasher to use when combining the components
            ///   of this instance.
            public func hash(into hasher: inout Hasher)

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: SpatialEventCollection.Event.InputDevicePose, b: SpatialEventCollection.Event.InputDevicePose) -> Bool

            /// The hash value.
            ///
            /// Hash values are not guaranteed to be equal across different executions of
            /// your program. Do not save hash values to use during a future execution.
            ///
            /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
            ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
            ///   The compiler provides an implementation for `hashValue` for you.
            public var hashValue: Int { get }
        }

        /// An identifier that uniquely identifies the event over its lifetime.
        public var id: SpatialEventCollection.Event.ID

        /// The time the event was processed.
        public var timestamp: TimeInterval

        /// The event's input source.
        public var kind: SpatialEventCollection.Event.Kind

        /// The 2D location of the event.
        public var location: CGPoint

        /// The phase of the event.
        public var phase: SpatialEventCollection.Event.Phase

        /// The set of active modifier keys at the time of this event.
        public var modifierKeys: EventModifiers

        /// The 3D position and orientation of the device controlling the touch, if one exists.
        @available(visionOS 1.0, iOS 18.0, *)
        @available(macOS, unavailable)
        @available(watchOS, unavailable)
        @available(tvOS, unavailable)
        public var inputDevicePose: SpatialEventCollection.Event.InputDevicePose?

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: SpatialEventCollection.Event, b: SpatialEventCollection.Event) -> Bool

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Retrieves an event using its unique identifier.
    ///
    /// Returns `nil` if the `Event` no longer exists in the collection.
    public subscript(index: SpatialEventCollection.Event.ID) -> SpatialEventCollection.Event? { get }

    /// An iterator over all events in the collection.
    public struct Iterator : IteratorProtocol {

        /// The next `Event` in the sequence, if one exists.
        public mutating func next() -> SpatialEventCollection.Event?

        /// The type of element traversed by the iterator.
        @available(iOS 18.0, watchOS 11.0, visionOS 1.0, macOS 15.0, *)
        @available(tvOS, unavailable)
        public typealias Element = SpatialEventCollection.Event
    }

    /// Makes an iterator over all events in the collection.
    public func makeIterator() -> SpatialEventCollection.Iterator

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    public struct Index : Comparable {

        /// Returns a Boolean value indicating whether the value of the first
        /// argument is less than that of the second argument.
        ///
        /// This function is the only requirement of the `Comparable` protocol. The
        /// remainder of the relational operator functions are implemented by the
        /// standard library for any type that conforms to `Comparable`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func < (lhs: SpatialEventCollection.Index, rhs: SpatialEventCollection.Index) -> Bool

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: SpatialEventCollection.Index, b: SpatialEventCollection.Index) -> Bool
    }

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: SpatialEventCollection.Index { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.firstIndex(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: SpatialEventCollection.Index { get }

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    ///
    /// - Complexity: O(1)
    public subscript(position: SpatialEventCollection.Index) -> SpatialEventCollection.Event { get }

    /// Returns the position immediately after the given index.
    ///
    /// The successor of an index must be well defined. For an index `i` into a
    /// collection `c`, calling `c.index(after: i)` returns the same index every
    /// time.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: SpatialEventCollection.Index) -> SpatialEventCollection.Index

    /// A type representing the sequence's elements.
    @available(iOS 18.0, watchOS 11.0, visionOS 1.0, macOS 15.0, *)
    @available(tvOS, unavailable)
    public typealias Element = SpatialEventCollection.Event

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    @available(iOS 18.0, watchOS 11.0, visionOS 1.0, macOS 15.0, *)
    @available(tvOS, unavailable)
    public typealias Indices = DefaultIndices<SpatialEventCollection>

    /// A collection representing a contiguous subrange of this collection's
    /// elements. The subsequence shares indices with the original collection.
    ///
    /// The default subsequence type for collections that don't define their own
    /// is `Slice`.
    @available(iOS 18.0, watchOS 11.0, visionOS 1.0, macOS 15.0, *)
    @available(tvOS, unavailable)
    public typealias SubSequence = Slice<SpatialEventCollection>
}

@available(visionOS 1.0, iOS 18.0, macOS 15.0, watchOS 11.0, *)
@available(tvOS, unavailable)
extension SpatialEventCollection : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: SpatialEventCollection, rhs: SpatialEventCollection) -> Bool
}

/// A gesture that provides information about ongoing spatial events like
/// clicks and touches.
///
/// Use a gesture of this type to track multiple simultaneous spatial events
/// and gain access to detailed information about each. For example, you can
/// place a particle emitter at every location in a ``Canvas`` that has an
/// ongoing spatial event:
///
/// ```
/// struct ParticlePlayground: View {
///     @State var model = ParticlesModel()
///
///     var body: some View {
///         Canvas { context, size in
///             for particle in model.particles {
///                 context.fill(Path(ellipseIn: particle.frame),
///                              with: .color(particle.color))
///             }
///         }
///         .gesture(
///             SpatialEventGesture()
///                 .onChanged { events in
///                     for event in events {
///                         if event.phase == .active {
///                             // Update particle emitters.
///                             model.emitters[event.id] = ParticlesModel.Emitter(
///                                 location: event.location
///                             )
///                         } else {
///                             // Remove emitters when no longer active.
///                             model.emitters[event.id] = nil
///                         }
///                     }
///                 }
///                 .onEnded { events in
///                     for event in events {
///                         // Remove emitters when no longer active.
///                         model.emitters[event.id] = nil
///                     }
///                 }
///         )
///     }
/// }
/// ```
///
/// The gesture provides a ``SpatialEventCollection`` structure when it detects
/// changes. The collection contains ``SpatialEventCollection/Event`` values
/// that represent ongoing spatial events. Each event contains a stable, unique
/// identifier so that you can track how the event changes over time. The event
/// also indicates its current location, a timestamp, the pose of the
/// input device that creates it, and other useful information.
///
/// The phase of events in the collection can change
/// to ``SpatialEventCollection/Event/Phase/ended`` or
/// ``SpatialEventCollection/Event/Phase/cancelled`` while the gesture itself
/// remains active. Individually track state for each event inside
/// ``Gesture/onChanged(_:)`` or ``Gesture/updating(_:body:)`` and clean up all
/// state in ``Gesture/onEnded(_:)``.
///
/// > Tip: Only use a spatial event gesture if you need to access low-level
///   event information, like when you create a complex multi-touch experience.
///   For most use cases, it's better to rely on gestures that recognize
///   targeted interactions, like a ``SpatialTapGesture``, ``MagnifyGesture``,
///   or ``DragGesture``.
@available(visionOS 1.0, iOS 18.0, macOS 15.0, watchOS 11.0, *)
@available(tvOS, unavailable)
public struct SpatialEventGesture : Gesture {

    /// Creates the gesture with a desired coordinate space.
    public init(coordinateSpace: any CoordinateSpaceProtocol = .local)

    /// The type representing the gesture's value.
    public typealias Value = SpatialEventCollection

    /// The coordinate space of the gesture.
    public let coordinateSpace: CoordinateSpace

    /// The type of gesture representing the body of `Self`.
    @available(iOS 18.0, watchOS 11.0, visionOS 1.0, macOS 15.0, *)
    @available(tvOS, unavailable)
    public typealias Body = Never
}

/// A gesture that recognizes one or more taps and reports their location.
///
/// To recognize a tap gesture on a view, create and configure the gesture, and
/// then add it to the view using the ``View/gesture(_:including:)`` modifier.
/// The following code adds a tap gesture to a ``Circle`` that toggles the color
/// of the circle based on the tap location:
///
///     struct TapGestureView: View {
///         @State private var location: CGPoint = .zero
///
///         var tap: some Gesture {
///             SpatialTapGesture()
///                 .onEnded { event in
///                     self.location = event.location
///                  }
///         }
///
///         var body: some View {
///             Circle()
///                 .fill(self.location.y > 50 ? Color.blue : Color.red)
///                 .frame(width: 100, height: 100, alignment: .center)
///                 .gesture(tap)
///         }
///     }
@available(iOS 16.0, macOS 13.0, watchOS 9.0, visionOS 1.0, *)
@available(tvOS, unavailable)
public struct SpatialTapGesture : Gesture {

    /// The attributes of a tap gesture.
    public struct Value : Equatable, @unchecked Sendable {

        /// The location of the tap gesture's current event.
        public var location: CGPoint

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: SpatialTapGesture.Value, b: SpatialTapGesture.Value) -> Bool
    }

    /// The required number of tap events.
    public var count: Int

    /// The coordinate space in which to receive location values.
    public var coordinateSpace: CoordinateSpace

    /// Creates a tap gesture with the number of required taps and the
    /// coordinate space of the gesture's location.
    ///
    /// - Parameters:
    ///   - count: The required number of taps to complete the tap
    ///     gesture.
    ///   - coordinateSpace: The coordinate space of the tap gesture's location.
    @available(iOS, introduced: 16.0, deprecated: 100000.0, message: "use overload that accepts a CoordinateSpaceProtocol instead")
    @available(macOS, introduced: 13.0, deprecated: 100000.0, message: "use overload that accepts a CoordinateSpaceProtocol instead")
    @available(watchOS, introduced: 9.0, deprecated: 100000.0, message: "use overload that accepts a CoordinateSpaceProtocol instead")
    @available(tvOS, unavailable)
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "use overload that accepts a CoordinateSpaceProtocol instead")
    public init(count: Int = 1, coordinateSpace: CoordinateSpace = .local)

    /// Creates a tap gesture with the number of required taps and the
    /// coordinate space of the gesture's location.
    ///
    /// - Parameters:
    ///   - count: The required number of taps to complete the tap
    ///     gesture.
    ///   - coordinateSpace: The coordinate space of the tap gesture's location.
    @available(iOS 17.0, macOS 14.0, watchOS 10.0, *)
    @available(tvOS, unavailable)
    public init(count: Int = 1, coordinateSpace: some CoordinateSpaceProtocol = .local)

    /// The type of gesture representing the body of `Self`.
    @available(iOS 16.0, watchOS 9.0, visionOS 1.0, macOS 13.0, *)
    @available(tvOS, unavailable)
    public typealias Body = Never
}

/// The options for controlling the spring loading behavior of views.
///
/// Use values of this type with the ``View/springLoadingBehavior(_:)``
/// modifier.
@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
public struct SpringLoadingBehavior : Hashable, Sendable {

    /// The automatic spring loading behavior.
    ///
    /// This defers to default component behavior for spring loading.
    /// Some components, such as `TabView`, will default to allowing spring
    /// loading; while others do not.
    public static let automatic: SpringLoadingBehavior

    /// Spring loaded interactions will be enabled for applicable views.
    public static let enabled: SpringLoadingBehavior

    /// Spring loaded interactions will be disabled for applicable views.
    public static let disabled: SpringLoadingBehavior

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: SpringLoadingBehavior, b: SpringLoadingBehavior) -> Bool

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

/// A navigation view style represented by a view stack that only shows a
/// single top view at a time.
///
/// You can also use ``NavigationViewStyle/stack`` to construct this style.
@available(iOS, introduced: 13.0, deprecated: 100000.0, message: "replace stack-styled NavigationView with NavigationStack")
@available(macOS, unavailable)
@available(tvOS, introduced: 13.0, deprecated: 100000.0, message: "replace stack-styled NavigationView with NavigationStack")
@available(watchOS, introduced: 7.0, deprecated: 100000.0, message: "replace stack-styled NavigationView with NavigationStack")
@available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "replace stack-styled NavigationView with NavigationStack")
public struct StackNavigationViewStyle : NavigationViewStyle {

    public init()
}

/// A control that performs increment and decrement actions.
///
/// Use a stepper control when you want the user to have granular control while
/// incrementing or decrementing a value. For example, you can use a stepper
/// to:
///
///  * Change a value up or down by `1`.
///  * Operate strictly over a prescribed range.
///  * Step by specific amounts over a stepper's range of possible values.
///
/// The example below uses an array that holds a number of ``Color`` values,
/// a local state variable, `value`, to set the control's background
/// color, and title label. When the user clicks or taps the stepper's
/// increment or decrement buttons, SwiftUI executes the relevant
/// closure that updates `value`, wrapping the `value` to prevent overflow.
/// SwiftUI then re-renders the view, updating the text and background
/// color to match the current index:
///
///     struct StepperView: View {
///         @State private var value = 0
///         let colors: [Color] = [.orange, .red, .gray, .blue,
///                                .green, .purple, .pink]
///
///         func incrementStep() {
///             value += 1
///             if value >= colors.count { value = 0 }
///         }
///
///         func decrementStep() {
///             value -= 1
///             if value < 0 { value = colors.count - 1 }
///         }
///
///         var body: some View {
///             Stepper {
///                 Text("Value: \(value) Color: \(colors[value].description)")
///             } onIncrement: {
///                 incrementStep()
///             } onDecrement: {
///                 decrementStep()
///             }
///             .padding(5)
///             .background(colors[value])
///         }
///     }
///
/// ![A view displaying a stepper that uses a text view for stepper's title and that changes the background color of its view when incremented or decremented. The view selects the new background color from a predefined array of colors using the stepper's value as the index.](SwiftUI-Stepper-increment-decrement-closures.png)
///
/// The following example shows a stepper that displays the effect of
/// incrementing or decrementing a value with the step size of `step` with
/// the bounds defined by `range`:
///
///     struct StepperView: View {
///         @State private var value = 0
///         let step = 5
///         let range = 1...50
///
///         var body: some View {
///             Stepper(
///                 value: $value,
///                 in: range,
///                 step: step
///             ) {
///                 Text("Current: \(value) in \(range.description) " +
///                      "stepping by \(step)")
///             }
///             .padding(10)
///         }
///     }
///
/// ![A view displaying a stepper with a step size of five, and a prescribed range of 1 though 50.](SwiftUI-Stepper-value-step-range.png)
@available(iOS 13.0, macOS 10.15, watchOS 9.0, *)
@available(tvOS, unavailable)
public struct Stepper<Label> : View where Label : View {

    /// Creates a stepper instance that performs the closures you provide when
    /// the user increments or decrements the stepper.
    ///
    /// Use this initializer to create a control with a custom title that
    /// executes closures you provide when the user clicks or taps the
    /// stepper's increment or decrement buttons.
    ///
    /// The example below uses an array that holds a number of ``Color`` values,
    /// a local state variable, `value`, to set the control's background
    /// color, and title label. When the user clicks or taps on the stepper's
    /// increment or decrement buttons SwiftUI executes the relevant
    /// closure that updates `value`, wrapping the `value` to prevent overflow.
    /// SwiftUI then re-renders the view, updating the text and background
    /// color to match the current index:
    ///
    ///     struct StepperView: View {
    ///         @State private var value = 0
    ///         let colors: [Color] = [.orange, .red, .gray, .blue, .green,
    ///                                .purple, .pink]
    ///
    ///         func incrementStep() {
    ///             value += 1
    ///             if value >= colors.count { value = 0 }
    ///         }
    ///
    ///         func decrementStep() {
    ///             value -= 1
    ///             if value < 0 { value = colors.count - 1 }
    ///         }
    ///
    ///         var body: some View {
    ///             Stepper {
    ///                 Text("Value: \(value) Color: \(colors[value].description)")
    ///             } onIncrement: {
    ///                 incrementStep()
    ///             } onDecrement: {
    ///                 decrementStep()
    ///             }
    ///             .padding(5)
    ///             .background(colors[value])
    ///         }
    ///    }
    ///
    /// ![A view displaying a stepper that uses a text view for stepper's title
    ///   and that changes the background color of its view when incremented or
    ///   decremented. The view selects the new background color from a
    ///    predefined array of colors using the stepper's value as the
    ///   index.](SwiftUI-Stepper-increment-decrement-closures.png)
    ///
    /// - Parameters:
    ///     - label: A view describing the purpose of this stepper.
    ///     - onIncrement: The closure to execute when the user clicks or taps
    ///       the control's plus button.
    ///     - onDecrement: The closure to execute when the user clicks or taps
    ///       the control's minus button.
    ///     - onEditingChanged: A closure called when editing begins and ends.
    ///       For example, on iOS, the user may touch and hold the increment
    ///       or decrement buttons on a `Stepper` which causes the execution
    ///       of the `onEditingChanged` closure at the start and end of
    ///       the gesture.
    public init(@ViewBuilder label: () -> Label, onIncrement: (() -> Void)?, onDecrement: (() -> Void)?, onEditingChanged: @escaping (Bool) -> Void = { _ in })

    /// The content and behavior of the view.
    ///
    /// When you implement a custom view, you must implement a computed
    /// `body` property to provide the content for your view. Return a view
    /// that's composed of built-in views that SwiftUI provides, plus other
    /// composite views that you've already defined:
    ///
    ///     struct MyView: View {
    ///         var body: some View {
    ///             Text("Hello, World!")
    ///         }
    ///     }
    ///
    /// For more information about composing views and a view hierarchy,
    /// see <doc:Declaring-a-Custom-View>.
    @MainActor @preconcurrency public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    @available(iOS 13.0, watchOS 9.0, macOS 10.15, *)
    @available(tvOS, unavailable)
    public typealias Body = some View
}

@available(iOS 13.0, macOS 10.15, watchOS 9.0, *)
@available(tvOS, unavailable)
extension Stepper {

    /// Creates a stepper configured to increment or decrement a binding to a
    /// value using a step value you provide.
    ///
    /// Use this initializer to create a stepper that increments or decrements
    /// a bound value by a specific amount each time the user
    /// clicks or taps the stepper's increment or decrement buttons.
    ///
    /// In the example below, a stepper increments or decrements `value` by the
    /// `step` value of 5 at each click or tap of the control's increment or
    /// decrement button:
    ///
    ///     struct StepperView: View {
    ///         @State private var value = 1
    ///         let step = 5
    ///         var body: some View {
    ///             Stepper(value: $value,
    ///                     step: step) {
    ///                 Text("Current value: \(value), step: \(step)")
    ///             }
    ///                 .padding(10)
    ///         }
    ///     }
    ///
    /// ![A view displaying a stepper that increments or decrements a value by
    ///   a specified amount each time the user clicks or taps the stepper's
    ///   increment or decrement buttons.](SwiftUI-Stepper-value-step.png)
    ///
    /// - Parameters:
    ///   - value: The ``Binding`` to a value that you provide.
    ///   - step: The amount to increment or decrement `value` each time the
    ///     user clicks or taps the stepper's increment or decrement buttons.
    ///     Defaults to `1`.
    ///   - label: A view describing the purpose of this stepper.
    ///   - onEditingChanged: A closure that's called when editing begins and
    ///     ends. For example, on iOS, the user may touch and hold the increment
    ///     or decrement buttons on a stepper which causes the execution
    ///     of the `onEditingChanged` closure at the start and end of
    ///     the gesture.
    @available(watchOS 9.0, *)
    @available(tvOS, unavailable)
    nonisolated public init<V>(value: Binding<V>, step: V.Stride = 1, @ViewBuilder label: () -> Label, onEditingChanged: @escaping (Bool) -> Void = { _ in }) where V : Strideable

    /// Creates a stepper configured to increment or decrement a binding to a
    /// value using a step value and within a range of values you provide.
    ///
    /// Use this initializer to create a stepper that increments or decrements
    /// a binding to value by the step size you provide within the given bounds.
    /// By setting the bounds, you ensure that the value never goes below or
    /// above the lowest or highest value, respectively.
    ///
    /// The example below shows a stepper that displays the effect of
    /// incrementing or decrementing a value with the step size of `step`
    /// with the bounds defined by `range`:
    ///
    ///     struct StepperView: View {
    ///         @State private var value = 0
    ///         let step = 5
    ///         let range = 1...50
    ///
    ///         var body: some View {
    ///             Stepper(value: $value,
    ///                     in: range,
    ///                     step: step) {
    ///                 Text("Current: \(value) in \(range.description) " +
    ///                      "stepping by \(step)")
    ///             }
    ///                 .padding(10)
    ///         }
    ///     }
    ///
    /// ![A view displaying a stepper with a step size of five, and a
    /// prescribed range of 1 though 50.](SwiftUI-Stepper-value-step-range.png)
    ///
    /// - Parameters:
    ///   - value: A ``Binding`` to a value that you provide.
    ///   - bounds: A closed range that describes the upper and lower bounds
    ///     permitted by the stepper.
    ///   - step: The amount to increment or decrement the stepper when the
    ///     user clicks or taps the stepper's increment or decrement buttons,
    ///     respectively.
    ///   - label: A view describing the purpose of this stepper.
    ///   - onEditingChanged: A closure that's called when editing begins and
    ///     ends. For example, on iOS, the user may touch and hold the increment
    ///     or decrement buttons on a stepper which causes the execution
    ///     of the `onEditingChanged` closure at the start and end of
    ///     the gesture.
    @available(watchOS 9.0, *)
    @available(tvOS, unavailable)
    nonisolated public init<V>(value: Binding<V>, in bounds: ClosedRange<V>, step: V.Stride = 1, @ViewBuilder label: () -> Label, onEditingChanged: @escaping (Bool) -> Void = { _ in }) where V : Strideable
}

@available(iOS 13.0, macOS 10.15, watchOS 9.0, *)
@available(tvOS, unavailable)
extension Stepper where Label == Text {

    /// Creates a stepper that uses a title key and executes the closures
    /// you provide when the user clicks or taps the stepper's increment and
    /// decrement buttons.
    ///
    /// Use this initializer to create a stepper with a custom title that
    /// executes closures you provide when either of the stepper's increment
    /// or decrement buttons are pressed. This version of ``Stepper`` doesn't
    /// take a binding to a value, nor does it allow you to specify a range of
    /// acceptable values, or a step value -- it simply calls the closures you
    /// provide when the control's buttons are pressed.
    ///
    /// The example below uses an array that holds a number of ``Color`` values,
    /// a local state variable, `value`, to set the control's background
    /// color, and title label. When the user clicks or taps on the stepper's
    /// increment or decrement buttons SwiftUI executes the relevant
    /// closure that updates `value`, wrapping the `value` to prevent overflow.
    /// SwiftUI then re-renders the view, updating the text and background
    /// color to match the current index:
    ///
    ///     struct StepperView: View {
    ///         @State private var value = 0
    ///         let colors: [Color] = [.orange, .red, .gray, .blue, .green,
    ///                                .purple, .pink]
    ///
    ///         func incrementStep() {
    ///             value += 1
    ///             if value >= colors.count { value = 0 }
    ///         }
    ///
    ///         func decrementStep() {
    ///             value -= 1
    ///             if value < 0 { value = colors.count - 1 }
    ///         }
    ///
    ///         var body: some View {
    ///             Stepper("Value: \(value) Color: \(colors[value].description)",
    ///                      onIncrement: incrementStep,
    ///                      onDecrement: decrementStep)
    ///             .padding(5)
    ///             .background(colors[value])
    ///         }
    ///     }
    ///
    /// ![A view displaying a stepper that uses a title key for the stepper's
    /// localized title and that changes the background color of its view
    /// when incremented or decremented selecting a color from a predefined
    /// array using the stepper value as the
    /// index.](SwiftUI-Stepper-increment-decrement-closures.png)
    ///
    /// - Parameters:
    ///     - titleKey: The key for the stepper's localized title describing
    ///       the purpose of the stepper.
    ///     - onIncrement: The closure to execute when the user clicks or taps the
    ///       control's plus button.
    ///     - onDecrement: The closure to execute when the user clicks or taps the
    ///       control's minus button.
    ///    - onEditingChanged: A closure that's called when editing begins and
    ///      ends. For example, on iOS, the user may touch and hold the increment
    ///      or decrement buttons on a `Stepper` which causes the execution
    ///      of the `onEditingChanged` closure at the start and end of
    ///      the gesture.
    @available(watchOS 9.0, *)
    @available(tvOS, unavailable)
    nonisolated public init(_ titleKey: LocalizedStringKey, onIncrement: (() -> Void)?, onDecrement: (() -> Void)?, onEditingChanged: @escaping (Bool) -> Void = { _ in })

    /// Creates a stepper using a title string and that executes closures
    /// you provide when the user clicks or taps the stepper's increment or
    /// decrement buttons.
    ///
    /// Use `Stepper(_:onIncrement:onDecrement:onEditingChanged:)` to create a
    /// control with a custom title that executes closures you provide when
    /// the user clicks or taps on the stepper's increment or decrement buttons.
    ///
    /// The example below uses an array that holds a number of ``Color`` values,
    /// a local state variable, `value`, to set the control's background
    /// color, and title label. When the user clicks or taps on the stepper's
    /// increment or decrement buttons SwiftUI executes the relevant
    /// closure that updates `value`, wrapping the `value` to prevent overflow.
    /// SwiftUI then re-renders the view, updating the text and background
    /// color to match the current index:
    ///
    ///     struct StepperView: View {
    ///         @State private var value = 0
    ///         let title: String
    ///         let colors: [Color] = [.orange, .red, .gray, .blue, .green,
    ///                                .purple, .pink]
    ///
    ///         func incrementStep() {
    ///             value += 1
    ///             if value >= colors.count { value = 0 }
    ///         }
    ///
    ///         func decrementStep() {
    ///             value -= 1
    ///             if value < 0 { value = colors.count - 1 }
    ///         }
    ///
    ///         var body: some View {
    ///             Stepper(title, onIncrement: incrementStep, onDecrement: decrementStep)
    ///                 .padding(5)
    ///                 .background(colors[value])
    ///         }
    ///     }
    ///
    /// ![A view displaying a stepper that uses a string for the stepper's title
    ///   and that changes the background color of its view when incremented or
    ///   decremented selecting a color from a predefined array using the
    ///   stepper's value as the
    ///   index.](SwiftUI-Stepper-increment-decrement-closures.png)
    ///
    /// - Parameters:
    ///     - title: A string describing the purpose of the stepper.
    ///     - onIncrement: The closure to execute when the user clicks or taps the
    ///       control's plus button.
    ///     - onDecrement: The closure to execute when the user clicks or taps the
    ///       control's minus button.
    ///    - onEditingChanged: A closure that's called when editing begins and
    ///      ends. For example, on iOS, the user may touch and hold the increment
    ///      or decrement buttons on a `Stepper` which causes the execution
    ///      of the `onEditingChanged` closure at the start and end of
    ///      the gesture.
    @available(watchOS 9.0, *)
    @available(tvOS, unavailable)
    nonisolated public init<S>(_ title: S, onIncrement: (() -> Void)?, onDecrement: (() -> Void)?, onEditingChanged: @escaping (Bool) -> Void = { _ in }) where S : StringProtocol

    /// Creates a stepper with a title key and configured to increment and
    /// decrement a binding to a value and step amount you provide.
    ///
    /// Use `Stepper(_:value:step:onEditingChanged:)` to create a stepper with a
    /// custom title that increments or decrements a binding to value by the
    /// step size you specify.
    ///
    /// In the example below, the stepper increments or decrements the binding
    /// value by `5` each time the user clicks or taps on the control's
    /// increment or decrement buttons, respectively:
    ///
    ///     struct StepperView: View {
    ///         @State private var value = 1
    ///         let step = 5
    ///
    ///         var body: some View {
    ///             Stepper("Current value: \(value), step: \(step)",
    ///                     value: $value,
    ///                     step: step)
    ///                 .padding(10)
    ///         }
    ///     }
    ///
    /// ![A view displaying a stepper that increments or decrements by 5 each
    ///   time the user clicks or taps on the control's increment or decrement
    ///   buttons, respectively.](SwiftUI-Stepper-value-step.png)
    ///
    /// - Parameters:
    ///     - titleKey: The key for the stepper's localized title describing
    ///       the purpose of the stepper.
    ///     - value: A ``Binding`` to a value that you provide.
    ///     - step: The amount to increment or decrement `value` each time the
    ///       user clicks or taps the stepper's plus or minus button,
    ///       respectively.  Defaults to `1`.
    ///     - onEditingChanged: A closure that's called when editing begins and
    ///       ends. For example, on iOS, the user may touch and hold the
    ///       increment or decrement buttons on a `Stepper` which causes the
    ///       execution of the `onEditingChanged` closure at the start and end
    ///       of the gesture.
    @available(watchOS 9.0, *)
    @available(tvOS, unavailable)
    nonisolated public init<V>(_ titleKey: LocalizedStringKey, value: Binding<V>, step: V.Stride = 1, onEditingChanged: @escaping (Bool) -> Void = { _ in }) where V : Strideable

    /// Creates a stepper with a title and configured to increment and
    /// decrement a binding to a value and step amount you provide.
    ///
    /// Use `Stepper(_:value:step:onEditingChanged:)` to create a stepper with a
    /// custom title that increments or decrements a binding to value by the
    /// step size you specify.
    ///
    /// In the example below, the stepper increments or decrements the binding
    /// value by `5` each time one of the user clicks or taps the control's
    /// increment or decrement buttons:
    ///
    ///     struct StepperView: View {
    ///         @State private var value = 1
    ///         let step = 5
    ///         let title: String
    ///
    ///         var body: some View {
    ///             Stepper(title, value: $value, step: step)
    ///                 .padding(10)
    ///         }
    ///     }
    ///
    /// ![A view displaying a stepper that increments or decrements by 1 each
    ///   time the control's buttons
    ///   are pressed.](SwiftUI-Stepper-value-step.png)
    ///
    /// - Parameters:
    ///     - title: A string describing the purpose of the stepper.
    ///     - value: The ``Binding`` to a value that you provide.
    ///     - step: The amount to increment or decrement `value` each time the
    ///       user clicks or taps the stepper's increment or decrement button,
    ///       respectively. Defaults to `1`.
    ///     - onEditingChanged: A closure that's called when editing begins and
    ///       ends. For example, on iOS, the user may touch and hold the
    ///       increment or decrement buttons on a `Stepper` which causes the
    ///       execution of the `onEditingChanged` closure at the start and end
    ///       of the gesture.
    @available(watchOS 9.0, *)
    @available(tvOS, unavailable)
    nonisolated public init<S, V>(_ title: S, value: Binding<V>, step: V.Stride = 1, onEditingChanged: @escaping (Bool) -> Void = { _ in }) where S : StringProtocol, V : Strideable

    /// Creates a stepper instance that increments and decrements a binding to
    /// a value, by a step size and within a closed range that you provide.
    ///
    /// Use `Stepper(_:value:in:step:onEditingChanged:)` to create a stepper
    /// that increments or decrements a value within a specific range of values
    /// by a specific step size. In the example below, a stepper increments or
    /// decrements a binding to value over a range of `1...50` by `5` at each
    /// press of the stepper's increment or decrement buttons:
    ///
    ///     struct StepperView: View {
    ///         @State private var value = 0
    ///         @State private var titleKey = "Stepper"
    ///
    ///         let step = 5
    ///         let range = 1...50
    ///
    ///         var body: some View {
    ///             VStack(spacing: 20) {
    ///                 Text("Current Stepper Value: \(value)")
    ///                 Stepper(titleKey, value: $value, in: range, step: step)
    ///             }
    ///         }
    ///     }
    ///
    /// ![A view displaying a stepper that increments or decrements within a
    ///   specified range and step size.](SwiftUI-Stepper-value-step-range.png)
    ///
    /// - Parameters:
    ///     - titleKey: The key for the stepper's localized title describing
    ///       the purpose of the stepper.
    ///     - value: A ``Binding`` to a value that your provide.
    ///     - bounds: A closed range that describes the upper and lower bounds
    ///       permitted by the stepper.
    ///     - step: The amount to increment or decrement `value` each time the
    ///       user clicks or taps the stepper's increment or decrement button,
    ///       respectively. Defaults to `1`.
    ///     - onEditingChanged: A closure that's called when editing begins and
    ///       ends. For example, on iOS, the user may touch and hold the increment
    ///       or decrement buttons on a `Stepper` which causes the execution
    ///       of the `onEditingChanged` closure at the start and end of
    ///       the gesture.
    @available(watchOS 9.0, *)
    @available(tvOS, unavailable)
    nonisolated public init<V>(_ titleKey: LocalizedStringKey, value: Binding<V>, in bounds: ClosedRange<V>, step: V.Stride = 1, onEditingChanged: @escaping (Bool) -> Void = { _ in }) where V : Strideable

    /// Creates a stepper instance that increments and decrements a binding to
    /// a value, by a step size and within a closed range that you provide.
    ///
    /// Use `Stepper(_:value:in:step:onEditingChanged:)` to create a stepper
    /// that increments or decrements a value within a specific range of values
    /// by a specific step size. In the example below, a stepper increments or
    /// decrements a binding to value over a range of `1...50` by `5` each time
    /// the user clicks or taps the stepper's increment or decrement buttons:
    ///
    ///     struct StepperView: View {
    ///         @State private var value = 0
    ///         let step = 5
    ///         let range = 1...50
    ///
    ///         var body: some View {
    ///             Stepper("Current: \(value) in \(range.description) stepping by \(step)",
    ///                     value: $value,
    ///                     in: range,
    ///                     step: step)
    ///                 .padding(10)
    ///         }
    ///     }
    ///
    /// ![A view displaying a stepper that increments or decrements within a
    ///   specified range and step size.](SwiftUI-Stepper-value-step-range.png)
    ///
    /// - Parameters:
    ///     - title: A string describing the purpose of the stepper.
    ///     - value: A ``Binding`` to a value that your provide.
    ///     - bounds: A closed range that describes the upper and lower bounds
    ///       permitted by the stepper.
    ///     - step: The amount to increment or decrement `value` each time the
    ///       user clicks or taps the stepper's increment or decrement button,
    ///       respectively. Defaults to `1`.
    ///     - onEditingChanged: A closure that's called when editing begins and
    ///       ends. For example, on iOS, the user may touch and hold the increment
    ///       or decrement buttons on a `Stepper` which causes the execution
    ///       of the `onEditingChanged` closure at the start and end of
    ///       the gesture.
    @available(watchOS 9.0, *)
    @available(tvOS, unavailable)
    nonisolated public init<S, V>(_ title: S, value: Binding<V>, in bounds: ClosedRange<V>, step: V.Stride = 1, onEditingChanged: @escaping (Bool) -> Void = { _ in }) where S : StringProtocol, V : Strideable
}

@available(iOS 16.0, macOS 13.0, watchOS 9.0, *)
@available(tvOS, unavailable)
extension Stepper {

    /// Creates a stepper configured to increment or decrement a binding to a
    /// value using a step value you provide, displaying its value with an
    /// applied format style.
    ///
    /// Use this initializer to create a stepper that increments or decrements
    /// a bound value by a specific amount each time the user clicks or taps
    /// the stepper's increment or decrement buttons, while displaying the
    /// current value.
    ///
    /// In the example below, a stepper increments or decrements `value` by the
    /// `step` value of 5 at each click or tap of the control's increment or
    /// decrement button:
    ///
    ///     struct StepperView: View {
    ///         @State private var value = 1
    ///         let step = 5
    ///         var body: some View {
    ///             Stepper(value: $value,
    ///                     step: step,
    ///                     format: .number) {
    ///                 Text("Current value: \(value), step: \(step)")
    ///             }
    ///                 .padding(10)
    ///         }
    ///     }
    ///
    /// ![A view displaying a stepper that increments or decrements a value by
    ///   a specified amount each time the user clicks or taps the stepper's
    ///   increment or decrement buttons.](SwiftUI-Stepper-value-step.png)
    ///
    /// - Parameters:
    ///   - value: The ``Binding`` to a value that you provide.
    ///   - step: The amount to increment or decrement `value` each time the
    ///     user clicks or taps the stepper's increment or decrement buttons.
    ///     Defaults to `1`.
    ///   - format: A format style of type `F` to use when converting between
    ///     the string the user edits and the underlying value of type
    ///     `F.FormatInput`. If `format` can't perform the conversion, the
    ///     stepper leaves `value` unchanged. If the user stops editing the
    ///     text in an invalid state, the stepper updates the text to the last
    ///     known valid value.
    ///   - label: A view describing the purpose of this stepper.
    ///   - onEditingChanged: A closure that's called when editing begins and
    ///     ends. For example, on iOS, the user may touch and hold the increment
    ///     or decrement buttons on a stepper which causes the execution
    ///     of the `onEditingChanged` closure at the start and end of
    ///     the gesture.
    nonisolated public init<F>(value: Binding<F.FormatInput>, step: F.FormatInput.Stride = 1, format: F, @ViewBuilder label: () -> Label, onEditingChanged: @escaping (Bool) -> Void = { _ in }) where F : ParseableFormatStyle, F.FormatInput : BinaryFloatingPoint, F.FormatOutput == String

    /// Creates a stepper configured to increment or decrement a binding to a
    /// value using a step value and within a range of values you provide,
    /// displaying its value with an applied format style.
    ///
    /// Use this initializer to create a stepper that increments or decrements
    /// a binding to value by the step size you provide within the given bounds.
    /// By setting the bounds, you ensure that the value never goes below or
    /// above the lowest or highest value, respectively.
    ///
    /// The example below shows a stepper that displays the effect of
    /// incrementing or decrementing a value with the step size of `step`
    /// with the bounds defined by `range`:
    ///
    ///     struct StepperView: View {
    ///         @State private var value = 0
    ///         let step = 5
    ///         let range = 1...50
    ///
    ///         var body: some View {
    ///             Stepper(value: $value,
    ///                     in: range,
    ///                     step: step,
    ///                     format: .number) {
    ///                 Text("Current: \(value) in \(range.description) " +
    ///                      "stepping by \(step)")
    ///             }
    ///                 .padding(10)
    ///         }
    ///     }
    ///
    /// ![A view displaying a stepper with a step size of five, and a
    /// prescribed range of 1 though 50.](SwiftUI-Stepper-value-step-range.png)
    ///
    /// - Parameters:
    ///   - value: A ``Binding`` to a value that you provide.
    ///   - bounds: A closed range that describes the upper and lower bounds
    ///     permitted by the stepper.
    ///   - step: The amount to increment or decrement the stepper when the
    ///     user clicks or taps the stepper's increment or decrement buttons,
    ///     respectively.
    ///   - format: A format style of type `F` to use when converting between
    ///     the string the user edits and the underlying value of type
    ///     `F.FormatInput`. If `format` can't perform the conversion, the
    ///     stepper leaves `value` unchanged. If the user stops editing the
    ///     text in an invalid state, the stepper updates the text to the last
    ///     known valid value.
    ///   - label: A view describing the purpose of this stepper.
    ///   - onEditingChanged: A closure that's called when editing begins and
    ///     ends. For example, on iOS, the user may touch and hold the increment
    ///     or decrement buttons on a stepper which causes the execution
    ///     of the `onEditingChanged` closure at the start and end of
    ///     the gesture.
    nonisolated public init<F>(value: Binding<F.FormatInput>, in bounds: ClosedRange<F.FormatInput>, step: F.FormatInput.Stride = 1, format: F, @ViewBuilder label: () -> Label, onEditingChanged: @escaping (Bool) -> Void = { _ in }) where F : ParseableFormatStyle, F.FormatInput : BinaryFloatingPoint, F.FormatOutput == String
}

@available(iOS 16.0, macOS 13.0, watchOS 9.0, *)
@available(tvOS, unavailable)
extension Stepper where Label == Text {

    /// Creates a stepper with a title key and configured to increment and
    /// decrement a binding to a value and step amount you provide,
    /// displaying its value with an applied format style.
    ///
    /// Use `Stepper(_:value:step:onEditingChanged:)` to create a stepper with a
    /// custom title that increments or decrements a binding to value by the
    /// step size you specify, while displaying the current value.
    ///
    /// In the example below, the stepper increments or decrements the binding
    /// value by `5` each time the user clicks or taps on the control's
    /// increment or decrement buttons, respectively:
    ///
    ///     struct StepperView: View {
    ///         @State private var value = 1
    ///
    ///         var body: some View {
    ///             Stepper("Stepping by \(step)",
    ///                 value: $value,
    ///                 step: 5,
    ///                 format: .number
    ///             )
    ///             .padding(10)
    ///         }
    ///     }
    ///
    /// ![A view displaying a stepper that increments or decrements by 5 each
    ///   time the user clicks or taps on the control's increment or decrement
    ///   buttons, respectively.](SwiftUI-Stepper-value-step.png)
    ///
    /// - Parameters:
    ///     - titleKey: The key for the stepper's localized title describing
    ///       the purpose of the stepper.
    ///     - value: A ``Binding`` to a value that you provide.
    ///     - step: The amount to increment or decrement `value` each time the
    ///       user clicks or taps the stepper's plus or minus button,
    ///       respectively.  Defaults to `1`.
    ///     - format: A format style of type `F` to use when converting between
    ///       the string the user edits and the underlying value of type
    ///       `F.FormatInput`. If `format` can't perform the conversion, the
    ///       stepper leaves `value` unchanged. If the user stops editing the
    ///       text in an invalid state, the stepper updates the text to the last
    ///       known valid value.
    ///     - onEditingChanged: A closure that's called when editing begins and
    ///       ends. For example, on iOS, the user may touch and hold the
    ///       increment or decrement buttons on a `Stepper` which causes the
    ///       execution of the `onEditingChanged` closure at the start and end
    ///       of the gesture.
    nonisolated public init<F>(_ titleKey: LocalizedStringKey, value: Binding<F.FormatInput>, step: F.FormatInput.Stride = 1, format: F, onEditingChanged: @escaping (Bool) -> Void = { _ in }) where F : ParseableFormatStyle, F.FormatInput : BinaryFloatingPoint, F.FormatOutput == String

    /// Creates a stepper with a title and configured to increment and
    /// decrement a binding to a value and step amount you provide,
    /// displaying its value with an applied format style.
    ///
    /// Use `Stepper(_:value:step:format:onEditingChanged:)` to create a stepper
    /// with a custom title that increments or decrements a binding to value by
    /// the step size you specify, while displaying the current value.
    ///
    /// In the example below, the stepper increments or decrements the binding
    /// value by `5` each time one of the user clicks or taps the control's
    /// increment or decrement buttons:
    ///
    ///     struct StepperView: View {
    ///         let title: String
    ///         @State private var value = 1
    ///
    ///         var body: some View {
    ///             Stepper(title, value: $value, step: 5, format: .number)
    ///                 .padding(10)
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///     - title: A string describing the purpose of the stepper.
    ///     - value: The ``Binding`` to a value that you provide.
    ///     - step: The amount to increment or decrement `value` each time the
    ///       user clicks or taps the stepper's increment or decrement button,
    ///       respectively. Defaults to `1`.
    ///     - format: A format style of type `F` to use when converting between
    ///       the string the user edits and the underlying value of type
    ///       `F.FormatInput`. If `format` can't perform the conversion, the
    ///       stepper leaves `value` unchanged. If the user stops editing the
    ///       text in an invalid state, the stepper updates the text to the last
    ///       known valid value.
    ///     - onEditingChanged: A closure that's called when editing begins and
    ///       ends. For example, on iOS, the user may touch and hold the
    ///       increment or decrement buttons on a `Stepper` which causes the
    ///       execution of the `onEditingChanged` closure at the start and end
    ///       of the gesture.
    nonisolated public init<S, F>(_ title: S, value: Binding<F.FormatInput>, step: F.FormatInput.Stride = 1, format: F, onEditingChanged: @escaping (Bool) -> Void = { _ in }) where S : StringProtocol, F : ParseableFormatStyle, F.FormatInput : BinaryFloatingPoint, F.FormatOutput == String

    /// Creates a stepper instance that increments and decrements a binding to
    /// a value, by a step size and within a closed range that you provide,
    /// displaying its value with an applied format style.
    ///
    /// Use `Stepper(_:value:in:step:format:onEditingChanged:)` to create a
    /// stepper that increments or decrements a value within a specific range
    /// of values by a specific step size, while displaying the current value.
    /// In the example below, a stepper increments or decrements a binding to
    /// value over a range of `1...50` by `5` each time the user clicks or taps
    /// the stepper's increment or decrement buttons:
    ///
    ///     struct StepperView: View {
    ///         @State private var value = 0
    ///
    ///         var body: some View {
    ///             Stepper("Stepping by \(step) in \(range.description)",
    ///                 value: $value,
    ///                 in: 1...50,
    ///                 step: 5,
    ///                 format: .number
    ///             )
    ///             .padding()
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///     - titleKey: The key for the stepper's localized title describing
    ///       the purpose of the stepper.
    ///     - value: A ``Binding`` to a value that your provide.
    ///     - bounds: A closed range that describes the upper and lower bounds
    ///       permitted by the stepper.
    ///     - step: The amount to increment or decrement `value` each time the
    ///       user clicks or taps the stepper's increment or decrement button,
    ///       respectively. Defaults to `1`.
    ///     - format: A format style of type `F` to use when converting between
    ///       the string the user edits and the underlying value of type
    ///       `F.FormatInput`. If `format` can't perform the conversion, the
    ///       stepper leaves `value` unchanged. If the user stops editing the
    ///       text in an invalid state, the stepper updates the text to the last
    ///       known valid value.
    ///     - onEditingChanged: A closure that's called when editing begins and
    ///       ends. For example, on iOS, the user may touch and hold the increment
    ///       or decrement buttons on a `Stepper` which causes the execution
    ///       of the `onEditingChanged` closure at the start and end of
    ///       the gesture.
    nonisolated public init<F>(_ titleKey: LocalizedStringKey, value: Binding<F.FormatInput>, in bounds: ClosedRange<F.FormatInput>, step: F.FormatInput.Stride = 1, format: F, onEditingChanged: @escaping (Bool) -> Void = { _ in }) where F : ParseableFormatStyle, F.FormatInput : BinaryFloatingPoint, F.FormatOutput == String

    /// Creates a stepper instance that increments and decrements a binding to
    /// a value, by a step size and within a closed range that you provide,
    /// displaying its value with an applied format style.
    ///
    /// Use `Stepper(_:value:in:step:format:onEditingChanged:)` to create a
    /// stepper that increments or decrements a value within a specific range
    /// of values by a specific step size, while displaying the current value.
    /// In the example below, a stepper increments or decrements a binding to
    /// value over a range of `1...50` by `5` each time the user clicks or taps
    /// the stepper's increment or decrement buttons:
    ///
    ///     struct StepperView: View {
    ///         let title: String
    ///         @State private var value = 0
    ///
    ///         let step = 5
    ///         let range = 1...50
    ///
    ///         var body: some View {
    ///             Stepper(title,
    ///                 value: $value,
    ///                 in: 1...50,
    ///                 step: 5,
    ///                 format: .number
    ///             )
    ///             .padding()
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///     - title: A string describing the purpose of the stepper.
    ///     - value: A ``Binding`` to a value that your provide.
    ///     - bounds: A closed range that describes the upper and lower bounds
    ///       permitted by the stepper.
    ///     - step: The amount to increment or decrement `value` each time the
    ///       user clicks or taps the stepper's increment or decrement button,
    ///       respectively. Defaults to `1`.
    ///     - format: A format style of type `F` to use when converting between
    ///       the string the user edits and the underlying value of type
    ///       `F.FormatInput`. If `format` can't perform the conversion, the
    ///       stepper leaves `value` unchanged. If the user stops editing the
    ///       text in an invalid state, the stepper updates the text to the last
    ///       known valid value.
    ///     - onEditingChanged: A closure that's called when editing begins and
    ///       ends. For example, on iOS, the user may touch and hold the increment
    ///       or decrement buttons on a `Stepper` which causes the execution
    ///       of the `onEditingChanged` closure at the start and end of
    ///       the gesture.
    nonisolated public init<S, F>(_ title: S, value: Binding<F.FormatInput>, in bounds: ClosedRange<F.FormatInput>, step: F.FormatInput.Stride = 1, format: F, onEditingChanged: @escaping (Bool) -> Void = { _ in }) where S : StringProtocol, F : ParseableFormatStyle, F.FormatInput : BinaryFloatingPoint, F.FormatOutput == String
}

@available(iOS 13.0, macOS 10.15, watchOS 9.0, *)
@available(tvOS, unavailable)
extension Stepper {

    /// Creates a stepper instance that performs the closures you provide when
    /// the user increments or decrements the stepper.
    ///
    /// Use this initializer to create a control with a custom title that
    /// executes closures you provide when the user clicks or taps the
    /// stepper's increment or decrement buttons.
    ///
    /// The example below uses an array that holds a number of ``Color`` values,
    /// a local state variable, `value`, to set the control's background
    /// color, and title label. When the user clicks or taps on the stepper's
    /// increment or decrement buttons SwiftUI executes the relevant
    /// closure that updates `value`, wrapping the `value` to prevent overflow.
    /// SwiftUI then re-renders the view, updating the text and background
    /// color to match the current index:
    ///
    ///     struct StepperView: View {
    ///         @State private var value = 0
    ///         let colors: [Color] = [.orange, .red, .gray, .blue, .green,
    ///                                .purple, .pink]
    ///
    ///         func incrementStep() {
    ///             value += 1
    ///             if value >= colors.count { value = 0 }
    ///         }
    ///
    ///         func decrementStep() {
    ///             value -= 1
    ///             if value < 0 { value = colors.count - 1 }
    ///         }
    ///
    ///         var body: some View {
    ///             Stepper(onIncrement: incrementStep,
    ///                 onDecrement: decrementStep) {
    ///                 Text("Value: \(value) Color: \(colors[value].description)")
    ///             }
    ///             .padding(5)
    ///             .background(colors[value])
    ///         }
    ///    }
    ///
    /// ![A view displaying a stepper that uses a text view for stepper's title
    ///   and that changes the background color of its view when incremented or
    ///   decremented. The view selects the new background color from a
    ///    predefined array of colors using the stepper's value as the
    ///   index.](SwiftUI-Stepper-increment-decrement-closures.png)
    ///
    /// - Parameters:
    ///     - onIncrement: The closure to execute when the user clicks or taps
    ///       the control's plus button.
    ///     - onDecrement: The closure to execute when the user clicks or taps
    ///       the control's minus button.
    ///     - onEditingChanged: A closure called when editing begins and ends.
    ///       For example, on iOS, the user may touch and hold the increment
    ///       or decrement buttons on a `Stepper` which causes the execution
    ///       of the `onEditingChanged` closure at the start and end of
    ///       the gesture.
    ///     - label: A view describing the purpose of this stepper.
    @available(iOS, deprecated: 100000.0, renamed: "Stepper(label:onIncrement:onDecrement:onEditingChanged:)")
    @available(macOS, deprecated: 100000.0, renamed: "Stepper(label:onIncrement:onDecrement:onEditingChanged:)")
    @available(watchOS, deprecated: 100000.0, renamed: "Stepper(label:onIncrement:onDecrement:onEditingChanged:)")
    @available(visionOS, deprecated: 100000.0, renamed: "Stepper(label:onIncrement:onDecrement:onEditingChanged:)")
    nonisolated public init(onIncrement: (() -> Void)?, onDecrement: (() -> Void)?, onEditingChanged: @escaping (Bool) -> Void = { _ in }, @ViewBuilder label: () -> Label)

    /// Creates a stepper configured to increment or decrement a binding to a
    /// value using a step value you provide.
    ///
    /// Use this initializer to create a stepper that increments or decrements
    /// a bound value by a specific amount each time the user
    /// clicks or taps the stepper's increment or decrement buttons.
    ///
    /// In the example below, a stepper increments or decrements `value` by the
    /// `step` value of 5 at each click or tap of the control's increment or
    /// decrement button:
    ///
    ///     struct StepperView: View {
    ///         @State private var value = 1
    ///         let step = 5
    ///         var body: some View {
    ///             Stepper(value: $value,
    ///                     step: step) {
    ///                 Text("Current value: \(value), step: \(step)")
    ///             }
    ///                 .padding(10)
    ///         }
    ///     }
    ///
    /// ![A view displaying a stepper that increments or decrements a value by
    ///   a specified amount each time the user clicks or taps the stepper's
    ///   increment or decrement buttons.](SwiftUI-Stepper-value-step.png)
    ///
    /// - Parameters:
    ///   - value: The ``Binding`` to a value that you provide.
    ///   - step: The amount to increment or decrement `value` each time the
    ///     user clicks or taps the stepper's increment or decrement buttons.
    ///     Defaults to `1`.
    ///   - onEditingChanged: A closure that's called when editing begins and
    ///     ends. For example, on iOS, the user may touch and hold the increment
    ///     or decrement buttons on a stepper which causes the execution
    ///     of the `onEditingChanged` closure at the start and end of
    ///     the gesture.
    ///   - label: A view describing the purpose of this stepper.
    @available(iOS, deprecated: 100000.0, renamed: "Stepper(value:step:label:onEditingChanged:)")
    @available(macOS, deprecated: 100000.0, renamed: "Stepper(value:step:label:onEditingChanged:)")
    @available(watchOS, deprecated: 100000.0, renamed: "Stepper(value:step:label:onEditingChanged:)")
    @available(visionOS, deprecated: 100000.0, renamed: "Stepper(value:step:label:onEditingChanged:)")
    nonisolated public init<V>(value: Binding<V>, step: V.Stride = 1, onEditingChanged: @escaping (Bool) -> Void = { _ in }, @ViewBuilder label: () -> Label) where V : Strideable

    /// Creates a stepper configured to increment or decrement a binding to a
    /// value using a step value and within a range of values you provide.
    ///
    /// Use this initializer to create a stepper that increments or decrements
    /// a binding to value by the step size you provide within the given bounds.
    /// By setting the bounds, you ensure that the value never goes below or
    /// above the lowest or highest value, respectively.
    ///
    /// The example below shows a stepper that displays the effect of
    /// incrementing or decrementing a value with the step size of `step`
    /// with the bounds defined by `range`:
    ///
    ///     struct StepperView: View {
    ///         @State private var value = 0
    ///         let step = 5
    ///         let range = 1...50
    ///
    ///         var body: some View {
    ///             Stepper(value: $value,
    ///                     in: range,
    ///                     step: step) {
    ///                 Text("Current: \(value) in \(range.description) " +
    ///                      "stepping by \(step)")
    ///             }
    ///                 .padding(10)
    ///         }
    ///     }
    ///
    /// ![A view displaying a stepper with a step size of five, and a
    /// prescribed range of 1 though 50.](SwiftUI-Stepper-value-step-range.png)
    ///
    /// - Parameters:
    ///   - value: A ``Binding`` to a value that you provide.
    ///   - bounds: A closed range that describes the upper and lower bounds
    ///     permitted by the stepper.
    ///   - step: The amount to increment or decrement the stepper when the
    ///     user clicks or taps the stepper's increment or decrement buttons,
    ///     respectively.
    ///   - onEditingChanged: A closure that's called when editing begins and
    ///     ends. For example, on iOS, the user may touch and hold the increment
    ///     or decrement buttons on a stepper which causes the execution
    ///     of the `onEditingChanged` closure at the start and end of
    ///     the gesture.
    ///   - label: A view describing the purpose of this stepper.
    @available(iOS, deprecated: 100000.0, renamed: "Stepper(value:in:step:label:onEditingChanged:)")
    @available(macOS, deprecated: 100000.0, renamed: "Stepper(value:in:step:label:onEditingChanged:)")
    @available(watchOS, deprecated: 100000.0, renamed: "Stepper(value:in:step:label:onEditingChanged:)")
    @available(visionOS, deprecated: 100000.0, renamed: "Stepper(value:in:step:label:onEditingChanged:)")
    nonisolated public init<V>(value: Binding<V>, in bounds: ClosedRange<V>, step: V.Stride = 1, onEditingChanged: @escaping (Bool) -> Void = { _ in }, @ViewBuilder label: () -> Label) where V : Strideable
}

/// A semantic label describing the label of submission within a view hierarchy.
///
/// A submit label is a description of a submission action provided to a
/// view hierarchy using the ``View/onSubmit(of:_:)`` modifier.
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public struct SubmitLabel : Sendable {

    /// Defines a submit label with text of "Done".
    public static var done: SubmitLabel { get }

    /// Defines a submit label with text of "Go".
    public static var go: SubmitLabel { get }

    /// Defines a submit label with text of "Send".
    public static var send: SubmitLabel { get }

    /// Defines a submit label with text of "Join".
    public static var join: SubmitLabel { get }

    /// Defines a submit label with text of "Route".
    public static var route: SubmitLabel { get }

    /// Defines a submit label with text of "Search".
    public static var search: SubmitLabel { get }

    /// Defines a submit label with text of "Return".
    public static var `return`: SubmitLabel { get }

    /// Defines a submit label with text of "Next".
    public static var next: SubmitLabel { get }

    /// Defines a submit label with text of "Continue".
    public static var `continue`: SubmitLabel { get }
}

/// A type that defines various triggers that result in the firing of a
/// submission action.
///
/// These triggers may be provided to the ``View/onSubmit(of:_:)``
/// modifier to alter which types of user behaviors trigger a provided
/// submission action.
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public struct SubmitTriggers : OptionSet, Sendable {

    /// The raw type that can be used to represent all values of the conforming
    /// type.
    ///
    /// Every distinct value of the conforming type has a corresponding unique
    /// value of the `RawValue` type, but there may be values of the `RawValue`
    /// type that don't have a corresponding value of the conforming type.
    public typealias RawValue = Int

    /// The corresponding value of the raw type.
    ///
    /// A new instance initialized with `rawValue` will be equivalent to this
    /// instance. For example:
    ///
    ///     enum PaperSize: String {
    ///         case A4, A5, Letter, Legal
    ///     }
    ///
    ///     let selectedSize = PaperSize.Letter
    ///     print(selectedSize.rawValue)
    ///     // Prints "Letter"
    ///
    ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
    ///     // Prints "true"
    public let rawValue: SubmitTriggers.RawValue

    /// Creates a set of submit triggers.
    public init(rawValue: SubmitTriggers.RawValue)

    /// Defines triggers originating from text input controls like `TextField`
    /// and `SecureField`.
    public static let text: SubmitTriggers

    /// Defines triggers originating from search fields constructed from
    /// searchable modifiers.
    ///
    /// In the example below, only the search field or search completions
    /// placed by the searchable modifier will trigger the view model to submit
    /// its current search query.
    ///
    ///     @StateObject private var viewModel = ViewModel()
    ///
    ///     NavigationView {
    ///         SidebarView()
    ///         DetailView()
    ///     }
    ///     .searchable(
    ///         text: $viewModel.searchText,
    ///         placement: .sidebar
    ///     ) {
    ///         SuggestionsView()
    ///     }
    ///     .onSubmit(of: .search) {
    ///         viewModel.submitCurrentSearchQuery()
    ///     }
    ///
    public static let search: SubmitTriggers

    /// The type of the elements of an array literal.
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias ArrayLiteralElement = SubmitTriggers

    /// The element type of the option set.
    ///
    /// To inherit all the default implementations from the `OptionSet` protocol,
    /// the `Element` type must be `Self`, the default.
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias Element = SubmitTriggers
}

/// A view that subscribes to a publisher with an action.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@frozen public struct SubscriptionView<PublisherType, Content> : View where PublisherType : Publisher, Content : View, PublisherType.Failure == Never {

    /// The content view.
    public var content: Content

    /// The `Publisher` that is being subscribed.
    public var publisher: PublisherType

    /// The `Action` executed when `publisher` emits an event.
    public var action: (PublisherType.Output) -> Void

    @inlinable public init(content: Content, publisher: PublisherType, action: @escaping (PublisherType.Output) -> Void)

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    public typealias Body = Never
}

/// An opaque value representing a subview of another view.
///
/// Access to a `Subview` can be obtained by using `ForEach(subviews:)` or
/// `Group(subviews:)`.
///
/// Subviews are proxies to the resolved view they represent, meaning
/// that modifiers applied to the original view will be applied before
/// modifiers applied to the subview, and the view is resolved
/// using the environment of its container, *not* the environment of the
/// its subview proxy. Additionally, because subviews must represent a
/// single leaf view, or container, a subview may represent a view after the
/// application of styles. As such, attempting to apply a style to it may
/// have no affect.
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct Subview : View, Identifiable {

    /// A unique identifier for a subview.
    public struct ID : Hashable {

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Subview.ID, b: Subview.ID) -> Bool

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// The unique identifier of the view.
    ///
    /// This identifier persists across updates, changes to the order of
    /// subviews, etc. so can be used to track the lifetime of a subview.
    public var id: Subview.ID { get }

    /// The container values associated with the given subview.
    public var containerValues: ContainerValues { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias Body = Never
}

/// An opaque collection representing the subviews of view.
///
/// Subviews collection constructs subviews on demand, so only access the part
/// of the collection you need to create the resulting content.
///
/// You can get access to a view's subview collection by using the
/// ``Group/init(sectionsOf:transform:)`` initializer.
///
/// The collection's elements are the pieces that make up the given view, and
/// the collection as a whole acts as a proxy for the original view.
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct SubviewsCollection : RandomAccessCollection {

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    public func index(before i: Int) -> Int

    /// Returns the position immediately after the given index.
    ///
    /// The successor of an index must be well defined. For an index `i` into a
    /// collection `c`, calling `c.index(after: i)` returns the same index every
    /// time.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: Int) -> Int

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    ///
    /// - Complexity: O(1)
    public subscript(index: Int) -> Subview { get }

    /// Accesses a contiguous subrange of the collection's elements.
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection uses. Always use the slice's `startIndex` property
    /// instead of assuming that its indices start at a particular value.
    ///
    /// This example demonstrates getting a slice of an array of strings, finding
    /// the index of one of the strings in the slice, and then using that index
    /// in the original array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2 ..< streets.endIndex]
    ///     print(streetsSlice)
    ///     // Prints "["Channing", "Douglas", "Evarts"]"
    ///
    ///     let index = streetsSlice.firstIndex(of: "Evarts")    // 4
    ///     print(streets[index!])
    ///     // Prints "Evarts"
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    ///
    /// - Complexity: O(1)
    public subscript(bounds: Range<Int>) -> SubviewsCollectionSlice { get }

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: Int { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.firstIndex(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: Int { get }

    /// A type representing the sequence's elements.
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias Element = Subview

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias Index = Int

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias Indices = Range<Int>

    /// A type that provides the collection's iteration interface and
    /// encapsulates its iteration state.
    ///
    /// By default, a collection conforms to the `Sequence` protocol by
    /// supplying `IndexingIterator` as its associated `Iterator`
    /// type.
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias Iterator = IndexingIterator<SubviewsCollection>

    /// A collection representing a contiguous subrange of this collection's
    /// elements. The subsequence shares indices with the original collection.
    ///
    /// The default subsequence type for collections that don't define their own
    /// is `Slice`.
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias SubSequence = SubviewsCollectionSlice
}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension SubviewsCollection : View {

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias Body = Never
}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct SubviewsCollectionSlice : RandomAccessCollection {

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    ///
    /// - Complexity: O(1)
    public subscript(index: Int) -> Subview { get }

    /// Accesses a contiguous subrange of the collection's elements.
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection uses. Always use the slice's `startIndex` property
    /// instead of assuming that its indices start at a particular value.
    ///
    /// This example demonstrates getting a slice of an array of strings, finding
    /// the index of one of the strings in the slice, and then using that index
    /// in the original array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2 ..< streets.endIndex]
    ///     print(streetsSlice)
    ///     // Prints "["Channing", "Douglas", "Evarts"]"
    ///
    ///     let index = streetsSlice.firstIndex(of: "Evarts")    // 4
    ///     print(streets[index!])
    ///     // Prints "Evarts"
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    ///
    /// - Complexity: O(1)
    public subscript(bounds: Range<Int>) -> SubviewsCollectionSlice { get }

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: Int { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.firstIndex(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: Int { get }

    /// A type representing the sequence's elements.
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias Element = Subview

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias Index = Int

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias Indices = Range<Int>

    /// A type that provides the collection's iteration interface and
    /// encapsulates its iteration state.
    ///
    /// By default, a collection conforms to the `Sequence` protocol by
    /// supplying `IndexingIterator` as its associated `Iterator`
    /// type.
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias Iterator = IndexingIterator<SubviewsCollectionSlice>

    /// A collection representing a contiguous subrange of this collection's
    /// elements. The subsequence shares indices with the original collection.
    ///
    /// The default subsequence type for collections that don't define their own
    /// is `Slice`.
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias SubSequence = SubviewsCollectionSlice
}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension SubviewsCollectionSlice : View {

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias Body = Never
}

/// A toggle style that displays a leading label and a trailing switch.
///
/// Use the ``ToggleStyle/switch`` static variable to create this style:
///
///     Toggle("Enhance Sound", isOn: $isEnhanced)
///         .toggleStyle(.switch)
///
@available(iOS 13.0, macOS 10.15, tvOS 18.0, watchOS 6.0, *)
public struct SwitchToggleStyle : ToggleStyle {

    /// Creates a switch toggle style.
    ///
    /// Don't call this initializer directly. Instead, use the
    /// ``ToggleStyle/switch`` static variable to create this style:
    ///
    ///     Toggle("Enhance Sound", isOn: $isEnhanced)
    ///         .toggleStyle(.switch)
    ///
    public init()

    /// Creates a switch style with a tint color.
    @available(iOS, introduced: 14.0, deprecated: 100000.0, message: "Use ``View/tint(_)`` instead.")
    @available(macOS, introduced: 11.0, deprecated: 100000.0, message: "Use ``View/tint(_)`` instead.")
    @available(tvOS, unavailable)
    @available(watchOS, introduced: 7.0, deprecated: 100000.0, message: "Use ``View/tint(_)`` instead.")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Use ``View/tint(_)`` instead.")
    public init(tint: Color)

    /// Creates a view that represents the body of a toggle switch.
    ///
    /// SwiftUI implements this required method of the ``ToggleStyle``
    /// protocol to define the behavior and appearance of the
    /// ``ToggleStyle/switch`` toggle style. Don't call this method
    /// directly. Rather, the system calls this method for each
    /// ``Toggle`` instance in a view hierarchy that's styled as
    /// a switch.
    ///
    /// - Parameter configuration: The properties of the toggle, including a
    ///   label and a binding to the toggle's state.
    /// - Returns: A view that represents a switch.
    @MainActor @preconcurrency public func makeBody(configuration: SwitchToggleStyle.Configuration) -> some View


    /// A view that represents the appearance and interaction of a toggle.
    ///
    /// SwiftUI infers this type automatically based on the ``View``
    /// instance that you return from your implementation of the
    /// ``makeBody(configuration:)`` method.
    @available(iOS 13.0, tvOS 18.0, watchOS 6.0, macOS 10.15, *)
    public typealias Body = some View
}

/// Creates a transition that applies the Appear or Disappear
/// symbol animation to symbol images within the inserted or
/// removed view hierarchy.
///
/// Other views are unaffected by this transition.
@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
@MainActor @frozen @preconcurrency public struct SymbolEffectTransition : Transition {

    @MainActor @preconcurrency public init<T>(effect: T, options: SymbolEffectOptions) where T : SymbolEffect, T : TransitionSymbolEffect

    /// Gets the current body of the caller.
    ///
    /// `content` is a proxy for the view that will have the modifier
    /// represented by `Self` applied to it.
    @MainActor @preconcurrency public func body(content: SymbolEffectTransition.Content, phase: TransitionPhase) -> some View


    /// Returns the properties this transition type has.
    ///
    /// Defaults to `TransitionProperties()`.
    @MainActor @preconcurrency public static let properties: TransitionProperties

    /// The type of view representing the body.
    @available(iOS 17.0, tvOS 17.0, watchOS 10.0, macOS 14.0, *)
    public typealias Body = some View
}

/// The content for a tab and the tab's associated tab item in a tab view.
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct Tab<Value, Content, Label> {
}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Tab : TabContent where Value : Hashable, Content : View, Label : View {

    /// The type used to drive selection for the containing tab view.
    public typealias TabValue = Value

    /// Creates a tab that the tab view presents when the tab view's selection
    /// matches the tab's value, with a string label.
    ///
    /// - Parameters:
    ///     - title: The label for the tab's tab item.
    ///     - image: The image for the tab's tab item.
    ///     - value: The `selection` value which selects this tab.
    ///     - content: The view content of the tab.
    nonisolated public init<S>(_ title: S, image: String, value: Value, @ViewBuilder content: () -> Content) where Label == DefaultTabLabel, S : StringProtocol

    /// Creates a tab that the tab view presents when the tab view's selection
    /// matches the tab's value, with a string label.
    ///
    /// - Parameters:
    ///     - title: The label for the tab's tab item.
    ///     - image: The image for the tab's tab item.
    ///     - value: The `selection` value which selects this tab.
    ///     - role: The role defining the semantic purpose of the tab.
    ///     - content: The view content of the tab.
    nonisolated public init<S>(_ title: S, image: String, value: Value, role: TabRole?, @ViewBuilder content: () -> Content) where Label == DefaultTabLabel, S : StringProtocol

    /// Creates a tab that the tab view presents when the tab view's selection
    /// matches the tab's value, with a string label.
    ///
    /// - Parameters:
    ///     - title: The label for the tab's tab item.
    ///     - image: The image for the tab's tab item.
    ///     - value: The `selection` value which selects this tab.
    ///     - content: The view content of the tab.
    nonisolated public init<S, T>(_ title: S, image: String, value: T, @ViewBuilder content: () -> Content) where Value == T?, Label == DefaultTabLabel, S : StringProtocol, T : Hashable

    /// Creates a tab that the tab view presents when the tab view's selection
    /// matches the tab's value, with a string label.
    ///
    /// - Parameters:
    ///     - title: The label for the tab's tab item.
    ///     - image: The image for the tab's tab item.
    ///     - value: The `selection` value which selects this tab.
    ///     - role: The role defining the semantic purpose of the tab.
    ///     - content: The view content of the tab.
    nonisolated public init<S, T>(_ title: S, image: String, value: T, role: TabRole?, @ViewBuilder content: () -> Content) where Value == T?, Label == DefaultTabLabel, S : StringProtocol, T : Hashable

    /// Creates a tab that the tab view presents when the tab view's selection
    /// matches the tab's value, with a localized string key label.
    ///
    /// - Parameters:
    ///     - titleKey: The localized string key label for the tab's tab item.
    ///     - image: The image for the tab's tab item.
    ///     - value: The `selection` value which selects this tab.
    ///     - content: The view content of the tab.
    nonisolated public init(_ titleKey: LocalizedStringKey, image: String, value: Value, @ViewBuilder content: () -> Content) where Label == DefaultTabLabel

    /// Creates a tab that the tab view presents when the tab view's selection
    /// matches the tab's value, with a localized string key label.
    ///
    /// - Parameters:
    ///     - titleKey: The localized string key label for the tab's tab item.
    ///     - image: The image for the tab's tab item.
    ///     - value: The `selection` value which selects this tab.
    ///     - role: The role defining the semantic purpose of the tab.
    ///     - content: The view content of the tab.
    nonisolated public init(_ titleKey: LocalizedStringKey, image: String, value: Value, role: TabRole?, @ViewBuilder content: () -> Content) where Label == DefaultTabLabel

    /// Creates a tab that the tab view presents when the tab view's selection
    /// matches the tab's value, with a localized string key label.
    ///
    /// - Parameters:
    ///     - titleKey: The localized string key label for the tab's tab item.
    ///     - image: The image for the tab's tab item.
    ///     - value: The `selection` value which selects this tab.
    ///     - content: The view content of the tab.
    nonisolated public init<T>(_ titleKey: LocalizedStringKey, image: String, value: T, @ViewBuilder content: () -> Content) where Value == T?, Label == DefaultTabLabel, T : Hashable

    /// Creates a tab that the tab view presents when the tab view's selection
    /// matches the tab's value, with a localized string key label.
    ///
    /// - Parameters:
    ///     - titleKey: The localized string key label for the tab's tab item.
    ///     - image: The image for the tab's tab item.
    ///     - value: The `selection` value which selects this tab.
    ///     - role: The role defining the semantic purpose of the tab.
    ///     - content: The view content of the tab.
    nonisolated public init<T>(_ titleKey: LocalizedStringKey, image: String, value: T, role: TabRole?, @ViewBuilder content: () -> Content) where Value == T?, Label == DefaultTabLabel, T : Hashable

    /// Creates a tab that the tab view presents when the tab view's selection
    /// matches the tab's value using a system image for the tab's tab item image,
    /// with a string label.
    ///
    /// - Parameters:
    ///     - title: The label for the tab's tab item.
    ///     - systemImage: The system image for the tab's tab item.
    ///     - value: The `selection` value which selects this tab.
    ///     - content: The view content of the tab.
    nonisolated public init<S>(_ title: S, systemImage: String, value: Value, @ViewBuilder content: () -> Content) where Label == DefaultTabLabel, S : StringProtocol

    /// Creates a tab that the tab view presents when the tab view's selection
    /// matches the tab's value using a system image for the tab's tab item image,
    /// with a string label.
    ///
    /// - Parameters:
    ///     - title: The label for the tab's tab item.
    ///     - systemImage: The system image for the tab's tab item.
    ///     - value: The `selection` value which selects this tab.
    ///     - role: The role defining the semantic purpose of the tab.
    ///     - content: The view content of the tab.
    nonisolated public init<S>(_ title: S, systemImage: String, value: Value, role: TabRole?, @ViewBuilder content: () -> Content) where Label == DefaultTabLabel, S : StringProtocol

    /// Creates a tab that the tab view presents when the tab view's selection
    /// matches the tab's value using a system image for the tab's tab item image,
    /// with a string label.
    ///
    /// - Parameters:
    ///     - title: The label for the tab's tab item.
    ///     - systemImage: The system image for the tab's tab item.
    ///     - value: The `selection` value which selects this tab.
    ///     - content: The view content of the tab.
    nonisolated public init<S, T>(_ title: S, systemImage: String, value: T, @ViewBuilder content: () -> Content) where Value == T?, Label == DefaultTabLabel, S : StringProtocol, T : Hashable

    /// Creates a tab that the tab view presents when the tab view's selection
    /// matches the tab's value using a system image for the tab's tab item image,
    /// with a string label.
    ///
    /// - Parameters:
    ///     - title: The label for the tab's tab item.
    ///     - systemImage: The system image for the tab's tab item.
    ///     - value: The `selection` value which selects this tab.
    ///     - role: The role defining the semantic purpose of the tab.
    ///     - content: The view content of the tab.
    nonisolated public init<S, T>(_ title: S, systemImage: String, value: T, role: TabRole?, @ViewBuilder content: () -> Content) where Value == T?, Label == DefaultTabLabel, S : StringProtocol, T : Hashable

    /// Creates a tab that the tab view presents when the tab view's selection
    /// matches the tab's value using a system image for the tab's tab item image,
    /// with a localized string key label.
    ///
    /// - Parameters:
    ///     - titleKey: The localized string key label for the tab's tab item.
    ///     - systemImage: The system image for the tab's tab item.
    ///     - value: The `selection` value which selects this tab.
    ///     - content: The view content of the tab.
    nonisolated public init(_ titleKey: LocalizedStringKey, systemImage: String, value: Value, @ViewBuilder content: () -> Content) where Label == DefaultTabLabel

    /// Creates a tab that the tab view presents when the tab view's selection
    /// matches the tab's value using a system image for the tab's tab item image,
    /// with a localized string key label.
    ///
    /// - Parameters:
    ///     - titleKey: The localized string key label for the tab's tab item.
    ///     - systemImage: The system image for the tab's tab item.
    ///     - value: The `selection` value which selects this tab.
    ///     - role: The role defining the semantic purpose of the tab.
    ///     - content: The view content of the tab.
    nonisolated public init(_ titleKey: LocalizedStringKey, systemImage: String, value: Value, role: TabRole?, @ViewBuilder content: () -> Content) where Label == DefaultTabLabel

    /// Creates a tab that the tab view presents when the tab view's selection
    /// matches the tab's value using a system image for the tab's tab item image,
    /// with a localized string key label.
    ///
    /// - Parameters:
    ///     - titleKey: The localized string key label for the tab's tab item.
    ///     - systemImage: The system image for the tab's tab item.
    ///     - value: The `selection` value which selects this tab.
    ///     - content: The view content of the tab.
    nonisolated public init<T>(_ titleKey: LocalizedStringKey, systemImage: String, value: T, @ViewBuilder content: () -> Content) where Value == T?, Label == DefaultTabLabel, T : Hashable

    /// Creates a tab that the tab view presents when the tab view's selection
    /// matches the tab's value using a system image for the tab's tab item image,
    /// with a localized string key label.
    ///
    /// - Parameters:
    ///     - titleKey: The localized string key label for the tab's tab item.
    ///     - systemImage: The system image for the tab's tab item.
    ///     - value: The `selection` value which selects this tab.
    ///     - role: The role defining the semantic purpose of the tab.
    ///     - content: The view content of the tab.
    nonisolated public init<T>(_ titleKey: LocalizedStringKey, systemImage: String, value: T, role: TabRole?, @ViewBuilder content: () -> Content) where Value == T?, Label == DefaultTabLabel, T : Hashable

    /// Creates a new tab that you can use in a tab view, with an empty label.
    ///
    /// - Parameters:
    ///     - value: The `selection` value which selects this tab.
    ///     - content: The view content of the tab.
    nonisolated public init(value: Value, @ViewBuilder content: () -> Content) where Label == EmptyView

    /// Creates a new tab that you can use in a tab view, with an empty label.
    ///
    /// - Parameters:
    ///     - value: The `selection` value which selects this tab.
    ///     - content: The view content of the tab.
    nonisolated public init<V>(value: V, @ViewBuilder content: () -> Content) where Value == V?, Label == EmptyView, V : Hashable

    /// Creates a new tab with a label inferred from the role.
    ///
    /// - Parameters:
    ///     - value: The `selection` value which selects this tab.
    ///     - role: The `role` defining the semantic purpose of the tab.
    ///     - content: The view content of the tab.
    nonisolated public init(value: Value, role: TabRole?, @ViewBuilder content: () -> Content) where Label == DefaultTabLabel

    /// Creates a new tab with a label inferred from the role.
    ///
    /// - Parameters:
    ///     - value: The `selection` value which selects this tab.
    ///     - role: The `role` defining the semantic purpose of the tab.
    ///     - content: The view content of the tab.
    nonisolated public init<V>(value: V, role: TabRole?, @ViewBuilder content: () -> Content) where Value == V?, Label == DefaultTabLabel, V : Hashable

    /// Creates a new tab with a label that you can use in a tab view.
    ///
    /// - Parameters:
    ///     - value: The `selection` value which selects this tab.
    ///     - content: The view content of the tab.
    ///     - label: The label for the tab's tab item.
    nonisolated public init(value: Value, @ViewBuilder content: () -> Content, @ViewBuilder label: () -> Label)

    /// Creates a new tab with a label that you can use in a tab view.
    ///
    /// - Parameters:
    ///     - value: The `selection` value which selects this tab.
    ///     - role: The role defining the semantic purpose of the tab.
    ///     - content: The view content of the tab.
    ///     - label: The label for the tab's tab item.
    nonisolated public init(value: Value, role: TabRole?, @ViewBuilder content: () -> Content, @ViewBuilder label: () -> Label)

    /// Creates a new tab with a label that you can use in a tab view.
    ///
    /// - Parameters:
    ///     - value: The `selection` value which selects this tab.
    ///     - content: The view content of the tab.
    ///     - label: The label for the tab's tab item.
    nonisolated public init<V>(value: V, @ViewBuilder content: () -> Content, @ViewBuilder label: () -> Label) where Value == V?, V : Hashable

    /// Creates a new tab with a label that you can use in a tab view.
    ///
    /// - Parameters:
    ///     - value: The `selection` value which selects this tab.
    ///     - role: The role defining the semantic purpose of the tab.
    ///     - content: The view content of the tab.
    ///     - label: The label for the tab's tab item.
    nonisolated public init<V>(value: V, role: TabRole?, @ViewBuilder content: () -> Content, @ViewBuilder label: () -> Label) where Value == V?, V : Hashable

    /// The value of this type's nested content.
    @MainActor @preconcurrency public var body: Tab<Value, Content, Label> { get }

    /// The type of content representing the body of this content type.
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias Body = Tab<Value, Content, Label>
}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Tab where Value == Never, Content : View, Label : View {

    /// Creates a new tab that you can use in a tab view, with a string label.
    ///
    /// - Parameters:
    ///     - title: The label for the tab's tab item.
    ///     - image: The image for the tab's tab item.
    ///     - content: The view content of the tab.
    public init<S>(_ title: S, image: String, @ViewBuilder content: () -> Content) where Label == DefaultTabLabel, S : StringProtocol

    /// Creates a new tab that you can use in a tab view, with a string label.
    ///
    /// - Parameters:
    ///     - title: The label for the tab's tab item.
    ///     - image: The image for the tab's tab item.
    ///     - role: The role defining the semantic purpose of the tab.
    ///     - content: The view content of the tab.
    public init<S>(_ title: S, image: String, role: TabRole?, @ViewBuilder content: () -> Content) where Label == DefaultTabLabel, S : StringProtocol

    /// Creates a new tab that you can use in a tab view, with a localized
    /// string key label.
    ///
    /// - Parameters:
    ///     - titleKey: The localized string key label for the tab's tab item.
    ///     - image: The image for the tab's tab item.
    ///     - content: The view content of the tab.
    public init(_ titleKey: LocalizedStringKey, image: String, @ViewBuilder content: () -> Content) where Label == DefaultTabLabel

    /// Creates a new tab that you can use in a tab view, with a localized
    /// string key label.
    ///
    /// - Parameters:
    ///     - titleKey: The localized string key label for the tab's tab item.
    ///     - image: The image for the tab's tab item.
    ///     - role: The role defining the semantic purpose of the tab.
    ///     - content: The view content of the tab.
    public init(_ titleKey: LocalizedStringKey, image: String, role: TabRole?, @ViewBuilder content: () -> Content) where Label == DefaultTabLabel

    /// Creates a new tab that you can use in a tab view using a system image
    /// for the tab item's image, and a string label.
    ///
    /// - Parameters:
    ///     - title: The label for the tab's tab item.
    ///     - image: The image for the tab's tab item.
    ///     - content: The view content of the tab.
    public init<S>(_ title: S, systemImage: String, @ViewBuilder content: () -> Content) where Label == DefaultTabLabel, S : StringProtocol

    /// Creates a new tab that you can use in a tab view using a system image
    /// for the tab item's image, and a string label.
    ///
    /// - Parameters:
    ///     - title: The label for the tab's tab item.
    ///     - image: The image for the tab's tab item.
    ///     - role: The role defining the semantic purpose of the tab.
    ///     - content: The view content of the tab.
    public init<S>(_ title: S, systemImage: String, role: TabRole?, @ViewBuilder content: () -> Content) where Label == DefaultTabLabel, S : StringProtocol

    /// Creates a new tab that you can use in a tab view using a system image
    /// for the tab item's image, and a localized string key label.
    ///
    /// - Parameters:
    ///     - titleKey: The localized string key label for the tab's tab item.
    ///     - image: The image for the tab's tab item.
    ///     - content: The view content of the tab.
    public init(_ titleKey: LocalizedStringKey, systemImage: String, @ViewBuilder content: () -> Content) where Label == DefaultTabLabel

    /// Creates a new tab that you can use in a tab view using a system image
    /// for the tab item's image, and a localized string key label.
    ///
    /// - Parameters:
    ///     - titleKey: The localized string key label for the tab's tab item.
    ///     - image: The image for the tab's tab item.
    ///     - role: The role defining the semantic purpose of the tab.
    ///     - content: The view content of the tab.
    public init(_ titleKey: LocalizedStringKey, systemImage: String, role: TabRole?, @ViewBuilder content: () -> Content) where Label == DefaultTabLabel
}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Tab where Value == Never, Content : View, Label : View {

    /// Creates a new tab that you can use in a tab view, with an empty label.
    ///
    /// - Parameters:
    ///     - content: The view content of the tab.
    public init(@ViewBuilder content: () -> Content) where Label == EmptyView

    /// Creates a new tab that you can use in a tab view, with an empty label.
    ///
    /// - Parameters:
    ///     - role: The role defining the semantic purpose of the tab.
    ///     - content: The view content of the tab.
    public init(role: TabRole?, @ViewBuilder content: () -> Content) where Label == DefaultTabLabel

    /// Creates a new tab with a label that you can use in a tab view.
    ///
    /// - Parameters:
    ///     - content: The view content of the tab.
    ///     - label: The label for the tab's tab item.
    public init(@ViewBuilder content: () -> Content, @ViewBuilder label: () -> Label)

    /// Creates a new tab with a label that you can use in a tab view.
    ///
    /// - Parameters:
    ///     - role: The role defining the semantic purpose of the tab.
    ///     - content: The view content of the tab.
    ///     - label: The label for the tab's tab item.
    public init(role: TabRole?, @ViewBuilder content: () -> Content, @ViewBuilder label: () -> Label)
}

/// A tab view style that displays a tab bar when possible.
///
/// Use ``TabViewStyle/tabBarOnly`` to construct this style.
///
/// To apply this style to a tab view, or to a view that contains tab views, use
/// the ``View/tabViewStyle(_:)`` modifier.
@available(iOS 18.0, macOS 15.0, tvOS 18.0, visionOS 2.0, *)
@available(watchOS, unavailable)
public struct TabBarOnlyTabViewStyle : TabViewStyle {

    public init()
}

/// A placement for tabs in a tab view.
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct TabBarPlacement : Hashable {

    /// Top bar of a tab view.
    ///
    /// A tab bar can display as the top
    /// bar in ``TabViewStyle/tabBarOnly`` on iPad and macOS, or
    /// ``TabViewStyle/sidebarAdaptable`` on iPad.
    public static let topBar: TabBarPlacement

    /// The sidebar of a tab view.
    ///
    /// A tab bar can appear as a sidebar
    /// in ``TabViewStyle/sidebarAdaptable`` on iPad,
    /// macOS, visionOS, and tvOS.
    public static let sidebar: TabBarPlacement

    /// Bottom bar of a tab view.
    public static let bottomBar: TabBarPlacement

    /// Tab view displaying as an ornament.
    public static let ornament: TabBarPlacement

    /// Tab view displaying as an indicator
    /// that shows the position within
    /// the pages.
    public static let pageIndicator: TabBarPlacement

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: TabBarPlacement, b: TabBarPlacement) -> Bool

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

/// A type that provides content for programmatically selectable tabs in a
/// tab view.
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
@MainActor @preconcurrency public protocol TabContent<TabValue> {

    /// The type used to drive selection for the containing tab view.
    associatedtype TabValue : Hashable where Self.TabValue == Self.Body.TabValue

    /// The type of content representing the body of this content type.
    associatedtype Body : TabContent

    /// The value of this type's nested content.
    @TabContentBuilder<Self.TabValue> @MainActor @preconcurrency var body: Self.Body { get }
}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension TabContent {

    /// Adds a textual description of the value that the tab contains.
    ///
    /// Use this method to describe the value represented by a tab, but only
    /// if that's different than the tab's label such as when an icon represent
    /// information about a tab.
    ///
    ///     var body: some View {
    ///         TabView {
    ///             Tab {
    ///                 MessagesView()
    ///             } label: {
    ///                 Text("Messages")
    ///             }
    ///             .badge(30)
    ///             .accessibilityValue("30 Unread")
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - valueDescription: The accessibility value to apply.
    ///   - isEnabled: If true the accessibility value is applied; otherwise
    ///     the accessibility value is unchanged.
    nonisolated public func accessibilityValue(_ valueDescription: Text, isEnabled: Bool = true) -> some TabContent<Self.TabValue>


    /// Adds a textual description of the value that the tab contains.
    ///
    /// Use this method to describe the value represented by a tab, but only
    /// if that's different than the tab's label such as when an icon represent
    /// information about a tab.
    ///
    ///     var body: some View {
    ///         TabView {
    ///             Tab {
    ///                 MessagesView()
    ///             } label: {
    ///                 Text("Messages")
    ///             }
    ///             .badge(30)
    ///             .accessibilityValue("30 Unread")
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - valueKey: The accessibility value to apply.
    ///   - isEnabled: If true the accessibility value is applied; otherwise
    ///     the accessibility value is unchanged.
    nonisolated public func accessibilityValue(_ valueKey: LocalizedStringKey, isEnabled: Bool = true) -> some TabContent<Self.TabValue>


    /// Adds a textual description of the value that the tab contains.
    ///
    /// Use this method to describe the value represented by a tab, but only
    /// if that's different than the tab's label such as when an icon represent
    /// information about a tab.
    ///
    ///     var body: some View {
    ///         TabView {
    ///             Tab {
    ///                 MessagesView()
    ///             } label: {
    ///                 Text("Messages")
    ///             }
    ///             .badge(30)
    ///             .accessibilityValue("30 Unread")
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - value: The accessibility value to apply.
    ///   - isEnabled: If true the accessibility value is applied; otherwise
    ///     the accessibility value is unchanged.
    nonisolated public func accessibilityValue<S>(_ value: S, isEnabled: Bool = true) -> some TabContent<Self.TabValue> where S : StringProtocol

}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension TabContent {

    /// Adds a label to the tab that describes its contents.
    ///
    /// Use this method to provide an accessibility label for a tab that
    /// contains content like an icon. Don't include text in the label that
    /// repeats information that users already have. For example, don't use
    /// the label "Library tab" because a tab already has a trait that
    /// identifies it as a tab.
    ///
    ///     var body: some View {
    ///         TabView {
    ///             Tab {
    ///                 FavoritesView()
    ///             } label: {
    ///                 Image(systemName: "star.fill")
    ///             }
    ///             .accessibilityLabel("Favorites")
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - label: The accessibility label to apply.
    ///   - isEnabled: If true the accessibility label is applied; otherwise
    ///     the accessibility label is unchanged.
    nonisolated public func accessibilityLabel(_ label: Text, isEnabled: Bool = true) -> some TabContent<Self.TabValue>


    /// Adds a label to the tab that describes its contents.
    ///
    /// Use this method to provide an accessibility label for a tab that
    /// contains content like an icon. Don't include text in the label that
    /// repeats information that users already have. For example, don't use
    /// the label "Library tab" because a tab already has a trait that
    /// identifies it as a tab.
    ///
    ///     var body: some View {
    ///         TabView {
    ///             Tab {
    ///                 FavoritesView()
    ///             } label: {
    ///                 Image(systemName: "star.fill")
    ///             }
    ///             .accessibilityLabel("Favorites")
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - labelKey: The accessibility label to apply.
    ///   - isEnabled: If true the accessibility label is applied; otherwise
    ///     the accessibility label is unchanged.
    nonisolated public func accessibilityLabel(_ labelKey: LocalizedStringKey, isEnabled: Bool = true) -> some TabContent<Self.TabValue>


    /// Adds a label to the tab that describes its contents.
    ///
    /// Use this method to provide an accessibility label for a tab that
    /// contains content like an icon. Don't include text in the label that
    /// repeats information that users already have. For example, don't use
    /// the label "Library tab" because a tab already has a trait that
    /// identifies it as a tab.
    ///
    ///     var body: some View {
    ///         TabView {
    ///             Tab {
    ///                 FavoritesView()
    ///             } label: {
    ///                 Image(systemName: "star.fill")
    ///             }
    ///             .accessibilityLabel("Favorites")
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - label: The accessibility label to apply.
    ///   - isEnabled: If true the accessibility label is applied; otherwise
    ///     the accessibility label is unchanged.
    nonisolated public func accessibilityLabel<S>(_ label: S, isEnabled: Bool = true) -> some TabContent<Self.TabValue> where S : StringProtocol

}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension TabContent {

    /// Communicates to the user what happens after selecting the tab.
    ///
    /// Provide a hint in the form of a brief phrase, like "Open shopping cart"
    /// or "Show downloaded attachments".
    ///
    ///     var body: some View {
    ///         TabView {
    ///             Tab {
    ///                 MessagesView()
    ///             } label: {
    ///                 Image(systemName: "play")
    ///             }
    ///             .accessibilityHint("Select videos to download")
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - hint: The accessibility hint to apply.
    ///   - isEnabled: If true the accessibility hint is applied; otherwise the
    ///     accessibility hint is unchanged.
    nonisolated public func accessibilityHint(_ hint: Text, isEnabled: Bool = true) -> some TabContent<Self.TabValue>


    /// Communicates to the user what happens after selecting the tab.
    ///
    /// Provide a hint in the form of a brief phrase, like "Open shopping cart"
    /// or "Show downloaded attachments".
    ///
    ///     var body: some View {
    ///         TabView {
    ///             Tab {
    ///                 MessagesView()
    ///             } label: {
    ///                 Image(systemName: "play")
    ///             }
    ///             .accessibilityHint("Select videos to download")
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - hintKey: The accessibility hint to apply.
    ///   - isEnabled: If true the accessibility hint is applied; otherwise the
    ///     accessibility hint is unchanged.
    nonisolated public func accessibilityHint(_ hintKey: LocalizedStringKey, isEnabled: Bool = true) -> some TabContent<Self.TabValue>


    /// Communicates to the user what happens after selecting the tab.
    ///
    /// Provide a hint in the form of a brief phrase, like "Open shopping cart"
    /// or "Show downloaded attachments".
    ///
    ///     var body: some View {
    ///         TabView {
    ///             Tab {
    ///                 MessagesView()
    ///             } label: {
    ///                 Image(systemName: "play")
    ///             }
    ///             .accessibilityHint("Select videos to download")
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - hint: The accessibility hint to apply.
    ///   - isEnabled: If true the accessibility hint is applied; otherwise the
    ///     accessibility hint is unchanged.
    nonisolated public func accessibilityHint<S>(_ hint: S, isEnabled: Bool = true) -> some TabContent<Self.TabValue> where S : StringProtocol

}

extension TabContent {

    /// Configures the customization behavior of customizable tab view content.
    ///
    /// The ``TabViewStyle/sidebarAdaptable`` style supports customization
    /// of the tab bar and sidebar on iPad. To enable customization, attach
    /// a ``TabViewCustomization`` to the ``TabView`` using
    /// ``View/tabViewCustomization(_:)``.
    ///
    /// This modifier has no effect on other platforms or on a ``TabViewStyle``
    /// that doesn't support customization.
    ///
    /// Use this modifier to specify the customization behavior a person can
    /// perform on items in the specified placement. To enable customization,
    /// all tabs need a customization ID.
    ///
    /// In the following example, the
    /// tabs support all of the different kinds of
    /// customizations in both the sidebar and tab bar.
    ///
    ///     @AppStorage("MyAppTabViewCustomization")
    ///     private var customization: TabViewCustomization
    ///
    ///     TabView {
    ///         Tab("Home", systemImage: "house") {
    ///             HomeView()
    ///         }
    ///         .customizationID("com.myApp.home")
    ///
    ///         Tab("Alerts", systemImage: "bell") {
    ///             AlertsView()
    ///         }
    ///         .customizationID("com.myApp.bell")
    ///
    ///         TabSection("Categories") {
    ///             Tab("Climate", systemImage: "fan") {
    ///                 ClimateView()
    ///             }
    ///             .customizationID("com.myApp.climate")
    ///
    ///             Tab("Lights", systemImage: "lightbulb") {
    ///                 LightsView()
    ///             }
    ///             .customizationID("com.myApp.lights")
    ///         }
    ///         .customizationID("com.myApp.categories")
    ///     }
    ///     .tabViewStyle(.sidebarAdaptable)
    ///     .tabViewCustomization($customization)
    ///
    /// You can create an item that cannot be hidden
    /// or moved by passing a value of
    /// ``TabCustomizationBehavior/disabled`` to this modifier.
    /// Only turn off customization for important tabs that people need
    /// for the app to do common functionality. If you turn off customization
    /// for both the sidebar and tab bar, then a customization ID isn't necessary.
    ///
    ///     @AppStorage("MyAppTabViewCustomization")
    ///     private var customization: TabViewCustomization
    ///
    ///     TabView {
    ///         Tab("Home", systemImage: "house") {
    ///             HomeView()
    ///         }
    ///         .customizationBehavior(.disabled, for: .sidebar, .tabBar)
    ///
    ///         Tab("Alerts", systemImage: "bell") {
    ///             AlertsView()
    ///         }
    ///         .customizationID("com.myApp.bell")
    ///
    ///         TabSection("Categories") {
    ///             Tab("Climate", systemImage: "fan") {
    ///                 ClimateView()
    ///             }
    ///             .customizationID("com.myApp.climate")
    ///
    ///             Tab("Lights", systemImage: "lightbulb") {
    ///                 LightsView()
    ///             }
    ///             .customizationID("com.myApp.lights")
    ///         }
    ///         .customizationID("com.myApp.categories")
    ///     }
    ///     .tabViewStyle(.sidebarAdaptable)
    ///     .tabViewCustomization($customization)
    ///
    /// Pass a value of ``TabCustomizationBehavior/reorderable`` to create an item
    /// that people can move, but can't hide.
    /// In the ``AdaptableTabBarPlacement/sidebar``, people can only reorder
    /// tabs within sections.
    ///
    ///     @AppStorage("MyAppTabViewCustomization")
    ///     private var customization: TabViewCustomization
    ///
    ///     TabView {
    ///         Tab("Home", systemImage: "house") {
    ///             HomeView()
    ///         }
    ///         .customizationID("com.myApp.home")
    ///
    ///         Tab("Alerts", systemImage: "bell") {
    ///             AlertsView()
    ///         }
    ///         .customizationID("com.myApp.bell")
    ///
    ///         TabSection("Categories") {
    ///             Tab("Climate", systemImage: "fan") {
    ///                 ClimateView()
    ///             }
    ///             .customizationID("com.myApp.climate")
    ///
    ///             Tab("Lights", systemImage: "lightbulb") {
    ///                 LightsView()
    ///             }
    ///             .customizationID("com.myApp.lights")
    ///         }
    ///         .customizationID("com.myApp.categories")
    ///         .customizationBehavior(.reorderable, for: .sidebar)
    ///     }
    ///     .tabViewStyle(.sidebarAdaptable)
    ///     .tabViewCustomization($customization)
    ///
    /// You can individually customize each placement's behavior. The following example
    /// would allow reordering of children in the sidebar but prohibit hiding or moving
    /// the tab in the tab bar.
    ///
    ///     @AppStorage("MyAppTabViewCustomization")
    ///     private var customization: TabViewCustomization
    ///
    ///     TabView {
    ///         Tab("Home", systemImage: "house") {
    ///             HomeView()
    ///         }
    ///         .customizationID("com.myApp.home")
    ///
    ///         Tab("Alerts", systemImage: "bell") {
    ///             AlertsView()
    ///         }
    ///         .customizationID("com.myApp.bell")
    ///
    ///         TabSection("Categories") {
    ///             Tab("Climate", systemImage: "fan") {
    ///                 ClimateView()
    ///             }
    ///             .customizationID("com.myApp.climate")
    ///
    ///             Tab("Lights", systemImage: "lightbulb") {
    ///                 LightsView()
    ///             }
    ///             .customizationID("com.myApp.lights")
    ///         }
    ///         .customizationID("com.myApp.categories")
    ///         .customizationBehavior(.reorderable, for: .sidebar)
    ///         .customizationBehavior(.disabled, for: .tabBar)
    ///     }
    ///     .tabViewStyle(.sidebarAdaptable)
    ///     .tabViewCustomization($customization)
    ///
    /// - Parameter behavior: The customization behavior of the customizable
    ///   tab content.
    @available(iOS 18.0, macOS 15.0, visionOS 2.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    nonisolated public func customizationBehavior(_ behavior: TabCustomizationBehavior, for placements: AdaptableTabBarPlacement...) -> some TabContent<Self.TabValue>


    /// Sets the identifier for a tab to persist its state.
    ///
    /// The identifier needs to be stable, including across app version
    /// updates.
    ///
    /// Only the ``TabViewStyle/sidebarAdaptable`` style supports
    /// supports customization. To enable customization, attach
    /// a ``TabViewCustomization`` to the ``TabView`` using
    /// ``View/tabViewCustomization(_:)``.
    ///
    /// All tabs and tab sections that support customization are required to have
    /// a customization ID. You can mark a tab as being non-customizable
    /// by specifying a ``TabCustomizationBehavior/disabled`` behavior
    /// in all adaptable tab bar placements
    /// using ``TabContent/customizationBehavior(_:for:)-2u727``.
    ///
    /// If you apply a customization ID to a ``TabSection``, ensure you specify
    /// customization IDs for all of the tabs within the section, unless the
    /// tab has been marked as having customization turned off.
    ///
    /// The following example adds customization identifiers to all tabs
    /// and tab sections.
    ///
    ///     @AppStorage("MyAppTabViewCustomization")
    ///     private var customization: TabViewCustomization
    ///
    ///     TabView {
    ///         Tab("Home", systemImage: "house") {
    ///             HomeView()
    ///         }
    ///         .customizationID("com.myApp.home")
    ///
    ///         Tab("Alerts", systemImage: "bell") {
    ///             AlertsView()
    ///         }
    ///         .customizationID("com.myApp.bell")
    ///
    ///         TabSection("Categories") {
    ///             Tab("Climate", systemImage: "fan") {
    ///                 ClimateView()
    ///             }
    ///             .customizationID("com.myApp.climate")
    ///
    ///             Tab("Lights", systemImage: "lightbulb") {
    ///                 LightsView()
    ///             }
    ///             .customizationID("com.myApp.lights")
    ///         }
    ///         .customizationID("com.myApp.categories")
    ///     }
    ///     .tabViewStyle(.sidebarAdaptable)
    ///     .tabViewCustomization($customization)
    ///
    /// - Parameter id: The identifier to associate with a tab or section.
    @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
    nonisolated public func customizationID(_ id: String) -> some TabContent<Self.TabValue>

}

/// Adds custom actions to a tab section.
///
/// On iOS, the actions are displayed after the other tabs
/// in the section. On macOS, the actions are displayed
/// when a user hovers over the section.
///
/// Applying this modifier to a single ``Tab`` has no effect.
///
/// The following example adds an 'Add' button to
/// the 'Categories' section.
///
///     TabView {
///         Tab("Home", systemImage: "house") {
///             HomeView()
///         }
///
///         Tab("Alerts", systemImage: "bell") {
///             AlertsView()
///         }
///
///         TabSection("Categories") {
///             Tab("Climate", systemImage: "fan") {
///                 ClimateView()
///             }
///
///             Tab("Lights", systemImage: "lightbulb") {
///                 LightsView()
///             }
///         }
///         .sectionActions {
///             Button("Add Category", systemImage: "plus") { }
///         }
///     }
///     .tabViewStyle(.sidebarAdaptable)
///
@available(iOS 18.0, macOS 15.0, tvOS 18.0, visionOS 2.0, *)
@available(watchOS, unavailable)
extension TabContent {

    nonisolated public func sectionActions<Content>(@ViewBuilder content: () -> Content) -> some TabContent<Self.TabValue> where Content : View

}

extension TabContent {

    /// Defines the destination of a drag and drop operation that handles the
    /// dropped content with a closure that you specify.
    ///
    /// The dropped content can be provided as binary data, file URLs, or file promises.
    ///
    /// The drop destination is the tab content.
    ///
    /// This example adds a profile to a group when the user drops it onto
    /// onto that group.
    ///
    ///     struct Profile: Identifiable {
    ///         let givenName: String
    ///         let familyName: String
    ///         let image = "person.fill"
    ///         let id = UUID().uuidString
    ///     }
    ///
    ///     @State private var profiles = [
    ///         Profile(givenName: "Juan", familyName: "Chavez"),
    ///         Profile(givenName: "Mei", familyName: "Chen"),
    ///         Profile(givenName: "Tom", familyName: "Clark"),
    ///         Profile(givenName: "Gita", familyName: "Kumar")
    ///     ]
    ///
    ///     @State private var favoriteProfiles: [Profile] = []
    ///
    ///     var body: some View {
    ///         TabView {
    ///             Tab("All Profiles", systemImage: "list.bullet") {
    ///                 List(profiles) { profile in
    ///                     Text(profile.givenName)
    ///                         .draggable(profile.id)
    ///                 }
    ///             }
    ///
    ///             Tab("Favorites", systemImage: "star.fill") {
    ///                 ForEach(favoritedProfiles) { profile in
    ///                     Tab(profile.givenName, image: profile.image) {
    ///                         Label(profile.givenName, systemImage: "star.fill")
    ///                     }
    ///                 }
    ///             }
    ///             .dropDestination(for: String.self) { receivedIds in
    ///                  // Add profiles with `receivedIds` to favorites
    ///             }
    ///        }
    ///
    /// - Parameters:
    ///   - payloadType: Type of the models that are dropped.
    ///   - action: A closure that takes the dropped content and responds
    ///     appropriately. The closure takes one argument, which
    ///     is an array of Transferable items
    ///     that represents the data to insert.
    ///
    /// - Returns: A view that calls `action` when elements are dropped onto
    ///   the tab.
    @available(iOS 18.0, macOS 15.0, visionOS 2.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    @MainActor @preconcurrency public func dropDestination<T>(for payloadType: T.Type = T.self, action: @escaping ([T]) -> Void) -> some TabContent<Self.TabValue> where T : Transferable


    /// Sets the spring loading behavior for the tab.
    ///
    /// Spring loading refers to a view being activated during a drag and drop
    /// interaction. On iOS this can occur when pausing briefly on top of a
    /// view with dragged content. On macOS this can occur with similar brief
    /// pauses or on pressure-sensitive systems by "force clicking" during the
    /// drag. This has no effect on tvOS or watchOS.
    ///
    /// This is commonly used with views that have a navigation or presentation
    /// effect, allowing the destination to be revealed without pausing the
    /// drag interaction. For example, a button that reveals a list of folders
    /// that a dragged item can be dropped onto.
    ///
    /// Unlike `disabled(_:)`, this modifier overrides the value set by an
    /// ancestor view rather than being unioned with it. For example, the tab
    /// below would allow spring loading:
    ///
    ///     TabView {
    ///         Tab("Favorites", systemImage: "star") {
    ///             MyFavoritesView()
    ///         }
    ///         .springLoadingBehavior(.enabled)
    ///
    ///         ...
    ///     }
    ///     .springLoadingBehavior(.disabled)
    ///
    /// - Parameter behavior: Whether spring loading is enabled or not. If
    ///   unspecified, the default behavior is `.automatic.`
    @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
    nonisolated public func springLoadingBehavior(_ behavior: SpringLoadingBehavior) -> some TabContent<Self.TabValue>

}

@available(iOS 18.0, macOS 15.0, visionOS 2.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension TabContent {

    /// Generates a badge for a tab from an integer value.
    ///
    /// Use a badge to convey optional, supplementary information about a
    /// view. The number provided will appear as a numerical indicator on the
    /// given tab.
    ///
    /// The following example shows a ``TabView`` with the value of
    /// `alerts.count` displayed as a badge on the alerts tab.
    ///
    ///     TabView {
    ///         Tab("Home", systemImage: "house") {
    ///             HomeView()
    ///         }
    ///         Tab("Alerts", systemImage: "bell") {
    ///             AlertsView()
    ///         }
    ///         .badge(alerts.count)
    ///     }
    ///
    /// - Parameter count: An integer value to display in the badge.
    ///   Set the value to zero to hide the badge.
    nonisolated public func badge(_ count: Int) -> some TabContent<Self.TabValue>


    /// Generates a badge for the tab from a text view.
    ///
    /// Use a badge to convey optional, supplementary information about a
    /// view. Keep the contents of the badge as short as possible. The string
    /// provided will appear as an indicator on the given tab.
    ///
    ///     var body: some View {
    ///         let badgeView = Text("\(recentAlerts.count)")
    ///
    ///         TabView {
    ///             Tab("Home", systemImage: "house"} {
    ///                 HomeView()
    ///             }
    ///             Tab("Alerts", systemImage: "bell") {
    ///                 AlertsView()
    ///             }
    ///             .badge(badgeView)
    ///         }
    ///     }
    ///
    /// - Parameter label: An optional ``Text`` view to display as a badge.
    ///   Set the value to `nil` to hide the badge.
    nonisolated public func badge(_ label: Text?) -> some TabContent<Self.TabValue>


    /// Generates a badge for the tab from a localized string key.
    ///
    /// Use a badge to convey optional, supplementary information about a
    /// view. Keep the contents of the badge as short as possible. The string
    /// provided will appear as an indicator on the given tab.
    ///
    /// This modifier creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. For
    /// more information about localizing strings, see ``Text``. The
    /// following example shows a tab that has a "New Alerts" badge
    /// when there are new alerts.
    ///
    ///     var body: some View {
    ///         TabView {
    ///             Tab("Home", systemImage: "house") {
    ///                 HomeView()
    ///             }
    ///             Tab("Alerts", systemImage: "bell") {
    ///                 AlertsView()
    ///             }
    ///             .badge(alertsManager.hasAlerts ? "New Alerts" : nil)
    ///         }
    ///     }
    ///
    /// - Parameter key: A string key to display as a badge.
    nonisolated public func badge(_ key: LocalizedStringKey) -> some TabContent<Self.TabValue>


    /// Generates a badge for the tab from a string.
    ///
    /// Use a badge to convey optional, supplementary information about a
    /// view. Keep the contents of the badge as short as possible. The string
    /// provided will appear as an indicator on the given tab.
    ///
    /// This modifier creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:)``. The
    /// following example shows tabs that have the server name as their badge.
    ///
    ///     TabView {
    ///         ForEach(servers) { server in
    ///             Tab(server.name, image: server.icon) {
    ///                 ServerDetailView(for: server)
    ///             }
    ///             .badge(server.defaultString())
    ///         }
    ///     }
    ///
    /// - Parameter label: A string to display as a badge.
    nonisolated public func badge<S>(_ label: S) -> some TabContent<Self.TabValue> where S : StringProtocol

}

@available(iOS 18.0, macOS 15.0, visionOS 2.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension TabContent {

    /// Presents a popover when a given condition is true.
    ///
    /// Use this method to show a popover whose contents are a SwiftUI view
    /// that you provide when a bound Boolean variable is `true`. In the
    /// example below, a popover displays whenever the user toggles
    /// the `isShowingPopover` state variable by pressing the
    /// "Show Popover" button:
    ///
    ///     struct PopoverExample: View {
    ///         @State private var isShowingPopover = false
    ///
    ///         var body: some View {
    ///             TabView {
    ///                 Tab("Popover Anchor", systemImage: "arrow.down") {
    ///                     Button("Show Popover") {
    ///                         self.isShowingPopover = true
    ///                     }
    ///                 }
    ///                 .popover(isPresented: $isShowingPopover) {
    ///                     Text("Popover Content")
    ///                         .padding()
    ///                 }
    ///             }
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - isPresented: A binding to a Boolean value that determines whether
    ///     to present the popover content that you return from the modifier's
    ///     `content` closure.
    ///   - attachmentAnchor: The positioning anchor that defines the
    ///     attachment point of the popover. The default is
    ///     ``Anchor/Source/bounds``.
    ///   - arrowEdge: The edge of the `attachmentAnchor` that defines the
    ///     location of the popover's arrow in macOS. The default is ``Edge/top``.
    ///   - content: A closure returning the content of the popover.
    nonisolated public func popover<Content>(isPresented: Binding<Bool>, attachmentAnchor: PopoverAttachmentAnchor = .rect(.bounds), arrowEdge: Edge? = nil, @ViewBuilder content: @escaping () -> Content) -> some TabContent<Self.TabValue> where Content : View


    /// Presents a popover using the given item as a data source for the
    /// popover's content.
    ///
    /// Use this method when you need to present a popover with content
    /// from a custom data source. The example below uses data in
    /// the `PopoverModel` structure to populate the view in the `content`
    /// closure that the popover displays to the user:
    ///
    ///     struct PopoverExample: View {
    ///         @State private var popover: PopoverModel?
    ///
    ///         var body: some View {
    ///             TabView {
    ///                 Tab("Popover Anchor", systemImage: "arrow.down") {
    ///                     Button("Show Popover") {
    ///                         popover = PopoverModel(message: "Custom Message")
    ///                     }
    ///                 }
    ///                 .popover(item: $popover) { detail in
    ///                      Text("\(detail.message)")
    ///                         .padding()
    ///                  }
    ///             }
    ///         }
    ///     }
    ///
    ///     struct PopoverModel: Identifiable {
    ///         var id: String { message }
    ///         let message: String
    ///     }
    ///
    /// - Parameters:
    ///   - item: A binding to an optional source of truth for the popover.
    ///     When `item` is non-`nil`, the system passes the contents to
    ///     the modifier's closure. You use this content to populate the fields
    ///     of a popover that you create that the system displays to the user.
    ///     If `item` changes, the system dismisses the currently presented
    ///     popover and replaces it with a new popover using the same process.
    ///   - attachmentAnchor: The positioning anchor that defines the
    ///     attachment point of the popover. The default is
    ///     ``Anchor/Source/bounds``.
    ///   - arrowEdge: The edge of the `attachmentAnchor` that defines the
    ///     location of the popover's arrow in macOS. The default is ``Edge/top``.
    ///   - content: A closure returning the content of the popover.
    nonisolated public func popover<Item, Content>(item: Binding<Item?>, attachmentAnchor: PopoverAttachmentAnchor = .rect(.bounds), arrowEdge: Edge? = nil, @ViewBuilder content: @escaping (Item) -> Content) -> some TabContent<Self.TabValue> where Item : Identifiable, Content : View

}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension TabContent {

    /// Sets alternate input labels with which users identify a tab.
    ///
    /// Provide labels in descending order of importance. Voice Control
    /// and Full Keyboard Access use the input labels.
    ///
    /// > Note: If you don't specify any input labels, the user can still
    ///   refer to the tab using the accessibility label that you add with the
    ///   `accessibilityLabel()` modifier.
    ///
    ///     var body: some View {
    ///         TabView {
    ///             Tab {
    ///                 MessagesView()
    ///             } label: {
    ///                 Image(systemName: "mail")
    ///             }
    ///             .accessibilityInputLabels(["Messages", "Mail", "Conversations"])
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - inputLabels: The accessibility input labels to apply.
    ///   - isEnabled: If true the accessibility input labels are applied;
    ///     otherwise the accessibility input labels are unchanged.
    nonisolated public func accessibilityInputLabels(_ inputLabels: [Text], isEnabled: Bool = true) -> some TabContent<Self.TabValue>


    /// Sets alternate input labels with which users identify a tab.
    ///
    /// Provide labels in descending order of importance. Voice Control
    /// and Full Keyboard Access use the input labels.
    ///
    /// > Note: If you don't specify any input labels, the user can still
    ///   refer to the tab using the accessibility label that you add with the
    ///   `accessibilityLabel()` modifier.
    ///
    ///     var body: some View {
    ///         TabView {
    ///             Tab {
    ///                 MessagesView()
    ///             } label: {
    ///                 Image(systemName: "mail")
    ///             }
    ///             .accessibilityInputLabels(["Messages", "Mail", "Conversations"])
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - inputLabelKeys: The accessibility input labels to apply.
    ///   - isEnabled: If true the accessibility input labels are applied;
    ///     otherwise the accessibility input labels are unchanged.
    nonisolated public func accessibilityInputLabels(_ inputLabelKeys: [LocalizedStringKey], isEnabled: Bool = true) -> some TabContent<Self.TabValue>


    /// Sets alternate input labels with which users identify a tab.
    ///
    /// Provide labels in descending order of importance. Voice Control
    /// and Full Keyboard Access use the input labels.
    ///
    /// > Note: If you don't specify any input labels, the user can still
    ///   refer to the tab using the accessibility label that you add with the
    ///   `accessibilityLabel()` modifier.
    ///
    ///     var body: some View {
    ///         TabView {
    ///             Tab {
    ///                 MessagesView()
    ///             } label: {
    ///                 Image(systemName: "mail")
    ///             }
    ///             .accessibilityInputLabels(["Messages", "Mail", "Conversations"])
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - inputLabels: The accessibility input labels to apply.
    ///   - isEnabled: If true the accessibility input labels are applied;
    ///     otherwise the accessibility input labels are unchanged.
    nonisolated public func accessibilityInputLabels<S>(_ inputLabels: [S], isEnabled: Bool = true) -> some TabContent<Self.TabValue> where S : StringProtocol

}

@available(iOS 18.0, macOS 15.0, visionOS 2.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension TabContent {

    /// Adds custom swipe actions to a tab in a tab view.
    ///
    /// Use this method to add swipe actions to a view that acts as a row in
    /// the tab sidebar. Indicate the ``HorizontalEdge`` where the swipe action
    /// originates, and define individual actions with ``Button`` instances.
    /// For example, if you have a group of message categories,
    /// you can add an action to toggle a category as unread
    /// on a swipe from the leading edge,
    /// and actions to hide or flag categories on a trailing edge swipe:
    ///
    ///     TabView {
    ///          TabSection("Messages") {
    ///              ForEach(store.messageCategories) { category in
    ///                  Tab(category.title, image: category.image)
    ///                      .swipeActions(edge: .leading) {
    ///                          Button { store.toggleUnread(category) } label: {
    ///                              if category.isUnread {
    ///                                  Label("Read", systemImage: "envelope.open")
    ///                              } else {
    ///                                  Label("Unread", systemImage: "envelope.badge")
    ///                              }
    ///                          }
    ///                      }
    ///                      .swipeActions(edge: .trailing) {
    ///                          Button(role: .destructive) {
    ///                              store.hide(category)
    ///                          } label: {
    ///                              Label("Remove", systemImage: "trash")
    ///                          }
    ///                          Button { store.flag(category) } label: {
    ///                              Label("Flag", systemImage: "flag")
    ///                          }
    ///                      }
    ///                  }
    ///              }
    ///          }
    ///     }
    ///
    /// Actions appear in the order you list them, starting from the swipe's
    /// originating edge. In the example above, the Delete action appears
    /// closest to the screen's trailing edge.
    ///
    /// For labels or images that appear in swipe actions, SwiftUI automatically
    /// applies the ``SymbolVariants/fill-swift.type.property`` symbol variant,
    /// as shown above.
    ///
    /// By default, the user can perform the first action for a given swipe
    /// direction with a full swipe. For the example above, the user can perform
    /// both the toggle unread and delete actions with full swipes.
    /// You can opt out of this behavior for an edge by setting
    /// the `allowsFullSwipe` parameter to `false`. For example, you can
    /// disable the full swipe on the leading edge:
    ///
    ///     .swipeActions(edge: .leading, allowsFullSwipe: false) {
    ///         Button { store.toggleUnread(category) } label: {
    ///             if category.isUnread {
    ///                 Label("Read", systemImage: "envelope.open")
    ///             } else {
    ///                 Label("Unread", systemImage: "envelope.badge")
    ///             }
    ///         }
    ///     }
    ///
    /// When you set a role for a button using one of the values from the
    /// ``ButtonRole`` enumeration, SwiftUI styles the button according to
    /// its role. In the example above, the delete action appears in
    /// ``ShapeStyle/red`` because it has the ``ButtonRole/destructive`` role.
    /// If you want to set a different color  for example, to match the
    /// overall theme of your app's UI  add the ``View/tint(_:)``
    /// modifier to the button:
    ///
    ///     .swipeActions(edge: .leading) {
    ///         Button { store.toggleUnread(category) } label: {
    ///             if category.isUnread {
    ///                 Label("Read", systemImage: "envelope.open")
    ///             } else {
    ///                 Label("Unread", systemImage: "envelope.badge")
    ///             }
    ///         }
    ///         .tint(.blue)
    ///     }
    ///     .swipeActions(edge: .trailing) {
    ///         Button(role: .destructive) { store.hide(category) } label: {
    ///             Label("Hide", systemImage: "trash")
    ///         }
    ///         Button { store.flag(category) } label: {
    ///             Label("Flag", systemImage: "flag")
    ///         }
    ///         .tint(.orange)
    ///     }
    ///
    /// The modifications in the code above make the toggle unread action
    /// ``ShapeStyle/blue`` and the flag action ``ShapeStyle/orange``:
    ///
    /// Actions accumulate for a given edge if you call the modifier multiple
    /// times on the same tab.
    ///
    /// - Parameters:
    ///     - edge: The edge of the view to associate the swipe actions with.
    ///         The default is ``HorizontalEdge/trailing``.
    ///     - allowsFullSwipe: A Boolean value that indicates whether a full swipe
    ///         automatically performs the first action. The default is `true`.
    ///     - content: The content of the swipe actions.
    nonisolated public func swipeActions<T>(edge: HorizontalEdge = .trailing, allowsFullSwipe: Bool = true, @ViewBuilder content: () -> T) -> some TabContent<Self.TabValue> where T : View

}

@available(iOS 18.0, macOS 15.0, visionOS 2.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension TabContent {

    /// Adds a context menu to a tab.
    ///
    /// Use this modifier to add a context menu to a tab's sidebar representation.
    /// Compose the menu by returning controls like ``Button``, ``Toggle``
    /// and ``Picker`` from the `menuItems` closure. You can also use ``Menu``
    /// to define submenus, or ``Section`` to group items.
    ///
    /// The following example adds the ability to pin the tab or share
    /// the tab's books with a friend.
    ///
    ///     Tab("Currently Reading", systemImage: "book") {
    ///         CurrentBooksList()
    ///     }
    ///     .contextMenu {
    ///         Button {
    ///             // Pin this tab.
    ///         } label: {
    ///             Label("Pin", systemImage: "pin")
    ///         }
    ///         Button {
    ///             // Open a share sheet to share
    ///         } label: {
    ///             Label("Share", systemImage: "square.and.arrow.up")
    ///         }
    ///     }
    ///
    /// - Parameter menuItems: A closure that produces the menu's contents. You
    ///   can deactivate the context menu by returning nothing from the closure.
    ///
    /// - Returns: A row that can display a context menu.
    nonisolated public func contextMenu<M>(@ViewBuilder menuItems: () -> M) -> some TabContent<Self.TabValue> where M : View

}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension TabContent {

    /// Uses the string you specify to identify the view.
    /// Use this value for testing. It isn't visible to the user.
    ///
    /// - Parameters:
    ///   - identifier: The accessibility identifier to apply.
    ///   - isEnabled: If true the accessibility identifier is applied;
    ///     otherwise the accessibility identifier is unchanged.
    nonisolated public func accessibilityIdentifier(_ identifier: String, isEnabled: Bool = true) -> some TabContent<Self.TabValue>

}

@available(iOS 18.0, macOS 15.0, visionOS 2.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension TabContent {

    /// Configures the default visibility of a tab in customizable contexts.
    ///
    /// The ``TabViewStyle/sidebarAdaptable`` style supports customization
    /// of the tab bar and sidebar on iPad. To enable customization, attach
    /// a ``TabViewCustomization`` to the ``TabView`` using
    /// ``View/tabViewCustomization(_:)``.
    ///
    /// This modifier has no effect on other platforms or on a ``TabViewStyle``
    /// that doesn't support customization.
    ///
    /// > Note: Tabs in the sidebar represent all of the of tabs in ``TabView``.
    ///   A tab that's hidden from the sidebar is also hidden
    ///   from the top bar.
    ///
    /// The following example shows a `TabView` with three tabs, one of which
    /// is hidden by default in the sidebar.
    ///
    ///     @AppStorage("MyAppTabViewCustomization")
    ///     private var customization: TabViewCustomization
    ///
    ///     TabView(selection: $selection) {
    ///         Tab("Home", systemImage: "house", value: MyTab.home) {
    ///             MyHomeView()
    ///         }
    ///         .customizationID("com.myApp.home")
    ///
    ///         Tab("Reports", systemImage: "chart.bar", value: MyTab.reports) {
    ///             MyReportsView()
    ///         }
    ///         .customizationID("com.myApp.reports")
    ///
    ///         Tab("Browse", systemImage: "list.bullet", value: MyTab.browse) {
    ///             MyBrowseView()
    ///         }
    ///         .customizationID("com.myApp.browse")
    ///         .defaultVisibility(.hidden, for: .sidebar)
    ///     }
    ///     .tabViewStyle(.sidebarAdaptable)
    ///     .tabViewCustomization($customization)
    ///
    /// - Parameters:
    ///   - visibility: The tab's visibility.
    ///   - placements: The locations to apply the visibility.
    nonisolated public func defaultVisibility(_ visibility: Visibility, for placements: AdaptableTabBarPlacement...) -> some TabContent<Self.TabValue>

}

@available(iOS 18.0, macOS 15.0, visionOS 2.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension TabContent {

    /// Hides the tab from the user.
    ///
    /// Unlike removing or adding tabs with `if` statements,
    /// this modifier preserves the associated state of the tab's content view
    /// when the tab is hidden.
    ///
    /// When you hide a tab using this modifier, make sure to update
    /// the TabView's selection appropriately, since that tab could be selected.
    ///
    /// The following example shows a `TabView` with 4 tabs in compact and
    /// 5 tabs in regular. In compact, one of the tabs is a 'Browse' tab that
    /// displays a custom list view. This list view allows navigating to the destinations
    /// that are contained within the 'Library' and 'Playlists' sections in regular.
    /// The navigation path and the selection state are updated when the
    /// number of tabs changes.
    ///
    ///     struct BrowseTabExample: View {
    ///         @Environment(\.horizontalSizeClass) var sizeClass
    ///
    ///         @State var selection: MusicTab = .listenNow
    ///         @State var browseTabPath: [MusicTab] = []
    ///         @State var playlists = [Playlist("All Playlists"), Playlist("Running")]
    ///
    ///         var body: some View {
    ///                 TabView(selection: $selection) {
    ///                     Tab("Listen Now", systemImage: "play.circle", value: .listenNow) {
    ///                         ListenNowView()
    ///                     }
    ///
    ///                     Tab("Radio", systemImage: "dot.radiowaves.left.and.right", value: .radio) {
    ///                         RadioView()
    ///                     }
    ///
    ///                     Tab("Search", systemImage: "magnifyingglass", value: .search) {
    ///                         SearchDetailView()
    ///                     }
    ///
    ///                     Tab("Browse", systemImage: "list.bullet", value: .browse) {
    ///                         LibraryView(path: $browseTabPath)
    ///                     }
    ///                     .hidden(sizeClass != .compact)
    ///
    ///                     TabSection("Library") {
    ///                         Tab("Recently Added", systemImage: "clock", value: MusicTab.library(.recentlyAdded)) {
    ///                             RecentlyAddedView()
    ///                         }
    ///
    ///                         Tab("Artists", systemImage: "music.mic", value: MusicTab.library(.artists)) {
    ///                             ArtistsView()
    ///                         }
    ///                     }
    ///                     .hidden(sizeClass == .compact)
    ///
    ///                     TabSection("Playlists") {
    ///                         ForEach(playlists) { playlist in
    ///                             Tab(playlist.name, image: playlist.imafe, value: MusicTab.playlists(playlist)) {
    ///                                 playlist.detailView()
    ///                             }
    ///                         }
    ///                     }
    ///                     .hidden(sizeClass == .compact)
    ///                 }
    ///                 .tabViewStyle(.sidebarAdaptable)
    ///                 .onChange(of: sizeClass, initial: true) { _, sizeClass in
    ///                     if sizeClass == .compact && selection.showInBrowseTab {
    ///                         browseTabPath = [selection]
    ///                         selection = .browse
    ///                     } else if sizeClass == .regular && selection == .browse {
    ///                         selection = browseTabPath.last ?? .library(.recentlyAdded)
    ///                     }
    ///                 }
    ///             }
    ///         }
    ///     }
    ///
    ///     struct LibraryView: View {
    ///         @Binding var path: [MusicTab]
    ///
    ///         var body: some View {
    ///             NavigationStack(path: $path) {
    ///                 List {
    ///                     ForEach(MusicLibraryTab.allCases, id: \.self) { tab in
    ///                         NavigationLink(tab.rawValue, value: MusicTab.library(tab))
    ///                     }
    ///                     // Code to add playlists here
    ///                 }
    ///                 .navigationDestination(for: MusicTab.self) { tab in
    ///                     tab.detail()
    ///                 }
    ///             }
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - hidden: Whether the tab is hidden.
    nonisolated public func hidden(_ hidden: Bool = true) -> some TabContent<Self.TabValue>

}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension TabContent {

    /// Specifies the placement of a tab.
    ///
    /// The following example shows a ``TabView`` with three tabs where the
    /// second tab is pinned to the trailing edge of the top tab bar on
    /// iPad.
    ///
    ///     TabView {
    ///         Tab("Home", systemImage: "house") {
    ///             MyHomeView()
    ///         }
    ///
    ///         Tab("Downloads", systemImage: "square.and.arrow.down.fill") {
    ///             MyDownloadsView()
    ///         }
    ///         .tabPlacement(.pinned)
    ///
    ///         Tab("Browse", systemImage: "list.bullet") {
    ///             MyBrowseView()
    ///         }
    ///     }
    ///     .tabViewStyle(.sidebarAdaptable)
    ///
    /// - Parameter placement: The location of the tab.
    nonisolated public func tabPlacement(_ placement: TabPlacement) -> some TabContent<Self.TabValue>

}

/// A result builder that constructs tabs for a tab view that supports
/// programmatic selection. This builder requires that all tabs in the
/// tab view have the same selection type.
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
@resultBuilder public struct TabContentBuilder<TabValue> where TabValue : Hashable {

    /// A view representation of the content of a builder-based tab view with
    /// selection.
    public struct Content<C> : View where C : TabContent {

        /// The content and behavior of the view.
        ///
        /// When you implement a custom view, you must implement a computed
        /// `body` property to provide the content for your view. Return a view
        /// that's composed of built-in views that SwiftUI provides, plus other
        /// composite views that you've already defined:
        ///
        ///     struct MyView: View {
        ///         var body: some View {
        ///             Text("Hello, World!")
        ///         }
        ///     }
        ///
        /// For more information about composing views and a view hierarchy,
        /// see <doc:Declaring-a-Custom-View>.
        @MainActor @preconcurrency public var body: some View { get }

        /// The type of view representing the body of this view.
        ///
        /// When you create a custom view, Swift infers this type from your
        /// implementation of the required ``View/body-swift.property`` property.
        @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
        public typealias Body = some View
    }

    public static func buildExpression(_ content: some TabContent<TabValue>) -> some TabContent<TabValue>


    public static func buildBlock(_ content: some TabContent<TabValue>) -> some TabContent<TabValue>


    public static func buildIf(_ content: (some TabContent<TabValue>)?) -> (some TabContent<TabValue>)?


    public static func buildEither<T, F>(first: T) -> _ConditionalContent<T, F> where TabValue == T.TabValue, T : TabContent, F : TabContent, T.TabValue == F.TabValue

    public static func buildEither<T, F>(second: F) -> _ConditionalContent<T, F> where TabValue == T.TabValue, T : TabContent, F : TabContent, T.TabValue == F.TabValue

    public static func buildLimitedAvailability<T>(_ content: T) -> AnyTabContent<T.TabValue> where T : TabContent
}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension TabContentBuilder {

    public static func buildBlock<C0, C1>(_ c0: C0, _ c1: C1) -> some TabContent<TabValue> where TabValue == C0.TabValue, C0 : TabContent, C1 : TabContent, C0.TabValue == C1.TabValue


    public static func buildBlock<C0, C1, C2>(_ c0: C0, _ c1: C1, _ c2: C2) -> some TabContent<TabValue> where TabValue == C0.TabValue, C0 : TabContent, C1 : TabContent, C2 : TabContent, C0.TabValue == C1.TabValue, C1.TabValue == C2.TabValue


    public static func buildBlock<C0, C1, C2, C3>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3) -> some TabContent<TabValue> where TabValue == C0.TabValue, C0 : TabContent, C1 : TabContent, C2 : TabContent, C3 : TabContent, C0.TabValue == C1.TabValue, C1.TabValue == C2.TabValue, C2.TabValue == C3.TabValue


    public static func buildBlock<C0, C1, C2, C3, C4>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4) -> some TabContent<TabValue> where TabValue == C0.TabValue, C0 : TabContent, C1 : TabContent, C2 : TabContent, C3 : TabContent, C4 : TabContent, C0.TabValue == C1.TabValue, C1.TabValue == C2.TabValue, C2.TabValue == C3.TabValue, C3.TabValue == C4.TabValue


    public static func buildBlock<C0, C1, C2, C3, C4, C5>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5) -> some TabContent<TabValue> where TabValue == C0.TabValue, C0 : TabContent, C1 : TabContent, C2 : TabContent, C3 : TabContent, C4 : TabContent, C5 : TabContent, C0.TabValue == C1.TabValue, C1.TabValue == C2.TabValue, C2.TabValue == C3.TabValue, C3.TabValue == C4.TabValue, C4.TabValue == C5.TabValue


    public static func buildBlock<C0, C1, C2, C3, C4, C5, C6>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5, _ c6: C6) -> some TabContent<TabValue> where TabValue == C0.TabValue, C0 : TabContent, C1 : TabContent, C2 : TabContent, C3 : TabContent, C4 : TabContent, C5 : TabContent, C6 : TabContent, C0.TabValue == C1.TabValue, C1.TabValue == C2.TabValue, C2.TabValue == C3.TabValue, C3.TabValue == C4.TabValue, C4.TabValue == C5.TabValue, C5.TabValue == C6.TabValue


    public static func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5, _ c6: C6, _ c7: C7) -> some TabContent<TabValue> where TabValue == C0.TabValue, C0 : TabContent, C1 : TabContent, C2 : TabContent, C3 : TabContent, C4 : TabContent, C5 : TabContent, C6 : TabContent, C7 : TabContent, C0.TabValue == C1.TabValue, C1.TabValue == C2.TabValue, C2.TabValue == C3.TabValue, C3.TabValue == C4.TabValue, C4.TabValue == C5.TabValue, C5.TabValue == C6.TabValue, C6.TabValue == C7.TabValue


    public static func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7, C8>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5, _ c6: C6, _ c7: C7, _ c8: C8) -> some TabContent<TabValue> where TabValue == C0.TabValue, C0 : TabContent, C1 : TabContent, C2 : TabContent, C3 : TabContent, C4 : TabContent, C5 : TabContent, C6 : TabContent, C7 : TabContent, C8 : TabContent, C0.TabValue == C1.TabValue, C1.TabValue == C2.TabValue, C2.TabValue == C3.TabValue, C3.TabValue == C4.TabValue, C4.TabValue == C5.TabValue, C5.TabValue == C6.TabValue, C6.TabValue == C7.TabValue, C7.TabValue == C8.TabValue


    public static func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7, C8, C9>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5, _ c6: C6, _ c7: C7, _ c8: C8, _ c9: C9) -> some TabContent<TabValue> where TabValue == C0.TabValue, C0 : TabContent, C1 : TabContent, C2 : TabContent, C3 : TabContent, C4 : TabContent, C5 : TabContent, C6 : TabContent, C7 : TabContent, C8 : TabContent, C9 : TabContent, C0.TabValue == C1.TabValue, C1.TabValue == C2.TabValue, C2.TabValue == C3.TabValue, C3.TabValue == C4.TabValue, C4.TabValue == C5.TabValue, C5.TabValue == C6.TabValue, C6.TabValue == C7.TabValue, C7.TabValue == C8.TabValue, C8.TabValue == C9.TabValue

}

/// The customization behavior of customizable tab view content.
///
/// Use this type in conjunction with the
/// ``TabContent/customizationBehavior(_:for:)`` modifier.
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct TabCustomizationBehavior : Equatable {

    /// The automatic customization behavior.
    ///
    /// Items with this behavior can be added, removed, or reordered.
    public static var automatic: TabCustomizationBehavior { get }

    /// The reorderable customization behavior.
    ///
    /// Items with this behavior can be moved by the user,
    /// but cannot be removed.
    @available(macOS, unavailable)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public static var reorderable: TabCustomizationBehavior { get }

    /// The customization behavior isn't available.
    ///
    /// Items with this behavior may not be removed. Use this behavior for the most
    /// important items that users need for the app to do common functionality.
    @available(macOS, unavailable)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public static var disabled: TabCustomizationBehavior { get }

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: TabCustomizationBehavior, b: TabCustomizationBehavior) -> Bool
}

/// A place that a tab can appear.
///
/// Not all `TabView` styles support all placements.
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct TabPlacement : Hashable {

    /// The default tab location.
    public static let automatic: TabPlacement

    /// The pinned tab placement location.
    public static let pinned: TabPlacement

    /// The sidebar tab placement location.
    ///
    /// On visionOS in the ``TabViewStyle/sidebarAdaptable`` style, the
    /// ornament tab bar is considered part of the sidebar.
    public static let sidebarOnly: TabPlacement

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: TabPlacement, b: TabPlacement) -> Bool

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

/// A value that defines the purpose of the tab.
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct TabRole : Hashable, Sendable {

    /// The search role.
    ///
    /// Searchable tab views will prefer to have the first tab with this
    /// role implement search. If no tabs are specified as the search
    /// tab, the tab view will apply search to all tabs, resetting search
    /// state as the selected tab changes.
    public static var search: TabRole { get }

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: TabRole, b: TabRole) -> Bool

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

/// A container that you can use to add hierarchy within a tab view.
///
/// Use ``TabSection`` to organize tab content into separate sections. Each section
/// has custom tab content that you provide on a per-instance basis. You can also
/// provide a header for each section.
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct TabSection<Header, Content, Footer, SelectionValue> {
}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension TabSection : TabContent where Header : View, Content : TabContent, Footer : View, SelectionValue == Content.TabValue {

    /// The type used to drive selection for the containing tab view.
    public typealias TabValue = Content.TabValue

    /// The type of content representing the body of this content type.
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias Body = TabSection<Header, Content, Footer, SelectionValue>
}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension TabSection where Content : TabContent, SelectionValue : Hashable {

    /// Creates a section with a header and the provided section content.
    ///
    /// - Parameters:
    ///   - content: The section's content.
    ///   - header: A view to use as the section's header.
    public init(@TabContentBuilder<SelectionValue> content: () -> Content, @ViewBuilder header: () -> Header) where Header : View, Footer == EmptyView

    /// Creates a section with the provided section content.
    /// - Parameters:
    ///   - content: The section's content.
    public init(@TabContentBuilder<SelectionValue> content: () -> Content) where Header == EmptyView, Footer == EmptyView

    /// Creates a section with the provided content.
    /// - Parameters:
    ///   - title: The label for the section's header.
    ///   - content: The section's content.
    public init<S>(_ title: S, @TabContentBuilder<SelectionValue> content: () -> Content) where Header == Text, Footer == EmptyView, S : StringProtocol

    /// Creates a section with the provided content.
    /// - Parameters:
    ///   - titleKey: The localized string key label for the section's header.
    ///   - content: The section's content.
    public init(_ titleKey: LocalizedStringKey, @TabContentBuilder<SelectionValue> content: () -> Content) where Header == Text, Footer == EmptyView

    /// Creates a section with a header and the provided section content.
    ///
    /// This initializer overload allows for non optional tab content to be
    /// passed into `content`, even if the selection value of the tab
    /// view is optional.
    ///
    /// - Parameters:
    ///   - content: The section's content.
    ///   - header: A view to use as the section's header.
    public init<V>(@TabContentBuilder<V?> content: () -> Content, @ViewBuilder header: () -> Header) where Header : View, Footer == EmptyView, SelectionValue == V?, V : Hashable

    /// Creates a section with the provided section content.
    ///
    /// This initializer overload allows for non optional tab content to be
    /// passed into `content`, even if the selection value of the tab
    /// view is optional.
    ///
    /// - Parameters:
    ///   - content: The section's content.
    public init<V>(@TabContentBuilder<V?> content: () -> Content) where Header == EmptyView, Footer == EmptyView, SelectionValue == V?, V : Hashable

    /// Creates a section with the provided content.
    ///
    /// This initializer overload allows for non optional tab content to be
    /// passed into `content`, even if the selection value of the tab
    /// view is optional.
    ///
    /// - Parameters:
    ///   - title: The label for the section's header.
    ///   - image: The image for the section's header.
    ///   - content: The section's content.
    public init<V, S>(_ title: S, @TabContentBuilder<V?> content: () -> Content) where Header == Text, Footer == EmptyView, SelectionValue == V?, V : Hashable, S : StringProtocol

    /// Creates a section with the provided content.
    ///
    /// This initializer overload allows for non optional tab content to be
    /// passed into `content`, even if the selection value of the tab
    /// view is optional.
    ///
    /// - Parameters:
    ///   - titleKey: The localized string key label for the section's header.
    ///   - image: The image for the section's header.
    ///   - content: The section's content.
    public init<V>(_ titleKey: LocalizedStringKey, @TabContentBuilder<V?> content: () -> Content) where Header == Text, Footer == EmptyView, SelectionValue == V?, V : Hashable
}

/// A view that switches between multiple child views using interactive user
/// interface elements.
///
/// To create a user interface with tabs, place ``Tab``s  in a `TabView`. On iOS, you
/// can also use one of the badge modifiers, like ``TabContent/badge(_:)``, to
/// assign a badge to each of the tabs.
///
/// The following example creates a tab view with three tabs, each presenting a
/// custom child view. The first tab has a numeric badge and the third has a
/// string badge.
///
///     TabView {
///         Tab("Received", systemImage: "tray.and.arrow.down.fill") {
///             ReceivedView()
///         }
///         .badge(2)
///
///         Tab("Sent", systemImage: "tray.and.arrow.up.fill") {
///             SentView()
///         }
///
///         Tab("Account", systemImage: "person.crop.circle.fill") {
///             AccountView()
///         }
///         .badge("!")
///     }
///
/// ![A tab bar with three tabs, each with an icon image and a text label.
/// The first and third tabs have badges.](TabView-1)
///
/// To programatically select different tabs, use the
/// ``init(selection:content:)`` initializer. You can assign a selection
/// value to each tab using a `Tab` initializer that takes a value. Each
/// tab should have a unique selection value and all tabs should have the
/// same selection value type. When people select a tab in the tab view,
/// the tab view updates the selection binding to the value of the currently
/// selected tab.
///
/// The following example creates a tab view that supports programatic selection
/// and has 3 tabs.
///
///     TabView(selection: $selection) {
///         Tab("Received", systemImage: "tray.and.arrow.down.fill", value: 0) {
///             ReceivedView()
///         }
///
///         Tab("Sent", systemImage: "tray.and.arrow.up.fill", value: 1) {
///             SentView()
///         }
///
///         Tab("Account", systemImage: "person.crop.circle.fill", value: 2) {
///             AccountView()
///         }
///     }
///
/// You can use the ``TabViewStyle/page`` style to display a tab view with
/// multiple scrolling pages of content.
///
/// The following example uses a `ForEach` to create a scrolling tab view
/// that shows the temperatures of various cities.
///
///     TabView {
///         ForEach(cities) { city in
///             TemperatureView(city)
///         }
///     }
///     .tabViewStyle(.page)
///
/// ### Using tab sections
///
/// The ``TabViewStyle/sidebarAdaptable`` style supports
/// declaring a secondary tab hierarchy by grouping tabs with a ``TabSection``.
///
/// On iPadOS, tab sections appear in both the sidebar and the tab bar. On
/// iOS and the horizontally compact size class on iPadOS, secondary tabs appear
/// in the tab bar. When secondary tabs appear in the tab bar, the section
/// header doesnt appear in the tab bar. Consider limiting the number of tabs
/// on iOS and the iPadOS horizontal compact size class so all tabs fit in the
/// tab bar.
///
/// The following example has 5 tabs, three of which are grouped within a
/// ``TabSection``.
///
///     TabView {
///         Tab("Requests", systemImage: "paperplane") {
///             RequestsView()
///         }
///
///         Tab("Account", systemImage: "person.crop.circle.fill") {
///             AccountView()
///         }
///
///         TabSection("Messages") {
///             Tab("Received", systemImage: "tray.and.arrow.down.fill") {
///                 ReceivedView()
///             }
///
///             Tab("Sent", systemImage: "tray.and.arrow.up.fill") {
///                 SentView()
///             }
///
///             Tab("Drafts", systemImage: "pencil") {
///                 DraftsView()
///             }
///         }
///     }
///     .tabViewStyle(.sidebarAdaptable)
///
/// ### Changing tab structure between horizontal and regular size classes
///
/// The following example shows a `TabView` with 4 tabs in compact and
/// 5 tabs in regular. In compact, one of the tabs is a 'Browse' tab that
/// displays a custom list view. This list view allows navigating to the destinations
/// that are contained within the 'Library' and 'Playlists' sections in the
/// horizontally regular size class. The navigation path and the selection state
/// are updated when the number of tabs changes.
///
///     struct BrowseTabExample: View {
///         @Environment(\.horizontalSizeClass) var sizeClass
///
///         @State var selection: MusicTab = .listenNow
///         @State var browseTabPath: [MusicTab] = []
///         @State var playlists = [Playlist("All Playlists"), Playlist("Running")]
///
///         var body: some View {
///                 TabView(selection: $selection) {
///                     Tab("Listen Now", systemImage: "play.circle", value: .listenNow) {
///                         ListenNowView()
///                     }
///
///                     Tab("Radio", systemImage: "dot.radiowaves.left.and.right", value: .radio) {
///                         RadioView()
///                     }
///
///                     Tab("Search", systemImage: "magnifyingglass", value: .search) {
///                         SearchDetailView()
///                     }
///
///                     Tab("Browse", systemImage: "list.bullet", value: .browse) {
///                         LibraryView(path: $browseTabPath)
///                     }
///                     .hidden(sizeClass != .compact)
///
///                     TabSection("Library") {
///                         Tab("Recently Added", systemImage: "clock", value: MusicTab.library(.recentlyAdded)) {
///                             RecentlyAddedView()
///                         }
///
///                         Tab("Artists", systemImage: "music.mic", value: MusicTab.library(.artists)) {
///                             ArtistsView()
///                         }
///                     }
///                     .hidden(sizeClass == .compact)
///
///                     TabSection("Playlists") {
///                         ForEach(playlists) { playlist in
///                             Tab(playlist.name, image: playlist.imafe, value: MusicTab.playlists(playlist)) {
///                                 playlist.detailView()
///                             }
///                         }
///                     }
///                     .hidden(sizeClass == .compact)
///                 }
///                 .tabViewStyle(.sidebarAdaptable)
///                 .onChange(of: sizeClass, initial: true) { _, sizeClass in
///                     if sizeClass == .compact && selection.showInBrowseTab {
///                         browseTabPath = [selection]
///                         selection = .browse
///                     } else if sizeClass == .regular && selection == .browse {
///                         selection = browseTabPath.last ?? .library(.recentlyAdded)
///                     }
///                 }
///             }
///         }
///     }
///
///     struct LibraryView: View {
///         @Binding var path: [MusicTab]
///
///         var body: some View {
///             NavigationStack(path: $path) {
///                 List {
///                     ForEach(MusicLibraryTab.allCases, id: \.self) { tab in
///                         NavigationLink(tab.rawValue, value: MusicTab.library(tab))
///                     }
///                     // Code to add playlists here
///                 }
///                 .navigationDestination(for: MusicTab.self) { tab in
///                     tab.detail()
///                 }
///             }
///         }
///     }
///
/// ### Adding support for customization
///
/// You can allow people to customize the tabs in a `TabView` by using
/// `sidebarAdaptable` style with the ``View/tabViewCustomization(_:)``
/// modifier. Customization allows people to drag tabs from the sidebar to the
/// tab bar, hide tabs, and rearrange tabs in the sidebar.
///
/// All tabs and tab sections that support customization need to have
/// a customization ID. You can mark a tab as being non-customizable
/// by specifying a ``TabCustomizationBehavior/disabled`` behavior
/// in all adaptable tab bar placements
/// using ``TabContent/customizationBehavior(_:for:)-2u727``.
///
/// On macOS, a default interaction is provided for reordering sections but
/// not for controlling the visibility of individual tabs. A custom
/// experience should be provided if desired by setting the visibility of
/// the tab on the customization.
///
/// You can use `@AppStorage` or `@SceneStorage` to automatically persist
/// any visibility or section order customizations a person makes.
///
/// The following example supports customizing all 4 tabs in the tab view
/// and uses `@AppStorage` to persist the customizations a person makes.
///
///     @AppStorage
///     private var customization: TabViewCustomization
///
///     TabView {
///         Tab("Home", systemImage: "house") {
///             MyHomeView()
///         }
///         .customizationID("com.myApp.home")
///
///         Tab("Reports", systemImage: "chart.bar") {
///             MyReportsView()
///         }
///         .customizationID("com.myApp.reports")
///
///         TabSection("Categories") {
///             Tab("Climate", systemImage: "fan") {
///                 ClimateView()
///             }
///             .customizationID("com.myApp.climate")
///
///             Tab("Lights", systemImage: "lightbulb") {
///                 LightsView()
///             }
///             .customizationID("com.myApp.lights")
///         }
///         .customizationID("com.myApp.browse")
///     }
///     .tabViewStyle(.sidebarAdaptable)
///     .tabViewCustomization($customization)
///
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 7.0, *)
public struct TabView<SelectionValue, Content> : View where SelectionValue : Hashable, Content : View {

    @available(iOS, deprecated: 100000.0, message: "Use TabContentBuilder-based TabView initializers instead")
    @available(macOS, deprecated: 100000.0, message: "Use TabContentBuilder-based TabView initializers instead")
    @available(tvOS, deprecated: 100000.0, message: "Use TabContentBuilder-based TabView initializers instead")
    @available(watchOS, deprecated: 100000.0, message: "Use TabContentBuilder-based TabView initializers instead")
    public init(selection: Binding<SelectionValue>?, @ViewBuilder content: () -> Content)

    /// Creates a tab view that uses a builder to create and specify
    /// selection values for its tabs.
    ///
    /// - Parameters:
    ///     - selection: The selection in the TabView. The value of this
    ///         binding must match the `value` of the tabs in `content`.
    ///     - content: The ``Tab`` content.
    @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
    public init<C>(selection: Binding<SelectionValue>, @TabContentBuilder<SelectionValue> content: () -> C) where Content == TabContentBuilder<SelectionValue>.Content<C>, C : TabContent

    /// The content and behavior of the view.
    ///
    /// When you implement a custom view, you must implement a computed
    /// `body` property to provide the content for your view. Return a view
    /// that's composed of built-in views that SwiftUI provides, plus other
    /// composite views that you've already defined:
    ///
    ///     struct MyView: View {
    ///         var body: some View {
    ///             Text("Hello, World!")
    ///         }
    ///     }
    ///
    /// For more information about composing views and a view hierarchy,
    /// see <doc:Declaring-a-Custom-View>.
    @MainActor @preconcurrency public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    @available(iOS 13.0, tvOS 13.0, watchOS 7.0, macOS 10.15, *)
    public typealias Body = some View
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 7.0, *)
extension TabView where SelectionValue == Int {

    nonisolated public init(@ViewBuilder content: () -> Content)
}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension TabView {

    /// Creates a tab view that uses a builder to create its tabs.
    ///
    /// - Parameters:
    ///     - content: The ``Tab`` content.
    public init<C>(@TabContentBuilder<Never> content: () -> C) where SelectionValue == Never, Content == TabContentBuilder<Never>.Content<C>, C : TabContent
}

/// The customizations a person makes to an adaptable sidebar tab view.
///
/// By default, if a person hasn't made customizations, tabs appear
/// according to the default builder visibilities and sections appear in
/// the order you declare in the tab view's tab builder.
///
/// You can change the default visibility by using the
/// ``TabContent/defaultVisibility(_:for:)`` with a
/// ``AdaptableTabBarPlacement/sidebar`` placement.
///
/// You can change the default section order by changing the order
/// in the builder. If there's an existing persisted customization,
/// reset the order by calling
/// ``TabViewCustomization/resetSectionOrder(for:)``
/// when you change the order.
///
/// All tabs and tab sections that support customization need to have
/// a customization ID. You can mark a tab as being non-customizable
/// by specifying a ``TabCustomizationBehavior/disabled`` behavior
/// in all adaptable tab bar placements
/// using ``TabContent/customizationBehavior(_:for:)-2u727``.
///
/// On macOS, a default interaction is provided for reordering sections but
/// not for controlling the visibility of individual tabs. A custom
/// experience should be provided if desired by setting the visibility of
/// the tab on the customization.
///
/// The following code example uses `@AppStorage` to automatically persist
/// any visibility or section order customizations a person makes.
///
///     @AppStorage
///     private var customization: TabViewCustomization
///
///     TabView {
///         Tab("Home", systemImage: "house") {
///             MyHomeView()
///         }
///         .customizationID("com.myApp.home")
///
///         Tab("Reports", systemImage: "chart.bar") {
///             MyReportsView()
///         }
///         .customizationID("com.myApp.reports")
///
///         TabSection("Categories") {
///             Tab("Climate", systemImage: "fan") {
///                 ClimateView()
///             }
///             .customizationID("com.myApp.climate")
///
///             Tab("Lights", systemImage: "lightbulb") {
///                 LightsView()
///             }
///             .customizationID("com.myApp.lights")
///         }
///         .customizationID("com.myApp.browse")
///     }
///     .tabViewStyle(.sidebarAdaptable)
///     .tabViewCustomization($customization)
///
@available(iOS 18.0, macOS 15.0, visionOS 2.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct TabViewCustomization : Equatable, Sendable, Codable {

    /// Creates an empty tab sidebar customization.
    ///
    /// To set this customization on a tab view, use
    /// the ``View/tabViewCustomization(_:)`` modifier.
    ///
    /// With an empty customization, tabs will be visible according to the default
    /// builder visibilities, and sections will be ordered in the order declared in
    /// the tab view's tab builder.
    ///
    /// You can specify a default visibility for the tab in the tab bar
    /// and sidebar by attaching
    /// ``TabContent/defaultVisibility(_:for:)-17xo7``
    /// to the tab.
    ///
    /// You can change the default section order by changing the order
    /// in the builder. If there's an existing persisted customization,
    /// reset the order by calling
    /// ``TabViewCustomization/resetSectionOrder(for:)``
    /// when you change the order.
    public init()

    /// The visibility of the tab identified by its customization identifier.
    ///
    /// Visibility can be set imperatively by subscripting with the tab's id:
    ///
    ///     customization[sidebarVisibility: "com.myApp.alerts"] = .hidden
    ///
    /// You can change the default visibility by using the
    /// ``TabContent/defaultVisibility(_:for:)`` with a
    /// ``AdaptableTabBarPlacement/sidebar`` placement.
    ///
    ///     Tab("Alerts", systemImage: "bell", value: .alerts) {
    ///         AlertsView()
    ///     }
    ///     .customizationID("com.myApp.alerts")
    ///     .defaultVisibility(.hidden, for: .sidebar)
    ///
    /// If the ID isn't associated with a tab or the tab has not been customized,
    /// a default value of `.automatic` is returned.
    public subscript(sidebarVisibility id: String) -> Visibility

    /// The customization for a section's children, identified by the
    /// section's customization identifier.
    ///
    /// Section order can be read by subscripting with the tab section's id:
    ///
    ///     let order = customization[sectionID: "com.myApp.categories"]
    ///
    /// Identifiers can be associated with a `Tab` or `TabSection` using the
    /// `customizationID(_:)` modifier.
    ///
    ///     TabSection("Categories") {
    ///         Tab("Climate", systemImage: "fan") {
    ///             ClimateView()
    ///         }
    ///         .customizationID("com.myApp.climate")
    ///
    ///         Tab("Lights", systemImage: "lightbulb") {
    ///             LightsView()
    ///         }
    ///         .customizationID("com.myApp.lights")
    ///     }
    ///     .customizationID("com.myApp.categories")
    ///
    /// If the ID isn't associated with a section or the section has not been customized,
    /// a default value of `nil` is returned.
    public subscript(sectionID id: String) -> [String]? { get }

    /// Resets the tab visibilities back to the default, preserving the customized
    /// section orderings.
    public mutating func resetVisibility()

    /// Resets ordering back to the default for the section with `sectionID`,
    /// preserving any customized tab visibilities.
    public mutating func resetSectionOrder(for sectionID: String)

    /// Resets the section orderings back to the default, preserving the customized
    /// tab visibilities.
    public mutating func resetSectionOrder()

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: TabViewCustomization, b: TabViewCustomization) -> Bool

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

/// A specification for the appearance and interaction of a tab view.
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
@MainActor @preconcurrency public protocol TabViewStyle {
}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, visionOS 2.0, *)
@available(watchOS, unavailable)
extension TabViewStyle where Self == SidebarAdaptableTabViewStyle {

    /// A tab bar style that adapts to each platform.
    ///
    /// Tab views using the sidebar adaptable style have an appearance
    /// that varies depending on the platform:
    /// * iPadOS displays a top tab bar that can adapt into a sidebar.
    /// * iOS displays a bottom tab bar.
    /// * macOS and tvOS always show a sidebar.
    /// * visionOS shows an ornament and also shows a sidebar for secondary tabs within a ``TabSection``.
    ///
    /// To apply this style to a tab view, or to a view that contains tab views, use
    /// the ``View/tabViewStyle(_:)`` modifier.
    @MainActor @preconcurrency public static var sidebarAdaptable: SidebarAdaptableTabViewStyle { get }
}

@available(iOS 14.0, tvOS 14.0, watchOS 7.0, *)
@available(macOS, unavailable)
extension TabViewStyle where Self == PageTabViewStyle {

    /// A `TabViewStyle` that displays a paged scrolling `TabView`.
    ///
    /// To apply this style to a tab view, or to a view that contains tab views, use
    /// the ``View/tabViewStyle(_:)`` modifier.
    @MainActor @preconcurrency public static var page: PageTabViewStyle { get }

    /// A `TabViewStyle` that implements a paged scrolling `TabView` with an
    /// index display mode.
    ///
    /// To apply this style to a tab view, or to a view that contains tab views, use
    /// the ``View/tabViewStyle(_:)`` modifier.
    @MainActor @preconcurrency public static func page(indexDisplayMode: PageTabViewStyle.IndexDisplayMode) -> PageTabViewStyle
}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, visionOS 2.0, *)
@available(watchOS, unavailable)
extension TabViewStyle where Self == TabBarOnlyTabViewStyle {

    /// A tab view style that displays a tab bar when possible.
    ///
    /// To apply this style to a tab view, or to a view that contains tab views, use
    /// the ``View/tabViewStyle(_:)`` modifier.
    @MainActor @preconcurrency public static var tabBarOnly: TabBarOnlyTabViewStyle { get }
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension TabViewStyle where Self == DefaultTabViewStyle {

    /// The default tab view style.
    @MainActor @preconcurrency public static var automatic: DefaultTabViewStyle { get }
}

/// A container that presents rows of data arranged in one or more columns,
/// optionally providing the ability to select one or more members.
///
/// You commonly create tables from collections of data. The following example
/// shows how to create a simple, three-column table from an array of `Person`
/// instances that conform to the
/// <doc://com.apple.documentation/documentation/Swift/Identifiable> protocol:
///
///     struct Person: Identifiable {
///         let givenName: String
///         let familyName: String
///         let emailAddress: String
///         let id = UUID()
///
///         var fullName: String { givenName + " " + familyName }
///     }
///
///     @State private var people = [
///         Person(givenName: "Juan", familyName: "Chavez", emailAddress: "juanchavez@icloud.com"),
///         Person(givenName: "Mei", familyName: "Chen", emailAddress: "meichen@icloud.com"),
///         Person(givenName: "Tom", familyName: "Clark", emailAddress: "tomclark@icloud.com"),
///         Person(givenName: "Gita", familyName: "Kumar", emailAddress: "gitakumar@icloud.com")
///     ]
///
///     struct PeopleTable: View {
///         var body: some View {
///             Table(people) {
///                 TableColumn("Given Name", value: \.givenName)
///                 TableColumn("Family Name", value: \.familyName)
///                 TableColumn("E-Mail Address", value: \.emailAddress)
///             }
///         }
///     }
///
/// ![A table with three columns and four rows, showing the
/// given name, family name, and email address of four people. Nonsortable
/// column headers at the top of the table indicate the data each column
/// displays.](Table-1-iOS)
///
/// If there are more rows than can fit in the available space, `Table` provides
/// vertical scrolling automatically. On macOS, the table also provides
/// horizontal scrolling if there are more columns than can fit in the width of the view. Scroll bars
/// appear as needed on iOS; on macOS, the `Table` shows or hides
/// scroll bars based on the "Show scroll bars" system preference.
///
/// ### Supporting selection in tables
///
/// To make rows of a table selectable, provide a binding to a selection
/// variable. Binding to a single instance of the table data's
/// <doc://com.apple.documentation/documentation/Swift/Identifiable/id-8t2ws>
/// type creates a single-selection table. Binding to a
/// <doc://com.apple.documentation/documentation/Swift/Set> creates a table that
/// supports multiple selections. The following example shows how to add
/// multi-select to the previous example. A ``Text`` view below the table shows
/// the number of items currently selected.
///
///     struct SelectableTable: View {
///         @State private var selectedPeople = Set<Person.ID>()
///
///         var body: some View {
///             Table(people, selection: $selectedPeople) {
///                 TableColumn("Given Name", value: \.givenName)
///                 TableColumn("Family Name", value: \.familyName)
///                 TableColumn("E-Mail Address", value: \.emailAddress)
///             }
///             Text("\(selectedPeople.count) people selected")
///         }
///     }
///
/// ### Supporting sorting in tables
///
/// To make the columns of a table sortable, provide a binding to an array
/// of <doc://com.apple.documentation/documentation/Foundation/SortComparator>
/// instances. The table reflects the sorted state through its column
/// headers, allowing sorting for any columns with key paths.
///
/// When the table sort descriptors update, re-sort the data collection
/// that underlies the table; the table itself doesn't perform a sort operation.
/// You can watch for changes in the sort descriptors by using a
/// ``View/onChange(of:perform:)`` modifier, and then sort the data in the
/// modifier's `perform` closure.
///
/// The following example shows how to add sorting capability to the
/// previous example:
///
///     struct SortableTable: View {
///         @State private var sortOrder = [KeyPathComparator(\Person.givenName)]
///
///         var body: some View {
///             Table(people, sortOrder: $sortOrder) {
///                 TableColumn("Given Name", value: \.givenName)
///                 TableColumn("Family Name", value: \.familyName)
///                 TableColumn("E-Mail address", value: \.emailAddress)
///             }
///             .onChange(of: sortOrder) { _, sortOrder in
///                 people.sort(using: sortOrder)
///             }
///         }
///     }
///
/// ### Building tables with static rows
///
/// To create a table from static rows, rather than the contents of a collection
/// of data, you provide both the columns and the rows.
///
/// The following example shows a table that calculates prices from applying
/// varying gratuities ("tips") to a fixed set of prices. It creates the table
/// with the ``Table/init(of:columns:rows:)`` initializer, with the `rows`
/// parameter providing the base price that each row uses for its calculations. Each
/// column receives each price and performs its calculation, producing a
/// ``Text`` to display the formatted result.
///
///     struct Purchase: Identifiable {
///         let price: Decimal
///         let id = UUID()
///     }
///
///     struct TipTable: View {
///         let currencyStyle = Decimal.FormatStyle.Currency(code: "USD")
///
///         var body: some View {
///             Table(of: Purchase.self) {
///                 TableColumn("Base price") { purchase in
///                     Text(purchase.price, format: currencyStyle)
///                 }
///                 TableColumn("With 15% tip") { purchase in
///                     Text(purchase.price * 1.15, format: currencyStyle)
///                 }
///                 TableColumn("With 20% tip") { purchase in
///                     Text(purchase.price * 1.2, format: currencyStyle)
///                 }
///                 TableColumn("With 25% tip") { purchase in
///                     Text(purchase.price * 1.25, format: currencyStyle)
///                 }
///             } rows: {
///                 TableRow(Purchase(price: 20))
///                 TableRow(Purchase(price: 50))
///                 TableRow(Purchase(price: 75))
///             }
///         }
///     }
///
/// ![A table with four columns and three rows. Each row of the
/// table shows a base price  $20, $50, and $75  followed in subsequent
/// columns by a dollar value calculated by applying a tip  15%, 20%, and 25% 
/// to the base amount.](Table-2-macOS)
///
/// ### Styling tables
///
/// Use the ``View/tableStyle(_:)`` modifier to set a ``TableStyle`` for all
/// tables within a view. SwiftUI provides several table styles, such as
/// ``InsetTableStyle`` and, on macOS, ``BorderedTableStyle``. The default
/// style is ``AutomaticTableStyle``, which is available on all platforms
/// that support `Table`.
///
/// ### Using tables on different platforms
///
/// You can define a single table for use on macOS, iOS, and iPadOS.
/// However, on iPhone or in a compact horizontal size class environment
/// --- typical on on iPad in certain modes, like Slide Over --- the table has
/// limited space to display its columns. To conserve space, the table
/// automatically hides headers and all columns after the first when it detects
/// this condition.
///
/// To provide a good user experience in a space-constrained environment, you
/// can customize the first column to show more information when you detect that
/// the ``EnvironmentValues/horizontalSizeClass`` environment value becomes
/// ``UserInterfaceSizeClass/compact``. For example, you can modify the sortable
/// table from above to conditionally show all the information in
/// the first column:
///
///     struct CompactableTable: View {
///         #if os(iOS)
///         @Environment(\.horizontalSizeClass) private var horizontalSizeClass
///         private var isCompact: Bool { horizontalSizeClass == .compact }
///         #else
///         private let isCompact = false
///         #endif
///
///         @State private var sortOrder = [KeyPathComparator(\Person.givenName)]
///
///         var body: some View {
///             Table(people, sortOrder: $sortOrder) {
///                 TableColumn("Given Name", value: \.givenName) { person in
///                     VStack(alignment: .leading) {
///                         Text(isCompact ? person.fullName : person.givenName)
///                         if isCompact {
///                             Text(person.emailAddress)
///                                 .foregroundStyle(.secondary)
///                         }
///                     }
///                 }
///                 TableColumn("Family Name", value: \.familyName)
///                 TableColumn("E-Mail Address", value: \.emailAddress)
///             }
///             .onChange(of: sortOrder) { _, sortOrder in
///                 people.sort(using: sortOrder)
///             }
///         }
///     }
///
/// By making this change, you provide a list-like appearance for narrower
/// displays, while displaying the full table on wider ones.
/// Because you use the same table instance in both cases, you get a seamless
/// transition when the size class changes, like when someone moves your app
/// into or out of Slide Over.
@available(iOS 16.0, macOS 12.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct Table<Value, Rows, Columns> : View where Value == Rows.TableRowValue, Rows : TableRowContent, Columns : TableColumnContent, Rows.TableRowValue == Columns.TableRowValue {

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    @available(iOS 16.0, macOS 12.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias Body = Never
}

@available(iOS 16.0, macOS 12.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension Table {

    /// Creates a table with the given columns and rows that generates its contents using values of the
    /// given type.
    ///
    /// - Parameters:
    ///   - valueType: The type of value used to derive the table's contents.
    ///   - columns: The columns to display in the table.
    ///   - rows: The rows to display in the table.
    nonisolated public init(of valueType: Value.Type, @TableColumnBuilder<Value, Never> columns: () -> Columns, @TableRowBuilder<Value> rows: () -> Rows)

    /// Creates a table with the given columns and rows that supports selecting
    /// zero or one row that generates its data using values of the given type.
    ///
    /// - Parameters:
    ///   - valueType: The type of value used to derive the table's contents.
    ///   - selection: A binding to the optional selected row ID.
    ///   - columns: The columns to display in the table.
    ///   - rows: The rows to display in the table.
    nonisolated public init(of valueType: Value.Type, selection: Binding<Value.ID?>, @TableColumnBuilder<Value, Never> columns: () -> Columns, @TableRowBuilder<Value> rows: () -> Rows)

    /// Creates a table with the given columns and rows that supports selecting
    /// multiple rows that generates its data using values of the given type.
    ///
    /// - Parameters:
    ///   - valueType: The type of value used to derive the table's contents.
    ///   - selection: A binding to a set that identifies the selected rows IDs.
    ///   - columns: The columns to display in the table.
    ///   - rows: The rows to display in the table.
    nonisolated public init(of valueType: Value.Type, selection: Binding<Set<Value.ID>>, @TableColumnBuilder<Value, Never> columns: () -> Columns, @TableRowBuilder<Value> rows: () -> Rows)

    /// Creates a sortable table with the given columns and rows.
    ///
    /// - Parameters:
    ///   - sortOrder: A binding to the ordered sorting of columns.
    ///   - columns: The columns to display in the table.
    ///   - rows: The rows to display in the table.
    nonisolated public init<Sort>(sortOrder: Binding<[Sort]>, @TableColumnBuilder<Value, Sort> columns: () -> Columns, @TableRowBuilder<Value> rows: () -> Rows) where Sort : SortComparator, Columns.TableRowValue == Sort.Compared

    /// Creates a sortable table with the given columns and rows.
    ///
    /// - Parameters:
    ///   - valueType: The type of value used to derive the table's contents.
    ///   - sortOrder: A binding to the ordered sorting of columns.
    ///   - columns: The columns to display in the table.
    ///   - rows: The rows to display in the table.
    nonisolated public init<Sort>(of valueType: Value.Type, sortOrder: Binding<[Sort]>, @TableColumnBuilder<Value, Sort> columns: () -> Columns, @TableRowBuilder<Value> rows: () -> Rows) where Sort : SortComparator, Columns.TableRowValue == Sort.Compared

    /// Creates a sortable table with the given columns and rows that supports
    /// selecting zero or one row.
    ///
    /// - Parameters:
    ///   - selection: A binding to the optional selected row ID.
    ///   - sortOrder: A binding to the ordered sorting of columns.
    ///   - columns: The columns to display in the table.
    ///   - rows: The rows to display in the table.
    nonisolated public init<Sort>(selection: Binding<Value.ID?>, sortOrder: Binding<[Sort]>, @TableColumnBuilder<Value, Sort> columns: () -> Columns, @TableRowBuilder<Value> rows: () -> Rows) where Sort : SortComparator, Columns.TableRowValue == Sort.Compared

    /// Creates a sortable table with the given columns and rows that supports
    /// selecting zero or one row.
    ///
    /// - Parameters:
    ///   - valueType: The type of value used to derive the table's contents.
    ///   - selection: A binding to the optional selected row ID.
    ///   - sortOrder: A binding to the ordered sorting of columns.
    ///   - columns: The columns to display in the table.
    ///   - rows: The rows to display in the table.
    nonisolated public init<Sort>(of valueType: Value.Type, selection: Binding<Value.ID?>, sortOrder: Binding<[Sort]>, @TableColumnBuilder<Value, Sort> columns: () -> Columns, @TableRowBuilder<Value> rows: () -> Rows) where Sort : SortComparator, Columns.TableRowValue == Sort.Compared

    /// Creates a sortable table with the given columns and rows that supports
    /// selecting multiple rows.
    ///
    /// - Parameters:
    ///   - selection: A binding to a set that identifies selected rows ids.
    ///   - sortOrder: A binding to the ordered sorting of columns.
    ///   - columns: The columns to display in the table.
    ///   - rows: The rows to display in the table.
    nonisolated public init<Sort>(selection: Binding<Set<Value.ID>>, sortOrder: Binding<[Sort]>, @TableColumnBuilder<Value, Sort> columns: () -> Columns, @TableRowBuilder<Value> rows: () -> Rows) where Sort : SortComparator, Columns.TableRowValue == Sort.Compared

    /// Creates a sortable table with the given columns and rows that supports
    /// selecting multiple rows.
    ///
    /// - Parameters:
    ///   - valueType: The type of value used to derive the table's contents.
    ///   - selection: A binding to a set that identifies selected rows ids.
    ///   - sortOrder: A binding to the ordered sorting of columns.
    ///   - columns: The columns to display in the table.
    ///   - rows: The rows to display in the table.
    nonisolated public init<Sort>(of valueType: Value.Type, selection: Binding<Set<Value.ID>>, sortOrder: Binding<[Sort]>, @TableColumnBuilder<Value, Sort> columns: () -> Columns, @TableRowBuilder<Value> rows: () -> Rows) where Sort : SortComparator, Columns.TableRowValue == Sort.Compared
}

@available(iOS 16.0, macOS 12.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension Table {

    /// Creates a table that computes its rows based on a collection of
    /// identifiable data.
    ///
    /// - Parameters:
    ///   - data: The identifiable data for computing the table rows.
    ///   - columns: The columns to display in the table.
    nonisolated public init<Data>(_ data: Data, @TableColumnBuilder<Value, Never> columns: () -> Columns) where Rows == TableForEachContent<Data>, Data : RandomAccessCollection, Columns.TableRowValue == Data.Element

    /// Creates a table that computes its rows based on a collection of
    /// identifiable data, and that supports selecting zero or one row.
    ///
    /// - Parameters:
    ///   - data: The identifiable data for computing the table rows.
    ///   - selection: A binding to the optional selected row ID.
    ///   - columns: The columns to display in the table.
    nonisolated public init<Data>(_ data: Data, selection: Binding<Value.ID?>, @TableColumnBuilder<Value, Never> columns: () -> Columns) where Rows == TableForEachContent<Data>, Data : RandomAccessCollection, Columns.TableRowValue == Data.Element

    /// Creates a table that computes its rows based on a collection of
    /// identifiable data, and that supports selecting multiple rows.
    ///
    /// - Parameters:
    ///   - data: The identifiable data for computing the table rows.
    ///   - selection: A binding to a set that identifies selected rows IDs.
    ///   - columns: The columns to display in the table.
    nonisolated public init<Data>(_ data: Data, selection: Binding<Set<Value.ID>>, @TableColumnBuilder<Value, Never> columns: () -> Columns) where Rows == TableForEachContent<Data>, Data : RandomAccessCollection, Columns.TableRowValue == Data.Element

    /// Creates a sortable table that computes its rows based on a collection of
    /// identifiable data.
    ///
    /// - Parameters:
    ///   - data: The identifiable data for computing the table rows.
    ///   - sortOrder: A binding to the ordered sorting of columns.
    ///   - columns: The columns to display in the table.
    nonisolated public init<Data, Sort>(_ data: Data, sortOrder: Binding<[Sort]>, @TableColumnBuilder<Value, Sort> columns: () -> Columns) where Rows == TableForEachContent<Data>, Data : RandomAccessCollection, Sort : SortComparator, Columns.TableRowValue == Data.Element, Data.Element == Sort.Compared

    /// Creates a sortable table that computes its rows based on a collection of
    /// identifiable data, and supports selecting zero or one row.
    ///
    /// - Parameters:
    ///   - data: The identifiable data for computing the table rows.
    ///   - selection: A binding to the optional selected row ID.
    ///   - sortOrder: A binding to the ordered sorting of columns.
    ///   - columns: The columns to display in the table.
    nonisolated public init<Data, Sort>(_ data: Data, selection: Binding<Value.ID?>, sortOrder: Binding<[Sort]>, @TableColumnBuilder<Value, Sort> columns: () -> Columns) where Rows == TableForEachContent<Data>, Data : RandomAccessCollection, Sort : SortComparator, Columns.TableRowValue == Data.Element, Data.Element == Sort.Compared

    /// Creates a sortable table that computes its rows based on a collection of
    /// identifiable data, and supports selecting multiple rows.
    ///
    /// - Parameters:
    ///   - data: The identifiable data for computing the table rows.
    ///   - selection: A binding to a set that identifies selected rows IDs.
    ///   - sortOrder: A binding to the ordered sorting of columns.
    ///   - columns: The columns to display in the table.
    nonisolated public init<Data, Sort>(_ data: Data, selection: Binding<Set<Value.ID>>, sortOrder: Binding<[Sort]>, @TableColumnBuilder<Value, Sort> columns: () -> Columns) where Rows == TableForEachContent<Data>, Data : RandomAccessCollection, Sort : SortComparator, Columns.TableRowValue == Data.Element, Data.Element == Sort.Compared
}

@available(iOS 17.0, macOS 14.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension Table {

    /// Creates a table with the given columns and rows that generates its
    /// contents using values of the given type and has dynamically customizable
    /// columns.
    ///
    /// Each column in the table that should participate in customization is
    /// required to have an identifier, specified with
    /// ``TableColumnContent/customizationID(_:)``.
    ///
    /// - Parameters:
    ///   - valueType: The type of value used to derive the table's contents.
    ///   - columnCustomization: A binding to the state of columns.
    ///   - columns: The columns to display in the table.
    ///   - rows: The rows to display in the table.
    nonisolated public init(of valueType: Value.Type, columnCustomization: Binding<TableColumnCustomization<Value>>, @TableColumnBuilder<Value, Never> columns: () -> Columns, @TableRowBuilder<Value> rows: () -> Rows)

    /// Creates a table with the given columns and rows that supports selecting
    /// zero or one row that generates its data using values of the given type
    /// and has dynamically customizable columns.
    ///
    /// Each column in the table that should participate in customization is
    /// required to have an identifier, specified with
    /// ``TableColumnContent/customizationID(_:)``.
    ///
    /// - Parameters:
    ///   - valueType: The type of value used to derive the table's contents.
    ///   - selection: A binding to the optional selected row ID.
    ///   - columnCustomization: A binding to the state of columns.
    ///   - columns: The columns to display in the table.
    ///   - rows: The rows to display in the table.
    nonisolated public init(of valueType: Value.Type, selection: Binding<Value.ID?>, columnCustomization: Binding<TableColumnCustomization<Value>>, @TableColumnBuilder<Value, Never> columns: () -> Columns, @TableRowBuilder<Value> rows: () -> Rows)

    /// Creates a table with the given columns and rows that supports selecting
    /// multiple rows that generates its data using values of the given type
    /// and has dynamically customizable columns.
    ///
    /// Each column in the table that should participate in customization is
    /// required to have an identifier, specified with
    /// ``TableColumnContent/customizationID(_:)``.
    ///
    /// - Parameters:
    ///   - valueType: The type of value used to derive the table's contents.
    ///   - selection: A binding to a set that identifies the selected rows IDs.
    ///   - columnCustomization: A binding to the state of columns.
    ///   - columns: The columns to display in the table.
    ///   - rows: The rows to display in the table.
    nonisolated public init(of valueType: Value.Type, selection: Binding<Set<Value.ID>>, columnCustomization: Binding<TableColumnCustomization<Value>>, @TableColumnBuilder<Value, Never> columns: () -> Columns, @TableRowBuilder<Value> rows: () -> Rows)

    /// Creates a sortable table with the given columns and rows and has
    /// dynamically customizable columns.
    ///
    /// Each column in the table that should participate in customization is
    /// required to have an identifier, specified with
    /// ``TableColumnContent/customizationID(_:)``.
    ///
    /// - Parameters:
    ///   - valueType: The type of value used to derive the table's contents.
    ///   - sortOrder: A binding to the ordered sorting of columns.
    ///   - columnCustomization: A binding to the state of columns.
    ///   - columns: The columns to display in the table.
    ///   - rows: The rows to display in the table.
    nonisolated public init<Sort>(of valueType: Value.Type = Value.self, sortOrder: Binding<[Sort]>, columnCustomization: Binding<TableColumnCustomization<Value>>, @TableColumnBuilder<Value, Sort> columns: () -> Columns, @TableRowBuilder<Value> rows: () -> Rows) where Sort : SortComparator, Columns.TableRowValue == Sort.Compared

    /// Creates a sortable table with the given columns and rows that supports
    /// selecting zero or one row and has dynamically customizable columns.
    ///
    /// Each column in the table that should participate in customization is
    /// required to have an identifier, specified with
    /// ``TableColumnContent/customizationID(_:)``.
    ///
    /// - Parameters:
    ///   - valueType: The type of value used to derive the table's contents.
    ///   - selection: A binding to the optional selected row ID.
    ///   - sortOrder: A binding to the ordered sorting of columns.
    ///   - columnCustomization: A binding to the state of columns.
    ///   - columns: The columns to display in the table.
    ///   - rows: The rows to display in the table.
    nonisolated public init<Sort>(of valueType: Value.Type = Value.self, selection: Binding<Value.ID?>, sortOrder: Binding<[Sort]>, columnCustomization: Binding<TableColumnCustomization<Value>>, @TableColumnBuilder<Value, Sort> columns: () -> Columns, @TableRowBuilder<Value> rows: () -> Rows) where Sort : SortComparator, Columns.TableRowValue == Sort.Compared

    /// Creates a sortable table with the given columns and rows that supports
    /// selecting multiple rows and dynamically customizable columns.
    ///
    /// Each column in the table that should participate in customization is
    /// required to have an identifier, specified with
    /// ``TableColumnContent/customizationID(_:)``.
    ///
    /// - Parameters:
    ///   - valueType: The type of value used to derive the table's contents.
    ///   - selection: A binding to a set that identifies selected rows ids.
    ///   - sortOrder: A binding to the ordered sorting of columns.
    ///   - columnCustomization: A binding to the state of columns.
    ///   - columns: The columns to display in the table.
    ///   - rows: The rows to display in the table.
    nonisolated public init<Sort>(of valueType: Value.Type = Value.self, selection: Binding<Set<Value.ID>>, sortOrder: Binding<[Sort]>, columnCustomization: Binding<TableColumnCustomization<Value>>, @TableColumnBuilder<Value, Sort> columns: () -> Columns, @TableRowBuilder<Value> rows: () -> Rows) where Sort : SortComparator, Columns.TableRowValue == Sort.Compared

    /// Creates a table that computes its rows based on a collection of
    /// identifiable data and has dynamically customizable columns.
    ///
    /// Each column in the table that should participate in customization is
    /// required to have an identifier, specified with
    /// ``TableColumnContent/customizationID(_:)``.
    ///
    /// - Parameters:
    ///   - data: The identifiable data for computing the table rows.
    ///   - columnCustomization: A binding to the state of columns.
    ///   - columns: The columns to display in the table.
    nonisolated public init<Data>(_ data: Data, columnCustomization: Binding<TableColumnCustomization<Value>>, @TableColumnBuilder<Value, Never> columns: () -> Columns) where Rows == TableForEachContent<Data>, Data : RandomAccessCollection, Columns.TableRowValue == Data.Element

    /// Creates a table that computes its rows based on a collection of
    /// identifiable data, that supports selecting zero or one row, and that has
    /// dynamically customizable columns.
    ///
    /// Each column in the table that should participate in customization is
    /// required to have an identifier, specified with
    /// ``TableColumnContent/customizationID(_:)``.
    ///
    /// - Parameters:
    ///   - data: The identifiable data for computing the table rows.
    ///   - selection: A binding to the optional selected row ID.
    ///   - columnCustomization: A binding to the state of columns.
    ///   - columns: The columns to display in the table.
    nonisolated public init<Data>(_ data: Data, selection: Binding<Value.ID?>, columnCustomization: Binding<TableColumnCustomization<Value>>, @TableColumnBuilder<Value, Never> columns: () -> Columns) where Rows == TableForEachContent<Data>, Data : RandomAccessCollection, Columns.TableRowValue == Data.Element

    /// Creates a table that computes its rows based on a collection of
    /// identifiable data, that supports selecting multiple rows, and that has
    /// dynamically customizable columns.
    ///
    /// Each column in the table that should participate in customization is
    /// required to have an identifier, specified with
    /// ``TableColumnContent/customizationID(_:)``.
    ///
    /// - Parameters:
    ///   - data: The identifiable data for computing the table rows.
    ///   - selection: A binding to a set that identifies selected rows IDs.
    ///   - columnCustomization: A binding to the state of columns.
    ///   - columns: The columns to display in the table.
    nonisolated public init<Data>(_ data: Data, selection: Binding<Set<Value.ID>>, columnCustomization: Binding<TableColumnCustomization<Value>>, @TableColumnBuilder<Value, Never> columns: () -> Columns) where Rows == TableForEachContent<Data>, Data : RandomAccessCollection, Columns.TableRowValue == Data.Element

    /// Creates a sortable table that computes its rows based on a collection of
    /// identifiable data and has dynamically customizable columns.
    ///
    /// Each column in the table that should participate in customization is
    /// required to have an identifier, specified with
    /// ``TableColumnContent/customizationID(_:)``.
    ///
    /// - Parameters:
    ///   - data: The identifiable data for computing the table rows.
    ///   - sortOrder: A binding to the ordered sorting of columns.
    ///   - columnCustomization: A binding to the state of columns.
    ///   - columns: The columns to display in the table.
    nonisolated public init<Data, Sort>(_ data: Data, sortOrder: Binding<[Sort]>, columnCustomization: Binding<TableColumnCustomization<Value>>, @TableColumnBuilder<Value, Sort> columns: () -> Columns) where Rows == TableForEachContent<Data>, Data : RandomAccessCollection, Sort : SortComparator, Columns.TableRowValue == Data.Element, Data.Element == Sort.Compared

    /// Creates a sortable table that computes its rows based on a collection of
    /// identifiable data, supports selecting zero or one row, and has
    /// dynamically customizable columns.
    ///
    /// Each column in the table that should participate in customization is
    /// required to have an identifier, specified with
    /// ``TableColumnContent/customizationID(_:)``.
    ///
    /// - Parameters:
    ///   - data: The identifiable data for computing the table rows.
    ///   - selection: A binding to the optional selected row ID.
    ///   - sortOrder: A binding to the ordered sorting of columns.
    ///   - columnCustomization: A binding to the state of columns.
    ///   - columns: The columns to display in the table.
    nonisolated public init<Data, Sort>(_ data: Data, selection: Binding<Value.ID?>, sortOrder: Binding<[Sort]>, columnCustomization: Binding<TableColumnCustomization<Value>>, @TableColumnBuilder<Value, Sort> columns: () -> Columns) where Rows == TableForEachContent<Data>, Data : RandomAccessCollection, Sort : SortComparator, Columns.TableRowValue == Data.Element, Data.Element == Sort.Compared

    /// Creates a sortable table that computes its rows based on a collection of
    /// identifiable data, supports selecting multiple rows, and has dynamically
    /// customizable columns.
    ///
    /// Each column in the table that should participate in customization is
    /// required to have an identifier, specified with
    /// ``TableColumnContent/customizationID(_:)``.
    ///
    /// - Parameters:
    ///   - data: The identifiable data for computing the table rows.
    ///   - selection: A binding to a set that identifies selected rows IDs.
    ///   - sortOrder: A binding to the ordered sorting of columns.
    ///   - columnCustomization: A binding to the state of columns.
    ///   - columns: The columns to display in the table.
    nonisolated public init<Data, Sort>(_ data: Data, selection: Binding<Set<Value.ID>>, sortOrder: Binding<[Sort]>, columnCustomization: Binding<TableColumnCustomization<Value>>, @TableColumnBuilder<Value, Sort> columns: () -> Columns) where Rows == TableForEachContent<Data>, Data : RandomAccessCollection, Sort : SortComparator, Columns.TableRowValue == Data.Element, Data.Element == Sort.Compared
}

@available(iOS 17.0, macOS 14.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension Table {

    /// Creates a hierarchical table that computes its rows based on a
    /// collection of identifiable data and key path to the children of that
    /// data.
    ///
    /// Each column in the table that should participate in customization is
    /// required to have an identifier, specified with
    /// ``TableColumnContent/customizationID(_:)``.
    ///
    /// - Parameters:
    ///   - data: The identifiable data for computing the table rows.
    ///   - children: A key path to a property whose non-`nil` value gives the
    ///     children of `data`, and whose `nil` value represents a leaf row of
    ///     the hierarchy, which is not capable of having children.
    ///   - columnCustomization: A binding to the state of columns.
    ///   - columns: The columns to display in the table.
    nonisolated public init<Data>(_ data: Data, children: KeyPath<Value, Data?>, columnCustomization: Binding<TableColumnCustomization<Value>>? = nil, @TableColumnBuilder<Value, Never> columns: () -> Columns) where Rows == TableOutlineGroupContent<Data>, Data : RandomAccessCollection, Columns.TableRowValue == Data.Element

    /// Creates a hierarchical table that computes its rows based on a
    /// collection of identifiable data and key path to the children of that
    /// data, and supports selecting zero or one row.
    ///
    /// Each column in the table that should participate in customization is
    /// required to have an identifier, specified with
    /// ``TableColumnContent/customizationID(_:)``.
    ///
    /// - Parameters:
    ///   - data: The identifiable data for computing the table rows.
    ///   - children: A key path to a property whose non-`nil` value gives the
    ///     children of `data`, and whose `nil` value represents a leaf row of
    ///     the hierarchy, which is not capable of having children.
    ///   - selection: A binding to the optional selected row ID.
    ///   - columnCustomization: A binding to the state of columns.
    ///   - columns: The columns to display in the table.
    nonisolated public init<Data>(_ data: Data, children: KeyPath<Data.Element, Data?>, selection: Binding<Value.ID?>, columnCustomization: Binding<TableColumnCustomization<Value>>? = nil, @TableColumnBuilder<Value, Never> columns: () -> Columns) where Rows == TableOutlineGroupContent<Data>, Data : RandomAccessCollection, Columns.TableRowValue == Data.Element

    /// Creates a hierarchical table that computes its rows based on a
    /// collection of identifiable data and key path to the children of that
    /// data, and supports selecting multiple rows.
    ///
    /// Each column in the table that should participate in customization is
    /// required to have an identifier, specified with
    /// ``TableColumnContent/customizationID(_:)``.
    ///
    /// - Parameters:
    ///   - data: The identifiable data for computing the table rows.
    ///   - children: A key path to a property whose non-`nil` value gives the
    ///     children of `data`, and whose `nil` value represents a leaf row of
    ///     the hierarchy, which is not capable of having children.
    ///   - selection: A binding to a set that identifies selected rows IDs.
    ///   - columnCustomization: A binding to the state of columns.
    ///   - columns: The columns to display in the table.
    nonisolated public init<Data>(_ data: Data, children: KeyPath<Data.Element, Data?>, selection: Binding<Set<Value.ID>>, columnCustomization: Binding<TableColumnCustomization<Value>>? = nil, @TableColumnBuilder<Value, Never> columns: () -> Columns) where Rows == TableOutlineGroupContent<Data>, Data : RandomAccessCollection, Columns.TableRowValue == Data.Element

    /// Creates a sortable, hierarchical table that computes its rows based on a
    /// collection of identifiable data and key path to the children of that
    /// data.
    ///
    /// Each column in the table that should participate in customization is
    /// required to have an identifier, specified with
    /// ``TableColumnContent/customizationID(_:)``.
    ///
    /// - Parameters:
    ///   - data: The identifiable data for computing the table rows.
    ///   - children: A key path to a property whose non-`nil` value gives the
    ///     children of `data`, and whose `nil` value represents a leaf row of
    ///     the hierarchy, which is not capable of having children.
    ///   - sortOrder: A binding to the ordered sorting of columns.
    ///   - columnCustomization: A binding to the state of columns.
    ///   - columns: The columns to display in the table.
    nonisolated public init<Data, Sort>(_ data: Data, children: KeyPath<Data.Element, Data?>, sortOrder: Binding<[Sort]>, columnCustomization: Binding<TableColumnCustomization<Value>>? = nil, @TableColumnBuilder<Value, Sort> columns: () -> Columns) where Rows == TableOutlineGroupContent<Data>, Data : RandomAccessCollection, Sort : SortComparator, Columns.TableRowValue == Data.Element, Data.Element == Sort.Compared

    /// Creates a sortable, hierarchical table that computes its rows based on a
    /// collection of identifiable data and key path to the children of that
    /// data, and supports selecting zero or one row.
    ///
    /// Each column in the table that should participate in customization is
    /// required to have an identifier, specified with
    /// ``TableColumnContent/customizationID(_:)``.
    ///
    /// - Parameters:
    ///   - data: The identifiable data for computing the table rows.
    ///   - children: A key path to a property whose non-`nil` value gives the
    ///     children of `data`, and whose `nil` value represents a leaf row of
    ///     the hierarchy, which is not capable of having children.
    ///   - selection: A binding to the optional selected row ID.
    ///   - sortOrder: A binding to the ordered sorting of columns.
    ///   - columnCustomization: A binding to the state of columns.
    ///   - columns: The columns to display in the table.
    nonisolated public init<Data, Sort>(_ data: Data, children: KeyPath<Data.Element, Data?>, selection: Binding<Value.ID?>, sortOrder: Binding<[Sort]>, columnCustomization: Binding<TableColumnCustomization<Value>>? = nil, @TableColumnBuilder<Value, Sort> columns: () -> Columns) where Rows == TableOutlineGroupContent<Data>, Data : RandomAccessCollection, Sort : SortComparator, Columns.TableRowValue == Data.Element, Data.Element == Sort.Compared

    /// Creates a sortable, hierarchical table that computes its rows based on a
    /// collection of identifiable data and key path to the children of that
    /// data, and supports selecting multiple rows.
    ///
    /// Each column in the table that should participate in customization is
    /// required to have an identifier, specified with
    /// ``TableColumnContent/customizationID(_:)``.
    ///
    /// - Parameters:
    ///   - data: The identifiable data for computing the table rows.
    ///   - children: A key path to a property whose non-`nil` value gives the
    ///     children of `data`, and whose `nil` value represents a leaf row of
    ///     the hierarchy, which is not capable of having children.
    ///   - selection: A binding to a set that identifies selected rows IDs.
    ///   - sortOrder: A binding to the ordered sorting of columns.
    ///   - columnCustomization: A binding to the state of columns.
    ///   - columns: The columns to display in the table.
    nonisolated public init<Data, Sort>(_ data: Data, children: KeyPath<Data.Element, Data?>, selection: Binding<Set<Value.ID>>, sortOrder: Binding<[Sort]>, columnCustomization: Binding<TableColumnCustomization<Value>>? = nil, @TableColumnBuilder<Value, Sort> columns: () -> Columns) where Rows == TableOutlineGroupContent<Data>, Data : RandomAccessCollection, Sort : SortComparator, Columns.TableRowValue == Data.Element, Data.Element == Sort.Compared
}

/// A column that displays a view for each row in a table.
///
/// You create a column with a label, content view, and optional key path.
/// The table calls the content view builder with the value for each row
/// in the table. The column uses a key path to map to a property of each row
/// value, which sortable tables use to reflect the current sort order.
///
/// The following example creates a sortable column for a table with `Person`
/// rows, displaying each person's given name:
///
///     TableColumn("Given name", value: \.givenName) { person in
///         Text(person.givenName)
///     }
///
/// For the common case of `String` properties, you can use the convenience
/// initializer that doesn't require an explicit content closure and displays
/// that string verbatim as a ``Text`` view. This means you can write the
/// previous example as:
///
///     TableColumn("Given name", value: \.givenName)
///
@available(iOS 16.0, macOS 12.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct TableColumn<RowValue, Sort, Content, Label> : TableColumnContent where RowValue : Identifiable, Sort : SortComparator, Content : View, Label : View {

    /// The type of value of rows presented by this column content.
    public typealias TableRowValue = RowValue

    /// The type of sort comparator associated with this table column content.
    public typealias TableColumnSortComparator = Sort

    /// The type of content representing the body of this table column content.
    @available(iOS 16.0, macOS 12.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias TableColumnBody = Never
}

@available(iOS 16.0, macOS 12.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension TableColumn where RowValue == Sort.Compared, Label == Text {

    /// Creates a sortable column that generates its label from a localized
    /// string key.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``.
    /// For more information about localizing strings, see``Text``.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the column's localized title.
    ///   - comparator: The prototype sort comparator to use when representing
    ///     this column. When a person taps or clicks the column header,
    ///     the containing table's `sortOrder` incorporates this value,
    ///     potentially with a flipped order.
    ///   - content: The view content to display for each row in a table.
    nonisolated public init(_ titleKey: LocalizedStringKey, sortUsing comparator: Sort, @ViewBuilder content: @escaping (RowValue) -> Content)

    /// Creates a sortable column that generates its label from a string.
    ///
    /// This initializer creates a ``Text`` view for you, and treats the
    /// title similar to ``Text/init(_:)``.
    /// For more information about localizing strings, see ``Text``.
    ///
    /// - Parameters:
    ///   - title: A string that describes the column.
    ///   - comparator: The prototype sort comparator to use when representing
    ///     this column. When a person taps or clicks the column header,
    ///     the containing table's `sortOrder` incorporates this value,
    ///     potentially with a flipped order.
    ///   - content: The view content to display for each row in a table.
    nonisolated public init<S>(_ title: S, sortUsing comparator: Sort, @ViewBuilder content: @escaping (RowValue) -> Content) where S : StringProtocol

    /// Creates a sortable column with text label.
    ///
    /// This initializer creates a ``Text`` view for you, and treats the
    /// title similar to ``Text/init(_:)``.
    /// For more information about localizing strings, see ``Text``.
    ///
    /// - Parameters:
    ///   - text: The column's label.
    ///   - comparator: The prototype sort comparator to use when representing
    ///     this column. When a person taps or clicks the column header,
    ///     the containing table's `sortOrder` incorporates this value,
    ///     potentially with a flipped order.
    ///   - content: The view content to display for each row in a table.
    @available(iOS 16.6, macOS 13.5, *)
    nonisolated public init(_ text: Text, sortUsing comparator: Sort, @ViewBuilder content: @escaping (RowValue) -> Content)
}

@available(iOS 16.0, macOS 12.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension TableColumn where Sort == Never, Label == Text {

    /// Creates an unsortable column that generates its label from a localized
    /// string key.
    ///
    /// This initializer creates a ``Text`` view for you, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``.
    /// For more information about localizing strings, see ``Text``.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the column's localized title.
    ///   - content: The view content to display for each row in a table.
    nonisolated public init(_ titleKey: LocalizedStringKey, @ViewBuilder content: @escaping (RowValue) -> Content)

    /// Creates an unsortable column that generates its label from a string.
    ///
    /// This initializer creates a ``Text`` view for you, and treats the
    /// title similar to ``Text/init(_:)``.
    /// For information about localizing strings, see ``Text``.
    ///
    /// - Parameters:
    ///   - title: A string that describes the column.
    ///   - content: The view content to display for each row in a table.
    nonisolated public init<S>(_ title: S, @ViewBuilder content: @escaping (RowValue) -> Content) where S : StringProtocol

    /// Creates an unsortable column with a text label
    ///
    /// This initializer creates a ``Text`` view for you, and treats the
    /// title similar to ``Text/init(_:)``.
    /// For information about localizing strings, see ``Text``.
    ///
    /// - Parameters:
    ///   - text: The column's label.
    ///   - content: The view content to display for each row in a table.
    @available(iOS 16.6, macOS 13.5, *)
    nonisolated public init(_ text: Text, @ViewBuilder content: @escaping (RowValue) -> Content)

    /// Creates an unsortable column that displays a string property that
    /// generates its label from a localized string key.
    ///
    /// This initializer creates a ``Text`` view for you, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``.
    /// For more information about localizing strings, see ``Text``.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the column's localized title.
    ///   - value: The path to the property associated with the column.
    ///     The table uses this to display the property as verbatim text in each
    ///     row of the table.
    nonisolated public init(_ titleKey: LocalizedStringKey, value: KeyPath<RowValue, String>) where Content == Text

    /// Creates an unsortable column that displays a string property that
    /// generates its label from a string.
    ///
    /// This initializer creates a ``Text`` view for you, and treats the
    /// title similar to ``Text/init(_:)``.
    /// For information about localizing strings, see ``Text``.
    ///
    /// - Parameters:
    ///   - title: A string that describes the column.
    ///   - value: The path to the property associated with the column.
    ///     The table uses this to display the property as verbatim text in each
    ///     row of the table.
    nonisolated public init<S>(_ title: S, value: KeyPath<RowValue, String>) where Content == Text, S : StringProtocol

    /// Creates an unsortable column that displays a string property with a
    /// text label.
    ///
    /// This initializer creates a ``Text`` view for you, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``.
    /// For more information about localizing strings, see ``Text``.
    ///
    /// - Parameters:
    ///   - text: The column's label.
    ///   - value: The path to the property associated with the column.
    ///     The table uses this to display the property as verbatim text in each
    ///     row of the table.
    @available(iOS 16.6, macOS 13.5, *)
    nonisolated public init(_ text: Text, value: KeyPath<RowValue, String>) where Content == Text
}

@available(iOS 16.0, macOS 12.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension TableColumn {

    /// Creates a fixed width table column that isn't user resizable.
    ///
    /// - Parameter width: A fixed width for the resulting column. If `width`
    ///   is `nil`, the resulting column has no change in sizing.
    nonisolated public func width(_ width: CGFloat? = nil) -> TableColumn<RowValue, Sort, Content, Label>

    /// Creates a resizable table column with the provided constraints.
    ///
    /// Always specify at least one width constraint when calling this method.
    /// Pass `nil` or leave out a constraint to indicate no change to the
    /// sizing of a column.
    ///
    /// To create a fixed size column use ``SwiftUI/TableColumn/width(_:)``
    /// instead.
    ///
    /// - Parameters:
    ///   - min: The minimum width of a resizable column. If non-`nil`, the
    ///     value must be greater than or equal to `0`.
    ///   - ideal: The ideal width of the column, used to determine the initial
    ///     width of the table column. The column always starts at least as
    ///     large as the set ideal size, but may be larger if table was sized
    ///     larger than the ideal of all of its columns.
    ///   - max: The maximum width of a resizable column. If non-`nil`, the
    ///     value must be greater than `0`. Pass
    ///     <doc://com.apple.documentation/documentation/CoreFoundation/CGFloat/1454161-infinity>
    ///     to indicate unconstrained maximum width.
    nonisolated public func width(min: CGFloat? = nil, ideal: CGFloat? = nil, max: CGFloat? = nil) -> TableColumn<RowValue, Sort, Content, Label>

    /// Does not change the table column's width.
    ///
    /// Use ``SwiftUI/TableColumn/width(_:)`` or
    /// ``SwiftUI/TableColumn/width(min:ideal:max:)`` instead.
    @available(*, deprecated, message: "Please pass one or more parameters to modify a column's width.")
    nonisolated public func width() -> TableColumn<RowValue, Sort, Content, Label>
}

@available(iOS 16.0, macOS 12.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension TableColumn where Sort == KeyPathComparator<RowValue>, Label == Text {

    /// Creates a sortable column for comparable values that generates its label
    /// from a localized string key.
    ///
    /// This initializer creates a ``Text`` view for you, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``.
    /// For more information about localizing strings, see ``Text``.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the column's localized title.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - content: The view content to display for each row in a table.
    public init<V>(_ titleKey: LocalizedStringKey, value: KeyPath<RowValue, V>, @ViewBuilder content: @escaping (RowValue) -> Content) where V : Comparable

    /// Creates a sortable column for comparable values that generates its label
    /// from a string.
    ///
    /// This initializer creates a ``Text`` view for you, and treats the
    /// title similar to ``Text/init(_:)``.
    /// For more information about localizing strings, see ``Text``.
    ///
    /// - Parameters:
    ///   - title: A string that describes the column.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - content: The view content to display for each row in a table.
    public init<S, V>(_ title: S, value: KeyPath<RowValue, V>, @ViewBuilder content: @escaping (RowValue) -> Content) where S : StringProtocol, V : Comparable

    /// Creates a sortable column for comparable values with a text label.
    ///
    /// This initializer creates a ``Text`` view for you, and treats the
    /// title similar to ``Text/init(_:)``.
    /// For more information about localizing strings, see ``Text``.
    ///
    /// - Parameters:
    ///   - text: The column's label.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - content: The view content to display for each row in a table.
    @available(iOS 16.6, macOS 13.5, *)
    public init<V>(_ text: Text, value: KeyPath<RowValue, V>, @ViewBuilder content: @escaping (RowValue) -> Content) where V : Comparable

    /// Creates a sortable column that generates its label from a localized
    /// string key, and uses an explicit comparator for sorting values.
    ///
    /// This initializer creates a ``Text`` view for you, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the column's localized title.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - comparator: The `SortComparator` used to order values of the sort
    ///     value type.
    ///   - content: The view content to display for each row in a table.
    public init<V, C>(_ titleKey: LocalizedStringKey, value: KeyPath<RowValue, V>, comparator: C, @ViewBuilder content: @escaping (RowValue) -> Content) where V == C.Compared, C : SortComparator

    /// Creates a sortable column that generates its label from a string, and
    /// uses an explicit comparator for sorting values.
    ///
    /// This initializer creates a ``Text`` view for you, and treats the
    /// title similar to ``Text/init(_:)``.
    /// For more information about localizing strings, see ``Text``.
    ///
    /// - Parameters:
    ///   - title: A string that describes the column.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - comparator: The `SortComparator` used to order values of the sort
    ///     value type.
    ///   - content: The view content to display for each row in a table.
    public init<S, V, C>(_ title: S, value: KeyPath<RowValue, V>, comparator: C, @ViewBuilder content: @escaping (RowValue) -> Content) where S : StringProtocol, V == C.Compared, C : SortComparator

    /// Creates a sortable column that has a text label, and uses an explicit
    /// comparator for sorting values.
    ///
    /// This initializer creates a ``Text`` view for you, and treats the
    /// title similar to ``Text/init(_:)``.
    /// For more information about localizing strings, see ``Text``.
    ///
    /// - Parameters:
    ///   - text: The column's label.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - comparator: The `SortComparator` used to order values of the sort
    ///     value type.
    ///   - content: The view content to display for each row in a table.
    @available(iOS 16.6, macOS 13.5, *)
    public init<V, C>(_ text: Text, value: KeyPath<RowValue, V>, comparator: C, @ViewBuilder content: @escaping (RowValue) -> Content) where V == C.Compared, C : SortComparator

    /// Creates a sortable column that displays a string property, and
    /// generates its label from a localized string key.
    ///
    /// This initializer creates a ``Text`` view for you, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``.
    /// For more information about localizing strings, see ``Text``.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the column's localized title.
    ///   - value: The path to the property associated with the column,
    ///     to display verbatim as text in each row of a table,
    ///     and the key path used to create a sort comparator when
    ///     sorting the column.
    ///   - comparator: The `SortComparator` used to order the string values.
    public init(_ titleKey: LocalizedStringKey, value: KeyPath<RowValue, String>, comparator: String.StandardComparator = .localizedStandard) where Content == Text

    /// Creates a sortable column that displays a string property, and
    /// generates its label from a string.
    ///
    /// This initializer creates a ``Text`` view for you, and treats the
    /// title similar to ``Text/init(_:)``.
    /// For more information about localizing strings, see ``Text``.
    ///
    /// - Parameters:
    ///   - title: A string that describes the column.
    ///   - value: The path to the property associated with the column,
    ///     to display verbatim as text in each row of a table,
    ///     and the key path used to create a sort comparator when
    ///     sorting the column.
    ///   - comparator: The `SortComparator` used to order the string values.
    public init<S>(_ title: S, value: KeyPath<RowValue, String>, comparator: String.StandardComparator = .localizedStandard) where Content == Text, S : StringProtocol

    /// Creates a sortable column that displays a string property and
    /// has a text label.
    ///
    /// This initializer creates a ``Text`` view for you, and treats the
    /// title similar to ``Text/init(_:)``.
    /// For more information about localizing strings, see ``Text``.
    ///
    /// - Parameters:
    ///   - text: The column's label.
    ///   - value: The path to the property associated with the column,
    ///     to display verbatim as text in each row of a table,
    ///     and the key path used to create a sort comparator when
    ///     sorting the column.
    ///   - comparator: The `SortComparator` used to order the string values.
    @available(iOS 16.6, macOS 13.5, *)
    public init(_ text: Text, value: KeyPath<RowValue, String>, comparator: String.StandardComparator = .localizedStandard) where Content == Text
}

@available(iOS 16.0, macOS 12.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension TableColumn where RowValue : NSObject, Sort == SortDescriptor<RowValue>, Label == Text {

    /// Creates a sortable column for Boolean values
    /// that generates its label from a localized string key.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the column's localized title.
    ///   - value: The path to the property associated with the column,
    ///     which will be used to update and reflect the sorting state in a
    ///     table.
    ///   - content: The view content to display for each row in a table.
    public init(_ titleKey: LocalizedStringKey, value: KeyPath<RowValue, Bool>, @ViewBuilder content: @escaping (RowValue) -> Content)

    /// Creates a sortable column for Boolean
    /// values that displays a string property.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// title similar to ``Text/init(_:)``. For more information about
    /// localizing strings, see ``Text``.
    ///
    /// - Parameters:
    ///   - title: A string that describes the column.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - content: The view content to display for each row in a table.
    public init<S>(_ title: S, value: KeyPath<RowValue, Bool>, @ViewBuilder content: @escaping (RowValue) -> Content) where S : StringProtocol

    /// Creates a sortable column for Boolean values with a text label.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - text: The column's label.
    ///   - value: The path to the property associated with the column,
    ///     which will be used to update and reflect the sorting state in a
    ///     table.
    ///   - content: The view content to display for each row in a table.
    @available(iOS 16.6, macOS 13.5, *)
    public init(_ text: Text, value: KeyPath<RowValue, Bool>, @ViewBuilder content: @escaping (RowValue) -> Content)

    /// Creates a sortable column for optional Boolean values that generates
    /// its label from a localized string key.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the column's localized title.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - content: The view content to display for each row in a table.
    public init(_ titleKey: LocalizedStringKey, value: KeyPath<RowValue, Bool?>, @ViewBuilder content: @escaping (RowValue) -> Content)

    /// Creates a sortable column for optional Boolean values that displays a
    /// string property.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// title similar to ``Text/init(_:)``. For more information about
    /// localizing strings, see ``Text``.
    ///
    /// - Parameters:
    ///   - title: A string that describes the column.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - content: The view content to display for each row in a table.
    public init<S>(_ title: S, value: KeyPath<RowValue, Bool?>, @ViewBuilder content: @escaping (RowValue) -> Content) where S : StringProtocol

    /// Creates a sortable column for optional Boolean values with a text
    /// label.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - text: The column's label.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - content: The view content to display for each row in a table.
    @available(iOS 16.6, macOS 13.5, *)
    public init(_ text: Text, value: KeyPath<RowValue, Bool?>, @ViewBuilder content: @escaping (RowValue) -> Content)

    /// Creates a sortable column for double-precision floating-point values
    /// that generates its label from a localized string key.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the column's localized title.
    ///   - value: The path to the property associated with the column,
    ///     which will be used to update and reflect the sorting state in a
    ///     table.
    ///   - content: The view content to display for each row in a table.
    public init(_ titleKey: LocalizedStringKey, value: KeyPath<RowValue, Double>, @ViewBuilder content: @escaping (RowValue) -> Content)

    /// Creates a sortable column for double-precision floating-point
    /// values that displays a string property.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// title similar to ``Text/init(_:)``. For more information about
    /// localizing strings, see ``Text``.
    ///
    /// - Parameters:
    ///   - title: A string that describes the column.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - content: The view content to display for each row in a table.
    public init<S>(_ title: S, value: KeyPath<RowValue, Double>, @ViewBuilder content: @escaping (RowValue) -> Content) where S : StringProtocol

    /// Creates a sortable column for double-precision floating-point values with a text label.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - text: The column's label.
    ///   - value: The path to the property associated with the column,
    ///     which will be used to update and reflect the sorting state in a
    ///     table.
    ///   - content: The view content to display for each row in a table.
    @available(iOS 16.6, macOS 13.5, *)
    public init(_ text: Text, value: KeyPath<RowValue, Double>, @ViewBuilder content: @escaping (RowValue) -> Content)

    /// Creates a sortable column for optional double-precision floating-point values that generates
    /// its label from a localized string key.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the column's localized title.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - content: The view content to display for each row in a table.
    public init(_ titleKey: LocalizedStringKey, value: KeyPath<RowValue, Double?>, @ViewBuilder content: @escaping (RowValue) -> Content)

    /// Creates a sortable column for optional double-precision floating-point values that displays a
    /// string property.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// title similar to ``Text/init(_:)``. For more information about
    /// localizing strings, see ``Text``.
    ///
    /// - Parameters:
    ///   - title: A string that describes the column.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - content: The view content to display for each row in a table.
    public init<S>(_ title: S, value: KeyPath<RowValue, Double?>, @ViewBuilder content: @escaping (RowValue) -> Content) where S : StringProtocol

    /// Creates a sortable column for optional double-precision floating-point values with a text
    /// label.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - text: The column's label.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - content: The view content to display for each row in a table.
    @available(iOS 16.6, macOS 13.5, *)
    public init(_ text: Text, value: KeyPath<RowValue, Double?>, @ViewBuilder content: @escaping (RowValue) -> Content)

    /// Creates a sortable column for single-precision floating-point values
    /// that generates its label from a localized string key.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the column's localized title.
    ///   - value: The path to the property associated with the column,
    ///     which will be used to update and reflect the sorting state in a
    ///     table.
    ///   - content: The view content to display for each row in a table.
    public init(_ titleKey: LocalizedStringKey, value: KeyPath<RowValue, Float>, @ViewBuilder content: @escaping (RowValue) -> Content)

    /// Creates a sortable column for single-precision floating-point
    /// values that displays a string property.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// title similar to ``Text/init(_:)``. For more information about
    /// localizing strings, see ``Text``.
    ///
    /// - Parameters:
    ///   - title: A string that describes the column.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - content: The view content to display for each row in a table.
    public init<S>(_ title: S, value: KeyPath<RowValue, Float>, @ViewBuilder content: @escaping (RowValue) -> Content) where S : StringProtocol

    /// Creates a sortable column for single-precision floating-point values with a text label.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - text: The column's label.
    ///   - value: The path to the property associated with the column,
    ///     which will be used to update and reflect the sorting state in a
    ///     table.
    ///   - content: The view content to display for each row in a table.
    @available(iOS 16.6, macOS 13.5, *)
    public init(_ text: Text, value: KeyPath<RowValue, Float>, @ViewBuilder content: @escaping (RowValue) -> Content)

    /// Creates a sortable column for optional single-precision floating-point values that generates
    /// its label from a localized string key.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the column's localized title.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - content: The view content to display for each row in a table.
    public init(_ titleKey: LocalizedStringKey, value: KeyPath<RowValue, Float?>, @ViewBuilder content: @escaping (RowValue) -> Content)

    /// Creates a sortable column for optional single-precision floating-point values that displays a
    /// string property.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// title similar to ``Text/init(_:)``. For more information about
    /// localizing strings, see ``Text``.
    ///
    /// - Parameters:
    ///   - title: A string that describes the column.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - content: The view content to display for each row in a table.
    public init<S>(_ title: S, value: KeyPath<RowValue, Float?>, @ViewBuilder content: @escaping (RowValue) -> Content) where S : StringProtocol

    /// Creates a sortable column for optional single-precision floating-point values with a text
    /// label.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - text: The column's label.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - content: The view content to display for each row in a table.
    @available(iOS 16.6, macOS 13.5, *)
    public init(_ text: Text, value: KeyPath<RowValue, Float?>, @ViewBuilder content: @escaping (RowValue) -> Content)

    /// Creates a sortable column for 8-bit integer values
    /// that generates its label from a localized string key.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the column's localized title.
    ///   - value: The path to the property associated with the column,
    ///     which will be used to update and reflect the sorting state in a
    ///     table.
    ///   - content: The view content to display for each row in a table.
    public init(_ titleKey: LocalizedStringKey, value: KeyPath<RowValue, Int8>, @ViewBuilder content: @escaping (RowValue) -> Content)

    /// Creates a sortable column for 8-bit integer
    /// values that displays a string property.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// title similar to ``Text/init(_:)``. For more information about
    /// localizing strings, see ``Text``.
    ///
    /// - Parameters:
    ///   - title: A string that describes the column.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - content: The view content to display for each row in a table.
    public init<S>(_ title: S, value: KeyPath<RowValue, Int8>, @ViewBuilder content: @escaping (RowValue) -> Content) where S : StringProtocol

    /// Creates a sortable column for 8-bit integer values with a text label.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - text: The column's label.
    ///   - value: The path to the property associated with the column,
    ///     which will be used to update and reflect the sorting state in a
    ///     table.
    ///   - content: The view content to display for each row in a table.
    @available(iOS 16.6, macOS 13.5, *)
    public init(_ text: Text, value: KeyPath<RowValue, Int8>, @ViewBuilder content: @escaping (RowValue) -> Content)

    /// Creates a sortable column for optional 8-bit integer values that generates
    /// its label from a localized string key.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the column's localized title.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - content: The view content to display for each row in a table.
    public init(_ titleKey: LocalizedStringKey, value: KeyPath<RowValue, Int8?>, @ViewBuilder content: @escaping (RowValue) -> Content)

    /// Creates a sortable column for optional 8-bit integer values that displays a
    /// string property.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// title similar to ``Text/init(_:)``. For more information about
    /// localizing strings, see ``Text``.
    ///
    /// - Parameters:
    ///   - title: A string that describes the column.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - content: The view content to display for each row in a table.
    public init<S>(_ title: S, value: KeyPath<RowValue, Int8?>, @ViewBuilder content: @escaping (RowValue) -> Content) where S : StringProtocol

    /// Creates a sortable column for optional 8-bit integer values with a text
    /// label.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - text: The column's label.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - content: The view content to display for each row in a table.
    @available(iOS 16.6, macOS 13.5, *)
    public init(_ text: Text, value: KeyPath<RowValue, Int8?>, @ViewBuilder content: @escaping (RowValue) -> Content)

    /// Creates a sortable column for 16-bit integer values
    /// that generates its label from a localized string key.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the column's localized title.
    ///   - value: The path to the property associated with the column,
    ///     which will be used to update and reflect the sorting state in a
    ///     table.
    ///   - content: The view content to display for each row in a table.
    public init(_ titleKey: LocalizedStringKey, value: KeyPath<RowValue, Int16>, @ViewBuilder content: @escaping (RowValue) -> Content)

    /// Creates a sortable column for 16-bit integer
    /// values that displays a string property.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// title similar to ``Text/init(_:)``. For more information about
    /// localizing strings, see ``Text``.
    ///
    /// - Parameters:
    ///   - title: A string that describes the column.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - content: The view content to display for each row in a table.
    public init<S>(_ title: S, value: KeyPath<RowValue, Int16>, @ViewBuilder content: @escaping (RowValue) -> Content) where S : StringProtocol

    /// Creates a sortable column for 16-bit integer values with a text label.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - text: The column's label.
    ///   - value: The path to the property associated with the column,
    ///     which will be used to update and reflect the sorting state in a
    ///     table.
    ///   - content: The view content to display for each row in a table.
    @available(iOS 16.6, macOS 13.5, *)
    public init(_ text: Text, value: KeyPath<RowValue, Int16>, @ViewBuilder content: @escaping (RowValue) -> Content)

    /// Creates a sortable column for optional 16-bit integer values that generates
    /// its label from a localized string key.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the column's localized title.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - content: The view content to display for each row in a table.
    public init(_ titleKey: LocalizedStringKey, value: KeyPath<RowValue, Int16?>, @ViewBuilder content: @escaping (RowValue) -> Content)

    /// Creates a sortable column for optional 16-bit integer values that displays a
    /// string property.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// title similar to ``Text/init(_:)``. For more information about
    /// localizing strings, see ``Text``.
    ///
    /// - Parameters:
    ///   - title: A string that describes the column.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - content: The view content to display for each row in a table.
    public init<S>(_ title: S, value: KeyPath<RowValue, Int16?>, @ViewBuilder content: @escaping (RowValue) -> Content) where S : StringProtocol

    /// Creates a sortable column for optional 16-bit integer values with a text
    /// label.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - text: The column's label.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - content: The view content to display for each row in a table.
    @available(iOS 16.6, macOS 13.5, *)
    public init(_ text: Text, value: KeyPath<RowValue, Int16?>, @ViewBuilder content: @escaping (RowValue) -> Content)

    /// Creates a sortable column for 32-bit integer values
    /// that generates its label from a localized string key.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the column's localized title.
    ///   - value: The path to the property associated with the column,
    ///     which will be used to update and reflect the sorting state in a
    ///     table.
    ///   - content: The view content to display for each row in a table.
    public init(_ titleKey: LocalizedStringKey, value: KeyPath<RowValue, Int32>, @ViewBuilder content: @escaping (RowValue) -> Content)

    /// Creates a sortable column for 32-bit integer
    /// values that displays a string property.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// title similar to ``Text/init(_:)``. For more information about
    /// localizing strings, see ``Text``.
    ///
    /// - Parameters:
    ///   - title: A string that describes the column.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - content: The view content to display for each row in a table.
    public init<S>(_ title: S, value: KeyPath<RowValue, Int32>, @ViewBuilder content: @escaping (RowValue) -> Content) where S : StringProtocol

    /// Creates a sortable column for 32-bit integer values with a text label.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - text: The column's label.
    ///   - value: The path to the property associated with the column,
    ///     which will be used to update and reflect the sorting state in a
    ///     table.
    ///   - content: The view content to display for each row in a table.
    @available(iOS 16.6, macOS 13.5, *)
    public init(_ text: Text, value: KeyPath<RowValue, Int32>, @ViewBuilder content: @escaping (RowValue) -> Content)

    /// Creates a sortable column for optional 32-bit integer values that generates
    /// its label from a localized string key.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the column's localized title.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - content: The view content to display for each row in a table.
    public init(_ titleKey: LocalizedStringKey, value: KeyPath<RowValue, Int32?>, @ViewBuilder content: @escaping (RowValue) -> Content)

    /// Creates a sortable column for optional 32-bit integer values that displays a
    /// string property.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// title similar to ``Text/init(_:)``. For more information about
    /// localizing strings, see ``Text``.
    ///
    /// - Parameters:
    ///   - title: A string that describes the column.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - content: The view content to display for each row in a table.
    public init<S>(_ title: S, value: KeyPath<RowValue, Int32?>, @ViewBuilder content: @escaping (RowValue) -> Content) where S : StringProtocol

    /// Creates a sortable column for optional 32-bit integer values with a text
    /// label.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - text: The column's label.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - content: The view content to display for each row in a table.
    @available(iOS 16.6, macOS 13.5, *)
    public init(_ text: Text, value: KeyPath<RowValue, Int32?>, @ViewBuilder content: @escaping (RowValue) -> Content)

    /// Creates a sortable column for 64-bit integer values
    /// that generates its label from a localized string key.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the column's localized title.
    ///   - value: The path to the property associated with the column,
    ///     which will be used to update and reflect the sorting state in a
    ///     table.
    ///   - content: The view content to display for each row in a table.
    public init(_ titleKey: LocalizedStringKey, value: KeyPath<RowValue, Int64>, @ViewBuilder content: @escaping (RowValue) -> Content)

    /// Creates a sortable column for 64-bit integer
    /// values that displays a string property.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// title similar to ``Text/init(_:)``. For more information about
    /// localizing strings, see ``Text``.
    ///
    /// - Parameters:
    ///   - title: A string that describes the column.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - content: The view content to display for each row in a table.
    public init<S>(_ title: S, value: KeyPath<RowValue, Int64>, @ViewBuilder content: @escaping (RowValue) -> Content) where S : StringProtocol

    /// Creates a sortable column for 64-bit integer values with a text label.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - text: The column's label.
    ///   - value: The path to the property associated with the column,
    ///     which will be used to update and reflect the sorting state in a
    ///     table.
    ///   - content: The view content to display for each row in a table.
    @available(iOS 16.6, macOS 13.5, *)
    public init(_ text: Text, value: KeyPath<RowValue, Int64>, @ViewBuilder content: @escaping (RowValue) -> Content)

    /// Creates a sortable column for optional 64-bit integer values that generates
    /// its label from a localized string key.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the column's localized title.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - content: The view content to display for each row in a table.
    public init(_ titleKey: LocalizedStringKey, value: KeyPath<RowValue, Int64?>, @ViewBuilder content: @escaping (RowValue) -> Content)

    /// Creates a sortable column for optional 64-bit integer values that displays a
    /// string property.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// title similar to ``Text/init(_:)``. For more information about
    /// localizing strings, see ``Text``.
    ///
    /// - Parameters:
    ///   - title: A string that describes the column.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - content: The view content to display for each row in a table.
    public init<S>(_ title: S, value: KeyPath<RowValue, Int64?>, @ViewBuilder content: @escaping (RowValue) -> Content) where S : StringProtocol

    /// Creates a sortable column for optional 64-bit integer values with a text
    /// label.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - text: The column's label.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - content: The view content to display for each row in a table.
    @available(iOS 16.6, macOS 13.5, *)
    public init(_ text: Text, value: KeyPath<RowValue, Int64?>, @ViewBuilder content: @escaping (RowValue) -> Content)

    /// Creates a sortable column for integer values
    /// that generates its label from a localized string key.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the column's localized title.
    ///   - value: The path to the property associated with the column,
    ///     which will be used to update and reflect the sorting state in a
    ///     table.
    ///   - content: The view content to display for each row in a table.
    public init(_ titleKey: LocalizedStringKey, value: KeyPath<RowValue, Int>, @ViewBuilder content: @escaping (RowValue) -> Content)

    /// Creates a sortable column for integer
    /// values that displays a string property.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// title similar to ``Text/init(_:)``. For more information about
    /// localizing strings, see ``Text``.
    ///
    /// - Parameters:
    ///   - title: A string that describes the column.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - content: The view content to display for each row in a table.
    public init<S>(_ title: S, value: KeyPath<RowValue, Int>, @ViewBuilder content: @escaping (RowValue) -> Content) where S : StringProtocol

    /// Creates a sortable column for integer values with a text label.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - text: The column's label.
    ///   - value: The path to the property associated with the column,
    ///     which will be used to update and reflect the sorting state in a
    ///     table.
    ///   - content: The view content to display for each row in a table.
    @available(iOS 16.6, macOS 13.5, *)
    public init(_ text: Text, value: KeyPath<RowValue, Int>, @ViewBuilder content: @escaping (RowValue) -> Content)

    /// Creates a sortable column for optional integer values that generates
    /// its label from a localized string key.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the column's localized title.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - content: The view content to display for each row in a table.
    public init(_ titleKey: LocalizedStringKey, value: KeyPath<RowValue, Int?>, @ViewBuilder content: @escaping (RowValue) -> Content)

    /// Creates a sortable column for optional integer values that displays a
    /// string property.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// title similar to ``Text/init(_:)``. For more information about
    /// localizing strings, see ``Text``.
    ///
    /// - Parameters:
    ///   - title: A string that describes the column.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - content: The view content to display for each row in a table.
    public init<S>(_ title: S, value: KeyPath<RowValue, Int?>, @ViewBuilder content: @escaping (RowValue) -> Content) where S : StringProtocol

    /// Creates a sortable column for optional integer values with a text
    /// label.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - text: The column's label.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - content: The view content to display for each row in a table.
    @available(iOS 16.6, macOS 13.5, *)
    public init(_ text: Text, value: KeyPath<RowValue, Int?>, @ViewBuilder content: @escaping (RowValue) -> Content)

    /// Creates a sortable column for unsigned 8-bit integer values
    /// that generates its label from a localized string key.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the column's localized title.
    ///   - value: The path to the property associated with the column,
    ///     which will be used to update and reflect the sorting state in a
    ///     table.
    ///   - content: The view content to display for each row in a table.
    public init(_ titleKey: LocalizedStringKey, value: KeyPath<RowValue, UInt8>, @ViewBuilder content: @escaping (RowValue) -> Content)

    /// Creates a sortable column for unsigned 8-bit integer
    /// values that displays a string property.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// title similar to ``Text/init(_:)``. For more information about
    /// localizing strings, see ``Text``.
    ///
    /// - Parameters:
    ///   - title: A string that describes the column.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - content: The view content to display for each row in a table.
    public init<S>(_ title: S, value: KeyPath<RowValue, UInt8>, @ViewBuilder content: @escaping (RowValue) -> Content) where S : StringProtocol

    /// Creates a sortable column for unsigned 8-bit integer values with a text label.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - text: The column's label.
    ///   - value: The path to the property associated with the column,
    ///     which will be used to update and reflect the sorting state in a
    ///     table.
    ///   - content: The view content to display for each row in a table.
    @available(iOS 16.6, macOS 13.5, *)
    public init(_ text: Text, value: KeyPath<RowValue, UInt8>, @ViewBuilder content: @escaping (RowValue) -> Content)

    /// Creates a sortable column for optional unsigned 8-bit integer values that generates
    /// its label from a localized string key.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the column's localized title.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - content: The view content to display for each row in a table.
    public init(_ titleKey: LocalizedStringKey, value: KeyPath<RowValue, UInt8?>, @ViewBuilder content: @escaping (RowValue) -> Content)

    /// Creates a sortable column for optional unsigned 8-bit integer values that displays a
    /// string property.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// title similar to ``Text/init(_:)``. For more information about
    /// localizing strings, see ``Text``.
    ///
    /// - Parameters:
    ///   - title: A string that describes the column.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - content: The view content to display for each row in a table.
    public init<S>(_ title: S, value: KeyPath<RowValue, UInt8?>, @ViewBuilder content: @escaping (RowValue) -> Content) where S : StringProtocol

    /// Creates a sortable column for optional unsigned 8-bit integer values with a text
    /// label.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - text: The column's label.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - content: The view content to display for each row in a table.
    @available(iOS 16.6, macOS 13.5, *)
    public init(_ text: Text, value: KeyPath<RowValue, UInt8?>, @ViewBuilder content: @escaping (RowValue) -> Content)

    /// Creates a sortable column for unsigned 16-bit integer values
    /// that generates its label from a localized string key.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the column's localized title.
    ///   - value: The path to the property associated with the column,
    ///     which will be used to update and reflect the sorting state in a
    ///     table.
    ///   - content: The view content to display for each row in a table.
    public init(_ titleKey: LocalizedStringKey, value: KeyPath<RowValue, UInt16>, @ViewBuilder content: @escaping (RowValue) -> Content)

    /// Creates a sortable column for unsigned 16-bit integer
    /// values that displays a string property.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// title similar to ``Text/init(_:)``. For more information about
    /// localizing strings, see ``Text``.
    ///
    /// - Parameters:
    ///   - title: A string that describes the column.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - content: The view content to display for each row in a table.
    public init<S>(_ title: S, value: KeyPath<RowValue, UInt16>, @ViewBuilder content: @escaping (RowValue) -> Content) where S : StringProtocol

    /// Creates a sortable column for unsigned 16-bit integer values with a text label.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - text: The column's label.
    ///   - value: The path to the property associated with the column,
    ///     which will be used to update and reflect the sorting state in a
    ///     table.
    ///   - content: The view content to display for each row in a table.
    @available(iOS 16.6, macOS 13.5, *)
    public init(_ text: Text, value: KeyPath<RowValue, UInt16>, @ViewBuilder content: @escaping (RowValue) -> Content)

    /// Creates a sortable column for optional unsigned 16-bit integer values that generates
    /// its label from a localized string key.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the column's localized title.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - content: The view content to display for each row in a table.
    public init(_ titleKey: LocalizedStringKey, value: KeyPath<RowValue, UInt16?>, @ViewBuilder content: @escaping (RowValue) -> Content)

    /// Creates a sortable column for optional unsigned 16-bit integer values that displays a
    /// string property.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// title similar to ``Text/init(_:)``. For more information about
    /// localizing strings, see ``Text``.
    ///
    /// - Parameters:
    ///   - title: A string that describes the column.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - content: The view content to display for each row in a table.
    public init<S>(_ title: S, value: KeyPath<RowValue, UInt16?>, @ViewBuilder content: @escaping (RowValue) -> Content) where S : StringProtocol

    /// Creates a sortable column for optional unsigned 16-bit integer values with a text
    /// label.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - text: The column's label.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - content: The view content to display for each row in a table.
    @available(iOS 16.6, macOS 13.5, *)
    public init(_ text: Text, value: KeyPath<RowValue, UInt16?>, @ViewBuilder content: @escaping (RowValue) -> Content)

    /// Creates a sortable column for unsigned 32-bit integer values
    /// that generates its label from a localized string key.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the column's localized title.
    ///   - value: The path to the property associated with the column,
    ///     which will be used to update and reflect the sorting state in a
    ///     table.
    ///   - content: The view content to display for each row in a table.
    public init(_ titleKey: LocalizedStringKey, value: KeyPath<RowValue, UInt32>, @ViewBuilder content: @escaping (RowValue) -> Content)

    /// Creates a sortable column for unsigned 32-bit integer
    /// values that displays a string property.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// title similar to ``Text/init(_:)``. For more information about
    /// localizing strings, see ``Text``.
    ///
    /// - Parameters:
    ///   - title: A string that describes the column.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - content: The view content to display for each row in a table.
    public init<S>(_ title: S, value: KeyPath<RowValue, UInt32>, @ViewBuilder content: @escaping (RowValue) -> Content) where S : StringProtocol

    /// Creates a sortable column for unsigned 32-bit integer values with a text label.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - text: The column's label.
    ///   - value: The path to the property associated with the column,
    ///     which will be used to update and reflect the sorting state in a
    ///     table.
    ///   - content: The view content to display for each row in a table.
    @available(iOS 16.6, macOS 13.5, *)
    public init(_ text: Text, value: KeyPath<RowValue, UInt32>, @ViewBuilder content: @escaping (RowValue) -> Content)

    /// Creates a sortable column for optional unsigned 32-bit integer values that generates
    /// its label from a localized string key.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the column's localized title.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - content: The view content to display for each row in a table.
    public init(_ titleKey: LocalizedStringKey, value: KeyPath<RowValue, UInt32?>, @ViewBuilder content: @escaping (RowValue) -> Content)

    /// Creates a sortable column for optional unsigned 32-bit integer values that displays a
    /// string property.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// title similar to ``Text/init(_:)``. For more information about
    /// localizing strings, see ``Text``.
    ///
    /// - Parameters:
    ///   - title: A string that describes the column.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - content: The view content to display for each row in a table.
    public init<S>(_ title: S, value: KeyPath<RowValue, UInt32?>, @ViewBuilder content: @escaping (RowValue) -> Content) where S : StringProtocol

    /// Creates a sortable column for optional unsigned 32-bit integer values with a text
    /// label.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - text: The column's label.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - content: The view content to display for each row in a table.
    @available(iOS 16.6, macOS 13.5, *)
    public init(_ text: Text, value: KeyPath<RowValue, UInt32?>, @ViewBuilder content: @escaping (RowValue) -> Content)

    /// Creates a sortable column for unsigned 64-bit integer values
    /// that generates its label from a localized string key.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the column's localized title.
    ///   - value: The path to the property associated with the column,
    ///     which will be used to update and reflect the sorting state in a
    ///     table.
    ///   - content: The view content to display for each row in a table.
    public init(_ titleKey: LocalizedStringKey, value: KeyPath<RowValue, UInt64>, @ViewBuilder content: @escaping (RowValue) -> Content)

    /// Creates a sortable column for unsigned 64-bit integer
    /// values that displays a string property.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// title similar to ``Text/init(_:)``. For more information about
    /// localizing strings, see ``Text``.
    ///
    /// - Parameters:
    ///   - title: A string that describes the column.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - content: The view content to display for each row in a table.
    public init<S>(_ title: S, value: KeyPath<RowValue, UInt64>, @ViewBuilder content: @escaping (RowValue) -> Content) where S : StringProtocol

    /// Creates a sortable column for unsigned 64-bit integer values with a text label.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - text: The column's label.
    ///   - value: The path to the property associated with the column,
    ///     which will be used to update and reflect the sorting state in a
    ///     table.
    ///   - content: The view content to display for each row in a table.
    @available(iOS 16.6, macOS 13.5, *)
    public init(_ text: Text, value: KeyPath<RowValue, UInt64>, @ViewBuilder content: @escaping (RowValue) -> Content)

    /// Creates a sortable column for optional unsigned 64-bit integer values that generates
    /// its label from a localized string key.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the column's localized title.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - content: The view content to display for each row in a table.
    public init(_ titleKey: LocalizedStringKey, value: KeyPath<RowValue, UInt64?>, @ViewBuilder content: @escaping (RowValue) -> Content)

    /// Creates a sortable column for optional unsigned 64-bit integer values that displays a
    /// string property.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// title similar to ``Text/init(_:)``. For more information about
    /// localizing strings, see ``Text``.
    ///
    /// - Parameters:
    ///   - title: A string that describes the column.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - content: The view content to display for each row in a table.
    public init<S>(_ title: S, value: KeyPath<RowValue, UInt64?>, @ViewBuilder content: @escaping (RowValue) -> Content) where S : StringProtocol

    /// Creates a sortable column for optional unsigned 64-bit integer values with a text
    /// label.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - text: The column's label.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - content: The view content to display for each row in a table.
    @available(iOS 16.6, macOS 13.5, *)
    public init(_ text: Text, value: KeyPath<RowValue, UInt64?>, @ViewBuilder content: @escaping (RowValue) -> Content)

    /// Creates a sortable column for unsigned integer values
    /// that generates its label from a localized string key.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the column's localized title.
    ///   - value: The path to the property associated with the column,
    ///     which will be used to update and reflect the sorting state in a
    ///     table.
    ///   - content: The view content to display for each row in a table.
    public init(_ titleKey: LocalizedStringKey, value: KeyPath<RowValue, UInt>, @ViewBuilder content: @escaping (RowValue) -> Content)

    /// Creates a sortable column for unsigned integer
    /// values that displays a string property.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// title similar to ``Text/init(_:)``. For more information about
    /// localizing strings, see ``Text``.
    ///
    /// - Parameters:
    ///   - title: A string that describes the column.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - content: The view content to display for each row in a table.
    public init<S>(_ title: S, value: KeyPath<RowValue, UInt>, @ViewBuilder content: @escaping (RowValue) -> Content) where S : StringProtocol

    /// Creates a sortable column for unsigned integer values with a text label.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - text: The column's label.
    ///   - value: The path to the property associated with the column,
    ///     which will be used to update and reflect the sorting state in a
    ///     table.
    ///   - content: The view content to display for each row in a table.
    @available(iOS 16.6, macOS 13.5, *)
    public init(_ text: Text, value: KeyPath<RowValue, UInt>, @ViewBuilder content: @escaping (RowValue) -> Content)

    /// Creates a sortable column for optional unsigned integer values that generates
    /// its label from a localized string key.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the column's localized title.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - content: The view content to display for each row in a table.
    public init(_ titleKey: LocalizedStringKey, value: KeyPath<RowValue, UInt?>, @ViewBuilder content: @escaping (RowValue) -> Content)

    /// Creates a sortable column for optional unsigned integer values that displays a
    /// string property.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// title similar to ``Text/init(_:)``. For more information about
    /// localizing strings, see ``Text``.
    ///
    /// - Parameters:
    ///   - title: A string that describes the column.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - content: The view content to display for each row in a table.
    public init<S>(_ title: S, value: KeyPath<RowValue, UInt?>, @ViewBuilder content: @escaping (RowValue) -> Content) where S : StringProtocol

    /// Creates a sortable column for optional unsigned integer values with a text
    /// label.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - text: The column's label.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - content: The view content to display for each row in a table.
    @available(iOS 16.6, macOS 13.5, *)
    public init(_ text: Text, value: KeyPath<RowValue, UInt?>, @ViewBuilder content: @escaping (RowValue) -> Content)

    /// Creates a sortable column for date values
    /// that generates its label from a localized string key.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the column's localized title.
    ///   - value: The path to the property associated with the column,
    ///     which will be used to update and reflect the sorting state in a
    ///     table.
    ///   - content: The view content to display for each row in a table.
    public init(_ titleKey: LocalizedStringKey, value: KeyPath<RowValue, Date>, @ViewBuilder content: @escaping (RowValue) -> Content)

    /// Creates a sortable column for date
    /// values that displays a string property.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// title similar to ``Text/init(_:)``. For more information about
    /// localizing strings, see ``Text``.
    ///
    /// - Parameters:
    ///   - title: A string that describes the column.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - content: The view content to display for each row in a table.
    public init<S>(_ title: S, value: KeyPath<RowValue, Date>, @ViewBuilder content: @escaping (RowValue) -> Content) where S : StringProtocol

    /// Creates a sortable column for date values with a text label.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - text: The column's label.
    ///   - value: The path to the property associated with the column,
    ///     which will be used to update and reflect the sorting state in a
    ///     table.
    ///   - content: The view content to display for each row in a table.
    @available(iOS 16.6, macOS 13.5, *)
    public init(_ text: Text, value: KeyPath<RowValue, Date>, @ViewBuilder content: @escaping (RowValue) -> Content)

    /// Creates a sortable column for optional date values that generates
    /// its label from a localized string key.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the column's localized title.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - content: The view content to display for each row in a table.
    public init(_ titleKey: LocalizedStringKey, value: KeyPath<RowValue, Date?>, @ViewBuilder content: @escaping (RowValue) -> Content)

    /// Creates a sortable column for optional date values that displays a
    /// string property.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// title similar to ``Text/init(_:)``. For more information about
    /// localizing strings, see ``Text``.
    ///
    /// - Parameters:
    ///   - title: A string that describes the column.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - content: The view content to display for each row in a table.
    public init<S>(_ title: S, value: KeyPath<RowValue, Date?>, @ViewBuilder content: @escaping (RowValue) -> Content) where S : StringProtocol

    /// Creates a sortable column for optional date values with a text
    /// label.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - text: The column's label.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - content: The view content to display for each row in a table.
    @available(iOS 16.6, macOS 13.5, *)
    public init(_ text: Text, value: KeyPath<RowValue, Date?>, @ViewBuilder content: @escaping (RowValue) -> Content)

    /// Creates a sortable column for UUID values
    /// that generates its label from a localized string key.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the column's localized title.
    ///   - value: The path to the property associated with the column,
    ///     which will be used to update and reflect the sorting state in a
    ///     table.
    ///   - content: The view content to display for each row in a table.
    public init(_ titleKey: LocalizedStringKey, value: KeyPath<RowValue, UUID>, @ViewBuilder content: @escaping (RowValue) -> Content)

    /// Creates a sortable column for UUID
    /// values that displays a string property.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// title similar to ``Text/init(_:)``. For more information about
    /// localizing strings, see ``Text``.
    ///
    /// - Parameters:
    ///   - title: A string that describes the column.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - content: The view content to display for each row in a table.
    public init<S>(_ title: S, value: KeyPath<RowValue, UUID>, @ViewBuilder content: @escaping (RowValue) -> Content) where S : StringProtocol

    /// Creates a sortable column for UUID values with a text label.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - text: The column's label.
    ///   - value: The path to the property associated with the column,
    ///     which will be used to update and reflect the sorting state in a
    ///     table.
    ///   - content: The view content to display for each row in a table.
    @available(iOS 16.6, macOS 13.5, *)
    public init(_ text: Text, value: KeyPath<RowValue, UUID>, @ViewBuilder content: @escaping (RowValue) -> Content)

    /// Creates a sortable column for optional UUID values that generates
    /// its label from a localized string key.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the column's localized title.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - content: The view content to display for each row in a table.
    public init(_ titleKey: LocalizedStringKey, value: KeyPath<RowValue, UUID?>, @ViewBuilder content: @escaping (RowValue) -> Content)

    /// Creates a sortable column for optional UUID values that displays a
    /// string property.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// title similar to ``Text/init(_:)``. For more information about
    /// localizing strings, see ``Text``.
    ///
    /// - Parameters:
    ///   - title: A string that describes the column.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - content: The view content to display for each row in a table.
    public init<S>(_ title: S, value: KeyPath<RowValue, UUID?>, @ViewBuilder content: @escaping (RowValue) -> Content) where S : StringProtocol

    /// Creates a sortable column for optional UUID values with a text
    /// label.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - text: The column's label.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - content: The view content to display for each row in a table.
    @available(iOS 16.6, macOS 13.5, *)
    public init(_ text: Text, value: KeyPath<RowValue, UUID?>, @ViewBuilder content: @escaping (RowValue) -> Content)

    /// Creates a sortable column that generates its label from a localized
    /// string key.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the column's localized title.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - comparator: The specific comparator to compare string values.
    ///   - content: The view content to display for each row in a table.
    public init(_ titleKey: LocalizedStringKey, value: KeyPath<RowValue, String>, comparator: String.StandardComparator = .localizedStandard, @ViewBuilder content: @escaping (RowValue) -> Content)

    /// Creates a sortable column that displays a string property.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// title similar to ``Text/init(_:)``. For more information about
    /// localizing strings, see ``Text``.
    ///
    /// - Parameters:
    ///   - title: A string that describes the column.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - comparator: The specific comparator to compare string values.
    ///   - content: The view content to display for each row in a table.
    public init<S>(_ title: S, value: KeyPath<RowValue, String>, comparator: String.StandardComparator = .localizedStandard, @ViewBuilder content: @escaping (RowValue) -> Content) where S : StringProtocol

    /// Creates a sortable column with a text label.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - text: The column's label.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - comparator: The specific comparator to compare string values.
    ///   - content: The view content to display for each row in a table.
    @available(iOS 16.6, macOS 13.5, *)
    public init(_ text: Text, value: KeyPath<RowValue, String>, comparator: String.StandardComparator = .localizedStandard, @ViewBuilder content: @escaping (RowValue) -> Content)

    /// Creates a sortable column that generates its label from a localized
    /// string key.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the column's localized title.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - comparator: The specific comparator to compare string values.
    ///   - content: The view content to display for each row in a table.
    public init(_ titleKey: LocalizedStringKey, value: KeyPath<RowValue, String?>, comparator: String.StandardComparator = .localizedStandard, @ViewBuilder content: @escaping (RowValue) -> Content)

    /// Creates a sortable column that displays a string property.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// title similar to ``Text/init(_:)``. For more information about
    /// localizing strings, see ``Text``.
    ///
    /// - Parameters:
    ///   - title: A string that describes the column.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - comparator: The specific comparator to compare string values.
    ///   - content: The view content to display for each row in a table.
    public init<S>(_ title: S, value: KeyPath<RowValue, String?>, comparator: String.StandardComparator = .localizedStandard, @ViewBuilder content: @escaping (RowValue) -> Content) where S : StringProtocol

    /// Creates a sortable column with a text label.
    ///
    /// - Parameters:
    ///   - text: The column's label.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state.
    ///   - comparator: The specific comparator to compare string values.
    ///   - content: The view content to display for each row in a table.
    @available(iOS 16.6, macOS 13.5, *)
    public init(_ text: Text, value: KeyPath<RowValue, String?>, comparator: String.StandardComparator = .localizedStandard, @ViewBuilder content: @escaping (RowValue) -> Content)

    /// Creates an unsortable column that displays a string property, and which
    /// generates its label from a localized string key.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// ``Text`` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the column's localized title.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state and to display as verbatim
    ///     text in each row.
    ///   - comparator: The specific comparator to compare string values.
    public init(_ titleKey: LocalizedStringKey, value: KeyPath<RowValue, String>, comparator: String.StandardComparator = .localizedStandard) where Content == Text

    /// Creates a sortable column that displays a string property, and which
    /// generates its label from a string.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// title similar to ``Text/init(_:)``. For more information about
    /// localizing strings, see ``Text``.
    ///
    /// - Parameters:
    ///   - title: A string that describes the column.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state and to display as verbatim
    ///     text in each row.
    ///   - comparator: The specific comparator to compare string values.
    public init<S>(_ title: S, value: KeyPath<RowValue, String>, comparator: String.StandardComparator = .localizedStandard) where Content == Text, S : StringProtocol

    /// Creates an unsortable column that displays a string property and has a
    /// text label.
    ///
    /// - Parameters:
    ///   - text: The column's label.
    ///   - value: The path to the property associated with the column,
    ///     used to update the table's sorting state and to display as verbatim
    ///     text in each row.
    ///   - comparator: The specific comparator to compare string values.
    @available(iOS 16.6, macOS 13.5, *)
    public init(_ text: Text, value: KeyPath<RowValue, String>, comparator: String.StandardComparator = .localizedStandard) where Content == Text
}

/// Describes the alignment of the content of a table column.
///
/// The alignment of a column applies to both its header label as well as the
/// default alignment of its content view for each row.
@available(iOS 17.0, macOS 14.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct TableColumnAlignment : Hashable, Sendable {

    /// The default column alignment.
    ///
    /// This is equivalent to `leading`.
    public static var automatic: TableColumnAlignment { get }

    /// Leading column alignment.
    ///
    /// With a `layoutDirection` of `leftToRight`, this is equivalent to left;
    /// and with a `layoutDirection` of `rightToLeft`, this is equivalent to
    /// right.
    public static var leading: TableColumnAlignment { get }

    /// Center column alignment.
    public static var center: TableColumnAlignment { get }

    /// Trailing column alignment.
    ///
    /// With a `layoutDirection` of `leftToRight`, this is equivalent to right;
    /// and with a `layoutDirection` of `rightToLeft`, this is equivalent to
    /// left.
    public static var trailing: TableColumnAlignment { get }

    /// Column alignment appropriate for numeric content.
    ///
    /// Use this alignment when a table column is primarily displaying numeric
    /// content, so that the values are easy to visually scan and compare.
    ///
    /// This uses the current locale's numbering system to determine the
    /// alignment:
    /// - For left to right numbering systems, this is equivalent to right.
    /// - For right to left numbering systems, this is equivalent to left.
    public static var numeric: TableColumnAlignment { get }

    /// Column alignment appropriate for numeric content.
    ///
    /// Use this alignment when a table column is primarily displaying numeric
    /// content, so that the values are easy to visually scan and compare.
    ///
    /// This uses the provided numbering system to determine the alignment:
    /// - For left to right numbering systems, this is equivalent to right.
    /// - For right to left numbering systems, this is equivalent to left.
    public static func numeric(_ numberingSystem: Locale.NumberingSystem) -> TableColumnAlignment

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: TableColumnAlignment, b: TableColumnAlignment) -> Bool

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

/// A result builder that creates table column content from closures.
///
/// The `buildBlock` methods in this type create ``TableColumnContent``
/// instances based on the number and types of sources provided as parameters.
///
/// Don't use this type directly; instead, SwiftUI annotates the `columns`
/// parameter of the various ``Table`` initializers with the
/// `@TableColumnBuilder` annotation, implicitly calling this builder for you.
@available(iOS 16.0, macOS 12.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@resultBuilder public struct TableColumnBuilder<RowValue, Sort> where RowValue : Identifiable, Sort : SortComparator {

    /// Creates a sortable table column expression whose value and sort types
    /// match those of the builder.
    public static func buildExpression<Content, Label>(_ column: TableColumn<RowValue, Sort, Content, Label>) -> TableColumn<RowValue, Sort, Content, Label> where Content : View, Label : View

    /// Creates a sortable table column expression whose value type matches
    /// that of the builder.
    public static func buildExpression<Content, Label>(_ column: TableColumn<RowValue, Never, Content, Label>) -> TableColumn<RowValue, Never, Content, Label> where Content : View, Label : View

    /// Creates a generic, sortable single column expression.
    public static func buildExpression<Column>(_ column: Column) -> Column where RowValue == Column.TableRowValue, Sort == Column.TableColumnSortComparator, Column : TableColumnContent

    /// Creates a generic, unsortable single column expression.
    public static func buildExpression<Column>(_ column: Column) -> Column where RowValue == Column.TableRowValue, Column : TableColumnContent, Column.TableColumnSortComparator == Never

    /// Creates a single, sortable column result.
    public static func buildBlock<Column>(_ column: Column) -> Column where RowValue == Column.TableRowValue, Sort == Column.TableColumnSortComparator, Column : TableColumnContent

    /// Creates a single, unsortable column result.
    public static func buildBlock<Column>(_ column: Column) -> Column where RowValue == Column.TableRowValue, Column : TableColumnContent, Column.TableColumnSortComparator == Never
}

@available(iOS 17.4, macOS 14.4, visionOS 1.1, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension TableColumnBuilder {

    /// Creates a column result for conditional statements.
    ///
    /// This method provides support for "if" statements in multi-statement
    /// closures, producing an optional value that is visible only when the
    /// condition evaluates to `true`.
    public static func buildIf<C>(_ content: C?) -> C? where RowValue == C.TableRowValue, Sort == C.TableColumnSortComparator, C : TableColumnContent

    public static func buildIf<C>(_ content: C?) -> C? where RowValue == C.TableRowValue, C : TableColumnContent, C.TableColumnSortComparator == Never

    /// Creates a column result for the first of two column content
    /// alternatives.
    ///
    /// This method provides support for "if" statements in multi-statement
    /// closures, producing conditional content for the "then" branch.
    public static func buildEither<T, F>(first: T) -> _ConditionalContent<T, F> where RowValue == T.TableRowValue, Sort == T.TableColumnSortComparator, T : TableColumnContent, F : TableColumnContent, T.TableColumnSortComparator == F.TableColumnSortComparator, T.TableRowValue == F.TableRowValue

    public static func buildEither<T, F>(first: T) -> _ConditionalContent<T, F> where RowValue == T.TableRowValue, T : TableColumnContent, F : TableColumnContent, T.TableColumnSortComparator == Never, T.TableRowValue == F.TableRowValue, F.TableColumnSortComparator == Never

    /// Creates a row result for the second of two row content alternatives.
    ///
    /// This method provides support for "if" statements in multi-statement
    /// closures, producing conditional content for the "else" branch.
    public static func buildEither<T, F>(second: F) -> _ConditionalContent<T, F> where RowValue == T.TableRowValue, Sort == T.TableColumnSortComparator, T : TableColumnContent, F : TableColumnContent, T.TableColumnSortComparator == F.TableColumnSortComparator, T.TableRowValue == F.TableRowValue

    public static func buildEither<T, F>(second: F) -> _ConditionalContent<T, F> where RowValue == T.TableRowValue, T : TableColumnContent, F : TableColumnContent, T.TableColumnSortComparator == Never, T.TableRowValue == F.TableRowValue, F.TableColumnSortComparator == Never
}

@available(iOS 17.5, macOS 14.5, visionOS 1.2, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension TableColumnBuilder {

    public static func buildLimitedAvailability(_ content: any TableColumnContent<RowValue, Sort>) -> some TableColumnContent<RowValue, Sort>


    public static func buildLimitedAvailability(_ content: any TableColumnContent<RowValue, Never>) -> some TableColumnContent<RowValue, Never>

}

@available(iOS 16.0, macOS 12.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension TableColumnBuilder {

    /// Creates a sortable column result from two sources.
    public static func buildBlock<C0, C1>(_ c0: C0, _ c1: C1) -> TupleTableColumnContent<RowValue, Sort, (C0, C1)> where RowValue == C0.TableRowValue, C0 : TableColumnContent, C1 : TableColumnContent, C0.TableRowValue == C1.TableRowValue

    /// Creates an unsortable column result from two sources.
    public static func buildBlock<C0, C1>(_ c0: C0, _ c1: C1) -> TupleTableColumnContent<RowValue, Never, (C0, C1)> where RowValue == C0.TableRowValue, C0 : TableColumnContent, C1 : TableColumnContent, C0.TableColumnSortComparator == Never, C0.TableRowValue == C1.TableRowValue, C1.TableColumnSortComparator == Never
}

@available(iOS 16.0, macOS 12.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension TableColumnBuilder {

    /// Creates a sortable column result from three sources.
    public static func buildBlock<C0, C1, C2>(_ c0: C0, _ c1: C1, _ c2: C2) -> TupleTableColumnContent<RowValue, Sort, (C0, C1, C2)> where RowValue == C0.TableRowValue, C0 : TableColumnContent, C1 : TableColumnContent, C2 : TableColumnContent, C0.TableRowValue == C1.TableRowValue, C1.TableRowValue == C2.TableRowValue

    /// Creates an unsortable column result from three sources.
    public static func buildBlock<C0, C1, C2>(_ c0: C0, _ c1: C1, _ c2: C2) -> TupleTableColumnContent<RowValue, Never, (C0, C1, C2)> where RowValue == C0.TableRowValue, C0 : TableColumnContent, C1 : TableColumnContent, C2 : TableColumnContent, C0.TableColumnSortComparator == Never, C0.TableRowValue == C1.TableRowValue, C1.TableColumnSortComparator == Never, C1.TableRowValue == C2.TableRowValue, C2.TableColumnSortComparator == Never
}

@available(iOS 16.0, macOS 12.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension TableColumnBuilder {

    /// Creates a sortable column result from four sources.
    public static func buildBlock<C0, C1, C2, C3>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3) -> TupleTableColumnContent<RowValue, Sort, (C0, C1, C2, C3)> where RowValue == C0.TableRowValue, C0 : TableColumnContent, C1 : TableColumnContent, C2 : TableColumnContent, C3 : TableColumnContent, C0.TableRowValue == C1.TableRowValue, C1.TableRowValue == C2.TableRowValue, C2.TableRowValue == C3.TableRowValue

    /// Creates an unsortable column result from four sources.
    public static func buildBlock<C0, C1, C2, C3>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3) -> TupleTableColumnContent<RowValue, Never, (C0, C1, C2, C3)> where RowValue == C0.TableRowValue, C0 : TableColumnContent, C1 : TableColumnContent, C2 : TableColumnContent, C3 : TableColumnContent, C0.TableColumnSortComparator == Never, C0.TableRowValue == C1.TableRowValue, C1.TableColumnSortComparator == Never, C1.TableRowValue == C2.TableRowValue, C2.TableColumnSortComparator == Never, C2.TableRowValue == C3.TableRowValue, C3.TableColumnSortComparator == Never
}

@available(iOS 16.0, macOS 12.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension TableColumnBuilder {

    /// Creates a sortable column result from five sources.
    public static func buildBlock<C0, C1, C2, C3, C4>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4) -> TupleTableColumnContent<RowValue, Sort, (C0, C1, C2, C3, C4)> where RowValue == C0.TableRowValue, C0 : TableColumnContent, C1 : TableColumnContent, C2 : TableColumnContent, C3 : TableColumnContent, C4 : TableColumnContent, C0.TableRowValue == C1.TableRowValue, C1.TableRowValue == C2.TableRowValue, C2.TableRowValue == C3.TableRowValue, C3.TableRowValue == C4.TableRowValue

    /// Creates an unsortable column result from five sources.
    public static func buildBlock<C0, C1, C2, C3, C4>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4) -> TupleTableColumnContent<RowValue, Never, (C0, C1, C2, C3, C4)> where RowValue == C0.TableRowValue, C0 : TableColumnContent, C1 : TableColumnContent, C2 : TableColumnContent, C3 : TableColumnContent, C4 : TableColumnContent, C0.TableColumnSortComparator == Never, C0.TableRowValue == C1.TableRowValue, C1.TableColumnSortComparator == Never, C1.TableRowValue == C2.TableRowValue, C2.TableColumnSortComparator == Never, C2.TableRowValue == C3.TableRowValue, C3.TableColumnSortComparator == Never, C3.TableRowValue == C4.TableRowValue, C4.TableColumnSortComparator == Never
}

@available(iOS 16.0, macOS 12.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension TableColumnBuilder {

    /// Creates a sortable column result from six sources.
    public static func buildBlock<C0, C1, C2, C3, C4, C5>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5) -> TupleTableColumnContent<RowValue, Sort, (C0, C1, C2, C3, C4, C5)> where RowValue == C0.TableRowValue, C0 : TableColumnContent, C1 : TableColumnContent, C2 : TableColumnContent, C3 : TableColumnContent, C4 : TableColumnContent, C5 : TableColumnContent, C0.TableRowValue == C1.TableRowValue, C1.TableRowValue == C2.TableRowValue, C2.TableRowValue == C3.TableRowValue, C3.TableRowValue == C4.TableRowValue, C4.TableRowValue == C5.TableRowValue

    /// Creates an unsortable column result from six sources.
    public static func buildBlock<C0, C1, C2, C3, C4, C5>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5) -> TupleTableColumnContent<RowValue, Never, (C0, C1, C2, C3, C4, C5)> where RowValue == C0.TableRowValue, C0 : TableColumnContent, C1 : TableColumnContent, C2 : TableColumnContent, C3 : TableColumnContent, C4 : TableColumnContent, C5 : TableColumnContent, C0.TableColumnSortComparator == Never, C0.TableRowValue == C1.TableRowValue, C1.TableColumnSortComparator == Never, C1.TableRowValue == C2.TableRowValue, C2.TableColumnSortComparator == Never, C2.TableRowValue == C3.TableRowValue, C3.TableColumnSortComparator == Never, C3.TableRowValue == C4.TableRowValue, C4.TableColumnSortComparator == Never, C4.TableRowValue == C5.TableRowValue, C5.TableColumnSortComparator == Never
}

@available(iOS 16.0, macOS 12.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension TableColumnBuilder {

    /// Creates a sortable column result from seven sources.
    public static func buildBlock<C0, C1, C2, C3, C4, C5, C6>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5, _ c6: C6) -> TupleTableColumnContent<RowValue, Sort, (C0, C1, C2, C3, C4, C5, C6)> where RowValue == C0.TableRowValue, C0 : TableColumnContent, C1 : TableColumnContent, C2 : TableColumnContent, C3 : TableColumnContent, C4 : TableColumnContent, C5 : TableColumnContent, C6 : TableColumnContent, C0.TableRowValue == C1.TableRowValue, C1.TableRowValue == C2.TableRowValue, C2.TableRowValue == C3.TableRowValue, C3.TableRowValue == C4.TableRowValue, C4.TableRowValue == C5.TableRowValue, C5.TableRowValue == C6.TableRowValue

    /// Creates an unsortable column result from seven sources.
    public static func buildBlock<C0, C1, C2, C3, C4, C5, C6>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5, _ c6: C6) -> TupleTableColumnContent<RowValue, Never, (C0, C1, C2, C3, C4, C5, C6)> where RowValue == C0.TableRowValue, C0 : TableColumnContent, C1 : TableColumnContent, C2 : TableColumnContent, C3 : TableColumnContent, C4 : TableColumnContent, C5 : TableColumnContent, C6 : TableColumnContent, C0.TableColumnSortComparator == Never, C0.TableRowValue == C1.TableRowValue, C1.TableColumnSortComparator == Never, C1.TableRowValue == C2.TableRowValue, C2.TableColumnSortComparator == Never, C2.TableRowValue == C3.TableRowValue, C3.TableColumnSortComparator == Never, C3.TableRowValue == C4.TableRowValue, C4.TableColumnSortComparator == Never, C4.TableRowValue == C5.TableRowValue, C5.TableColumnSortComparator == Never, C5.TableRowValue == C6.TableRowValue, C6.TableColumnSortComparator == Never
}

@available(iOS 16.0, macOS 12.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension TableColumnBuilder {

    /// Creates a sortable column result from eight sources.
    public static func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5, _ c6: C6, _ c7: C7) -> TupleTableColumnContent<RowValue, Sort, (C0, C1, C2, C3, C4, C5, C6, C7)> where RowValue == C0.TableRowValue, C0 : TableColumnContent, C1 : TableColumnContent, C2 : TableColumnContent, C3 : TableColumnContent, C4 : TableColumnContent, C5 : TableColumnContent, C6 : TableColumnContent, C7 : TableColumnContent, C0.TableRowValue == C1.TableRowValue, C1.TableRowValue == C2.TableRowValue, C2.TableRowValue == C3.TableRowValue, C3.TableRowValue == C4.TableRowValue, C4.TableRowValue == C5.TableRowValue, C5.TableRowValue == C6.TableRowValue, C6.TableRowValue == C7.TableRowValue

    /// Creates an unsortable column result from eight sources.
    public static func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5, _ c6: C6, _ c7: C7) -> TupleTableColumnContent<RowValue, Never, (C0, C1, C2, C3, C4, C5, C6, C7)> where RowValue == C0.TableRowValue, C0 : TableColumnContent, C1 : TableColumnContent, C2 : TableColumnContent, C3 : TableColumnContent, C4 : TableColumnContent, C5 : TableColumnContent, C6 : TableColumnContent, C7 : TableColumnContent, C0.TableColumnSortComparator == Never, C0.TableRowValue == C1.TableRowValue, C1.TableColumnSortComparator == Never, C1.TableRowValue == C2.TableRowValue, C2.TableColumnSortComparator == Never, C2.TableRowValue == C3.TableRowValue, C3.TableColumnSortComparator == Never, C3.TableRowValue == C4.TableRowValue, C4.TableColumnSortComparator == Never, C4.TableRowValue == C5.TableRowValue, C5.TableColumnSortComparator == Never, C5.TableRowValue == C6.TableRowValue, C6.TableColumnSortComparator == Never, C6.TableRowValue == C7.TableRowValue, C7.TableColumnSortComparator == Never
}

@available(iOS 16.0, macOS 12.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension TableColumnBuilder {

    /// Creates a sortable column result from nine sources.
    public static func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7, C8>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5, _ c6: C6, _ c7: C7, _ c8: C8) -> TupleTableColumnContent<RowValue, Sort, (C0, C1, C2, C3, C4, C5, C6, C7, C8)> where RowValue == C0.TableRowValue, C0 : TableColumnContent, C1 : TableColumnContent, C2 : TableColumnContent, C3 : TableColumnContent, C4 : TableColumnContent, C5 : TableColumnContent, C6 : TableColumnContent, C7 : TableColumnContent, C8 : TableColumnContent, C0.TableRowValue == C1.TableRowValue, C1.TableRowValue == C2.TableRowValue, C2.TableRowValue == C3.TableRowValue, C3.TableRowValue == C4.TableRowValue, C4.TableRowValue == C5.TableRowValue, C5.TableRowValue == C6.TableRowValue, C6.TableRowValue == C7.TableRowValue, C7.TableRowValue == C8.TableRowValue

    /// Creates an unsortable column result from nine sources.
    public static func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7, C8>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5, _ c6: C6, _ c7: C7, _ c8: C8) -> TupleTableColumnContent<RowValue, Never, (C0, C1, C2, C3, C4, C5, C6, C7, C8)> where RowValue == C0.TableRowValue, C0 : TableColumnContent, C1 : TableColumnContent, C2 : TableColumnContent, C3 : TableColumnContent, C4 : TableColumnContent, C5 : TableColumnContent, C6 : TableColumnContent, C7 : TableColumnContent, C8 : TableColumnContent, C0.TableColumnSortComparator == Never, C0.TableRowValue == C1.TableRowValue, C1.TableColumnSortComparator == Never, C1.TableRowValue == C2.TableRowValue, C2.TableColumnSortComparator == Never, C2.TableRowValue == C3.TableRowValue, C3.TableColumnSortComparator == Never, C3.TableRowValue == C4.TableRowValue, C4.TableColumnSortComparator == Never, C4.TableRowValue == C5.TableRowValue, C5.TableColumnSortComparator == Never, C5.TableRowValue == C6.TableRowValue, C6.TableColumnSortComparator == Never, C6.TableRowValue == C7.TableRowValue, C7.TableColumnSortComparator == Never, C7.TableRowValue == C8.TableRowValue, C8.TableColumnSortComparator == Never
}

@available(iOS 16.0, macOS 12.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension TableColumnBuilder {

    /// Creates a sortable column result from ten sources.
    public static func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7, C8, C9>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5, _ c6: C6, _ c7: C7, _ c8: C8, _ c9: C9) -> TupleTableColumnContent<RowValue, Sort, (C0, C1, C2, C3, C4, C5, C6, C7, C8, C9)> where RowValue == C0.TableRowValue, C0 : TableColumnContent, C1 : TableColumnContent, C2 : TableColumnContent, C3 : TableColumnContent, C4 : TableColumnContent, C5 : TableColumnContent, C6 : TableColumnContent, C7 : TableColumnContent, C8 : TableColumnContent, C9 : TableColumnContent, C0.TableRowValue == C1.TableRowValue, C1.TableRowValue == C2.TableRowValue, C2.TableRowValue == C3.TableRowValue, C3.TableRowValue == C4.TableRowValue, C4.TableRowValue == C5.TableRowValue, C5.TableRowValue == C6.TableRowValue, C6.TableRowValue == C7.TableRowValue, C7.TableRowValue == C8.TableRowValue, C8.TableRowValue == C9.TableRowValue

    /// Creates an unsortable column result from ten sources.
    public static func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7, C8, C9>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5, _ c6: C6, _ c7: C7, _ c8: C8, _ c9: C9) -> TupleTableColumnContent<RowValue, Never, (C0, C1, C2, C3, C4, C5, C6, C7, C8, C9)> where RowValue == C0.TableRowValue, C0 : TableColumnContent, C1 : TableColumnContent, C2 : TableColumnContent, C3 : TableColumnContent, C4 : TableColumnContent, C5 : TableColumnContent, C6 : TableColumnContent, C7 : TableColumnContent, C8 : TableColumnContent, C9 : TableColumnContent, C0.TableColumnSortComparator == Never, C0.TableRowValue == C1.TableRowValue, C1.TableColumnSortComparator == Never, C1.TableRowValue == C2.TableRowValue, C2.TableColumnSortComparator == Never, C2.TableRowValue == C3.TableRowValue, C3.TableColumnSortComparator == Never, C3.TableRowValue == C4.TableRowValue, C4.TableColumnSortComparator == Never, C4.TableRowValue == C5.TableRowValue, C5.TableColumnSortComparator == Never, C5.TableRowValue == C6.TableRowValue, C6.TableColumnSortComparator == Never, C6.TableRowValue == C7.TableRowValue, C7.TableColumnSortComparator == Never, C7.TableRowValue == C8.TableRowValue, C8.TableColumnSortComparator == Never, C8.TableRowValue == C9.TableRowValue, C9.TableColumnSortComparator == Never
}

/// A type used to represent columns within a table.
///
/// This type provides the body content of the column, as well as the types
/// of the column's row values and the comparator used to sort rows.
///
/// You can factor column content out into separate types or properties, or
/// by creating a custom type conforming to `TableColumnContent`.
///
///     var body: some View {
///         Table(people, selection: $selectedPeople, sortOrder: $sortOrder) {
///             nameColumns
///
///             TableColumn("Location", value: \.location) {
///                 LocationView($0.location)
///             }
///         }
///     }
///
///     @TableColumnBuilder<Person, KeyPathComparator<Person>>
///     private var nameColumns: some TableColumnContent<
///         Person, KeyPathComparator<Person>
///     > {
///         TableColumn("First Name", value: \.firstName) {
///             PrimaryColumnView(person: $0)
///         }
///         TableColumn("Last Name", value: \.lastName)
///         TableColumn("Nickname", value: \.nickname)
///     }
///
/// The above example factors three table columns into a separate computed
/// property that has an opaque type. The property's primary associated
/// type `TableRowValue` is a `Person` and its associated type
/// `TableColumnSortComparator` is a key comparator for the `Person` type.
@available(iOS 16.0, macOS 12.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@MainActor @preconcurrency public protocol TableColumnContent<TableRowValue, TableColumnSortComparator> {

    /// The type of value of rows presented by this column content.
    associatedtype TableRowValue : Identifiable = Self.TableColumnBody.TableRowValue

    /// The type of sort comparator associated with this table column content.
    associatedtype TableColumnSortComparator : SortComparator = Self.TableColumnBody.TableColumnSortComparator

    /// The type of content representing the body of this table column content.
    associatedtype TableColumnBody : TableColumnContent

    /// The composition of content that comprise the table column content.
    nonisolated var tableColumnBody: Self.TableColumnBody { get }
}

@available(iOS 17.0, macOS 14.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension TableColumnContent {

    /// Sets the default visibility of a table column.
    ///
    /// A `hidden` column will not be visible, unless the `Table` is also bound
    /// to `TableColumnCustomization` and either modified programmatically or by
    /// the user.
    ///
    /// - Parameter visibility: The default visibility to apply to columns.
    @MainActor @preconcurrency public func defaultVisibility(_ visibility: Visibility) -> some TableColumnContent<Self.TableRowValue, Self.TableColumnSortComparator>


    /// Sets the identifier to be associated with a column when persisting its
    /// state with `TableColumnCustomization`.
    ///
    /// This is required to allow user customization of a specific table column,
    /// in addition to the table as a whole being provided a binding to a
    /// `TableColumnCustomization`.
    ///
    /// The identifier needs to to be stable, including across app version
    /// updates, since it is used to persist the user customization.
    ///
    /// - Parameter id: The identifier to associate with a column.
    @MainActor @preconcurrency public func customizationID(_ id: String) -> some TableColumnContent<Self.TableRowValue, Self.TableColumnSortComparator>


    /// Sets the disabled customization behavior for a table column.
    ///
    /// When the containing `Table` is bound to some `TableColumnCustomization`,
    /// all columns will be able to be customized by the user on macOS by
    /// default (i.e. `TableColumnCustomizationBehavior.all`). This
    /// modifier allows disabling specific behavior.
    ///
    /// This modifier has no effect on iOS since `Table` does not support any
    /// built-in user customization features.
    ///
    /// This does not prevent programmatic changes to a table column
    /// customization.
    ///
    /// - Parameter behavior: The behavior to disable, or `.all` to not allow
    ///   any customization.
    @MainActor @preconcurrency public func disabledCustomizationBehavior(_ behavior: TableColumnCustomizationBehavior) -> some TableColumnContent<Self.TableRowValue, Self.TableColumnSortComparator>

}

@available(iOS 17.0, macOS 14.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension TableColumnContent {

    /// Sets the alignment of the column, applying to both its column header
    /// label and the row view content for that column.
    ///
    /// - Parameter alignment: The alignment to apply to the column.
    @MainActor @preconcurrency public func alignment(_ alignment: TableColumnAlignment) -> some TableColumnContent<Self.TableRowValue, Self.TableColumnSortComparator>

}

/// A representation of the state of the columns in a table.
///
/// `TableColumnCustomization` can be created and provided to a table to enable
/// column reordering and column visibility. The state can be queried and
/// updated programmatically, as well as bound to persistent app or scene
/// storage.
///
///     struct BugReportTable: View {
///         @ObservedObject var dataModel: DataModel
///         @Binding var selectedBugReports: Set<BugReport.ID>
///
///         @SceneStorage("BugReportTableConfig")
///         private var columnCustomization: TableColumnCustomization<BugReport>
///
///         var body: some View {
///             Table(dataModel.bugReports, selection: $selectedBugReports,
///                 sortOrder: $dataModel.sortOrder,
///                 columnCustomization: $columnCustomization
///             ) {
///                 TableColumn("Title", value: \.title)
///                     .customizationID("title")
///                 TableColumn("ID", value: \.id) {
///                     Link("\($0.id)", destination: $0.url)
///                 }
///                 .customizationID("id")
///                 TableColumn("Number of Reports", value: \.duplicateCount) {
///                     Text($0.duplicateCount, format: .number)
///                 }
///                 .customizationID("duplicates")
///             }
///         }
///     }
///
/// The above example creates a table with three columns. On macOS, these
/// columns can be reordered or hidden and shown by the user of the app.
/// Their configuration will be saved and restored with the window on relaunches
/// of the app, using the "BugReportTableConfig" scene storage identifier.
///
/// The state of a specific column is stored relative to its customization
/// identifier, using using the value from the
/// ``TableColumnContent/customizationID(_:)`` modifier.
/// When column customization is encoded and decoded, it relies on stable
/// identifiers to restore the associate the saved state with a specific column.
/// If a table column does not have a customization identifier, it will not
/// be customizable.
///
/// These identifiers can also be used to programmatically change column
/// customizations, such as programmatically hiding a column:
///
///     columnCustomization[visibility: "duplicates"] = .hidden
///
/// With a binding to the overall customization, a binding to the visibility
/// of a column can be accessed using the same subscript syntax:
///
///     struct BugReportTable: View {
///         @SceneStorage("BugReportTableConfig")
///         private var columnCustomization: TableColumnCustomization<BugReport>
///
///         var body: some View {
///             ...
///             MyVisibilityView($columnCustomization[visibility: "duplicates"])
///         }
///     }
///
///     struct MyVisibilityView: View {
///         @Binding var visibility: Visibility
///         ...
///     }
///
@available(iOS 17.0, macOS 14.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct TableColumnCustomization<RowValue> : Equatable, Sendable, Codable where RowValue : Identifiable {

    /// Creates an empty table column customization.
    ///
    /// With an empty customization, columns will be ordered as described by the
    /// table's column builder.
    public init()

    /// The visibility of the column identified by its identifier.
    ///
    /// Explicit identifiers can be associated with a `TableColumn` using the
    /// `customizationID(_:)` modifier.
    ///
    ///     TableColumn("Number of Reports", value: \.duplicateCount) {
    ///         Text($0.duplicateCount, format: .number)
    ///     }
    ///     .customizationID("numberOfReports")
    ///
    ///     ...
    ///
    ///     columnsCustomization[visibility: "numberOfReports"] = .hidden
    ///
    /// If the ID isn't associated with the state, a default value of
    /// `.automatic` is returned.
    public subscript(visibility id: String) -> Visibility

    /// Resets the column order back to the default, preserving the customized
    /// visibility and size.
    ///
    /// Tables that are bound to this state will order their columns as
    /// described by their column builder.
    public mutating func resetOrder()

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: TableColumnCustomization<RowValue>, b: TableColumnCustomization<RowValue>) -> Bool

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

/// A set of customization behaviors of a column that a table can offer to
/// a user.
///
/// This is used as a value provided to
/// ``TableColumnContent/disabledCustomizationBehavior(_:)``.
///
/// Setting any of these values as the `disabledCustomizationBehavior(_:)`
/// doesn't have any effect on iOS.
@available(iOS 17.0, macOS 14.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct TableColumnCustomizationBehavior : SetAlgebra, Sendable {

    /// A type for which the conforming type provides a containment test.
    public typealias Element = TableColumnCustomizationBehavior

    /// Creates an empty customization behavior, representing no customization
    public init()

    /// All customization behaviors.
    public static var all: TableColumnCustomizationBehavior { get }

    /// A behavior that allows the column to be reordered by the user.
    public static let reorder: TableColumnCustomizationBehavior

    /// A behavior that allows the column to be resized by the user.
    public static let resize: TableColumnCustomizationBehavior

    /// A behavior that allows the column to be hidden or revealed by the user.
    public static let visibility: TableColumnCustomizationBehavior

    /// Returns a Boolean value that indicates whether the given element exists
    /// in the set.
    ///
    /// This example uses the `contains(_:)` method to test whether an integer is
    /// a member of a set of prime numbers.
    ///
    ///     let primes: Set = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]
    ///     let x = 5
    ///     if primes.contains(x) {
    ///         print("\(x) is prime!")
    ///     } else {
    ///         print("\(x). Not prime.")
    ///     }
    ///     // Prints "5 is prime!"
    ///
    /// - Parameter member: An element to look for in the set.
    /// - Returns: `true` if `member` exists in the set; otherwise, `false`.
    public func contains(_ member: TableColumnCustomizationBehavior.Element) -> Bool

    /// Returns a new set with the elements of both this and the given set.
    ///
    /// In the following example, the `attendeesAndVisitors` set is made up
    /// of the elements of the `attendees` and `visitors` sets:
    ///
    ///     let attendees: Set = ["Alicia", "Bethany", "Diana"]
    ///     let visitors = ["Marcia", "Nathaniel"]
    ///     let attendeesAndVisitors = attendees.union(visitors)
    ///     print(attendeesAndVisitors)
    ///     // Prints "["Diana", "Nathaniel", "Bethany", "Alicia", "Marcia"]"
    ///
    /// If the set already contains one or more elements that are also in
    /// `other`, the existing members are kept.
    ///
    ///     let initialIndices = Set(0..<5)
    ///     let expandedIndices = initialIndices.union([2, 3, 6, 7])
    ///     print(expandedIndices)
    ///     // Prints "[2, 4, 6, 7, 0, 1, 3]"
    ///
    /// - Parameter other: A set of the same type as the current set.
    /// - Returns: A new set with the unique elements of this set and `other`.
    ///
    /// - Note: if this set and `other` contain elements that are equal but
    ///   distinguishable (e.g. via `===`), which of these elements is present
    ///   in the result is unspecified.
    public func union(_ other: TableColumnCustomizationBehavior) -> TableColumnCustomizationBehavior

    /// Returns a new set with the elements that are common to both this set and
    /// the given set.
    ///
    /// In the following example, the `bothNeighborsAndEmployees` set is made up
    /// of the elements that are in *both* the `employees` and `neighbors` sets.
    /// Elements that are in only one or the other are left out of the result of
    /// the intersection.
    ///
    ///     let employees: Set = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    ///     let neighbors: Set = ["Bethany", "Eric", "Forlani", "Greta"]
    ///     let bothNeighborsAndEmployees = employees.intersection(neighbors)
    ///     print(bothNeighborsAndEmployees)
    ///     // Prints "["Bethany", "Eric"]"
    ///
    /// - Parameter other: A set of the same type as the current set.
    /// - Returns: A new set.
    ///
    /// - Note: if this set and `other` contain elements that are equal but
    ///   distinguishable (e.g. via `===`), which of these elements is present
    ///   in the result is unspecified.
    public func intersection(_ other: TableColumnCustomizationBehavior) -> TableColumnCustomizationBehavior

    /// Returns a new set with the elements that are either in this set or in the
    /// given set, but not in both.
    ///
    /// In the following example, the `eitherNeighborsOrEmployees` set is made up
    /// of the elements of the `employees` and `neighbors` sets that are not in
    /// both `employees` *and* `neighbors`. In particular, the names `"Bethany"`
    /// and `"Eric"` do not appear in `eitherNeighborsOrEmployees`.
    ///
    ///     let employees: Set = ["Alicia", "Bethany", "Diana", "Eric"]
    ///     let neighbors: Set = ["Bethany", "Eric", "Forlani"]
    ///     let eitherNeighborsOrEmployees = employees.symmetricDifference(neighbors)
    ///     print(eitherNeighborsOrEmployees)
    ///     // Prints "["Diana", "Forlani", "Alicia"]"
    ///
    /// - Parameter other: A set of the same type as the current set.
    /// - Returns: A new set.
    public func symmetricDifference(_ other: TableColumnCustomizationBehavior) -> TableColumnCustomizationBehavior

    /// Inserts the given element in the set if it is not already present.
    ///
    /// If an element equal to `newMember` is already contained in the set, this
    /// method has no effect. In this example, a new element is inserted into
    /// `classDays`, a set of days of the week. When an existing element is
    /// inserted, the `classDays` set does not change.
    ///
    ///     enum DayOfTheWeek: Int {
    ///         case sunday, monday, tuesday, wednesday, thursday,
    ///             friday, saturday
    ///     }
    ///
    ///     var classDays: Set<DayOfTheWeek> = [.wednesday, .friday]
    ///     print(classDays.insert(.monday))
    ///     // Prints "(true, .monday)"
    ///     print(classDays)
    ///     // Prints "[.friday, .wednesday, .monday]"
    ///
    ///     print(classDays.insert(.friday))
    ///     // Prints "(false, .friday)"
    ///     print(classDays)
    ///     // Prints "[.friday, .wednesday, .monday]"
    ///
    /// - Parameter newMember: An element to insert into the set.
    /// - Returns: `(true, newMember)` if `newMember` was not contained in the
    ///   set. If an element equal to `newMember` was already contained in the
    ///   set, the method returns `(false, oldMember)`, where `oldMember` is the
    ///   element that was equal to `newMember`. In some cases, `oldMember` may
    ///   be distinguishable from `newMember` by identity comparison or some
    ///   other means.
    public mutating func insert(_ newMember: TableColumnCustomizationBehavior.Element) -> (inserted: Bool, memberAfterInsert: TableColumnCustomizationBehavior.Element)

    /// Removes the given element and any elements subsumed by the given element.
    ///
    /// - Parameter member: The element of the set to remove.
    /// - Returns: For ordinary sets, an element equal to `member` if `member` is
    ///   contained in the set; otherwise, `nil`. In some cases, a returned
    ///   element may be distinguishable from `member` by identity comparison
    ///   or some other means.
    ///
    ///   For sets where the set type and element type are the same, like
    ///   `OptionSet` types, this method returns any intersection between the set
    ///   and `[member]`, or `nil` if the intersection is empty.
    public mutating func remove(_ member: TableColumnCustomizationBehavior.Element) -> TableColumnCustomizationBehavior.Element?

    /// Inserts the given element into the set unconditionally.
    ///
    /// If an element equal to `newMember` is already contained in the set,
    /// `newMember` replaces the existing element. In this example, an existing
    /// element is inserted into `classDays`, a set of days of the week.
    ///
    ///     enum DayOfTheWeek: Int {
    ///         case sunday, monday, tuesday, wednesday, thursday,
    ///             friday, saturday
    ///     }
    ///
    ///     var classDays: Set<DayOfTheWeek> = [.monday, .wednesday, .friday]
    ///     print(classDays.update(with: .monday))
    ///     // Prints "Optional(.monday)"
    ///
    /// - Parameter newMember: An element to insert into the set.
    /// - Returns: For ordinary sets, an element equal to `newMember` if the set
    ///   already contained such a member; otherwise, `nil`. In some cases, the
    ///   returned element may be distinguishable from `newMember` by identity
    ///   comparison or some other means.
    ///
    ///   For sets where the set type and element type are the same, like
    ///   `OptionSet` types, this method returns any intersection between the 
    ///   set and `[newMember]`, or `nil` if the intersection is empty.
    public mutating func update(with newMember: TableColumnCustomizationBehavior.Element) -> TableColumnCustomizationBehavior.Element?

    /// Adds the elements of the given set to the set.
    ///
    /// In the following example, the elements of the `visitors` set are added to
    /// the `attendees` set:
    ///
    ///     var attendees: Set = ["Alicia", "Bethany", "Diana"]
    ///     let visitors: Set = ["Diana", "Marcia", "Nathaniel"]
    ///     attendees.formUnion(visitors)
    ///     print(attendees)
    ///     // Prints "["Diana", "Nathaniel", "Bethany", "Alicia", "Marcia"]"
    ///
    /// If the set already contains one or more elements that are also in
    /// `other`, the existing members are kept.
    ///
    ///     var initialIndices = Set(0..<5)
    ///     initialIndices.formUnion([2, 3, 6, 7])
    ///     print(initialIndices)
    ///     // Prints "[2, 4, 6, 7, 0, 1, 3]"
    ///
    /// - Parameter other: A set of the same type as the current set.
    public mutating func formUnion(_ other: TableColumnCustomizationBehavior)

    /// Removes the elements of this set that aren't also in the given set.
    ///
    /// In the following example, the elements of the `employees` set that are
    /// not also members of the `neighbors` set are removed. In particular, the
    /// names `"Alicia"`, `"Chris"`, and `"Diana"` are removed.
    ///
    ///     var employees: Set = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    ///     let neighbors: Set = ["Bethany", "Eric", "Forlani", "Greta"]
    ///     employees.formIntersection(neighbors)
    ///     print(employees)
    ///     // Prints "["Bethany", "Eric"]"
    ///
    /// - Parameter other: A set of the same type as the current set.
    public mutating func formIntersection(_ other: TableColumnCustomizationBehavior)

    /// Removes the elements of the set that are also in the given set and adds
    /// the members of the given set that are not already in the set.
    ///
    /// In the following example, the elements of the `employees` set that are
    /// also members of `neighbors` are removed from `employees`, while the
    /// elements of `neighbors` that are not members of `employees` are added to
    /// `employees`. In particular, the names `"Bethany"` and `"Eric"` are
    /// removed from `employees` while the name `"Forlani"` is added.
    ///
    ///     var employees: Set = ["Alicia", "Bethany", "Diana", "Eric"]
    ///     let neighbors: Set = ["Bethany", "Eric", "Forlani"]
    ///     employees.formSymmetricDifference(neighbors)
    ///     print(employees)
    ///     // Prints "["Diana", "Forlani", "Alicia"]"
    ///
    /// - Parameter other: A set of the same type.
    public mutating func formSymmetricDifference(_ other: TableColumnCustomizationBehavior)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: TableColumnCustomizationBehavior, b: TableColumnCustomizationBehavior) -> Bool

    /// The type of the elements of an array literal.
    @available(iOS 17.0, macOS 14.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias ArrayLiteralElement = TableColumnCustomizationBehavior.Element
}

/// A structure that computes columns on demand from an underlying collection of
/// identified data.
///
/// Use `TableColumnForEach` to create columns based on a
/// <doc://com.apple.documentation/documentation/Swift/RandomAccessCollection>
/// of some data type. Either the collection's elements must conform to
/// <doc://com.apple.documentation/documentation/Swift/Identifiable> or you
/// need to provide an `id` parameter to the `TableColumnForEach` initializer.
///
/// The following example shows the interface for an `AudioSampleTrack`, which h
/// as a collection of `AudioSample` across a dynamic number of `AudioChannel`s.
/// The `Table` is created for displaying rows for each sample. It has one
/// static column for the sample's timestamp and uses a `TableColumnForEach`
/// instance to produce a column for each of the audio channels in the track.
///
///     struct AudioChannel: Identifiable {
///         let name: String
///         let id: UUID
///     }
///
///     struct AudioSample: Identifiable {
///         let id: UUID
///         let timestamp: TimeInterval
///         func level(channel: AudioChannel.ID) -> Double
///     }
///
///     @Observable
///     class AudioSampleTrack {
///         let channels: [AudioChannel]
///         var samples: some RandomAccessCollection<AudioSample> { get }
///     }
///
///     struct ContentView: View {
///         var track: AudioSampleTrack
///
///         var body: some View {
///             Table(track.samples) {
///                 TableColumn("Timestamp (ms)") { sample in
///                     Text(sample.timestamp, format: .number.scale(1000))
///                         .monospacedDigit()
///                 }
///                 TableColumnForEach(track.channels) { channel in
///                     TableColumn(channel.name) { sample in
///                         Text(sample.level(channel: channel.id),
///                              format: .number.precision(.fractionLength(2))
///                         )
///                         .monospacedDigit()
///                     }
///                     .width(ideal: 70)
///                     .alignment(.numeric)
///                 }
///             }
///         }
///     }
///
@available(iOS 17.4, macOS 14.4, visionOS 1.1, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct TableColumnForEach<Data, ID, RowValue, Sort, Content> : TableColumnContent where Data : RandomAccessCollection, ID : Hashable, RowValue == Content.TableRowValue, Sort == Content.TableColumnSortComparator, Content : TableColumnContent {

    /// The type of value of rows presented by this column content.
    public typealias TableRowValue = RowValue

    /// The type of sort comparator associated with this table column content.
    public typealias TableColumnSortComparator = Sort

    /// The type of content representing the body of this table column content.
    public typealias TableColumnBody = Never

    /// The collection of underlying identified data that SwiftUI uses to create
    /// columns dynamically.
    public var data: Data

    /// A function to create content on demand using the underlying data.
    public var content: (Data.Element) -> Content

    /// Creates an instance that uniquely identifies and creates table columns
    /// across updates based on the identity of the underlying data.
    ///
    /// - Parameters:
    ///   - data: The identified data that the ``TableColumnForEach`` instance
    ///     uses to create table columns dynamically.
    ///   - content: The table column builder that creates columns dynamically
    ///     for each element.
    public init(_ data: Data, @TableColumnBuilder<TableColumnForEach<Data, ID, RowValue, Sort, Content>.TableRowValue, TableColumnForEach<Data, ID, RowValue, Sort, Content>.TableColumnSortComparator> content: @escaping (Data.Element) -> Content) where ID == Data.Element.ID, Data.Element : Identifiable

    /// Creates an instance that uniquely identifies and creates table columns
    /// across updates based on the provided key path to the underlying data's
    /// identifier.
    ///
    /// - Parameters:
    ///   - data: The data that the ``TableColumnForEach`` instance uses to
    ///     create table columns dynamically.
    ///   - id: The key path to the provided data's identifier.
    ///   - content: The table column builder that creates columns dynamically
    ///     for each element.
    public init(_ data: Data, id: KeyPath<Data.Element, ID>, @TableColumnBuilder<TableColumnForEach<Data, ID, RowValue, Sort, Content>.TableRowValue, TableColumnForEach<Data, ID, RowValue, Sort, Content>.TableColumnSortComparator> content: @escaping (Data.Element) -> Content)

    /// Creates an instance that computes table columns on demand over a given
    /// constant range.
    ///
    /// The instance only reads the initial value of the provided `data` and
    /// doesn't need to identify columns across updates. To compute columns on
    /// demand over a dynamic range, use
    /// ``TableColumnForEach/init(_:id:content:)``.
    ///
    /// - Parameters:
    ///   - data: A constant range.
    ///   - content: The table column builder that creates columns based on the
    ///     range index.
    public init(_ data: Range<Int>, @TableColumnBuilder<TableColumnForEach<Range<Int>, Int, RowValue, Sort, Content>.TableRowValue, TableColumnForEach<Range<Int>, Int, RowValue, Sort, Content>.TableColumnSortComparator> content: @escaping (Int) -> Content) where Data == Range<Int>, ID == Int
}

/// A type of table row content that creates table rows created by iterating
/// over a collection.
///
/// You don't use this type directly. The various `Table.init(_:,...)`
/// initializers create this type as the table's `Rows` generic type.
///
/// To explicitly create dynamic collection-based rows, use ``ForEach`` instead.
@available(iOS 16.0, macOS 12.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct TableForEachContent<Data> : TableRowContent where Data : RandomAccessCollection, Data.Element : Identifiable {

    /// The type of value represented by this table row content.
    public typealias TableRowValue = Data.Element

    /// The composition of content that comprise the table row content.
    @MainActor @preconcurrency public var tableRowBody: some TableRowContent { get }

    /// The type of content representing the body of this table row content.
    @available(iOS 16.0, macOS 12.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias TableRowBody = some TableRowContent
}

/// A table row that displays a single view instead of columned content.
///
/// You do not create this type directly. The framework creates it on your
/// behalf.
@available(iOS 16.0, macOS 13.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct TableHeaderRowContent<Value, Content> : TableRowContent where Value : Identifiable, Content : View {

    /// The type of value represented by this table row content.
    public typealias TableRowValue = Value

    /// The composition of content that comprise the table row content.
    @MainActor @preconcurrency public var tableRowBody: some TableRowContent { get }

    /// The type of content representing the body of this table row content.
    @available(iOS 16.0, macOS 13.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias TableRowBody = some TableRowContent
}

/// An opaque table row type created by a table's hierarchical initializers.
///
/// This row content is created by `Table.init(_:,children:,...)` initializers
/// as the table's `Rows` generic type.
///
/// To explicitly create hierarchical rows, use ``OutlineGroup`` instead.
@available(iOS 17.0, macOS 14.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct TableOutlineGroupContent<Data> : TableRowContent where Data : RandomAccessCollection, Data.Element : Identifiable {

    /// The type of value represented by this table row content.
    public typealias TableRowValue = Data.Element

    /// The composition of content that comprise the table row content.
    @MainActor @preconcurrency public var tableRowBody: some TableRowContent { get }

    /// The type of content representing the body of this table row content.
    @available(iOS 17.0, macOS 14.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias TableRowBody = some TableRowContent
}

/// A row that represents a data value in a table.
///
/// Create instances of ``TableRow`` in the closure you provide to the
/// `rows` parameter in ``Table`` initializers that take columns and rows.
/// The table provides the value of a row to each column of a table, which produces
/// the cells for each row in the column.
@available(iOS 16.0, macOS 12.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct TableRow<Value> : TableRowContent where Value : Identifiable {

    /// The type of value represented by this table row content.
    public typealias TableRowValue = Value

    /// The type of content representing the body of this table row content.
    public typealias TableRowBody = Never

    /// Creates a table row for the given value.
    ///
    /// The table provides the value of a row to each column of a table,
    /// which produces the cells for each row in the column.
    ///
    /// The following example creates a row for one instance of the `Person`
    /// type. The table delivers this value to its columns, which
    /// displays different fields of `Person`.
    ///
    ///      TableRow(Person(givenName: "Tom", familyName: "Clark"))
    ///
    /// - Parameter value: The value of the row.
    public init(_ value: Value)
}

/// A result builder that creates table row content from closures.
///
/// The `buildBlock` methods in this type create ``TableRowContent``
/// instances based on the number and types of sources provided as parameters.
///
/// Don't use this type directly; instead, SwiftUI annotates the `rows`
/// parameter of the various ``Table`` initializers with the
/// `@TableRowBuilder` annotation, implicitly calling this builder for you.
@available(iOS 16.0, macOS 12.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@resultBuilder public struct TableRowBuilder<Value> where Value : Identifiable {

    /// Builds an expression within the builder.
    public static func buildExpression<Content>(_ content: Content) -> Content where Value == Content.TableRowValue, Content : TableRowContent

    /// Creates a single row result.
    public static func buildBlock<C>(_ content: C) -> C where Value == C.TableRowValue, C : TableRowContent
}

@available(iOS 16.0, macOS 13.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension TableRowBuilder {

    /// Creates a row result for conditional statements.
    ///
    /// This method provides support for "if" statements in multi-statement
    /// closures, producing an optional value that is visible only when the
    /// condition evaluates to `true`.
    public static func buildIf<C>(_ content: C?) -> C? where Value == C.TableRowValue, C : TableRowContent

    /// Creates a row result for the first of two row content alternatives.
    ///
    /// This method provides support for "if" statements in multi-statement
    /// closures, producing conditional content for the "then" branch.
    public static func buildEither<T, F>(first: T) -> _ConditionalContent<T, F> where Value == T.TableRowValue, T : TableRowContent, F : TableRowContent, T.TableRowValue == F.TableRowValue

    /// Creates a row result for the second of two row content alternatives.
    ///
    /// This method provides support for "if" statements in multi-statement
    /// closures, producing conditional content for the "else" branch.
    public static func buildEither<T, F>(second: F) -> _ConditionalContent<T, F> where Value == T.TableRowValue, T : TableRowContent, F : TableRowContent, T.TableRowValue == F.TableRowValue
}

@available(iOS 16.0, macOS 12.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension TableRowBuilder {

    /// Creates a row result from two sources.
    public static func buildBlock<C0, C1>(_ c0: C0, _ c1: C1) -> TupleTableRowContent<Value, (C0, C1)> where Value == C0.TableRowValue, C0 : TableRowContent, C1 : TableRowContent, C0.TableRowValue == C1.TableRowValue
}

@available(iOS 16.0, macOS 12.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension TableRowBuilder {

    /// Creates a row result from three sources.
    public static func buildBlock<C0, C1, C2>(_ c0: C0, _ c1: C1, _ c2: C2) -> TupleTableRowContent<Value, (C0, C1, C2)> where Value == C0.TableRowValue, C0 : TableRowContent, C1 : TableRowContent, C2 : TableRowContent, C0.TableRowValue == C1.TableRowValue, C1.TableRowValue == C2.TableRowValue
}

@available(iOS 16.0, macOS 12.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension TableRowBuilder {

    /// Creates a row result from four sources.
    public static func buildBlock<C0, C1, C2, C3>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3) -> TupleTableRowContent<Value, (C0, C1, C2, C3)> where Value == C0.TableRowValue, C0 : TableRowContent, C1 : TableRowContent, C2 : TableRowContent, C3 : TableRowContent, C0.TableRowValue == C1.TableRowValue, C1.TableRowValue == C2.TableRowValue, C2.TableRowValue == C3.TableRowValue
}

@available(iOS 16.0, macOS 12.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension TableRowBuilder {

    /// Creates a row result from five sources.
    public static func buildBlock<C0, C1, C2, C3, C4>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4) -> TupleTableRowContent<Value, (C0, C1, C2, C3, C4)> where Value == C0.TableRowValue, C0 : TableRowContent, C1 : TableRowContent, C2 : TableRowContent, C3 : TableRowContent, C4 : TableRowContent, C0.TableRowValue == C1.TableRowValue, C1.TableRowValue == C2.TableRowValue, C2.TableRowValue == C3.TableRowValue, C3.TableRowValue == C4.TableRowValue
}

@available(iOS 16.0, macOS 12.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension TableRowBuilder {

    /// Creates a row result from six sources.
    public static func buildBlock<C0, C1, C2, C3, C4, C5>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5) -> TupleTableRowContent<Value, (C0, C1, C2, C3, C4, C5)> where Value == C0.TableRowValue, C0 : TableRowContent, C1 : TableRowContent, C2 : TableRowContent, C3 : TableRowContent, C4 : TableRowContent, C5 : TableRowContent, C0.TableRowValue == C1.TableRowValue, C1.TableRowValue == C2.TableRowValue, C2.TableRowValue == C3.TableRowValue, C3.TableRowValue == C4.TableRowValue, C4.TableRowValue == C5.TableRowValue
}

@available(iOS 16.0, macOS 12.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension TableRowBuilder {

    /// Creates a row result from seven sources.
    public static func buildBlock<C0, C1, C2, C3, C4, C5, C6>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5, _ c6: C6) -> TupleTableRowContent<Value, (C0, C1, C2, C3, C4, C5, C6)> where Value == C0.TableRowValue, C0 : TableRowContent, C1 : TableRowContent, C2 : TableRowContent, C3 : TableRowContent, C4 : TableRowContent, C5 : TableRowContent, C6 : TableRowContent, C0.TableRowValue == C1.TableRowValue, C1.TableRowValue == C2.TableRowValue, C2.TableRowValue == C3.TableRowValue, C3.TableRowValue == C4.TableRowValue, C4.TableRowValue == C5.TableRowValue, C5.TableRowValue == C6.TableRowValue
}

@available(iOS 16.0, macOS 12.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension TableRowBuilder {

    /// Creates a row result from eight sources.
    public static func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5, _ c6: C6, _ c7: C7) -> TupleTableRowContent<Value, (C0, C1, C2, C3, C4, C5, C6, C7)> where Value == C0.TableRowValue, C0 : TableRowContent, C1 : TableRowContent, C2 : TableRowContent, C3 : TableRowContent, C4 : TableRowContent, C5 : TableRowContent, C6 : TableRowContent, C7 : TableRowContent, C0.TableRowValue == C1.TableRowValue, C1.TableRowValue == C2.TableRowValue, C2.TableRowValue == C3.TableRowValue, C3.TableRowValue == C4.TableRowValue, C4.TableRowValue == C5.TableRowValue, C5.TableRowValue == C6.TableRowValue, C6.TableRowValue == C7.TableRowValue
}

@available(iOS 16.0, macOS 12.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension TableRowBuilder {

    /// Creates a row result from nine sources.
    public static func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7, C8>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5, _ c6: C6, _ c7: C7, _ c8: C8) -> TupleTableRowContent<Value, (C0, C1, C2, C3, C4, C5, C6, C7, C8)> where Value == C0.TableRowValue, C0 : TableRowContent, C1 : TableRowContent, C2 : TableRowContent, C3 : TableRowContent, C4 : TableRowContent, C5 : TableRowContent, C6 : TableRowContent, C7 : TableRowContent, C8 : TableRowContent, C0.TableRowValue == C1.TableRowValue, C1.TableRowValue == C2.TableRowValue, C2.TableRowValue == C3.TableRowValue, C3.TableRowValue == C4.TableRowValue, C4.TableRowValue == C5.TableRowValue, C5.TableRowValue == C6.TableRowValue, C6.TableRowValue == C7.TableRowValue, C7.TableRowValue == C8.TableRowValue
}

@available(iOS 16.0, macOS 12.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension TableRowBuilder {

    /// Creates a row result from ten sources.
    public static func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7, C8, C9>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5, _ c6: C6, _ c7: C7, _ c8: C8, _ c9: C9) -> TupleTableRowContent<Value, (C0, C1, C2, C3, C4, C5, C6, C7, C8, C9)> where Value == C0.TableRowValue, C0 : TableRowContent, C1 : TableRowContent, C2 : TableRowContent, C3 : TableRowContent, C4 : TableRowContent, C5 : TableRowContent, C6 : TableRowContent, C7 : TableRowContent, C8 : TableRowContent, C9 : TableRowContent, C0.TableRowValue == C1.TableRowValue, C1.TableRowValue == C2.TableRowValue, C2.TableRowValue == C3.TableRowValue, C3.TableRowValue == C4.TableRowValue, C4.TableRowValue == C5.TableRowValue, C5.TableRowValue == C6.TableRowValue, C6.TableRowValue == C7.TableRowValue, C7.TableRowValue == C8.TableRowValue, C8.TableRowValue == C9.TableRowValue
}

/// A type used to represent table rows.
///
/// Like with the ``View`` protocol, you can create custom table row content
/// by declaring a type that conforms to the `TableRowContent` protocol and implementing
/// the required ``TableRowContent/tableRowBody-swift.property`` property.
///
///     struct GroupOfPeopleRows: TableRowContent {
///         @Binding var people: [Person]
///
///         var tableRowBody: some TableRowContent<Person> {
///             ForEach(people) { person in
///                 TableRow(person)
///                     .itemProvider { person.itemProvider }
///             }
///             .dropDestination(for: Person.self) { destination, newPeople in
///                 people.insert(contentsOf: newPeople, at: destination)
///             }
///         }
///     }
///
/// This example uses an opaque result type and specifies that the
/// primary associated type `TableRowValue` for the `tableRowBody`
/// property is a `Person`. From this, SwiftUI can infer
/// `TableRowValue` for the `GroupOfPeopleRows` structure is also `Person`.
@available(iOS 16.0, macOS 12.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@MainActor @preconcurrency public protocol TableRowContent<TableRowValue> {

    /// The type of value represented by this table row content.
    associatedtype TableRowValue : Identifiable = Self.TableRowBody.TableRowValue

    /// The type of content representing the body of this table row content.
    associatedtype TableRowBody : TableRowContent

    /// The composition of content that comprise the table row content.
    @MainActor @preconcurrency var tableRowBody: Self.TableRowBody { get }
}

@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension TableRowContent {

    /// Adds a condition that controls whether users can select this row.
    ///
    /// Use this modifier to control the selectability of views in
    /// selectable containers like ``List`` or ``Table``. In the example,
    /// below, the user can't select the first item in the table.
    ///
    ///
    ///     @Binding var rows: [Item]
    ///     @Binding var selection: Set<Item.ID>
    ///
    ///     var body: some View {
    ///         Table(of: Item.self, selection: $selection) {
    ///             TableColumn("ID", value: \.id.uuidString)
    ///         } rows: {
    ///             ForEach(rows) { row in
    ///                 TableRow(row)
    ///                     .selectionDisabled(
    ///                         row.id == rows.first?.id
    ///                     )
    ///             }
    ///         }
    ///     }
    ///
    /// You can also use this modifier to specify the selectability of views
    /// within a `Picker`. The following example represents a flavor picker
    /// that disables selection on flavors that are unavailable.
    ///
    ///     Picker("Flavor", selection: $selectedFlavor) {
    ///         ForEach(Flavor.allCases) { flavor in
    ///             Text(flavor.rawValue.capitalized)
    ///                 .selectionDisabled(isSoldOut(flavor))
    ///         }
    ///     }
    ///
    /// - Parameter isDisabled: A Boolean value that determines whether users
    ///   can select this row.
    @available(iOS 17.0, macOS 14.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    @MainActor @preconcurrency public func selectionDisabled(_ isDisabled: Bool = true) -> some TableRowContent<Self.TableRowValue>

}

@available(iOS 17.0, macOS 14.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension TableRowContent {

    /// Activates this row as the source of a drag and drop operation.
    ///
    /// Applying the `draggable(_:)` modifier adds the appropriate gestures for
    /// drag and drop to this row.
    ///
    /// - Parameter payload: A closure that returns a single
    /// instance or a value conforming to <doc://com.apple.documentation/documentation/coretransferable/transferable> that
    /// represents the draggable data from this view.
    ///
    /// - Returns: A row that activates this row as the source of a drag and
    ///   drop operation.
    @MainActor @preconcurrency public func draggable<T>(_ payload: @autoclosure @escaping () -> T) -> some TableRowContent<Self.TableRowValue> where T : Transferable


    /// Defines the entire row as a destination of a drag and drop operation
    /// that handles the dropped content with a closure that you specify.
    ///
    /// - Parameters:
    ///   - payloadType: The expected type of the dropped models.
    ///   - action: A closure that takes the dropped content and responds
    ///     with `true` if the drop operation was successful; otherwise, return
    ///     `false`.
    ///
    /// - Returns: A row that provides a drop destination for a drag
    ///   operation of the specified type.
    @MainActor @preconcurrency public func dropDestination<T>(for payloadType: T.Type = T.self, action: @escaping (_ items: [T]) -> Void) -> some TableRowContent<Self.TableRowValue> where T : Transferable

}

@available(iOS 16.0, macOS 12.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension TableRowContent {

    /// Provides a closure that vends the drag representation for a
    /// particular data element.
    @MainActor @preconcurrency public func itemProvider(_ action: (() -> NSItemProvider?)?) -> ModifiedContent<Self, ItemProviderTableRowModifier>
}

@available(iOS 16.0, macOS 13.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension TableRowContent {

    /// Adds a context menu to a table row.
    ///
    /// Use this modifier to add a context menu to a table row. Compose
    /// the menu by returning controls like ``Button``, ``Toggle``, and
    /// ``Picker`` from the `menuItems` closure. You can also use ``Menu``
    /// to define submenus, or ``Section`` to group items.
    ///
    /// The following example adds a context menu to each row in a table
    /// that people can use to send an email to the person represented by
    /// that row:
    ///
    ///     Table(of: Person.self) {
    ///         TableColumn("Given Name", value: \.givenName)
    ///         TableColumn("Family Name", value: \.familyName)
    ///     } rows: {
    ///         ForEach(people) { person in
    ///             TableRow(person)
    ///                 .contextMenu {
    ///                     Button("Send Email...") { }
    ///                 }
    ///         }
    ///     }
    ///
    /// If you want to display a preview beside the context menu, use
    /// ``TableRowContent/contextMenu(menuItems:preview:)``. If you want
    /// to display a context menu that's based on the current selection,
    /// use ``View/contextMenu(forSelectionType:menu:primaryAction:)``. To add
    /// context menus to other kinds of views, use ``View/contextMenu(menuItems:)``.
    ///
    /// - Parameter menuItems: A closure that produces the menu's contents. You
    ///   can deactivate the context menu by returning nothing from the closure.
    ///
    /// - Returns: A row that can display a context menu.
    @MainActor @preconcurrency public func contextMenu<M>(@ViewBuilder menuItems: () -> M) -> ModifiedContent<Self, _ContextMenuTableRowModifier<M>> where M : View

    /// Adds a context menu with a preview to a table row.
    ///
    /// When you use this modifier to add a context menu to rows in a
    /// table, the system shows a preview beside the menu.
    /// Compose the menu by returning controls like ``Button``, ``Toggle``, and
    /// ``Picker`` from the `menuItems` closure. You can also use ``Menu`` to
    /// define submenus.
    ///
    /// Define the preview by returning a view from the `preview` closure. The
    /// system sizes the preview to match the size of its content. For example,
    /// the following code adds a context menu with a preview to each row in a
    /// table that people can use to send an email to the person represented by
    /// that row:
    ///
    ///     Table(of: Person.self) {
    ///         TableColumn("Given Name", value: \.givenName)
    ///         TableColumn("Family Name", value: \.familyName)
    ///     } rows: {
    ///         ForEach(people) { person in
    ///             TableRow(person)
    ///                 .contextMenu {
    ///                     Button("Send Email...") { }
    ///                 } preview: {
    ///                     Image("envelope") // Loads the image from an asset catalog.
    ///                 }
    ///         }
    ///     }
    ///
    /// > Note: This view modifier produces a context menu on macOS, but that
    /// platform doesn't display the preview.
    ///
    /// If you don't need a preview, use
    /// ``TableRowContent/contextMenu(menuItems:)``. If you want
    /// to display a context menu that's based on the current selection,
    /// use ``View/contextMenu(forSelectionType:menu:primaryAction:)``. To add
    /// context menus to other kinds of views, see ``View/contextMenu(menuItems:)``.
    ///
    /// - Parameters:
    ///   - menuItems: A closure that produces the menu's contents. You can
    ///     deactivate the context menu by returning nothing from the closure.
    ///   - preview: A view that the system displays along with the menu.
    ///
    /// - Returns: A row that can display a context menu with a preview.
    @MainActor @preconcurrency public func contextMenu<M, P>(@ViewBuilder menuItems: () -> M, @ViewBuilder preview: () -> P) -> ModifiedContent<Self, _ContextMenuPreviewTableRowModifier<M, P>> where M : View, P : View
}

/// A type that applies a custom appearance to all tables within a view.
///
/// To configure the current table style for a view hierarchy, use the
/// ``View/tableStyle(_:)`` modifier.
@available(iOS 16.0, macOS 12.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@MainActor @preconcurrency public protocol TableStyle {

    /// A view that represents the body of a table.
    associatedtype Body : View

    /// Creates a view that represents the body of a table.
    ///
    /// The system calls this method for each ``Table`` instance in a view
    /// hierarchy where this style is the current table style.
    ///
    /// - Parameter configuration: The properties of the table.
    @ViewBuilder @MainActor @preconcurrency func makeBody(configuration: Self.Configuration) -> Self.Body

    /// The properties of a table.
    typealias Configuration = TableStyleConfiguration
}

@available(iOS 16.0, macOS 12.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension TableStyle where Self == InsetTableStyle {

    /// The table style that describes the behavior and appearance of a table
    /// with its content and selection inset from the table edges.
    ///
    /// To customize whether the rows of the table should alternate their
    /// backgrounds, use ``View/alternatingRowBackgrounds(_:)``.
    @MainActor @preconcurrency public static var inset: InsetTableStyle { get }
}

@available(iOS 16.0, macOS 12.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension TableStyle where Self == AutomaticTableStyle {

    /// The default table style in the current context.
    @MainActor @preconcurrency public static var automatic: AutomaticTableStyle { get }
}

/// The properties of a table.
@available(iOS 16.0, macOS 12.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct TableStyleConfiguration {
}

/// A built-in group of commands for searching, editing, and transforming
/// selections of text.
///
/// These commands are optional and can be explicitly requested by passing a
/// value of this type to the `Scene.commands(_:)` modifier.
@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct TextEditingCommands : Commands {

    /// A new value describing the built-in text-editing commands.
    public init()

    /// The contents of the command hierarchy.
    ///
    /// For any commands that you create, provide a computed `body` property
    /// that defines the scene as a composition of other scenes. You can
    /// assemble a command hierarchy from built-in commands that SwiftUI
    /// provides, as well as other commands that you've defined.
    @MainActor @preconcurrency public var body: some Commands { get }

    /// The type of commands that represents the body of this command hierarchy.
    ///
    /// When you create custom commands, Swift infers this type from your
    /// implementation of the required ``SwiftUI/Commands/body-swift.property``
    /// property.
    @available(iOS 14.0, macOS 11.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias Body = some Commands
}

/// A view that can display and edit long-form text.
///
/// A text editor view allows you to display and edit multiline, scrollable
/// text in your app's user interface. By default, the text editor view styles
/// the text using characteristics inherited from the environment, like
/// ``View/font(_:)``, ``View/foregroundColor(_:)``, and
/// ``View/multilineTextAlignment(_:)``.
///
/// You create a text editor by adding a `TextEditor` instance to the
/// body of your view, and initialize it by passing in a
/// ``Binding`` to a string variable in your app:
///
///     struct TextEditingView: View {
///         @State private var fullText: String = "This is some editable text..."
///
///         var body: some View {
///             TextEditor(text: $fullText)
///         }
///     }
///
/// To style the text, use the standard view modifiers to configure a system
/// font, set a custom font, or change the color of the view's text.
///
/// In this example, the view renders the editor's text in gray with a
/// custom font:
///
///     struct TextEditingView: View {
///         @State private var fullText: String = "This is some editable text..."
///
///         var body: some View {
///             TextEditor(text: $fullText)
///                 .foregroundColor(Color.gray)
///                 .font(.custom("HelveticaNeue", size: 13))
///         }
///     }
///
/// If you want to change the spacing or font scaling aspects of the text, you
/// can use modifiers like ``View/lineLimit(_:)``,
/// ``View/lineSpacing(_:)``, and ``View/minimumScaleFactor(_:)`` to configure
/// how the view displays text depending on the space constraints. For example,
/// here the ``View/lineSpacing(_:)`` modifier sets the spacing between lines
/// to 5 points:
///
///     struct TextEditingView: View {
///         @State private var fullText: String = "This is some editable text..."
///
///         var body: some View {
///             TextEditor(text: $fullText)
///                 .foregroundColor(Color.gray)
///                 .font(.custom("HelveticaNeue", size: 13))
///                 .lineSpacing(5)
///         }
///     }
///
@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct TextEditor : View {

    /// Creates a plain text editor.
    ///
    /// Use a ``TextEditor`` instance to create a view in which users can enter
    /// and edit long-form text.
    ///
    /// In this example, the text editor renders gray text using the 13
    /// point Helvetica Neue font with 5 points of spacing between each line:
    ///
    ///     struct TextEditingView: View {
    ///         @State private var fullText: String = "This is some editable text..."
    ///
    ///         var body: some View {
    ///             TextEditor(text: $fullText)
    ///                 .foregroundColor(Color.gray)
    ///                 .font(.custom("HelveticaNeue", size: 13))
    ///                 .lineSpacing(5)
    ///         }
    ///     }
    ///
    /// You can define the styling for the text within the view, including the
    /// text color, font, and line spacing. You define these styles by applying
    /// standard view modifiers to the view.
    ///
    /// The default text editor doesn't support rich text, such as styling of
    /// individual elements within the editor's view. The styles you set apply
    /// globally to all text in the view.
    ///
    /// - Parameter text: A ``Binding`` to the variable containing the
    ///    text to edit.
    public init(text: Binding<String>)

    /// Creates a plain text editor that captures the current selection.
    ///
    /// Use this initializer to create a view in which users can enter
    /// and edit long-form text and access the current selection.
    ///
    /// In this example, the text editor renders gray text using the 13
    /// point Helvetica Neue font with 5 points of spacing between each line:
    ///
    ///     struct TextEditingView: View {
    ///         @State private var fullText: String = "This is some editable text..."
    ///         @State var selection: TextSelection? = nil
    ///
    ///         var body: some View {
    ///             TextEditor(text: $fullText, selection: $selection)
    ///                 .foregroundColor(Color.gray)
    ///                 .font(.custom("HelveticaNeue", size: 13))
    ///                 .lineSpacing(5)
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - text: A ``Binding`` to the variable containing the text to edit.
    ///   - selection: A ``Binding`` to the variable containing the selection.
    @available(iOS 18.0, macOS 15.0, visionOS 2.0, *)
    public init(text: Binding<String>, selection: Binding<TextSelection?>)

    /// The content and behavior of the view.
    ///
    /// When you implement a custom view, you must implement a computed
    /// `body` property to provide the content for your view. Return a view
    /// that's composed of built-in views that SwiftUI provides, plus other
    /// composite views that you've already defined:
    ///
    ///     struct MyView: View {
    ///         var body: some View {
    ///             Text("Hello, World!")
    ///         }
    ///     }
    ///
    /// For more information about composing views and a view hierarchy,
    /// see <doc:Declaring-a-Custom-View>.
    @MainActor @preconcurrency public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    @available(iOS 14.0, macOS 11.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias Body = some View
}

/// A specification for the appearance and interaction of a text editor.
@available(iOS 17.0, macOS 14.0, visionOS 1.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@MainActor @preconcurrency public protocol TextEditorStyle {

    /// A view that represents the body of a text editor.
    associatedtype Body : View

    /// Creates a view that represents the body of a text editor.
    ///
    /// The system calls this method for each ``TextEditor`` instance in a view
    /// hierarchy where this style is the current text editor style.
    ///
    /// - Parameter configuration: The properties of the text editor.
    @ViewBuilder @MainActor @preconcurrency func makeBody(configuration: Self.Configuration) -> Self.Body

    /// The properties of a text editor.
    typealias Configuration = TextEditorStyleConfiguration
}

@available(iOS 17.0, macOS 14.0, visionOS 1.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension TextEditorStyle where Self == AutomaticTextEditorStyle {

    /// The default text editor style, based on the text editor's context.
    ///
    /// The default style represents the recommended style based on the
    /// current platform and the text editor's context within the view hierarchy.
    @MainActor @preconcurrency public static var automatic: AutomaticTextEditorStyle { get }
}

@available(iOS 17.0, macOS 14.0, visionOS 1.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension TextEditorStyle where Self == PlainTextEditorStyle {

    /// A text editor style with no decoration.
    @MainActor @preconcurrency public static var plain: PlainTextEditorStyle { get }
}

/// The properties of a text editor.
@available(iOS 17.0, macOS 14.0, visionOS 1.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct TextEditorStyleConfiguration {
}

/// A control that displays an editable text interface.
///
/// You create a text field with a label and a binding to a value. If the
/// value is a string, the text field updates this value continuously as the
/// user types or otherwise edits the text in the field. For non-string types,
/// it updates the value when the user commits their edits, such as by pressing
/// the Return key.
///
/// The following example shows a text field to accept a username, and a
/// ``Text`` view below it that shadows the continuously updated value
/// of `username`. The ``Text`` view changes color as the user begins and ends
/// editing. When the user submits their completed entry to the text field,
/// the ``View/onSubmit(of:_:)`` modifier calls an internal `validate(name:)`
/// method.
///
///     @State private var username: String = ""
///     @FocusState private var emailFieldIsFocused: Bool = false
///
///     var body: some View {
///         TextField(
///             "User name (email address)",
///             text: $username
///         )
///         .focused($emailFieldIsFocused)
///         .onSubmit {
///             validate(name: username)
///         }
///         .textInputAutocapitalization(.never)
///         .disableAutocorrection(true)
///         .border(.secondary)
///
///         Text(username)
///             .foregroundColor(emailFieldIsFocused ? .red : .blue)
///     }
///
/// ![A text field showing the typed email mruiz2@icloud.com, with a text
/// view below it also showing this value.](SwiftUI-TextField-echoText.png)
///
/// The bound value doesn't have to be a string. By using a
/// <doc://com.apple.documentation/documentation/Foundation/FormatStyle>,
/// you can bind the text field to a nonstring type, using the format style
/// to convert the typed text into an instance of the bound type. The following
/// example uses a
/// <doc://com.apple.documentation/documentation/Foundation/PersonNameComponents/FormatStyle>
/// to convert the name typed in the text field to a
/// <doc://com.apple.documentation/documentation/Foundation/PersonNameComponents>
/// instance. A ``Text`` view below the text field shows the debug description
/// string of this instance.
///
///     @State private var nameComponents = PersonNameComponents()
///
///     var body: some View {
///         TextField(
///             "Proper name",
///             value: $nameComponents,
///             format: .name(style: .medium)
///         )
///         .onSubmit {
///             validate(components: nameComponents)
///         }
///         .disableAutocorrection(true)
///         .border(.secondary)
///         Text(nameComponents.debugDescription)
///     }
///
/// ![A text field showing the typed name Maria Ruiz, with a text view below
///  it showing the string givenName:Maria
///  familyName:Ruiz.](SwiftUI-TextField-nameComponents.png)
///
/// ### Text field prompts
///
/// You can set an explicit prompt on the text field to guide users on what
/// text they should provide. Each text field style determines where and
/// when the text field uses a prompt and label. For example, a form on macOS
/// always places the label at the leading edge of the field and
/// uses a prompt, when available, as placeholder text within the field itself.
/// In the same context on iOS, the text field uses either the prompt or label
/// as placeholder text, depending on whether the initializer provided a prompt.
///
/// The following example shows a ``Form`` with two text fields, each of which
/// provides a prompt to indicate that the field is required, and a view builder
/// to provide a label:
///
///     Form {
///         TextField(text: $username, prompt: Text("Required")) {
///             Text("Username")
///         }
///         SecureField(text: $password, prompt: Text("Required")) {
///             Text("Password")
///         }
///     }
///
/// ![A macOS form, showing two text fields, arranged vertically, with labels to
/// the side that say Username and Password, respectively. Inside each text
/// field, the prompt text says Required.](TextField-prompt-1)
///
/// ![An iOS form, showing two text fields, arranged vertically, with prompt
/// text that says Required.](TextField-prompt-2)
///
/// ### Styling text fields
///
/// SwiftUI provides a default text field style that reflects an appearance and
/// behavior appropriate to the platform. The default style also takes the
/// current context into consideration, like whether the text field is in a
/// container that presents text fields with a special style. Beyond this, you
/// can customize the appearance and interaction of text fields using the
/// ``View/textFieldStyle(_:)`` modifier, passing in an instance of
/// ``TextFieldStyle``. The following example applies the
/// ``TextFieldStyle/roundedBorder`` style to both text fields within a ``VStack``.
///
///     @State private var givenName: String = ""
///     @State private var familyName: String = ""
///
///     var body: some View {
///         VStack {
///             TextField(
///                 "Given Name",
///                 text: $givenName
///             )
///             .disableAutocorrection(true)
///             TextField(
///                 "Family Name",
///                 text: $familyName
///             )
///             .disableAutocorrection(true)
///         }
///         .textFieldStyle(.roundedBorder)
///     }
/// ![Two vertically-stacked text fields, with the prompt text Given Name and
/// Family Name, both with rounded
/// borders.](SwiftUI-TextField-roundedBorderStyle.png)
///
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public struct TextField<Label> : View where Label : View {

    /// The content and behavior of the view.
    ///
    /// When you implement a custom view, you must implement a computed
    /// `body` property to provide the content for your view. Return a view
    /// that's composed of built-in views that SwiftUI provides, plus other
    /// composite views that you've already defined:
    ///
    ///     struct MyView: View {
    ///         var body: some View {
    ///             Text("Hello, World!")
    ///         }
    ///     }
    ///
    /// For more information about composing views and a view hierarchy,
    /// see <doc:Declaring-a-Custom-View>.
    @MainActor @preconcurrency public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    public typealias Body = some View
}

extension TextField where Label == Text {

    /// Creates a text field that applies a format style to a bound optional
    /// value, with a label generated from a localized title string.
    ///
    /// Use this initializer to create a text field that binds to a bound optional
    /// value, using a
    /// <doc://com.apple.documentation/documentation/Foundation/ParseableFormatStyle>
    /// to convert to and from this type. Changes to the bound value update
    /// the string displayed by the text field. Editing the text field
    /// updates the bound value, as long as the format style can parse the
    /// text. If the format style can't parse the input, the text field
    /// sets the bound value to `nil`.
    ///
    /// Use the ``View/onSubmit(of:_:)`` modifier to invoke an action
    /// whenever the user submits this text field.
    ///
    /// The following example uses an optional
    /// <doc://com.apple.documentation/documentation/Swift/Double>
    /// as the bound currency value, and a
    /// <doc://com.apple.documentation/documentation/Foundation/FloatingPointFormatStyle/Currency>
    /// instance to convert to and from a representation as U.S. dollars. As
    /// the user types, a `View.onChange(of:_:)` modifier logs the new value to
    /// the console. If the user enters an invalid currency value, like letters
    /// or emoji, the console output is `Optional(nil)`.
    ///
    ///     @State private var myMoney: Double? = 300.0
    ///     var body: some View {
    ///         TextField(
    ///             "Currency (USD)",
    ///             value: $myMoney,
    ///             format: .currency(code: "USD")
    ///         )
    ///         .onChange(of: myMoney) { newValue in
    ///             print ("myMoney: \(newValue)")
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - titleKey: The title of the text field, describing its purpose.
    ///   - value: The underlying value to edit.
    ///   - format: A format style of type `F` to use when converting between
    ///     the string the user edits and the underlying value of type
    ///     `F.FormatInput`. If `format` can't perform the conversion, the text
    ///     field sets `binding.value` to `nil`.
    ///   - prompt: A `Text` which provides users with guidance on what to type
    ///     into the text field.
    @available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
    nonisolated public init<F>(_ titleKey: LocalizedStringKey, value: Binding<F.FormatInput?>, format: F, prompt: Text? = nil) where F : ParseableFormatStyle, F.FormatOutput == String

    /// Creates a text field that applies a format style to a bound optional
    /// value, with a label generated from a title string.
    ///
    /// Use this initializer to create a text field that binds to a bound optional
    /// value, using a
    /// <doc://com.apple.documentation/documentation/Foundation/ParseableFormatStyle>
    /// to convert to and from this type. Changes to the bound value update
    /// the string displayed by the text field. Editing the text field
    /// updates the bound value, as long as the format style can parse the
    /// text. If the format style can't parse the input, the text field
    /// sets the bound value to `nil`.
    ///
    /// Use the ``View/onSubmit(of:_:)`` modifier to invoke an action
    /// whenever the user submits this text field.
    ///
    /// The following example uses an optional
    /// <doc://com.apple.documentation/documentation/Swift/Double>
    /// as the bound currency value, and a
    /// <doc://com.apple.documentation/documentation/Foundation/FloatingPointFormatStyle/Currency>
    /// instance to convert to and from a representation as U.S. dollars. As
    /// the user types, a `View.onChange(of:_:)` modifier logs the new value to
    /// the console. If the user enters an invalid currency value, like letters
    /// or emoji, the console output is `Optional(nil)`.
    ///
    ///     @State private var label = "Currency (USD)"
    ///     @State private var myMoney: Double? = 300.0
    ///     var body: some View {
    ///         TextField(
    ///             label,
    ///             value: $myMoney,
    ///             format: .currency(code: "USD")
    ///         )
    ///         .onChange(of: myMoney) { newValue in
    ///             print ("myMoney: \(newValue)")
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - title: The title of the text field, describing its purpose.
    ///   - value: The underlying value to edit.
    ///   - format: A format style of type `F` to use when converting between
    ///     the string the user edits and the underlying value of type
    ///     `F.FormatInput`. If `format` can't perform the conversion, the text
    ///     field sets `binding.value` to `nil`.
    ///   - prompt: A `Text` which provides users with guidance on what to type
    ///     into the text field.
    @available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
    nonisolated public init<S, F>(_ title: S, value: Binding<F.FormatInput?>, format: F, prompt: Text? = nil) where S : StringProtocol, F : ParseableFormatStyle, F.FormatOutput == String

    /// Creates a text field that applies a format style to a bound
    /// value, with a label generated from a localized title string.
    ///
    /// Use this initializer to create a text field that binds to a bound
    /// value, using a
    /// <doc://com.apple.documentation/documentation/Foundation/ParseableFormatStyle>
    /// to convert to and from this type. Changes to the bound value update
    /// the string displayed by the text field. Editing the text field
    /// updates the bound value, as long as the format style can parse the
    /// text. If the format style can't parse the input, the bound value
    /// remains unchanged.
    ///
    /// Use the ``View/onSubmit(of:_:)`` modifier to invoke an action
    /// whenever the user submits this text field.
    ///
    ///
    /// The following example uses a
    /// <doc://com.apple.documentation/documentation/Swift/Double>
    /// as the bound value, and a
    /// <doc://com.apple.documentation/documentation/Foundation/FloatingPointFormatStyle>
    /// instance to convert to and from a string representation. As the user types, the bound
    /// value updates, which in turn updates three ``Text`` views that use
    /// different format styles. If the user enters text that doesn't represent
    /// a valid `Double`, the bound value doesn't update.
    ///
    ///     @State private var myDouble: Double = 0.673
    ///     var body: some View {
    ///         VStack {
    ///             TextField(
    ///                 "Double",
    ///                 value: $myDouble,
    ///                 format: .number
    ///             )
    ///             Text(myDouble, format: .number)
    ///             Text(myDouble, format: .number.precision(.significantDigits(5)))
    ///             Text(myDouble, format: .number.notation(.scientific))
    ///         }
    ///     }
    ///
    /// ![A text field with the string 0.673. Below this, three text views
    /// showing the number with different styles: 0.673, 0.67300, and 6.73E-1.](TextField-init-format-1)
    ///
    /// - Parameters:
    ///   - titleKey: The title of the text field, describing its purpose.
    ///   - value: The underlying value to edit.
    ///   - format: A format style of type `F` to use when converting between
    ///     the string the user edits and the underlying value of type
    ///     `F.FormatInput`. If `format` can't perform the conversion, the text
    ///     field leaves `binding.value` unchanged. If the user stops editing
    ///     the text in an invalid state, the text field updates the field's
    ///     text to the last known valid value.
    ///   - prompt: A `Text` which provides users with guidance on what to type
    ///     into the text field.
    @available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
    nonisolated public init<F>(_ titleKey: LocalizedStringKey, value: Binding<F.FormatInput>, format: F, prompt: Text? = nil) where F : ParseableFormatStyle, F.FormatOutput == String

    /// Creates a text field that applies a format style to a bound
    /// value, with a label generated from a title string.
    ///
    /// Use this initializer to create a text field that binds to a bound
    /// value, using a
    /// <doc://com.apple.documentation/documentation/Foundation/ParseableFormatStyle>
    /// to convert to and from this type. Changes to the bound value update
    /// the string displayed by the text field. Editing the text field
    /// updates the bound value, as long as the format style can parse the
    /// text. If the format style can't parse the input, the bound value
    /// remains unchanged.
    ///
    /// Use the ``View/onSubmit(of:_:)`` modifier to invoke an action
    /// whenever the user submits this text field.
    ///
    /// The following example uses a
    /// <doc://com.apple.documentation/documentation/Swift/Double>
    /// as the bound value, and a
    /// <doc://com.apple.documentation/documentation/Foundation/FloatingPointFormatStyle>
    /// instance to convert to and from a string representation. As the user types, the bound
    /// value updates, which in turn updates three ``Text`` views that use
    /// different format styles. If the user enters text that doesn't represent
    /// a valid `Double`, the bound value doesn't update.
    ///
    ///     @State private var label = "Double"
    ///     @State private var myDouble: Double = 0.673
    ///     var body: some View {
    ///         VStack {
    ///             TextField(
    ///                 label,
    ///                 value: $myDouble,
    ///                 format: .number
    ///             )
    ///             Text(myDouble, format: .number)
    ///             Text(myDouble, format: .number.precision(.significantDigits(5)))
    ///             Text(myDouble, format: .number.notation(.scientific))
    ///         }
    ///     }
    ///
    /// ![A text field with the string 0.673. Below this, three text views
    /// showing the number with different styles: 0.673, 0.67300, and 6.73E-1.](TextField-init-format-1)
    /// - Parameters:
    ///   - title: The title of the text field, describing its purpose.
    ///   - value: The underlying value to edit.
    ///   - format: A format style of type `F` to use when converting between
    ///     the string the user edits and the underlying value of type
    ///     `F.FormatInput`. If `format` can't perform the conversion, the text
    ///     field leaves `binding.value` unchanged. If the user stops editing
    ///     the text in an invalid state, the text field updates the field's
    ///     text to the last known valid value.
    ///   - prompt: A `Text` which provides users with guidance on what to type
    ///     into the text field.
    @available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
    nonisolated public init<S, F>(_ title: S, value: Binding<F.FormatInput>, format: F, prompt: Text? = nil) where S : StringProtocol, F : ParseableFormatStyle, F.FormatOutput == String
}

extension TextField {

    /// Creates a text field that applies a format style to a bound optional
    /// value, with a label generated from a view builder.
    ///
    /// Use this initializer to create a text field that binds to a bound optional
    /// value, using a
    /// <doc://com.apple.documentation/documentation/Foundation/ParseableFormatStyle>
    /// to convert to and from this type. Changes to the bound value update
    /// the string displayed by the text field. Editing the text field
    /// updates the bound value, as long as the format style can parse the
    /// text. If the format style can't parse the input, the text field
    /// sets the bound value to `nil`.
    ///
    /// Use the ``View/onSubmit(of:_:)`` modifier to invoke an action
    /// whenever the user submits this text field.
    ///
    /// The following example uses an optional
    /// <doc://com.apple.documentation/documentation/Swift/Double>
    /// as the bound currency value, and a
    /// <doc://com.apple.documentation/documentation/Foundation/FloatingPointFormatStyle/Currency>
    /// instance to convert to and from a representation as U.S. dollars. As
    /// the user types, a `View.onChange(of:_:)` modifier logs the new value to
    /// the console. If the user enters an invalid currency value, like letters
    /// or emoji, the console output is `Optional(nil)`.
    ///
    ///     @State private var myMoney: Double? = 300.0
    ///     var body: some View {
    ///         TextField(
    ///             value: $myMoney,
    ///             format: .currency(code: "USD")
    ///         ) {
    ///             Text("Currency (USD)")
    ///         }
    ///         .onChange(of: myMoney) { newValue in
    ///             print ("myMoney: \(newValue)")
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - value: The underlying value to edit.
    ///   - format: A format style of type `F` to use when converting between
    ///     the string the user edits and the underlying value of type
    ///     `F.FormatInput`. If `format` can't perform the conversion, the text
    ///     field sets `binding.value` to `nil`.
    ///   - prompt: A `Text` which provides users with guidance on what to type
    ///     into the text field.
    ///   - label: A view builder that produces a label for the text field,
    ///     describing its purpose.
    @available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
    nonisolated public init<F>(value: Binding<F.FormatInput?>, format: F, prompt: Text? = nil, @ViewBuilder label: () -> Label) where F : ParseableFormatStyle, F.FormatOutput == String

    /// Creates a text field that applies a format style to a bound
    /// value, with a label generated from a view builder.
    ///
    /// Use this initializer to create a text field that binds to a bound
    /// value, using a
    /// <doc://com.apple.documentation/documentation/Foundation/ParseableFormatStyle>
    /// to convert to and from this type. Changes to the bound value update
    /// the string displayed by the text field. Editing the text field
    /// updates the bound value, as long as the format style can parse the
    /// text. If the format style can't parse the input, the bound value
    /// remains unchanged.
    ///
    /// Use the ``View/onSubmit(of:_:)`` modifier to invoke an action
    /// whenever the user submits this text field.
    ///
    /// The following example uses a
    /// <doc://com.apple.documentation/documentation/Swift/Double>
    /// as the bound value, and a
    /// <doc://com.apple.documentation/documentation/Foundation/FloatingPointFormatStyle>
    /// instance to convert to and from a string representation. As the user types, the bound
    /// value updates, which in turn updates three ``Text`` views that use
    /// different format styles. If the user enters text that doesn't represent
    /// a valid `Double`, the bound value doesn't update.
    ///
    ///     @State private var myDouble: Double = 0.673
    ///     var body: some View {
    ///         VStack {
    ///             TextField(
    ///                 value: $myDouble,
    ///                 format: .number
    ///             ) {
    ///                 Text("Double")
    ///             }
    ///             Text(myDouble, format: .number)
    ///             Text(myDouble, format: .number.precision(.significantDigits(5)))
    ///             Text(myDouble, format: .number.notation(.scientific))
    ///         }
    ///     }
    ///
    /// ![A text field with the string 0.673. Below this, three text views
    /// showing the number with different styles: 0.673, 0.67300, and 6.73E-1.](TextField-init-format-1)
    ///
    /// - Parameters:
    ///   - value: The underlying value to edit.
    ///   - format: A format style of type `F` to use when converting between
    ///     the string the user edits and the underlying value of type
    ///     `F.FormatInput`. If `format` can't perform the conversion, the text
    ///     field leaves the value unchanged. If the user stops editing
    ///     the text in an invalid state, the text field updates the field's
    ///     text to the last known valid value.
    ///   - prompt: A `Text` which provides users with guidance on what to type
    ///     into the text field.
    ///   - label: A view builder that produces a label for the text field,
    ///     describing its purpose.
    @available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
    nonisolated public init<F>(value: Binding<F.FormatInput>, format: F, prompt: Text? = nil, @ViewBuilder label: () -> Label) where F : ParseableFormatStyle, F.FormatOutput == String
}

extension TextField where Label == Text {

    /// Creates a text field that applies a formatter to a bound
    /// value, with a label generated from a localized title string.
    ///
    /// Use this initializer to create a text field that binds to a bound
    /// value, using a
    /// <doc://com.apple.documentation/documentation/Foundation/Formatter>
    /// to convert to and from this type. Changes to the bound value update
    /// the string displayed by the text field. Editing the text field
    /// updates the bound value, as long as the formatter can parse the
    /// text. If the format style can't parse the input, the bound value
    /// remains unchanged.
    ///
    /// Use the ``View/onSubmit(of:_:)`` modifier to invoke an action
    /// whenever the user submits this text field.
    ///
    /// The following example uses a
    /// <doc://com.apple.documentation/documentation/Swift/Double>
    /// as the bound value, and a
    /// <doc://com.apple.documentation/documentation/Foundation/NumberFormatter>
    /// instance to convert to and from a string representation. The formatter
    /// uses the
    /// <doc://com.apple.documentation/documentation/Foundation/NumberFormatter/Style/decimal>
    /// style, to allow entering a fractional part. As the user types, the bound
    /// value updates, which in turn updates three ``Text`` views that use
    /// different format styles. If the user enters text that doesn't represent
    /// a valid `Double`, the bound value doesn't update.
    ///
    ///     @State private var myDouble: Double = 0.673
    ///     @State private var numberFormatter: NumberFormatter = {
    ///         var nf = NumberFormatter()
    ///         nf.numberStyle = .decimal
    ///         return nf
    ///     }()
    ///
    ///     var body: some View {
    ///         VStack {
    ///             TextField(
    ///                 "Double",
    ///                 value: $myDouble,
    ///                 formatter: numberFormatter
    ///             )
    ///             Text(myDouble, format: .number)
    ///             Text(myDouble, format: .number.precision(.significantDigits(5)))
    ///             Text(myDouble, format: .number.notation(.scientific))
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - titleKey: The key for the localized title of the text field,
    ///     describing its purpose.
    ///   - value: The underlying value to edit.
    ///   - formatter: A formatter to use when converting between the
    ///     string the user edits and the underlying value of type `V`.
    ///     If `formatter` can't perform the conversion, the text field doesn't
    ///     modify `binding.value`.
    ///   - prompt: A `Text` which provides users with guidance on what to enter
    ///     into the text field.
    @available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
    nonisolated public init<V>(_ titleKey: LocalizedStringKey, value: Binding<V>, formatter: Formatter, prompt: Text?)

    /// Creates a text field that applies a formatter to a bound
    /// value, with a label generated from a title string.
    ///
    /// Use this initializer to create a text field that binds to a bound
    /// value, using a
    /// <doc://com.apple.documentation/documentation/Foundation/Formatter>
    /// to convert to and from this type. Changes to the bound value update
    /// the string displayed by the text field. Editing the text field
    /// updates the bound value, as long as the formatter can parse the
    /// text. If the format style can't parse the input, the bound value
    /// remains unchanged.
    ///
    /// Use the ``View/onSubmit(of:_:)`` modifier to invoke an action
    /// whenever the user submits this text field.
    ///
    ///
    /// The following example uses a
    /// <doc://com.apple.documentation/documentation/Swift/Double>
    /// as the bound value, and a
    /// <doc://com.apple.documentation/documentation/Foundation/NumberFormatter>
    /// instance to convert to and from a string representation. The formatter
    /// uses the
    /// <doc://com.apple.documentation/documentation/Foundation/NumberFormatter/Style/decimal>
    /// style, to allow entering a fractional part. As the user types, the bound
    /// value updates, which in turn updates three ``Text`` views that use
    /// different format styles. If the user enters text that doesn't represent
    /// a valid `Double`, the bound value doesn't update.
    ///
    ///     @State private var label = "Double"
    ///     @State private var myDouble: Double = 0.673
    ///     @State private var numberFormatter: NumberFormatter = {
    ///         var nf = NumberFormatter()
    ///         nf.numberStyle = .decimal
    ///         return nf
    ///     }()
    ///
    ///     var body: some View {
    ///         VStack {
    ///             TextField(
    ///                 label,
    ///                 value: $myDouble,
    ///                 formatter: numberFormatter
    ///             )
    ///             Text(myDouble, format: .number)
    ///             Text(myDouble, format: .number.precision(.significantDigits(5)))
    ///             Text(myDouble, format: .number.notation(.scientific))
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - title: The title of the text field, describing its purpose.
    ///   - value: The underlying value to edit.
    ///   - formatter: A formatter to use when converting between the
    ///     string the user edits and the underlying value of type `V`.
    ///     If `formatter` can't perform the conversion, the text field doesn't
    ///     modify `binding.value`.
    ///   - prompt: A `Text` which provides users with guidance on what to enter
    ///     into the text field.
    @available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
    nonisolated public init<S, V>(_ title: S, value: Binding<V>, formatter: Formatter, prompt: Text?) where S : StringProtocol
}

extension TextField {

    /// Creates a text field that applies a formatter to a bound optional
    /// value, with a label generated from a view builder.
    ///
    /// Use this initializer to create a text field that binds to a bound optional
    /// value, using a
    /// <doc://com.apple.documentation/documentation/Foundation/Formatter>
    /// to convert to and from this type. Changes to the bound value update
    /// the string displayed by the text field. Editing the text field
    /// updates the bound value, as long as the formatter can parse the
    /// text. If the format style can't parse the input, the bound value
    /// remains unchanged.
    ///
    /// Use the ``View/onSubmit(of:_:)`` modifier to invoke an action
    /// whenever the user submits this text field.
    ///
    /// The following example uses a
    /// <doc://com.apple.documentation/documentation/Swift/Double>
    /// as the bound value, and a
    /// <doc://com.apple.documentation/documentation/Foundation/NumberFormatter>
    /// instance to convert to and from a string representation. The formatter
    /// uses the
    /// <doc://com.apple.documentation/documentation/Foundation/NumberFormatter/Style/decimal>
    /// style, to allow entering a fractional part. As the user types, the bound
    /// value updates, which in turn updates three ``Text`` views that use
    /// different format styles. If the user enters text that doesn't represent
    /// a valid `Double`, the bound value doesn't update.
    ///
    ///     @State private var myDouble: Double = 0.673
    ///     @State private var numberFormatter: NumberFormatter = {
    ///         var nf = NumberFormatter()
    ///         nf.numberStyle = .decimal
    ///         return nf
    ///     }()
    ///
    ///     var body: some View {
    ///         VStack {
    ///             TextField(
    ///                 value: $myDouble,
    ///                 formatter: numberFormatter
    ///             ) {
    ///                 Text("Double")
    ///             }
    ///             Text(myDouble, format: .number)
    ///             Text(myDouble, format: .number.precision(.significantDigits(5)))
    ///             Text(myDouble, format: .number.notation(.scientific))
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - value: The underlying value to edit.
    ///   - formatter: A formatter to use when converting between the
    ///     string the user edits and the underlying value of type `V`.
    ///     If `formatter` can't perform the conversion, the text field doesn't
    ///     modify `binding.value`.
    ///   - prompt: A `Text` which provides users with guidance on what to enter
    ///     into the text field.
    ///   - label: A view that describes the purpose of the text field.
    @available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
    nonisolated public init<V>(value: Binding<V>, formatter: Formatter, prompt: Text? = nil, @ViewBuilder label: () -> Label)
}

extension TextField where Label == Text {

    /// Create an instance which binds over an arbitrary type, `V`.
    ///
    /// Use this initializer to create a text field that binds to a bound optional
    /// value, using a
    /// <doc://com.apple.documentation/documentation/Foundation/Formatter>
    /// to convert to and from this type. Changes to the bound value update
    /// the string displayed by the text field. Editing the text field
    /// updates the bound value, as long as the formatter can parse the
    /// text. If the format style can't parse the input, the bound value
    /// remains unchanged.
    ///
    /// Use the ``View/onSubmit(of:_:)`` modifier to invoke an action
    /// whenever the user submits this text field.
    ///
    /// The following example uses a
    /// <doc://com.apple.documentation/documentation/Swift/Double>
    /// as the bound value, and a
    /// <doc://com.apple.documentation/documentation/Foundation/NumberFormatter>
    /// instance to convert to and from a string representation. The formatter
    /// uses the
    /// <doc://com.apple.documentation/documentation/Foundation/NumberFormatter/Style/decimal>
    /// style, to allow entering a fractional part. As the user types, the bound
    /// value updates, which in turn updates three ``Text`` views that use
    /// different format styles. If the user enters text that doesn't represent
    /// a valid `Double`, the bound value doesn't update.
    ///
    ///     @State private var myDouble: Double = 0.673
    ///     @State private var numberFormatter: NumberFormatter = {
    ///         var nf = NumberFormatter()
    ///         nf.numberStyle = .decimal
    ///         return nf
    ///     }()
    ///
    ///     var body: some View {
    ///         VStack {
    ///             TextField(
    ///                 value: $myDouble,
    ///                 formatter: numberFormatter
    ///             ) {
    ///                 Text("Double")
    ///             }
    ///             Text(myDouble, format: .number)
    ///             Text(myDouble, format: .number.precision(.significantDigits(5)))
    ///             Text(myDouble, format: .number.notation(.scientific))
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - titleKey: The key for the localized title of the text field,
    ///     describing its purpose.
    ///   - value: The underlying value to edit.
    ///   - formatter: A formatter to use when converting between the
    ///     string the user edits and the underlying value of type `V`.
    ///     If `formatter` can't perform the conversion, the text field doesn't
    ///     modify `binding.value`.
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    nonisolated public init<V>(_ titleKey: LocalizedStringKey, value: Binding<V>, formatter: Formatter)

    /// Create an instance which binds over an arbitrary type, `V`.
    ///
    /// Use this initializer to create a text field that binds to a bound optional
    /// value, using a
    /// <doc://com.apple.documentation/documentation/Foundation/Formatter>
    /// to convert to and from this type. Changes to the bound value update
    /// the string displayed by the text field. Editing the text field
    /// updates the bound value, as long as the formatter can parse the
    /// text. If the format style can't parse the input, the bound value
    /// remains unchanged.
    ///
    /// Use the ``View/onSubmit(of:_:)`` modifier to invoke an action
    /// whenever the user submits this text field.
    ///
    /// The following example uses a
    /// <doc://com.apple.documentation/documentation/Swift/Double>
    /// as the bound value, and a
    /// <doc://com.apple.documentation/documentation/Foundation/NumberFormatter>
    /// instance to convert to and from a string representation. The formatter
    /// uses the
    /// <doc://com.apple.documentation/documentation/Foundation/NumberFormatter/Style/decimal>
    /// style, to allow entering a fractional part. As the user types, the bound
    /// value updates, which in turn updates three ``Text`` views that use
    /// different format styles. If the user enters text that doesn't represent
    /// a valid `Double`, the bound value doesn't update.
    ///
    ///     @State private var myDouble: Double = 0.673
    ///     @State private var numberFormatter: NumberFormatter = {
    ///         var nf = NumberFormatter()
    ///         nf.numberStyle = .decimal
    ///         return nf
    ///     }()
    ///
    ///     var body: some View {
    ///         VStack {
    ///             TextField(
    ///                 value: $myDouble,
    ///                 formatter: numberFormatter
    ///             ) {
    ///                 Text("Double")
    ///             }
    ///             Text(myDouble, format: .number)
    ///             Text(myDouble, format: .number.precision(.significantDigits(5)))
    ///             Text(myDouble, format: .number.notation(.scientific))
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - title: The title of the text view, describing its purpose.
    ///   - value: The underlying value to edit.
    ///   - formatter: A formatter to use when converting between the
    ///     string the user edits and the underlying value of type `V`.
    ///     If `formatter` can't perform the conversion, the text field doesn't
    ///     modify `binding.value`.
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    nonisolated public init<S, V>(_ title: S, value: Binding<V>, formatter: Formatter) where S : StringProtocol
}

extension TextField where Label == Text {

    /// Create an instance which binds over an arbitrary type, `V`.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the localized title of the text field,
    ///     describing its purpose.
    ///   - value: The underlying value to be edited.
    ///   - formatter: A formatter to use when converting between the
    ///     string the user edits and the underlying value of type `V`.
    ///     In the event that `formatter` is unable to perform the conversion,
    ///     `binding.value` isn't modified.
    ///   - onEditingChanged: The action to perform when the user
    ///     begins editing `text` and after the user finishes editing `text`.
    ///     The closure receives a Boolean value that indicates the editing
    ///     status: `true` when the user begins editing, `false` when they
    ///     finish.
    ///   - onCommit: An action to perform when the user performs an action
    ///     (for example, when the user presses the Return key) while the text
    ///     field has focus.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, message: "Renamed TextField.init(_:value:formatter:onEditingChanged:). Use View.onSubmit(of:_:) for functionality previously provided by the onCommit parameter. Use FocusState<T> and View.focused(_:equals:) for functionality previously provided by the onEditingChanged parameter.")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, message: "Renamed TextField.init(_:value:formatter:onEditingChanged:). Use View.onSubmit(of:_:) for functionality previously provided by the onCommit parameter. Use FocusState<T> and View.focused(_:equals:) for functionality previously provided by the onEditingChanged parameter.")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, message: "Renamed TextField.init(_:value:formatter:onEditingChanged:). Use View.onSubmit(of:_:) for functionality previously provided by the onCommit parameter. Use FocusState<T> and View.focused(_:equals:) for functionality previously provided by the onEditingChanged parameter.")
    @available(watchOS, introduced: 6.0, deprecated: 100000.0, message: "Renamed TextField.init(_:value:formatter:onEditingChanged:). Use View.onSubmit(of:_:) for functionality previously provided by the onCommit parameter. Use FocusState<T> and View.focused(_:equals:) for functionality previously provided by the onEditingChanged parameter.")
    nonisolated public init<V>(_ titleKey: LocalizedStringKey, value: Binding<V>, formatter: Formatter, onEditingChanged: @escaping (Bool) -> Void, onCommit: @escaping () -> Void)

    /// Create an instance which binds over an arbitrary type, `V`.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the localized title of the text field,
    ///     describing its purpose.
    ///   - value: The underlying value to be edited.
    ///   - formatter: A formatter to use when converting between the
    ///     string the user edits and the underlying value of type `V`.
    ///     In the event that `formatter` is unable to perform the conversion,
    ///     `binding.value` isn't modified.
    ///   - onEditingChanged: The action to perform when the user
    ///     begins editing `text` and after the user finishes editing `text`.
    ///     The closure receives a Boolean value that indicates the editing
    ///     status: `true` when the user begins editing, `false` when they
    ///     finish.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, message: "Renamed TextField.init(_:value:formatter:onEditingChanged:). Use View.onSubmit(of:_:) for functionality previously provided by the onCommit parameter. Use FocusState<T> and View.focused(_:equals:) for functionality previously provided by the onEditingChanged parameter.")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, message: "Renamed TextField.init(_:value:formatter:onEditingChanged:). Use View.onSubmit(of:_:) for functionality previously provided by the onCommit parameter. Use FocusState<T> and View.focused(_:equals:) for functionality previously provided by the onEditingChanged parameter.")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, message: "Renamed TextField.init(_:value:formatter:onEditingChanged:). Use View.onSubmit(of:_:) for functionality previously provided by the onCommit parameter. Use FocusState<T> and View.focused(_:equals:) for functionality previously provided by the onEditingChanged parameter.")
    @available(watchOS, introduced: 6.0, deprecated: 100000.0, message: "Renamed TextField.init(_:value:formatter:onEditingChanged:). Use View.onSubmit(of:_:) for functionality previously provided by the onCommit parameter. Use FocusState<T> and View.focused(_:equals:) for functionality previously provided by the onEditingChanged parameter.")
    nonisolated public init<V>(_ titleKey: LocalizedStringKey, value: Binding<V>, formatter: Formatter, onEditingChanged: @escaping (Bool) -> Void)

    /// Create an instance which binds over an arbitrary type, `V`.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the localized title of the text field,
    ///     describing its purpose.
    ///   - value: The underlying value to be edited.
    ///   - formatter: A formatter to use when converting between the
    ///     string the user edits and the underlying value of type `V`.
    ///     In the event that `formatter` is unable to perform the conversion,
    ///     `binding.value` isn't modified.
    ///   - onCommit: An action to perform when the user performs an action
    ///     (for example, when the user presses the Return key) while the text
    ///     field has focus.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, message: "Renamed TextField.init(_:value:formatter:onEditingChanged:). Use View.onSubmit(of:_:) for functionality previously provided by the onCommit parameter. Use FocusState<T> and View.focused(_:equals:) for functionality previously provided by the onEditingChanged parameter.")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, message: "Renamed TextField.init(_:value:formatter:onEditingChanged:). Use View.onSubmit(of:_:) for functionality previously provided by the onCommit parameter. Use FocusState<T> and View.focused(_:equals:) for functionality previously provided by the onEditingChanged parameter.")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, message: "Renamed TextField.init(_:value:formatter:onEditingChanged:). Use View.onSubmit(of:_:) for functionality previously provided by the onCommit parameter. Use FocusState<T> and View.focused(_:equals:) for functionality previously provided by the onEditingChanged parameter.")
    @available(watchOS, introduced: 6.0, deprecated: 100000.0, message: "Renamed TextField.init(_:value:formatter:onEditingChanged:). Use View.onSubmit(of:_:) for functionality previously provided by the onCommit parameter. Use FocusState<T> and View.focused(_:equals:) for functionality previously provided by the onEditingChanged parameter.")
    nonisolated public init<V>(_ titleKey: LocalizedStringKey, value: Binding<V>, formatter: Formatter, onCommit: @escaping () -> Void)

    /// Create an instance which binds over an arbitrary type, `V`.
    ///
    /// - Parameters:
    ///   - title: The title of the text field, describing its purpose.
    ///   - value: The underlying value to be edited.
    ///   - formatter: A formatter to use when converting between the
    ///     string the user edits and the underlying value of type `V`.
    ///     In the event that `formatter` is unable to perform the conversion,
    ///     `binding.value` isn't modified.
    ///   - onEditingChanged: The action to perform when the user
    ///     begins editing `text` and after the user finishes editing `text`.
    ///     The closure receives a Boolean value that indicates the editing
    ///     status: `true` when the user begins editing, `false` when they
    ///     finish.
    ///   - onCommit: An action to perform when the user performs an action
    ///     (for example, when the user presses the Return key) while the text
    ///     field has focus.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, message: "Renamed TextField.init(_:value:formatter:onEditingChanged:). Use View.onSubmit(of:_:) for functionality previously provided by the onCommit parameter. Use FocusState<T> and View.focused(_:equals:) for functionality previously provided by the onEditingChanged parameter.")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, message: "Renamed TextField.init(_:value:formatter:onEditingChanged:). Use View.onSubmit(of:_:) for functionality previously provided by the onCommit parameter. Use FocusState<T> and View.focused(_:equals:) for functionality previously provided by the onEditingChanged parameter.")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, message: "Renamed TextField.init(_:value:formatter:onEditingChanged:). Use View.onSubmit(of:_:) for functionality previously provided by the onCommit parameter. Use FocusState<T> and View.focused(_:equals:) for functionality previously provided by the onEditingChanged parameter.")
    @available(watchOS, introduced: 6.0, deprecated: 100000.0, message: "Renamed TextField.init(_:value:formatter:onEditingChanged:). Use View.onSubmit(of:_:) for functionality previously provided by the onCommit parameter. Use FocusState<T> and View.focused(_:equals:) for functionality previously provided by the onEditingChanged parameter.")
    nonisolated public init<S, V>(_ title: S, value: Binding<V>, formatter: Formatter, onEditingChanged: @escaping (Bool) -> Void, onCommit: @escaping () -> Void) where S : StringProtocol

    /// Create an instance which binds over an arbitrary type, `V`.
    ///
    /// - Parameters:
    ///   - title: The title of the text field, describing its purpose.
    ///   - value: The underlying value to be edited.
    ///   - formatter: A formatter to use when converting between the
    ///     string the user edits and the underlying value of type `V`.
    ///     In the event that `formatter` is unable to perform the conversion,
    ///     `binding.value` isn't modified.
    ///   - onEditingChanged: The action to perform when the user
    ///     begins editing `text` and after the user finishes editing `text`.
    ///     The closure receives a Boolean value that indicates the editing
    ///     status: `true` when the user begins editing, `false` when they
    ///     finish.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, message: "Renamed TextField.init(_:value:formatter:onEditingChanged:). Use View.onSubmit(of:_:) for functionality previously provided by the onCommit parameter. Use FocusState<T> and View.focused(_:equals:) for functionality previously provided by the onEditingChanged parameter.")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, message: "Renamed TextField.init(_:value:formatter:onEditingChanged:). Use View.onSubmit(of:_:) for functionality previously provided by the onCommit parameter. Use FocusState<T> and View.focused(_:equals:) for functionality previously provided by the onEditingChanged parameter.")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, message: "Renamed TextField.init(_:value:formatter:onEditingChanged:). Use View.onSubmit(of:_:) for functionality previously provided by the onCommit parameter. Use FocusState<T> and View.focused(_:equals:) for functionality previously provided by the onEditingChanged parameter.")
    @available(watchOS, introduced: 6.0, deprecated: 100000.0, message: "Renamed TextField.init(_:value:formatter:onEditingChanged:). Use View.onSubmit(of:_:) for functionality previously provided by the onCommit parameter. Use FocusState<T> and View.focused(_:equals:) for functionality previously provided by the onEditingChanged parameter.")
    nonisolated public init<S, V>(_ title: S, value: Binding<V>, formatter: Formatter, onEditingChanged: @escaping (Bool) -> Void) where S : StringProtocol

    /// Create an instance which binds over an arbitrary type, `V`.
    ///
    /// - Parameters:
    ///   - title: The title of the text field, describing its purpose.
    ///   - value: The underlying value to be edited.
    ///   - formatter: A formatter to use when converting between the
    ///     string the user edits and the underlying value of type `V`.
    ///     In the event that `formatter` is unable to perform the conversion,
    ///     `binding.value` isn't modified.
    ///   - onCommit: An action to perform when the user performs an action
    ///     (for example, when the user presses the Return key) while the text
    ///     field has focus.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, message: "Renamed TextField.init(_:value:formatter:onEditingChanged:). Use View.onSubmit(of:_:) for functionality previously provided by the onCommit parameter. Use FocusState<T> and View.focused(_:equals:) for functionality previously provided by the onEditingChanged parameter.")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, message: "Renamed TextField.init(_:value:formatter:onEditingChanged:). Use View.onSubmit(of:_:) for functionality previously provided by the onCommit parameter. Use FocusState<T> and View.focused(_:equals:) for functionality previously provided by the onEditingChanged parameter.")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, message: "Renamed TextField.init(_:value:formatter:onEditingChanged:). Use View.onSubmit(of:_:) for functionality previously provided by the onCommit parameter. Use FocusState<T> and View.focused(_:equals:) for functionality previously provided by the onEditingChanged parameter.")
    @available(watchOS, introduced: 6.0, deprecated: 100000.0, message: "Renamed TextField.init(_:value:formatter:onEditingChanged:). Use View.onSubmit(of:_:) for functionality previously provided by the onCommit parameter. Use FocusState<T> and View.focused(_:equals:) for functionality previously provided by the onEditingChanged parameter.")
    nonisolated public init<S, V>(_ title: S, value: Binding<V>, formatter: Formatter, onCommit: @escaping () -> Void) where S : StringProtocol
}

extension TextField where Label == Text {

    /// Creates a text field with a preferred axis and a text label generated
    /// from a localized title string.
    ///
    /// Specify a preferred axis in which the text field should scroll
    /// its content when it does not fit in the available space. Depending
    /// on the style of the field, this axis may not be respected.
    ///
    /// Use the ``View/onSubmit(of:_:)`` modifier to invoke an action
    /// whenever the user submits this text field.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the localized title of the text field,
    ///     describing its purpose.
    ///   - text: The text to display and edit.
    ///   - axis: The axis in which to scroll text when it doesn't fit
    ///     in the available space.
    @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
    nonisolated public init(_ titleKey: LocalizedStringKey, text: Binding<String>, axis: Axis)

    /// Creates a text field with a preferred axis and a text label generated
    /// from a localized title string.
    ///
    /// Specify a preferred axis in which the text field should scroll
    /// its content when it does not fit in the available space. Depending
    /// on the style of the field, this axis may not be respected.
    ///
    /// Use the ``View/onSubmit(of:_:)`` modifier to invoke an action
    /// whenever the user submits this text field.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the localized title of the text field,
    ///     describing its purpose.
    ///   - text: The text to display and edit.
    ///   - prompt: A `Text` representing the prompt of the text field
    ///     which provides users with guidance on what to type into the text
    ///     field.
    ///   - axis: The axis in which to scroll text when it doesn't fit
    ///     in the available space.
    @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
    nonisolated public init(_ titleKey: LocalizedStringKey, text: Binding<String>, prompt: Text?, axis: Axis)

    /// Creates a text field with a preferred axis and a text label generated
    /// from a title string.
    ///
    /// Specify a preferred axis in which the text field should scroll
    /// its content when it does not fit in the available space. Depending
    /// on the style of the field, this axis may not be respected.
    ///
    /// Use the ``View/onSubmit(of:_:)`` modifier to invoke an action
    /// whenever the user submits this text field.
    ///
    /// - Parameters:
    ///   - title: The title of the text view, describing its purpose.
    ///   - text: The text to display and edit.
    ///   - axis: The axis in which to scroll text when it doesn't fit
    ///     in the available space.
    @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
    nonisolated public init<S>(_ title: S, text: Binding<String>, axis: Axis) where S : StringProtocol

    /// Creates a text field with a text label generated from a title string.
    ///
    /// Specify a preferred axis in which the text field should scroll
    /// its content when it does not fit in the available space. Depending
    /// on the style of the field, this axis may not be respected.
    ///
    /// Use the ``View/onSubmit(of:_:)`` modifier to invoke an action
    /// whenever the user submits this text field.
    ///
    /// - Parameters:
    ///   - title: The title of the text view, describing its purpose.
    ///   - text: The text to display and edit.
    ///   - prompt: A `Text` representing the prompt of the text field
    ///     which provides users with guidance on what to type into the text
    ///     field.
    ///   - axis: The axis in which to scroll text when it doesn't fit
    ///     in the available space.
    @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
    nonisolated public init<S>(_ title: S, text: Binding<String>, prompt: Text?, axis: Axis) where S : StringProtocol
}

extension TextField {

    /// Creates a text field with a preferred axis and a prompt generated from
    /// a `Text`.
    ///
    /// Specify a preferred axis in which the text field should scroll
    /// its content when it does not fit in the available space. Depending
    /// on the style of the field, this axis may not be respected.
    ///
    /// Use the ``View/onSubmit(of:_:)`` modifier to invoke an action
    /// whenever the user submits this text field.
    ///
    /// - Parameters:
    ///   - text: The text to display and edit.
    ///   - prompt: A `Text` representing the prompt of the text field
    ///     which provides users with guidance on what to type into the text
    ///     field.
    ///   - axis: The axis in which to scroll text when it doesn't fit
    ///     in the available space.
    ///   - label: A view that describes the purpose of the text field.
    @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
    nonisolated public init(text: Binding<String>, prompt: Text? = nil, axis: Axis, @ViewBuilder label: () -> Label)
}

extension TextField where Label == Text {

    /// Creates a text field with a text label generated from a localized title
    /// string.
    ///
    /// Use the ``View/onSubmit(of:_:)`` modifier to invoke an action
    /// whenever the user submits this text field.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the localized title of the text field,
    ///     describing its purpose.
    ///   - text: The text to display and edit.
    ///   - prompt: A `Text` representing the prompt of the text field
    ///     which provides users with guidance on what to type into the text
    ///     field.
    @available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
    nonisolated public init(_ titleKey: LocalizedStringKey, text: Binding<String>, prompt: Text?)

    /// Creates a text field with a text label generated from a title string.
    ///
    /// Use the ``View/onSubmit(of:_:)`` modifier to invoke an action
    /// whenever the user submits this text field.
    ///
    /// - Parameters:
    ///   - title: The title of the text view, describing its purpose.
    ///   - text: The text to display and edit.
    ///   - prompt: A `Text` representing the prompt of the text field
    ///     which provides users with guidance on what to type into the text
    ///     field.
    @available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
    nonisolated public init<S>(_ title: S, text: Binding<String>, prompt: Text?) where S : StringProtocol
}

extension TextField {

    /// Creates a text field with a prompt generated from a `Text`.
    ///
    /// Use the ``View/onSubmit(of:_:)`` modifier to invoke an action
    /// whenever the user submits this text field.
    ///
    /// - Parameters:
    ///   - text: The text to display and edit.
    ///   - prompt: A `Text` representing the prompt of the text field
    ///     which provides users with guidance on what to type into the text
    ///     field.
    ///   - label: A view that describes the purpose of the text field.
    @available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
    nonisolated public init(text: Binding<String>, prompt: Text? = nil, @ViewBuilder label: () -> Label)
}

@available(iOS 18.0, macOS 15.0, visionOS 2.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension TextField where Label == Text {

    /// Creates a text field with a binding to the current selection and a text
    /// label generated from a localized title string.
    ///
    /// The following example shows a text field with a binding the the current selection:
    ///
    ///     @State private var message: String = ""
    ///     @State private var selection: TextSelection? = nil
    ///
    ///     var body: some View {
    ///         TextField(
    ///             "Message",
    ///             text: $message,
    ///             selection: $selection
    ///         )
    ///     }
    ///
    /// Use the ``View/onSubmit(of:_:)`` modifier to invoke an action
    /// whenever the user submits this text field.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the localized title of the text field,
    ///     describing its purpose.
    ///   - text: The text to display and edit.
    ///   - selection: A ``Binding`` to the variable containing the selection.
    ///   - prompt: A `Text` representing the prompt of the text field
    ///     which provides users with guidance on what to type into the text
    ///     field. Defaults to `nil`.
    ///   - axis: The axis in which to scroll text when it doesn't fit
    ///     in the available space. Defaults to `nil`.
    nonisolated public init(_ titleKey: LocalizedStringKey, text: Binding<String>, selection: Binding<TextSelection?>, prompt: Text? = nil, axis: Axis? = nil)

    /// Creates a text field with a binding to the current selection and a text
    /// label generated from a title string.
    ///
    /// The following example shows a text field with a binding the the current selection:
    ///
    ///     @State private var message: String = ""
    ///     @State private var selection: TextSelection? = nil
    ///
    ///     var body: some View {
    ///         TextField(
    ///             "Message",
    ///             text: $message,
    ///             selection: $selection
    ///         )
    ///     }
    ///
    /// Use the ``View/onSubmit(of:_:)`` modifier to invoke an action
    /// whenever the user submits this text field.
    ///
    /// - Parameters:
    ///   - title: The title of the text view, describing its purpose.
    ///   - selection: A ``Binding`` to the variable containing the selection.
    ///   - text: The text to display and edit.
    ///   - prompt: A `Text` representing the prompt of the text field
    ///     which provides users with guidance on what to type into the text
    ///     field. Defaults to `nil`.
    ///   - axis: The axis in which to scroll text when it doesn't fit
    ///     in the available space. Defaults to `nil`
    nonisolated public init<S>(_ title: S, text: Binding<String>, selection: Binding<TextSelection?>, prompt: Text? = nil, axis: Axis? = nil) where S : StringProtocol
}

extension TextField where Label == Text {

    /// Creates a text field with a text label generated from a localized title
    /// string.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the localized title of the text field,
    ///     describing its purpose.
    ///   - text: The text to display and edit.
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    nonisolated public init(_ titleKey: LocalizedStringKey, text: Binding<String>)

    /// Creates a text field with a text label generated from a title string.
    ///
    /// - Parameters:
    ///   - title: The title of the text view, describing its purpose.
    ///   - text: The text to display and edit.
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    nonisolated public init<S>(_ title: S, text: Binding<String>) where S : StringProtocol
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension TextField where Label == Text {

    /// Creates a text field with a text label generated from a localized title
    /// string.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the localized title of the text field,
    ///     describing its purpose.
    ///   - text: The text to display and edit.
    ///   - onEditingChanged: The action to perform when the user
    ///     begins editing `text` and after the user finishes editing `text`.
    ///     The closure receives a Boolean value that indicates the editing
    ///     status: `true` when the user begins editing, `false` when they
    ///     finish.
    ///   - onCommit: An action to perform when the user performs an action
    ///     (for example, when the user presses the Return key) while the text
    ///     field has focus.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, message: "Renamed TextField.init(_:text:onEditingChanged:). Use View.onSubmit(of:_:) for functionality previously provided by the onCommit parameter. Use FocusState<T> and View.focused(_:equals:) for functionality previously provided by the onEditingChanged parameter.")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, message: "Renamed TextField.init(_:text:onEditingChanged:). Use View.onSubmit(of:_:) for functionality previously provided by the onCommit parameter. Use FocusState<T> and View.focused(_:equals:) for functionality previously provided by the onEditingChanged parameter.")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, message: "Renamed TextField.init(_:text:onEditingChanged:). Use View.onSubmit(of:_:) for functionality previously provided by the onCommit parameter. Use FocusState<T> and View.focused(_:equals:) for functionality previously provided by the onEditingChanged parameter.")
    @available(watchOS, introduced: 6.0, deprecated: 100000.0, message: "Renamed TextField.init(_:text:onEditingChanged:). Use View.onSubmit(of:_:) for functionality previously provided by the onCommit parameter. Use FocusState<T> and View.focused(_:equals:) for functionality previously provided by the onEditingChanged parameter.")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Renamed TextField.init(_:text:onEditingChanged:). Use View.onSubmit(of:_:) for functionality previously provided by the onCommit parameter. Use FocusState<T> and View.focused(_:equals:) for functionality previously provided by the onEditingChanged parameter.")
    nonisolated public init(_ titleKey: LocalizedStringKey, text: Binding<String>, onEditingChanged: @escaping (Bool) -> Void, onCommit: @escaping () -> Void)

    /// Creates a text field with a text label generated from a localized title
    /// string.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the localized title of the text field,
    ///     describing its purpose.
    ///   - text: The text to display and edit.
    ///   - onEditingChanged: The action to perform when the user
    ///     begins editing `text` and after the user finishes editing `text`.
    ///     The closure receives a Boolean value that indicates the editing
    ///     status: `true` when the user begins editing, `false` when they
    ///     finish.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, message: "Renamed TextField.init(_:text:onEditingChanged:). Use View.onSubmit(of:_:) for functionality previously provided by the onCommit parameter. Use FocusState<T> and View.focused(_:equals:) for functionality previously provided by the onEditingChanged parameter.")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, message: "Renamed TextField.init(_:text:onEditingChanged:). Use View.onSubmit(of:_:) for functionality previously provided by the onCommit parameter. Use FocusState<T> and View.focused(_:equals:) for functionality previously provided by the onEditingChanged parameter.")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, message: "Renamed TextField.init(_:text:onEditingChanged:). Use View.onSubmit(of:_:) for functionality previously provided by the onCommit parameter. Use FocusState<T> and View.focused(_:equals:) for functionality previously provided by the onEditingChanged parameter.")
    @available(watchOS, introduced: 6.0, deprecated: 100000.0, message: "Renamed TextField.init(_:text:onEditingChanged:). Use View.onSubmit(of:_:) for functionality previously provided by the onCommit parameter. Use FocusState<T> and View.focused(_:equals:) for functionality previously provided by the onEditingChanged parameter.")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Renamed TextField.init(_:text:onEditingChanged:). Use View.onSubmit(of:_:) for functionality previously provided by the onCommit parameter. Use FocusState<T> and View.focused(_:equals:) for functionality previously provided by the onEditingChanged parameter.")
    nonisolated public init(_ titleKey: LocalizedStringKey, text: Binding<String>, onEditingChanged: @escaping (Bool) -> Void)

    /// Creates a text field with a text label generated from a localized title
    /// string.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the localized title of the text field,
    ///     describing its purpose.
    ///   - text: The text to display and edit.
    ///   - onCommit: An action to perform when the user performs an action
    ///     (for example, when the user presses the Return key) while the text
    ///     field has focus.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, message: "Renamed TextField.init(_:text:onEditingChanged:). Use View.onSubmit(of:_:) for functionality previously provided by the onCommit parameter. Use FocusState<T> and View.focused(_:equals:) for functionality previously provided by the onEditingChanged parameter.")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, message: "Renamed TextField.init(_:text:onEditingChanged:). Use View.onSubmit(of:_:) for functionality previously provided by the onCommit parameter. Use FocusState<T> and View.focused(_:equals:) for functionality previously provided by the onEditingChanged parameter.")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, message: "Renamed TextField.init(_:text:onEditingChanged:). Use View.onSubmit(of:_:) for functionality previously provided by the onCommit parameter. Use FocusState<T> and View.focused(_:equals:) for functionality previously provided by the onEditingChanged parameter.")
    @available(watchOS, introduced: 6.0, deprecated: 100000.0, message: "Renamed TextField.init(_:text:onEditingChanged:). Use View.onSubmit(of:_:) for functionality previously provided by the onCommit parameter. Use FocusState<T> and View.focused(_:equals:) for functionality previously provided by the onEditingChanged parameter.")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Renamed TextField.init(_:text:onEditingChanged:). Use View.onSubmit(of:_:) for functionality previously provided by the onCommit parameter. Use FocusState<T> and View.focused(_:equals:) for functionality previously provided by the onEditingChanged parameter.")
    nonisolated public init(_ titleKey: LocalizedStringKey, text: Binding<String>, onCommit: @escaping () -> Void)

    /// Creates a text field with a text label generated from a title string.
    ///
    /// - Parameters:
    ///   - title: The title of the text view, describing its purpose.
    ///   - text: The text to display and edit.
    ///   - onEditingChanged: The action to perform when the user
    ///     begins editing `text` and after the user finishes editing `text`.
    ///     The closure receives a Boolean value that indicates the editing
    ///     status: `true` when the user begins editing, `false` when they
    ///     finish.
    ///   - onCommit: An action to perform when the user performs an action
    ///     (for example, when the user presses the Return key) while the text
    ///     field has focus.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, message: "Renamed TextField.init(_:text:onEditingChanged:). Use View.onSubmit(of:_:) for functionality previously provided by the onCommit parameter. Use FocusState<T> and View.focused(_:equals:) for functionality previously provided by the onEditingChanged parameter.")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, message: "Renamed TextField.init(_:text:onEditingChanged:). Use View.onSubmit(of:_:) for functionality previously provided by the onCommit parameter. Use FocusState<T> and View.focused(_:equals:) for functionality previously provided by the onEditingChanged parameter.")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, message: "Renamed TextField.init(_:text:onEditingChanged:). Use View.onSubmit(of:_:) for functionality previously provided by the onCommit parameter. Use FocusState<T> and View.focused(_:equals:) for functionality previously provided by the onEditingChanged parameter.")
    @available(watchOS, introduced: 6.0, deprecated: 100000.0, message: "Renamed TextField.init(_:text:onEditingChanged:). Use View.onSubmit(of:_:) for functionality previously provided by the onCommit parameter. Use FocusState<T> and View.focused(_:equals:) for functionality previously provided by the onEditingChanged parameter.")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Renamed TextField.init(_:text:onEditingChanged:). Use View.onSubmit(of:_:) for functionality previously provided by the onCommit parameter. Use FocusState<T> and View.focused(_:equals:) for functionality previously provided by the onEditingChanged parameter.")
    nonisolated public init<S>(_ title: S, text: Binding<String>, onEditingChanged: @escaping (Bool) -> Void, onCommit: @escaping () -> Void) where S : StringProtocol

    /// Creates a text field with a text label generated from a title string.
    ///
    /// - Parameters:
    ///   - title: The title of the text view, describing its purpose.
    ///   - text: The text to display and edit.
    ///   - onEditingChanged: The action to perform when the user
    ///     begins editing `text` and after the user finishes editing `text`.
    ///     The closure receives a Boolean value that indicates the editing
    ///     status: `true` when the user begins editing, `false` when they
    ///     finish.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, message: "Renamed TextField.init(_:text:onEditingChanged:). Use View.onSubmit(of:_:) for functionality previously provided by the onCommit parameter. Use FocusState<T> and View.focused(_:equals:) for functionality previously provided by the onEditingChanged parameter.")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, message: "Renamed TextField.init(_:text:onEditingChanged:). Use View.onSubmit(of:_:) for functionality previously provided by the onCommit parameter. Use FocusState<T> and View.focused(_:equals:) for functionality previously provided by the onEditingChanged parameter.")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, message: "Renamed TextField.init(_:text:onEditingChanged:). Use View.onSubmit(of:_:) for functionality previously provided by the onCommit parameter. Use FocusState<T> and View.focused(_:equals:) for functionality previously provided by the onEditingChanged parameter.")
    @available(watchOS, introduced: 6.0, deprecated: 100000.0, message: "Renamed TextField.init(_:text:onEditingChanged:). Use View.onSubmit(of:_:) for functionality previously provided by the onCommit parameter. Use FocusState<T> and View.focused(_:equals:) for functionality previously provided by the onEditingChanged parameter.")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Renamed TextField.init(_:text:onEditingChanged:). Use View.onSubmit(of:_:) for functionality previously provided by the onCommit parameter. Use FocusState<T> and View.focused(_:equals:) for functionality previously provided by the onEditingChanged parameter.")
    nonisolated public init<S>(_ title: S, text: Binding<String>, onEditingChanged: @escaping (Bool) -> Void) where S : StringProtocol

    /// Creates a text field with a text label generated from a title string.
    ///
    /// - Parameters:
    ///   - title: The title of the text view, describing its purpose.
    ///   - text: The text to display and edit.
    ///   - onEditingChanged: The action to perform when the user
    ///     begins editing `text` and after the user finishes editing `text`.
    ///     The closure receives a Boolean value that indicates the editing
    ///     status: `true` when the user begins editing, `false` when they
    ///     finish.
    ///   - onCommit: An action to perform when the user performs an action
    ///     (for example, when the user presses the Return key) while the text
    ///     field has focus.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, message: "Renamed TextField.init(_:text:onEditingChanged:). Use View.onSubmit(of:_:) for functionality previously provided by the onCommit parameter. Use FocusState<T> and View.focused(_:equals:) for functionality previously provided by the onEditingChanged parameter.")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, message: "Renamed TextField.init(_:text:onEditingChanged:). Use View.onSubmit(of:_:) for functionality previously provided by the onCommit parameter. Use FocusState<T> and View.focused(_:equals:) for functionality previously provided by the onEditingChanged parameter.")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, message: "Renamed TextField.init(_:text:onEditingChanged:). Use View.onSubmit(of:_:) for functionality previously provided by the onCommit parameter. Use FocusState<T> and View.focused(_:equals:) for functionality previously provided by the onEditingChanged parameter.")
    @available(watchOS, introduced: 6.0, deprecated: 100000.0, message: "Renamed TextField.init(_:text:onEditingChanged:). Use View.onSubmit(of:_:) for functionality previously provided by the onCommit parameter. Use FocusState<T> and View.focused(_:equals:) for functionality previously provided by the onEditingChanged parameter.")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Renamed TextField.init(_:text:onEditingChanged:). Use View.onSubmit(of:_:) for functionality previously provided by the onCommit parameter. Use FocusState<T> and View.focused(_:equals:) for functionality previously provided by the onEditingChanged parameter.")
    nonisolated public init<S>(_ title: S, text: Binding<String>, onCommit: @escaping () -> Void) where S : StringProtocol
}

/// A specification for the appearance and interaction of a text field.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public protocol TextFieldStyle {
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension TextFieldStyle where Self == DefaultTextFieldStyle {

    /// The default text field style, based on the text field's context.
    ///
    /// The default style represents the recommended style based on the
    /// current platform and the text field's context within the view hierarchy.
    public static var automatic: DefaultTextFieldStyle { get }
}

@available(iOS 13.0, macOS 10.15, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension TextFieldStyle where Self == RoundedBorderTextFieldStyle {

    /// A text field style with a system-defined rounded border.
    public static var roundedBorder: RoundedBorderTextFieldStyle { get }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension TextFieldStyle where Self == PlainTextFieldStyle {

    /// A text field style with no decoration.
    public static var plain: PlainTextFieldStyle { get }
}

/// A built-in set of commands for transforming the styles applied to selections
/// of text.
///
/// These commands are optional and can be explicitly requested by passing a
/// value of this type to the `Scene.commands(_:)` modifier.
@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct TextFormattingCommands : Commands {

    /// A new value describing the built-in text-formatting commands.
    public init()

    /// The contents of the command hierarchy.
    ///
    /// For any commands that you create, provide a computed `body` property
    /// that defines the scene as a composition of other scenes. You can
    /// assemble a command hierarchy from built-in commands that SwiftUI
    /// provides, as well as other commands that you've defined.
    @MainActor @preconcurrency public var body: some Commands { get }

    /// The type of commands that represents the body of this command hierarchy.
    ///
    /// When you create custom commands, Swift infers this type from your
    /// implementation of the required ``SwiftUI/Commands/body-swift.property``
    /// property.
    @available(iOS 14.0, macOS 11.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias Body = some Commands
}

/// The kind of autocapitalization behavior applied during text input.
///
/// Pass an instance of `TextInputAutocapitalization` to the
/// ``View/textInputAutocapitalization(_:)`` view modifier.
@available(iOS 15.0, tvOS 15.0, watchOS 8.0, *)
@available(macOS, unavailable)
public struct TextInputAutocapitalization : Sendable {

    /// Defines an autocapitalizing behavior that will not capitalize anything.
    public static var never: TextInputAutocapitalization { get }

    /// Defines an autocapitalizing behavior that will capitalize the first
    /// letter of every word.
    public static var words: TextInputAutocapitalization { get }

    /// Defines an autocapitalizing behavior that will capitalize the first
    /// letter in every sentence.
    public static var sentences: TextInputAutocapitalization { get }

    /// Defines an autocapitalizing behavior that will capitalize every letter.
    public static var characters: TextInputAutocapitalization { get }
}

@available(iOS 15.0, tvOS 15.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension TextInputAutocapitalization {

    /// Creates a new ``TextInputAutocapitalization`` struct from a
    /// `UITextAutocapitalizationType` enum.
    public init?(_ type: UITextAutocapitalizationType)
}

@available(iOS 17.0, visionOS 1.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
public struct TextInputDictationActivation : Equatable, Sendable {

    /// A configuration that activates dictation when someone selects the
    /// microphone.
    @available(iOS 17.0, visionOS 1.0, *)
    @available(macOS, unavailable)
    @available(watchOS, unavailable)
    @available(tvOS, unavailable)
    public static let onSelect: TextInputDictationActivation

    /// A configuration that activates dictation when someone selects the
    /// microphone or looks at the entry field.
    @available(iOS 17.0, visionOS 1.0, *)
    @available(macOS, unavailable)
    @available(watchOS, unavailable)
    @available(tvOS, unavailable)
    public static let onLook: TextInputDictationActivation

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: TextInputDictationActivation, b: TextInputDictationActivation) -> Bool
}

@available(iOS 17.0, visionOS 1.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
public struct TextInputDictationBehavior : Equatable, Sendable {

    /// A platform-appropriate default text input dictation behavior.
    ///
    /// The automatic behavior uses a ``TextInputDictationActivation`` value of
    /// ``TextInputDictationActivation/onLook`` for visionOS apps and
    /// ``TextInputDictationActivation/onSelect`` for iOS apps.
    @available(iOS 17.0, visionOS 1.0, *)
    @available(macOS, unavailable)
    @available(watchOS, unavailable)
    @available(tvOS, unavailable)
    public static let automatic: TextInputDictationBehavior

    /// Adds a dictation microphone in the search bar.
    @available(iOS 17.0, visionOS 1.0, *)
    @available(macOS, unavailable)
    @available(watchOS, unavailable)
    @available(tvOS, unavailable)
    public static func inline(activation: TextInputDictationActivation) -> TextInputDictationBehavior

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: TextInputDictationBehavior, b: TextInputDictationBehavior) -> Bool
}

/// Represents a selection of text.
///
/// A selection is either an insertion point (e.g. a cursor in the text), a
/// selection over a range of text or on macOS, multiple selections.
///
/// This is frequently used to represent selection of text in a `TextField` or
/// `TextEditor`. The following example shows a text editor that leverages
/// text selection to offer live suggestions based on the current selection.
///
///     struct SuggestionTextEditor: View {
///         @State var text: String = ""
///         @State var selection: TextSelection? = nil
///
///         var body: some View {
///             VStack {
///                 TextEditor(text: $text, selection: $selection)
///                 // A helper view that offers live suggestions based on selection.
///                 SuggestionsView(
///                     substrings: getSubstrings(text: text, indices: selection?.indices))
///             }
///         }
///
///         private func getSubstrings(
///             text: String, indices: TextSelection.Indices?
///         ) -> [Substring] {
///             // Resolve substrings representing the current selection...
///         }
///     }
///
///     struct SuggestionsView: View { ... }
///
/// You can also use the ``View/textSelectionAffinity(_:)`` modifier to specify
/// a selection affinity on the given hierarchy:
///
///     struct SuggestionTextEditor: View {
///         @State var text: String = ""
///         @State var selection: TextSelection? = nil
///
///         var body: some View {
///             VStack {
///                 TextEditor(text: $text, selection: $selection)
///                 // A helper view that offers live suggestions based on selection.
///                 SuggestionsView(
///                     substrings: getSubstrings(text: text, indices: selection?.indices))
///             }
///             .textSelectionAffinity(.upstream)
///         }
///
///         private func getSubstrings(
///             text: String, indices: TextSelection.Indices?
///         ) -> [Substring] {
///             // Resolve substrings representing the current selection...
///         }
///     }
///
///     struct SuggestionsView: View { ... }
///
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct TextSelection : Equatable, Hashable {

    /// The indicies of the current selection.
    public enum Indices : Equatable, Hashable {

        /// The range of the single selection. This may also an represent
        /// insertion points if `range.lowerBound == range.upperBound`.
        case selection(Range<String.Index>)

        /// The range-set of the selections.
        case multiSelection(RangeSet<String.Index>)

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: TextSelection.Indices, b: TextSelection.Indices) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Return the current text selection indices.
    public var indices: TextSelection.Indices

    /// Return the selection affinity of the selection.
    public var affinity: TextSelectionAffinity { get }

    /// Create a single selection with a given range.
    ///
    /// - Parameters:
    ///   - range: A range of `String.Index` representing the selection.
    public init(range: Range<String.Index>)

    /// Create multiple selections with a given range-set.
    ///
    /// - Parameters:
    ///   - ranges: A range-set of `String.Index` representing the selection.
    public init(ranges: RangeSet<String.Index>)

    /// Create a selection at a given insertion point.
    ///
    /// - Parameters:
    ///   - insertionPoint: A`String.Index` representing the insertion point.
    public init(insertionPoint: String.Index)

    /// Return `true` if the selection is an insertion point.
    ///
    /// An insertion point effectively represents a range that contains no
    /// characters, indicating a location in the string. This location refers
    /// to the point in the text where new characters will be inserted.
    /// In other words, it represents cases when the start and end index are equal.
    public var isInsertion: Bool { get }

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: TextSelection, b: TextSelection) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

/// A representation of the direction or association of a selection or cursor
/// relative to a text character. This concept becomes much more prominent
/// when dealing with bidirectional text (text that contains both LTR and RTL
/// scripts, like English and Arabic combined).
///
/// This type also determines whether, for example, the insertion point appears
/// after the last character on a line or before the first character on the
/// following line in cases where text wraps across line boundaries.
///
/// Given the scenario `hello|`, where `|` represents the cursor & ``
/// represents "hello" in Arabic, the ambiguity arises because:
///
/// - If the cursor is associated with the end of the English word, it would be
///   as if you're continuing to type in English (LTR).
/// - If the cursor is associated with the beginning of the Arabic word, it would
///   also be as if you're continuing to type in Arabic (RTL).
///
/// `TextSelectionAffinity` helps resolve this ambiguity by determining the
/// direction or association of the cursor relative to the surrounding text.
///
/// You can configure the selection affinity on a given hierarchy by using the
/// ``View/textSelectionAffinity(_:)`` modifier:
///
///     struct SuggestionTextEditor: View {
///         @State var text: String = ""
///         @State var selection: TextSelection? = nil
///
///         var body: some View {
///             VStack {
///                 TextEditor(text: $text, selection: $selection)
///                 // A helper view that offers live suggestions based on selection.
///                 SuggestionsView(
///                     substrings: getSubstrings(text: text, indices: selection?.indices))
///             }
///             .textSelectionAffinity(.upstream)
///         }
///
///         private func getSubstrings(
///             text: String, indices: TextSelection.Indices?
///         ) -> [Substring] {
///             // Resolve substrings representing the current selection...
///         }
///     }
///
///     struct SuggestionsView: View { ... }
///
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public enum TextSelectionAffinity : Equatable, Hashable {

    /// A selection affinity determined by the framework based on the
    /// current context.
    case automatic

    /// An upstream selection affinity. In this case, the cursor is associated
    /// with the character immediately before it.
    ///
    /// In the context of our example  `hello|`, with an upstream affinity,
    /// the cursor would be associated with the "o" from "hello". If you were
    /// to type in English, the characters would continue to be added after the "o" in "hello".
    case upstream

    /// An downstream selection affinity. In this case, the cursor is associated
    /// with the character immediately after it.
    ///
    /// In the context of our example `hello|`, with a downstream affinity,
    /// the cursor would be associated with the first character of "".
    /// If you were to type in Arabic, the characters would be added before the ""
    /// in "", since Arabic is written right-to-left.
    case downstream

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: TextSelectionAffinity, b: TextSelectionAffinity) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

/// A view that updates according to a schedule that you provide.
///
/// A timeline view acts as a container with no appearance of its own. Instead,
/// it redraws the content it contains at scheduled points in time.
/// For example, you can update the face of an analog timer once per second:
///
///     TimelineView(.periodic(from: startDate, by: 1)) { context in
///         AnalogTimerView(date: context.date)
///     }
///
/// The closure that creates the content receives an input of type ``Context``
/// that you can use to customize the content's appearance. The context includes
/// the ``Context/date`` that triggered the update. In the example above,
/// the timeline view sends that date to an analog timer that you create so the
/// timer view knows how to draw the hands on its face.
///
/// The context also includes a ``Context/cadence-swift.property``
/// property that you can use to hide unnecessary detail. For example, you
/// can use the cadence to decide when it's appropriate to display the
/// timer's second hand:
///
///     TimelineView(.periodic(from: startDate, by: 1.0)) { context in
///         AnalogTimerView(
///             date: context.date,
///             showSeconds: context.cadence <= .seconds)
///     }
///
/// The system might use a cadence that's slower than the schedule's
/// update rate. For example, a view on watchOS might remain visible when the
/// user lowers their wrist, but update less frequently, and thus require
/// less detail.
///
/// You can define a custom schedule by creating a type that conforms to the
/// ``TimelineSchedule`` protocol, or use one of the built-in schedule types:
/// * Use an ``TimelineSchedule/everyMinute`` schedule to update at the
///   beginning of each minute.
/// * Use a ``TimelineSchedule/periodic(from:by:)`` schedule to update
///   periodically with a custom start time and interval between updates.
/// * Use an ``TimelineSchedule/explicit(_:)`` schedule when you need a finite number, or
///   irregular set of updates.
///
/// For a schedule containing only dates in the past,
/// the timeline view shows the last date in the schedule.
/// For a schedule containing only dates in the future,
/// the timeline draws its content using the current date
/// until the first scheduled date arrives.
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public struct TimelineView<Schedule, Content> where Schedule : TimelineSchedule {

    /// Information passed to a timeline view's content callback.
    ///
    /// The context includes both the ``date`` from the schedule that triggered
    /// the callback, and a ``cadence-swift.property`` that you can use
    /// to customize the appearance of your view. For example, you might choose
    /// to display the second hand of an analog clock only when the cadence is
    /// ``Cadence-swift.enum/seconds`` or faster.
    public struct Context {

        /// A rate at which timeline views can receive updates.
        ///
        /// Use the cadence presented to content in a ``TimelineView`` to hide
        /// information that updates faster than the view's current update rate.
        /// For example, you could hide the millisecond component of a digital
        /// timer when the cadence is ``seconds`` or ``minutes``.
        ///
        /// Because this enumeration conforms to the
        /// <doc://com.apple.documentation/documentation/Swift/Comparable>
        /// protocol, you can compare cadences with relational operators.
        /// Slower cadences have higher values, so you could perform the check
        /// described above with the following comparison:
        ///
        ///     let hideMilliseconds = cadence > .live
        ///
        public enum Cadence : Comparable, Sendable {

            /// Updates the view continuously.
            case live

            /// Updates the view approximately once per second.
            case seconds

            /// Updates the view approximately once per minute.
            case minutes

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: TimelineView<Schedule, Content>.Context.Cadence, b: TimelineView<Schedule, Content>.Context.Cadence) -> Bool

            /// Hashes the essential components of this value by feeding them into the
            /// given hasher.
            ///
            /// Implement this method to conform to the `Hashable` protocol. The
            /// components used for hashing must be the same as the components compared
            /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
            /// with each of these components.
            ///
            /// - Important: In your implementation of `hash(into:)`,
            ///   don't call `finalize()` on the `hasher` instance provided,
            ///   or replace it with a different instance.
            ///   Doing so may become a compile-time error in the future.
            ///
            /// - Parameter hasher: The hasher to use when combining the components
            ///   of this instance.
            public func hash(into hasher: inout Hasher)

            /// Returns a Boolean value indicating whether the value of the first
            /// argument is less than that of the second argument.
            ///
            /// This function is the only requirement of the `Comparable` protocol. The
            /// remainder of the relational operator functions are implemented by the
            /// standard library for any type that conforms to `Comparable`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func < (a: TimelineView<Schedule, Content>.Context.Cadence, b: TimelineView<Schedule, Content>.Context.Cadence) -> Bool

            /// The hash value.
            ///
            /// Hash values are not guaranteed to be equal across different executions of
            /// your program. Do not save hash values to use during a future execution.
            ///
            /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
            ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
            ///   The compiler provides an implementation for `hashValue` for you.
            public var hashValue: Int { get }
        }

        /// The date from the schedule that triggered the current view update.
        ///
        /// The first time a ``TimelineView`` closure receives this date, it
        /// might be in the past. For example, if you create an
        /// ``TimelineSchedule/everyMinute`` schedule at `10:09:55`, the
        /// schedule creates entries `10:09:00`, `10:10:00`, `10:11:00`, and so
        /// on. In response, the timeline view performs an initial update
        /// immediately, at `10:09:55`, but the context contains the `10:09:00`
        /// date entry. Subsequent entries arrive at their corresponding times.
        public let date: Date

        /// The rate at which the timeline updates the view.
        ///
        /// Use this value to hide information that updates faster than the
        /// view's current update rate. For example, you could hide the
        /// millisecond component of a digital timer when the cadence is
        /// anything slower than ``Cadence-swift.enum/live``.
        ///
        /// Because the ``Cadence-swift.enum`` enumeration conforms to the
        /// <doc://com.apple.documentation/documentation/Swift/Comparable>
        /// protocol, you can compare cadences with relational operators.
        /// Slower cadences have higher values, so you could perform the check
        /// described above with the following comparison:
        ///
        ///     let hideMilliseconds = cadence > .live
        ///
        public let cadence: TimelineView<Schedule, Content>.Context.Cadence
    }
}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension TimelineView : View where Content : View {

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    public typealias Body = Never

    /// Creates a new timeline view that uses the given schedule.
    ///
    /// - Parameters:
    ///   - schedule: A schedule that produces a sequence of dates that
    ///     indicate the instances when the view should update.
    ///     Use a type that conforms to ``TimelineSchedule``, like
    ///     ``TimelineSchedule/everyMinute``, or a custom timeline schedule
    ///     that you define.
    ///   - content: A closure that generates view content at the moments
    ///     indicated by the schedule. The closure takes an input of type
    ///     ``TimelineViewDefaultContext`` that includes the date from the schedule that
    ///     prompted the update, as well as a ``Context/Cadence-swift.enum``
    ///     value that the view can use to customize its appearance.
    nonisolated public init(_ schedule: Schedule, @ViewBuilder content: @escaping (TimelineViewDefaultContext) -> Content)

    /// Creates a new timeline view that uses the given schedule.
    ///
    /// - Parameters:
    ///   - schedule: A schedule that produces a sequence of dates that
    ///     indicate the instances when the view should update.
    ///     Use a type that conforms to ``TimelineSchedule``, like
    ///     ``TimelineSchedule/everyMinute``, or a custom timeline schedule
    ///     that you define.
    ///   - content: A closure that generates view content at the moments
    ///     indicated by the schedule. The closure takes an input of type
    ///     ``Context`` that includes the date from the schedule that
    ///     prompted the update, as well as a ``Context/Cadence-swift.enum``
    ///     value that the view can use to customize its appearance.
    @available(iOS, deprecated, introduced: 15.0, message: "Use TimelineViewDefaultContext for the type of the context parameter passed into TimelineView's content closure to resolve this warning. The new version of this initializer, using TimelineViewDefaultContext, improves compilation performance by using an independent generic type signature, which helps avoid unintended cyclical type dependencies.")
    @available(macOS, deprecated, introduced: 12.0, message: "Use TimelineViewDefaultContext for the type of the context parameter passed into TimelineView's content closure to resolve this warning. The new version of this initializer, using TimelineViewDefaultContext, improves compilation performance by using an independent generic type signature, which helps avoid unintended cyclical type dependencies.")
    @available(watchOS, deprecated, introduced: 8.0, message: "Use TimelineViewDefaultContext for the type of the context parameter passed into TimelineView's content closure to resolve this warning. The new version of this initializer, using TimelineViewDefaultContext, improves compilation performance by using an independent generic type signature, which helps avoid unintended cyclical type dependencies.")
    @available(tvOS, deprecated, introduced: 15.0, message: "Use TimelineViewDefaultContext for the type of the context parameter passed into TimelineView's content closure to resolve this warning. The new version of this initializer, using TimelineViewDefaultContext, improves compilation performance by using an independent generic type signature, which helps avoid unintended cyclical type dependencies.")
    @available(visionOS, deprecated, introduced: 1.0, message: "Use TimelineViewDefaultContext for the type of the context parameter passed into TimelineView's content closure to resolve this warning. The new version of this initializer, using TimelineViewDefaultContext, improves compilation performance by using an independent generic type signature, which helps avoid unintended cyclical type dependencies.")
    nonisolated public init(_ schedule: Schedule, @ViewBuilder content: @escaping (TimelineView<Schedule, Content>.Context) -> Content)
}

@available(iOS 16.0, watchOS 8.0, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
extension TimelineView.Context {

    /// Resets any pre-rendered views the system has from the timeline.
    ///
    /// When entering Always On Display, the system might pre-render frames. If the
    /// content of these frames must change in a way that isn't reflected by
    /// the schedule or the timeline view's current bindings --- for example, because
    /// the user changes the title of a future calendar event --- call this method to
    /// request that the frames be regenerated.
    public func invalidateTimelineContent()
}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension TimelineView.Context.Cadence : Hashable {
}

/// Information passed to a timeline view's content callback.
///
/// The context includes both the date from the schedule that triggered
/// the callback, and a cadence that you can use to customize the appearance of
/// your view. For example, you might choose to display the second hand of an
/// analog clock only when the cadence is
/// ``TimelineView/Context/Cadence-swift.enum/seconds`` or faster.
///
/// > Note: This type alias uses a specific concrete instance of
/// ``TimelineView/Context`` that all timeline views can use.
/// It does this to prevent introducing an unnecessary generic parameter
/// dependency on the context type.
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public typealias TimelineViewDefaultContext = TimelineView<EveryMinuteTimelineSchedule, Never>.Context

/// A label style that shows both the title and icon of the label using a
/// system-standard layout.
///
/// You can also use ``LabelStyle/titleAndIcon`` to construct this style.
@available(iOS 14.5, macOS 11.3, tvOS 14.5, watchOS 7.4, *)
public struct TitleAndIconLabelStyle : LabelStyle {

    /// Creates a label style that shows both the title and icon of the label
    /// using a system-standard layout.
    public init()

    /// Creates a view that represents the body of a label.
    ///
    /// The system calls this method for each ``Label`` instance in a view
    /// hierarchy where this style is the current label style.
    ///
    /// - Parameter configuration: The properties of the label.
    @MainActor @preconcurrency public func makeBody(configuration: TitleAndIconLabelStyle.Configuration) -> some View


    /// A view that represents the body of a label.
    @available(iOS 14.5, tvOS 14.5, watchOS 7.4, macOS 11.3, *)
    public typealias Body = some View
}

/// A label style that only displays the title of the label.
///
/// You can also use ``LabelStyle/titleOnly`` to construct this style.
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public struct TitleOnlyLabelStyle : LabelStyle {

    /// Creates a title-only label style.
    public init()

    /// Creates a view that represents the body of a label.
    ///
    /// The system calls this method for each ``Label`` instance in a view
    /// hierarchy where this style is the current label style.
    ///
    /// - Parameter configuration: The properties of the label.
    @MainActor @preconcurrency public func makeBody(configuration: TitleOnlyLabelStyle.Configuration) -> some View


    /// A view that represents the body of a label.
    @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
    public typealias Body = some View
}

/// A control that toggles between on and off states.
///
/// You create a toggle by providing an `isOn` binding and a label. Bind `isOn`
/// to a Boolean property that determines whether the toggle is on or off. Set
/// the label to a view that visually describes the purpose of switching between
/// toggle states. For example:
///
///     @State private var vibrateOnRing = false
///
///     var body: some View {
///         Toggle(isOn: $vibrateOnRing) {
///             Text("Vibrate on Ring")
///         }
///     }
///
/// For the common case of ``Label`` based labels, you can use the convenience
/// initializer that takes a title string (or localized string key) and the
/// name of a system image:
///
///     @State private var vibrateOnRing = true
///
///     var body: some View {
///         Toggle(
///             "Vibrate on Ring",
///             systemImage: "dot.radiowaves.left.and.right",
///             isOn: $vibrateOnRing
///         )
///     }
///
/// For text-only labels, you can use the convenience initializer that takes
/// a title string (or localized string key) as its first parameter, instead
/// of a trailing closure:
///
///     @State private var vibrateOnRing = true
///
///     var body: some View {
///         Toggle("Vibrate on Ring", isOn: $vibrateOnRing)
///     }
///
/// For cases where adding a subtitle to the label is desired, use a view
/// builder that creates multiple `Text` views where the first text represents
/// the title and the second text represents the subtitle:
///
///     @State private var vibrateOnRing = false
///
///     var body: some View {
///         Toggle(isOn: $vibrateOnRing) {
///             Text("Vibrate on Ring")
///             Text("Enable vibration when the phone rings")
///         }
///     }
/// > Note: This behavior does not apply to ``ToggleStyle/button``.
///
///
/// ### Styling toggles
///
/// Toggles use a default style that varies based on both the platform and
/// the context. For more information, read about the ``ToggleStyle/automatic``
/// toggle style.
///
/// You can customize the appearance and interaction of toggles by applying
/// styles using the ``View/toggleStyle(_:)`` modifier. You can apply built-in
/// styles, like ``ToggleStyle/switch``, to either a toggle, or to a view
/// hierarchy that contains toggles:
///
///     VStack {
///         Toggle("Vibrate on Ring", isOn: $vibrateOnRing)
///         Toggle("Vibrate on Silent", isOn: $vibrateOnSilent)
///     }
///     .toggleStyle(.switch)
///
/// You can also define custom styles by creating a type that conforms to the
/// ``ToggleStyle`` protocol.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public struct Toggle<Label> : View where Label : View {

    /// Creates a toggle that displays a custom label.
    ///
    /// - Parameters:
    ///   - isOn: A binding to a property that determines whether the toggle is on
    ///     or off.
    ///   - label: A view that describes the purpose of the toggle.
    public init(isOn: Binding<Bool>, @ViewBuilder label: () -> Label)

    /// Creates a toggle representing a collection of values with a custom label.
    ///
    /// The following example creates a single toggle that represents
    /// the state of multiple alarms:
    ///
    ///     struct Alarm: Hashable, Identifiable {
    ///         var id = UUID()
    ///         var isOn = false
    ///         var name = ""
    ///     }
    ///
    ///     @State private var alarms = [
    ///         Alarm(isOn: true, name: "Morning"),
    ///         Alarm(isOn: false, name: "Evening")
    ///     ]
    ///
    ///     Toggle(sources: $alarms, isOn: \.isOn) {
    ///         Text("Enable all alarms")
    ///     }
    ///
    /// - Parameters:
    ///   - sources: A collection of values used as the source for rendering the
    ///     Toggle's state.
    ///   - isOn: The key path of the values that determines whether the toggle
    ///     is on, mixed or off.
    ///   - label: A view that describes the purpose of the toggle.
    @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
    public init<C>(sources: C, isOn: KeyPath<C.Element, Binding<Bool>>, @ViewBuilder label: () -> Label) where C : RandomAccessCollection

    /// The content and behavior of the view.
    ///
    /// When you implement a custom view, you must implement a computed
    /// `body` property to provide the content for your view. Return a view
    /// that's composed of built-in views that SwiftUI provides, plus other
    /// composite views that you've already defined:
    ///
    ///     struct MyView: View {
    ///         var body: some View {
    ///             Text("Hello, World!")
    ///         }
    ///     }
    ///
    /// For more information about composing views and a view hierarchy,
    /// see <doc:Declaring-a-Custom-View>.
    @MainActor @preconcurrency public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    public typealias Body = some View
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Toggle where Label == ToggleStyleConfiguration.Label {

    /// Creates a toggle based on a toggle style configuration.
    ///
    /// You can use this initializer within the
    /// ``ToggleStyle/makeBody(configuration:)`` method of a ``ToggleStyle`` to
    /// create an instance of the styled toggle. This is useful for custom
    /// toggle styles that only modify the current toggle style, as opposed to
    /// implementing a brand new style.
    ///
    /// For example, the following style adds a red border around the toggle,
    /// but otherwise preserves the toggle's current style:
    ///
    ///     struct RedBorderToggleStyle: ToggleStyle {
    ///         func makeBody(configuration: Configuration) -> some View {
    ///             Toggle(configuration)
    ///                 .padding()
    ///                 .border(.red)
    ///         }
    ///     }
    ///
    /// - Parameter configuration: The properties of the toggle, including a
    ///   label and a binding to the toggle's state.
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    nonisolated public init(_ configuration: ToggleStyleConfiguration)
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Toggle where Label == Text {

    /// Creates a toggle that generates its label from a localized string key.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// `Text` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the toggle's localized title, that describes
    ///     the purpose of the toggle.
    ///   - isOn: A binding to a property that indicates whether the toggle is
    ///    on or off.
    nonisolated public init(_ titleKey: LocalizedStringKey, isOn: Binding<Bool>)

    /// Creates a toggle that generates its label from a string.
    ///
    /// This initializer creates a ``Text`` view on your behalf. See `Text` for more
    /// information about localizing strings.
    ///
    /// - Parameters:
    ///   - title: A string that describes the purpose of the toggle.
    ///   - isOn: A binding to a property that indicates whether the toggle is
    ///    on or off.
    nonisolated public init<S>(_ title: S, isOn: Binding<Bool>) where S : StringProtocol

    /// Creates a toggle representing a collection of values that generates its
    /// label from a localized string key.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// `Text` for more information about localizing strings.
    ///
    /// The following example creates a single toggle that represents
    /// the state of multiple alarms:
    ///
    ///     struct Alarm: Hashable, Identifiable {
    ///         var id = UUID()
    ///         var isOn = false
    ///         var name = ""
    ///     }
    ///
    ///     @State private var alarms = [
    ///         Alarm(isOn: true, name: "Morning"),
    ///         Alarm(isOn: false, name: "Evening")
    ///     ]
    ///
    ///     Toggle("Enable all alarms", sources: $alarms, isOn: \.isOn)
    ///
    /// - Parameters:
    ///   - titleKey: The key for the toggle's localized title, that describes
    ///     the purpose of the toggle.
    ///   - sources: A collection of values used as the source for rendering the
    ///     Toggle's state.
    ///   - isOn: The key path of the values that determines whether the toggle
    ///     is on, mixed or off.
    @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
    nonisolated public init<C>(_ titleKey: LocalizedStringKey, sources: C, isOn: KeyPath<C.Element, Binding<Bool>>) where C : RandomAccessCollection

    /// Creates a toggle representing a collection of values that generates its
    /// label from a string.
    ///
    /// This initializer creates a ``Text`` view on your behalf. See `Text` for more
    /// information about localizing strings.
    ///
    /// The following example creates a single toggle that represents
    /// the state of multiple alarms:
    ///
    ///     struct Alarm: Hashable, Identifiable {
    ///         var id = UUID()
    ///         var isOn = false
    ///         var name = ""
    ///     }
    ///
    ///     @State private var alarms = [
    ///         Alarm(isOn: true, name: "Morning"),
    ///         Alarm(isOn: false, name: "Evening")
    ///     ]
    ///
    ///     Toggle("Enable all alarms", sources: $alarms, isOn: \.isOn)
    ///
    /// - Parameters:
    ///   - title: A string that describes the purpose of the toggle.
    ///   - sources: A collection of values used as the source for rendering
    ///     the Toggle's state.
    ///   - isOn: The key path of the values that determines whether the toggle
    ///     is on, mixed or off.
    @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
    nonisolated public init<S, C>(_ title: S, sources: C, isOn: KeyPath<C.Element, Binding<Bool>>) where S : StringProtocol, C : RandomAccessCollection
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension Toggle where Label == Label<Text, Image> {

    /// Creates a toggle that generates its label from a localized string key
    /// and system image.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// `Text` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the toggle's localized title, that describes
    ///     the purpose of the toggle.
    ///   - systemImage: The name of the image resource to lookup.
    ///   - isOn: A binding to a property that indicates whether the toggle is
    ///    on or off.
    nonisolated public init(_ titleKey: LocalizedStringKey, systemImage: String, isOn: Binding<Bool>)

    /// Creates a toggle that generates its label from a string and
    /// system image.
    ///
    /// This initializer creates a ``Text`` view on your behalf. See `Text` for more
    /// information about localizing strings.
    ///
    /// - Parameters:
    ///   - title: A string that describes the purpose of the toggle.
    ///   - systemImage: The name of the image resource to lookup.
    ///   - isOn: A binding to a property that indicates whether the toggle is
    ///    on or off.
    nonisolated public init<S>(_ title: S, systemImage: String, isOn: Binding<Bool>) where S : StringProtocol

    /// Creates a toggle representing a collection of values that generates its
    /// label from a localized string key and system image.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// `Text` for more information about localizing strings.
    ///
    /// The following example creates a single toggle that represents
    /// the state of multiple alarms:
    ///
    ///     struct Alarm: Hashable, Identifiable {
    ///         var id = UUID()
    ///         var isOn = false
    ///         var name = ""
    ///     }
    ///
    ///     @State private var alarms = [
    ///         Alarm(isOn: true, name: "Morning"),
    ///         Alarm(isOn: false, name: "Evening")
    ///     ]
    ///
    ///     Toggle("Enable all alarms", sources: $alarms, isOn: \.isOn)
    ///
    /// - Parameters:
    ///   - titleKey: The key for the toggle's localized title, that describes
    ///     the purpose of the toggle.
    ///   - systemImage: The name of the image resource to lookup.
    ///   - sources: A collection of values used as the source for rendering the
    ///     Toggle's state.
    ///   - isOn: The key path of the values that determines whether the toggle
    ///     is on, mixed or off.
    @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
    nonisolated public init<C>(_ titleKey: LocalizedStringKey, systemImage: String, sources: C, isOn: KeyPath<C.Element, Binding<Bool>>) where C : RandomAccessCollection

    /// Creates a toggle representing a collection of values that generates its
    /// label from a string.
    ///
    /// This initializer creates a ``Text`` view on your behalf. See `Text` for more
    /// information about localizing strings.
    ///
    /// The following example creates a single toggle that represents
    /// the state of multiple alarms:
    ///
    ///     struct Alarm: Hashable, Identifiable {
    ///         var id = UUID()
    ///         var isOn = false
    ///         var name = ""
    ///     }
    ///
    ///     @State private var alarms = [
    ///         Alarm(isOn: true, name: "Morning"),
    ///         Alarm(isOn: false, name: "Evening")
    ///     ]
    ///
    ///     Toggle("Enable all alarms", sources: $alarms, isOn: \.isOn)
    ///
    /// - Parameters:
    ///   - title: A string that describes the purpose of the toggle.
    ///   - systemImage: The name of the image resource to lookup.
    ///   - sources: A collection of values used as the source for rendering
    ///     the Toggle's state.
    ///   - isOn: The key path of the values that determines whether the toggle
    ///     is on, mixed or off.
    @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
    nonisolated public init<S, C>(_ title: S, systemImage: String, sources: C, isOn: KeyPath<C.Element, Binding<Bool>>) where S : StringProtocol, C : RandomAccessCollection
}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension Toggle where Label == Label<Text, Image> {

    /// Creates a toggle that generates its label from a localized string key
    /// and image resource.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// `Text` for more information about localizing strings.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the toggle's localized title, that describes
    ///     the purpose of the toggle.
    ///   - image: The name of the image resource to lookup.
    ///   - isOn: A binding to a property that indicates whether the toggle is
    ///    on or off.
    nonisolated public init(_ titleKey: LocalizedStringKey, image: ImageResource, isOn: Binding<Bool>)

    /// Creates a toggle that generates its label from a string and
    /// image resource.
    ///
    /// This initializer creates a ``Text`` view on your behalf.  See `Text` for more
    /// information about localizing strings.
    ///
    /// - Parameters:
    ///   - title: A string that describes the purpose of the toggle.
    ///   - image: The name of the image resource to lookup.
    ///   - isOn: A binding to a property that indicates whether the toggle is
    ///    on or off.
    nonisolated public init<S>(_ title: S, image: ImageResource, isOn: Binding<Bool>) where S : StringProtocol

    /// Creates a toggle representing a collection of values that generates its
    /// label from a localized string key and image resource.
    ///
    /// This initializer creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. See
    /// `Text` for more information about localizing strings.
    ///
    /// The following example creates a single toggle that represents
    /// the state of multiple alarms:
    ///
    ///     struct Alarm: Hashable, Identifiable {
    ///         var id = UUID()
    ///         var isOn = false
    ///         var name = ""
    ///     }
    ///
    ///     @State private var alarms = [
    ///         Alarm(isOn: true, name: "Morning"),
    ///         Alarm(isOn: false, name: "Evening")
    ///     ]
    ///
    ///     Toggle("Enable all alarms", sources: $alarms, isOn: \.isOn)
    ///
    /// - Parameters:
    ///   - titleKey: The key for the toggle's localized title, that describes
    ///     the purpose of the toggle.
    ///   - image: The name of the image resource to lookup.
    ///   - sources: A collection of values used as the source for rendering the
    ///     Toggle's state.
    ///   - isOn: The key path of the values that determines whether the toggle
    ///     is on, mixed or off.
    nonisolated public init<C>(_ titleKey: LocalizedStringKey, image: ImageResource, sources: C, isOn: KeyPath<C.Element, Binding<Bool>>) where C : RandomAccessCollection

    /// Creates a toggle representing a collection of values that generates its
    /// label from a string and image resource.
    ///
    /// This initializer creates a ``Text`` view on your behalf. See `Text` for more
    /// information about localizing strings.
    ///
    /// The following example creates a single toggle that represents
    /// the state of multiple alarms:
    ///
    ///     struct Alarm: Hashable, Identifiable {
    ///         var id = UUID()
    ///         var isOn = false
    ///         var name = ""
    ///     }
    ///
    ///     @State private var alarms = [
    ///         Alarm(isOn: true, name: "Morning"),
    ///         Alarm(isOn: false, name: "Evening")
    ///     ]
    ///
    ///     Toggle("Enable all alarms", sources: $alarms, isOn: \.isOn)
    ///
    /// - Parameters:
    ///   - title: A string that describes the purpose of the toggle.
    ///   - image: The name of the image resource to lookup.
    ///   - sources: A collection of values used as the source for rendering
    ///     the Toggle's state.
    ///   - isOn: The key path of the values that determines whether the toggle
    ///     is on, mixed or off.
    nonisolated public init<S, C>(_ title: S, image: ImageResource, sources: C, isOn: KeyPath<C.Element, Binding<Bool>>) where S : StringProtocol, C : RandomAccessCollection
}

/// The appearance and behavior of a toggle.
///
/// To configure the style for a single ``Toggle`` or for all toggle instances
/// in a view hierarchy, use the ``View/toggleStyle(_:)`` modifier. You can
/// specify one of the built-in toggle styles, like ``ToggleStyle/switch`` or
/// ``ToggleStyle/button``:
///
///     Toggle(isOn: $isFlagged) {
///         Label("Flag", systemImage: "flag.fill")
///     }
///     .toggleStyle(.button)
///
/// Alternatively, you can create and apply a custom style.
///
/// ### Custom styles
///
/// To create a custom style, declare a type that conforms to the `ToggleStyle`
/// protocol and implement the required ``ToggleStyle/makeBody(configuration:)``
/// method. For example, you can define a checklist toggle style:
///
///     struct ChecklistToggleStyle: ToggleStyle {
///         func makeBody(configuration: Configuration) -> some View {
///             // Return a view that has checklist appearance and behavior.
///         }
///     }
///
/// Inside the method, use the `configuration` parameter, which is an instance
/// of the ``ToggleStyleConfiguration`` structure, to get the label and
/// a binding to the toggle state. To see examples of how to use these items
/// to construct a view that has the appearance and behavior of a toggle, see
/// ``ToggleStyle/makeBody(configuration:)``.
///
/// To provide easy access to the new style, declare a corresponding static
/// variable in an extension to `ToggleStyle`:
///
///     extension ToggleStyle where Self == ChecklistToggleStyle {
///         static var checklist: ChecklistToggleStyle { .init() }
///     }
///
/// You can then use your custom style:
///
///     Toggle(activity.name, isOn: $activity.isComplete)
///         .toggleStyle(.checklist)
///
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@MainActor @preconcurrency public protocol ToggleStyle {

    /// A view that represents the appearance and interaction of a toggle.
    ///
    /// SwiftUI infers this type automatically based on the ``View``
    /// instance that you return from your implementation of the
    /// ``makeBody(configuration:)`` method.
    associatedtype Body : View

    /// Creates a view that represents the body of a toggle.
    ///
    /// Implement this method when you define a custom toggle style that
    /// conforms to the ``ToggleStyle`` protocol. Use the `configuration`
    /// input --- a ``ToggleStyleConfiguration`` instance --- to access the
    /// toggle's label and state. Return a view that has the appearance and
    /// behavior of a toggle. For example you can create a toggle that displays
    /// a label and a circle that's either empty or filled with a checkmark:
    ///
    ///     struct ChecklistToggleStyle: ToggleStyle {
    ///         func makeBody(configuration: Configuration) -> some View {
    ///             Button {
    ///                 configuration.isOn.toggle()
    ///             } label: {
    ///                 HStack {
    ///                     Image(systemName: configuration.isOn
    ///                             ? "checkmark.circle.fill"
    ///                             : "circle")
    ///                     configuration.label
    ///                 }
    ///             }
    ///             .tint(.primary)
    ///             .buttonStyle(.borderless)
    ///         }
    ///     }
    ///
    /// The `ChecklistToggleStyle` toggle style provides a way to both observe
    /// and modify the toggle state: the circle fills for the on state, and
    /// users can tap or click the toggle to change the state. By using a
    /// customized ``Button`` to compose the toggle's body, SwiftUI
    /// automatically provides the behaviors that users expect from a
    /// control that has button-like characteristics.
    ///
    /// You can present a collection of toggles that use this style in a stack:
    ///
    /// ![A screenshot of three items stacked vertically. All have a circle
    /// followed by a label. The first has the label Walk the dog, and the
    /// circle is filled. The second has the label Buy groceries, and the
    /// circle is filled. The third has the label Call Mom, and the cirlce is
    /// empty.](ToggleStyle-makeBody-1-iOS)
    ///
    /// When updating a view hierarchy, the system calls your implementation
    /// of the `makeBody(configuration:)` method for each ``Toggle`` instance
    /// that uses the associated style.
    ///
    /// ### Modify the current style
    ///
    /// Rather than create an entirely new style, you can alternatively
    /// modify a toggle's current style. Use the ``Toggle/init(_:)``
    /// initializer inside the `makeBody(configuration:)` method to create
    /// and modify a toggle based on a `configuration` value. For example,
    /// you can create a style that adds padding and a red border to the
    /// current style:
    ///
    ///     struct RedBorderToggleStyle: ToggleStyle {
    ///         func makeBody(configuration: Configuration) -> some View {
    ///             Toggle(configuration)
    ///                 .padding()
    ///                 .border(.red)
    ///         }
    ///     }
    ///
    /// If you create a `redBorder` static variable from this style,
    /// you can apply the style to toggles that already use another style, like
    /// the built-in ``ToggleStyle/switch`` and ``ToggleStyle/button`` styles:
    ///
    ///     Toggle("Switch", isOn: $isSwitchOn)
    ///         .toggleStyle(.redBorder)
    ///         .toggleStyle(.switch)
    ///
    ///     Toggle("Button", isOn: $isButtonOn)
    ///         .toggleStyle(.redBorder)
    ///         .toggleStyle(.button)
    ///
    /// Both toggles appear with the usual styling, each with a red border:
    ///
    /// ![A screenshot of a switch toggle with a red border, and a button
    /// toggle with a red border.](ToggleStyle-makeBody-2-iOS)
    ///
    /// Apply the custom style closer to the toggle than the
    /// modified style because SwiftUI evaluates style view modifiers in order
    /// from outermost to innermost. If you apply the styles in the other
    /// order, the red border style doesn't have an effect, because the
    /// built-in styles override it completely.
    ///
    /// - Parameter configuration: The properties of the toggle, including a
    ///   label and a binding to the toggle's state.
    /// - Returns: A view that has behavior and appearance that enables it
    ///   to function as a ``Toggle``.
    @ViewBuilder @MainActor @preconcurrency func makeBody(configuration: Self.Configuration) -> Self.Body

    /// The properties of a toggle instance.
    ///
    /// You receive a `configuration` parameter of this type --- which is an
    /// alias for the ``ToggleStyleConfiguration`` type --- when you implement
    /// the required ``makeBody(configuration:)`` method in a custom toggle
    /// style implementation.
    typealias Configuration = ToggleStyleConfiguration
}

@available(iOS 15.0, macOS 12.0, watchOS 9.0, *)
@available(tvOS, unavailable)
extension ToggleStyle where Self == ButtonToggleStyle {

    /// A toggle style that displays as a button with its label as the title.
    ///
    /// Apply this style to a ``Toggle`` or to a view hierarchy that contains
    /// toggles using the ``View/toggleStyle(_:)`` modifier:
    ///
    ///     Toggle(isOn: $isFlagged) {
    ///         Label("Flag", systemImage: "flag.fill")
    ///     }
    ///     .toggleStyle(.button)
    ///
    /// The style produces a button with a label that describes the purpose
    /// of the toggle. The user taps or clicks the button to change the
    /// toggle's state. The button indicates the `on` state by filling in the
    /// background with its tint color. You can change the tint color using
    /// the ``View/tint(_:)`` modifier. SwiftUI uses this style as the
    /// default for toggles that appear in a toolbar.
    ///
    /// The following table shows the toggle in both the `off` and `on` states,
    /// respectively:
    ///
    ///   | Platform    | Appearance |
    ///   |-------------|------------|
    ///   | iOS, iPadOS | ![A screenshot of two buttons with a flag icon and the word flag inside. The first button isn't highlighted; the second one is.](ToggleStyle-button-1-iOS) |
    ///   | macOS       | ![A screenshot of two buttons with a flag icon and the word flag inside. The first button isn't highlighted; the second one is.](ToggleStyle-button-1-macOS) |
    ///
    /// A ``Label`` instance is a good choice for a button toggle's label.
    /// Based on the context, SwiftUI decides whether to display both the title
    /// and icon, as in the example above, or just the icon, like when the
    /// toggle appears in a toolbar. You can also control the label's style
    /// by adding a ``View/labelStyle(_:)`` modifier. In any case, SwiftUI
    /// always uses the title to identify the control using VoiceOver.
    @MainActor @preconcurrency public static var button: ButtonToggleStyle { get }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension ToggleStyle where Self == DefaultToggleStyle {

    /// The default toggle style.
    ///
    /// Use this ``ToggleStyle`` to let SwiftUI pick a suitable style for
    /// the current platform and context. Toggles use the `automatic` style
    /// by default, but you might need to set it explicitly using the
    /// ``View/toggleStyle(_:)`` modifier to override another style
    /// in the environment. For example, you can request automatic styling for
    /// a toggle in an ``HStack`` that's otherwise configured to use the
    /// ``ToggleStyle/button`` style:
    ///
    ///     HStack {
    ///         Toggle(isOn: $isShuffling) {
    ///             Label("Shuffle", systemImage: "shuffle")
    ///         }
    ///         Toggle(isOn: $isRepeating) {
    ///             Label("Repeat", systemImage: "repeat")
    ///         }
    ///
    ///         Divider()
    ///
    ///         Toggle("Enhance Sound", isOn: $isEnhanced)
    ///             .toggleStyle(.automatic) // Set the style automatically here.
    ///     }
    ///     .toggleStyle(.button) // Use button style for toggles in the stack.
    ///
    /// ### Platform defaults
    ///
    /// The `automatic` style produces an appearance that varies by platform,
    /// using the following styles in most contexts:
    ///
    /// | Platform    | Default style                            |
    /// |-------------|------------------------------------------|
    /// | iOS, iPadOS | ``ToggleStyle/switch``                   |
    /// | macOS       | ``ToggleStyle/checkbox``                 |
    /// | tvOS        | ``ToggleStyle/switch``                   |
    /// | watchOS     | ``ToggleStyle/switch``                   |
    ///
    /// The default style for tvOS behaves like a button. However,
    /// unlike the ``ToggleStyle/switch`` style that's on other platforms, the
    /// tvOS toggle takes as much horizontal space as its parent offers, and
    /// displays both the toggle's label and a text field that indicates the
    /// toggle's state. You typically collect tvOS toggles into a ``List``:
    ///
    ///     List {
    ///         Toggle("Show Lyrics", isOn: $isShowingLyrics)
    ///         Toggle("Shuffle", isOn: $isShuffling)
    ///         Toggle("Repeat", isOn: $isRepeating)
    ///     }
    ///
    /// ![A screenshot of three buttons labeled Show Lyrics, Shuffle, and
    /// Repeat, stacked vertically. The first is highlighted. The second is
    /// on, while the others are off.](ToggleStyle-automatic-2-tvOS)
    ///
    /// ### Contextual defaults
    ///
    /// A toggle's automatic appearance varies in certain contexts:
    ///
    /// * A toggle that appears as part of the content that you provide to one
    ///   of the toolbar modifiers, like ``View/toolbar(content:)``, uses
    ///   the ``ToggleStyle/button`` style by default.
    ///
    /// * A toggle in a ``Menu`` uses a style that you can't create explicitly:
    ///     ```
    ///     Menu("Playback") {
    ///         Toggle("Show Lyrics", isOn: $isShowingLyrics)
    ///         Toggle("Shuffle", isOn: $isShuffling)
    ///         Toggle("Repeat", isOn: $isRepeating)
    ///     }
    ///     ```
    ///   SwiftUI shows the toggle's label with a checkmark that appears only
    ///   in the `on` state:
    ///
    ///   | Platform    | Appearance |
    ///   |-------------|------------|
    ///   | iOS, iPadOS | ![A screenshot of a Playback menu in iOS showing three menu items with the labels Repeat, Shuffle, and Show Lyrics. The shuffle item has a checkmark to its left, while the other two items have a blank space to their left.](ToggleStyle-automatic-1-iOS) |
    ///   | macOS       | ![A screenshot of a Playback menu in macOS showing three menu items with the labels Repeat, Shuffle, and Show Lyrics. The shuffle item has a checkmark to its left, while the other two items have a blank space to their left.](ToggleStyle-automatic-1-macOS) |
    @MainActor @preconcurrency public static var automatic: DefaultToggleStyle { get }
}

@available(iOS 13.0, macOS 10.15, tvOS 18.0, watchOS 6.0, *)
extension ToggleStyle where Self == SwitchToggleStyle {

    /// A toggle style that displays a leading label and a trailing switch.
    ///
    /// Apply this style to a ``Toggle`` or to a view hierarchy that contains
    /// toggles using the ``View/toggleStyle(_:)`` modifier:
    ///
    ///     Toggle("Enhance Sound", isOn: $isEnhanced)
    ///         .toggleStyle(.switch)
    ///
    /// The style produces a label that describes the purpose of the toggle
    /// and a switch that shows the toggle's state. The user taps or clicks
    /// the switch to change the toggle's state. The default appearance is
    /// similar across platforms, although the way you use switches in your
    /// user interface varies a little, as described in
    /// <doc://com.apple.documentation/design/human-interface-guidelines/toggles>
    /// in the Human Interface Guidelines.
    ///
    /// @TabNavigator {
    ///     @Tab("iOS") {
    ///         @Image(source: "ToggleStyle-switch-1-iOS", alt: "A screenshot of the text On appearing to the left of a toggle switch that's on. The toggle's tint color is green. The toggle and its text appear in a rounded rectangle, and are aligned with opposite edges of the rectangle.")
    ///     }
    ///     @Tab("macOS") {
    ///         @Image(source: "ToggleStyle-switch-1-macOS", alt: "A screenshot of the text On appearing to the left of a toggle switch that's on. The toggle's tint color is blue. The toggle and its text are adjacent to each other.")
    ///     }
    ///     @Tab("watchOS") {
    ///         @Image(source: "ToggleStyle-switch-1-watchOS", alt: "A screenshot of the text On appearing to the left of a toggle switch that's on. The toggle's tint color is green. The toggle and its text appear in a rounded rectangle, and are aligned with opposite edges of the rectangle.")
    ///     }
    ///     @Tab("tvOS") {
    ///         @Image(source: "ToggleStyle-automatic-2-tvOS", alt: "A screenshot of three buttons labeled Show Lyrics, Shuffle, and Repeat, stacked vertically. The first is highlighted. The second is on, while the others are off.")
    ///     }
    /// }
    ///
    /// In iOS, iPadOS, watchOS, and tvOS, the label and switch fill as much
    /// horizontal space as the toggle's parent offers by aligning the label's
    /// leading edge and the switch's trailing edge with the containing view's
    /// respective leading and trailing edges. In macOS, the style uses a
    /// minimum of horizontal space by aligning the trailing edge of the label
    /// with the leading edge of the switch. SwiftUI helps you to manage the
    /// spacing and alignment when this style appears in a ``Form``.
    ///
    /// SwiftUI uses this style as the default for iOS, iPadOS, watchOS, and
    /// tvOS in most contexts when you don't set a style, or when you apply
    /// the ``ToggleStyle/automatic`` style.
    @MainActor @preconcurrency public static var `switch`: SwitchToggleStyle { get }
}

/// The properties of a toggle instance.
///
/// When you define a custom toggle style by creating a type that conforms to
/// the ``ToggleStyle`` protocol, you implement the
/// ``ToggleStyle/makeBody(configuration:)`` method. That method takes a
/// `ToggleStyleConfiguration` input that has the information you need
/// to define the behavior and appearance of a ``Toggle``.
///
/// The configuration structure's ``label-swift.property`` reflects the
/// toggle's content, which might be the value that you supply to the
/// `label` parameter of the ``Toggle/init(isOn:label:)`` initializer.
/// Alternatively, it could be another view that SwiftUI builds from an
/// initializer that takes a string input, like ``Toggle/init(_:isOn:)``.
/// In either case, incorporate the label into the toggle's view to help
/// the user understand what the toggle does. For example, the built-in
/// ``ToggleStyle/switch`` style horizontally stacks the label with the
/// control element.
///
/// The structure's ``isOn`` property provides a ``Binding`` to the state
/// of the toggle. Adjust the appearance of the toggle based on this value.
/// For example, the built-in ``ToggleStyle/button`` style fills the button's
/// background when the property is `true`, but leaves the background empty
/// when the property is `false`. Change the value when the user performs
/// an action that's meant to change the toggle, like the button does when
/// tapped or clicked by the user.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public struct ToggleStyleConfiguration {

    /// A type-erased label of a toggle.
    ///
    /// SwiftUI provides a value of this type --- which is a ``View`` type ---
    /// as the ``label-swift.property`` to your custom toggle style
    /// implementation. Use the label to help define the appearance of the
    /// toggle.
    @MainActor @preconcurrency public struct Label : View {

        /// The type of view representing the body of this view.
        ///
        /// When you create a custom view, Swift infers this type from your
        /// implementation of the required ``View/body-swift.property`` property.
        @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
        public typealias Body = Never
    }

    /// A view that describes the effect of switching the toggle between states.
    ///
    /// Use this value in your implementation of the
    /// ``ToggleStyle/makeBody(configuration:)`` method when defining a custom
    /// ``ToggleStyle``. Access it through the that method's `configuration`
    /// parameter.
    ///
    /// Because the label is a ``View``, you can incorporate it into the
    /// view hierarchy that you return from your style definition. For example,
    /// you can combine the label with a circle image in an ``HStack``:
    ///
    ///     HStack {
    ///         Image(systemName: configuration.isOn
    ///             ? "checkmark.circle.fill"
    ///             : "circle")
    ///         configuration.label
    ///     }
    ///
    public let label: ToggleStyleConfiguration.Label

    /// A binding to a state property that indicates whether the toggle is on.
    ///
    /// Because this value is a ``Binding``, you can both read and write it
    /// in your implementation of the ``ToggleStyle/makeBody(configuration:)``
    /// method when defining a custom ``ToggleStyle``. Access it through
    /// that method's `configuration` parameter.
    ///
    /// Read this value to set the appearance of the toggle. For example, you
    /// can choose between empty and filled circles based on the `isOn` value:
    ///
    ///     Image(systemName: configuration.isOn
    ///         ? "checkmark.circle.fill"
    ///         : "circle")
    ///
    /// Write this value when the user takes an action that's meant to change
    /// the state of the toggle. For example, you can toggle it inside the
    /// `action` closure of a ``Button`` instance:
    ///
    ///     Button {
    ///         configuration.isOn.toggle()
    ///     } label: {
    ///         // Draw the toggle.
    ///     }
    ///
    @Binding public var isOn: Bool { get nonmutating set }

    public var $isOn: Binding<Bool> { get }

    /// Whether the ``Toggle`` is currently in a mixed state.
    ///
    /// Use this property to determine whether the toggle style should render
    /// a mixed state presentation. A mixed state corresponds to an underlying
    /// collection with a mix of true and false Bindings.
    /// To toggle the state, use the ``Bool.toggle()`` method on the ``isOn``
    /// binding.
    ///
    /// In the following example, a custom style uses the `isMixed` property
    /// to render the correct toggle state using symbols:
    ///
    ///     struct SymbolToggleStyle: ToggleStyle {
    ///         func makeBody(configuration: Configuration) -> some View {
    ///             Button {
    ///                 configuration.isOn.toggle()
    ///             } label: {
    ///                 Image(
    ///                     systemName: configuration.isMixed
    ///                     ? "minus.circle.fill" : configuration.isOn
    ///                     ? "checkmark.circle.fill" : "circle.fill")
    ///                 configuration.label
    ///             }
    ///         }
    ///     }
    @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
    public var isMixed: Bool
}

/// A built-in set of commands for manipulating window toolbars.
///
/// These commands are optional and can be explicitly requested by passing a
/// value of this type to the ``Scene/commands(content:)`` modifier.
@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct ToolbarCommands : Commands {

    /// A new value describing the built-in toolbar-related commands.
    public init()

    /// The contents of the command hierarchy.
    ///
    /// For any commands that you create, provide a computed `body` property
    /// that defines the scene as a composition of other scenes. You can
    /// assemble a command hierarchy from built-in commands that SwiftUI
    /// provides, as well as other commands that you've defined.
    @MainActor @preconcurrency public var body: some Commands { get }

    /// The type of commands that represents the body of this command hierarchy.
    ///
    /// When you create custom commands, Swift infers this type from your
    /// implementation of the required ``SwiftUI/Commands/body-swift.property``
    /// property.
    @available(iOS 14.0, macOS 11.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias Body = some Commands
}

/// Conforming types represent items that can be placed in various locations
/// in a toolbar.
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
@MainActor @preconcurrency public protocol ToolbarContent {

    /// The type of content representing the body of this toolbar content.
    associatedtype Body : ToolbarContent

    /// The composition of content that comprise the toolbar content.
    @ToolbarContentBuilder @MainActor @preconcurrency var body: Self.Body { get }
}

/// Constructs a toolbar item set from multi-expression closures.
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
@resultBuilder public struct ToolbarContentBuilder {

    /// Builds an expression within the builder.
    public static func buildExpression<Content>(_ content: Content) -> Content where Content : ToolbarContent

    public static func buildBlock<Content>(_ content: Content) -> some ToolbarContent where Content : ToolbarContent


    /// Builds an expression within the builder.
    public static func buildExpression<Content>(_ content: Content) -> Content where Content : CustomizableToolbarContent

    public static func buildBlock<Content>(_ content: Content) -> some CustomizableToolbarContent where Content : CustomizableToolbarContent

}

extension ToolbarContentBuilder {

    @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
    public static func buildIf<Content>(_ content: Content?) -> Content? where Content : ToolbarContent

    @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
    public static func buildIf<Content>(_ content: Content?) -> Content? where Content : CustomizableToolbarContent

    @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
    public static func buildEither<TrueContent, FalseContent>(first: TrueContent) -> _ConditionalContent<TrueContent, FalseContent> where TrueContent : ToolbarContent, FalseContent : ToolbarContent

    @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
    public static func buildEither<TrueContent, FalseContent>(first: TrueContent) -> _ConditionalContent<TrueContent, FalseContent> where TrueContent : CustomizableToolbarContent, FalseContent : CustomizableToolbarContent

    @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
    public static func buildEither<TrueContent, FalseContent>(second: FalseContent) -> _ConditionalContent<TrueContent, FalseContent> where TrueContent : ToolbarContent, FalseContent : ToolbarContent

    @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
    public static func buildEither<TrueContent, FalseContent>(second: FalseContent) -> _ConditionalContent<TrueContent, FalseContent> where TrueContent : CustomizableToolbarContent, FalseContent : CustomizableToolbarContent

    @available(iOS 17.5, macOS 14.5, tvOS 17.5, watchOS 10.5, *)
    public static func buildLimitedAvailability(_ content: any ToolbarContent) -> some ToolbarContent


    @available(iOS 17.5, macOS 14.5, tvOS 17.5, watchOS 10.5, *)
    public static func buildLimitedAvailability(_ content: any CustomizableToolbarContent) -> some CustomizableToolbarContent

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ToolbarContentBuilder {

    public static func buildBlock<C0, C1>(_ c0: C0, _ c1: C1) -> some ToolbarContent where C0 : ToolbarContent, C1 : ToolbarContent

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ToolbarContentBuilder {

    public static func buildBlock<C0, C1, C2>(_ c0: C0, _ c1: C1, _ c2: C2) -> some ToolbarContent where C0 : ToolbarContent, C1 : ToolbarContent, C2 : ToolbarContent

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ToolbarContentBuilder {

    public static func buildBlock<C0, C1, C2, C3>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3) -> some ToolbarContent where C0 : ToolbarContent, C1 : ToolbarContent, C2 : ToolbarContent, C3 : ToolbarContent

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ToolbarContentBuilder {

    public static func buildBlock<C0, C1, C2, C3, C4>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4) -> some ToolbarContent where C0 : ToolbarContent, C1 : ToolbarContent, C2 : ToolbarContent, C3 : ToolbarContent, C4 : ToolbarContent

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ToolbarContentBuilder {

    public static func buildBlock<C0, C1, C2, C3, C4, C5>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5) -> some ToolbarContent where C0 : ToolbarContent, C1 : ToolbarContent, C2 : ToolbarContent, C3 : ToolbarContent, C4 : ToolbarContent, C5 : ToolbarContent

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ToolbarContentBuilder {

    public static func buildBlock<C0, C1, C2, C3, C4, C5, C6>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5, _ c6: C6) -> some ToolbarContent where C0 : ToolbarContent, C1 : ToolbarContent, C2 : ToolbarContent, C3 : ToolbarContent, C4 : ToolbarContent, C5 : ToolbarContent, C6 : ToolbarContent

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ToolbarContentBuilder {

    public static func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5, _ c6: C6, _ c7: C7) -> some ToolbarContent where C0 : ToolbarContent, C1 : ToolbarContent, C2 : ToolbarContent, C3 : ToolbarContent, C4 : ToolbarContent, C5 : ToolbarContent, C6 : ToolbarContent, C7 : ToolbarContent

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ToolbarContentBuilder {

    public static func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7, C8>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5, _ c6: C6, _ c7: C7, _ c8: C8) -> some ToolbarContent where C0 : ToolbarContent, C1 : ToolbarContent, C2 : ToolbarContent, C3 : ToolbarContent, C4 : ToolbarContent, C5 : ToolbarContent, C6 : ToolbarContent, C7 : ToolbarContent, C8 : ToolbarContent

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ToolbarContentBuilder {

    public static func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7, C8, C9>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5, _ c6: C6, _ c7: C7, _ c8: C8, _ c9: C9) -> some ToolbarContent where C0 : ToolbarContent, C1 : ToolbarContent, C2 : ToolbarContent, C3 : ToolbarContent, C4 : ToolbarContent, C5 : ToolbarContent, C6 : ToolbarContent, C7 : ToolbarContent, C8 : ToolbarContent, C9 : ToolbarContent

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ToolbarContentBuilder {

    public static func buildBlock<C0, C1>(_ c0: C0, _ c1: C1) -> some CustomizableToolbarContent where C0 : CustomizableToolbarContent, C1 : CustomizableToolbarContent

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ToolbarContentBuilder {

    public static func buildBlock<C0, C1, C2>(_ c0: C0, _ c1: C1, _ c2: C2) -> some CustomizableToolbarContent where C0 : CustomizableToolbarContent, C1 : CustomizableToolbarContent, C2 : CustomizableToolbarContent

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ToolbarContentBuilder {

    public static func buildBlock<C0, C1, C2, C3>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3) -> some CustomizableToolbarContent where C0 : CustomizableToolbarContent, C1 : CustomizableToolbarContent, C2 : CustomizableToolbarContent, C3 : CustomizableToolbarContent

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ToolbarContentBuilder {

    public static func buildBlock<C0, C1, C2, C3, C4>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4) -> some CustomizableToolbarContent where C0 : CustomizableToolbarContent, C1 : CustomizableToolbarContent, C2 : CustomizableToolbarContent, C3 : CustomizableToolbarContent, C4 : CustomizableToolbarContent

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ToolbarContentBuilder {

    public static func buildBlock<C0, C1, C2, C3, C4, C5>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5) -> some CustomizableToolbarContent where C0 : CustomizableToolbarContent, C1 : CustomizableToolbarContent, C2 : CustomizableToolbarContent, C3 : CustomizableToolbarContent, C4 : CustomizableToolbarContent, C5 : CustomizableToolbarContent

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ToolbarContentBuilder {

    public static func buildBlock<C0, C1, C2, C3, C4, C5, C6>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5, _ c6: C6) -> some CustomizableToolbarContent where C0 : CustomizableToolbarContent, C1 : CustomizableToolbarContent, C2 : CustomizableToolbarContent, C3 : CustomizableToolbarContent, C4 : CustomizableToolbarContent, C5 : CustomizableToolbarContent, C6 : CustomizableToolbarContent

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ToolbarContentBuilder {

    public static func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5, _ c6: C6, _ c7: C7) -> some CustomizableToolbarContent where C0 : CustomizableToolbarContent, C1 : CustomizableToolbarContent, C2 : CustomizableToolbarContent, C3 : CustomizableToolbarContent, C4 : CustomizableToolbarContent, C5 : CustomizableToolbarContent, C6 : CustomizableToolbarContent, C7 : CustomizableToolbarContent

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ToolbarContentBuilder {

    public static func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7, C8>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5, _ c6: C6, _ c7: C7, _ c8: C8) -> some CustomizableToolbarContent where C0 : CustomizableToolbarContent, C1 : CustomizableToolbarContent, C2 : CustomizableToolbarContent, C3 : CustomizableToolbarContent, C4 : CustomizableToolbarContent, C5 : CustomizableToolbarContent, C6 : CustomizableToolbarContent, C7 : CustomizableToolbarContent, C8 : CustomizableToolbarContent

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ToolbarContentBuilder {

    public static func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7, C8, C9>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5, _ c6: C6, _ c7: C7, _ c8: C8, _ c9: C9) -> some CustomizableToolbarContent where C0 : CustomizableToolbarContent, C1 : CustomizableToolbarContent, C2 : CustomizableToolbarContent, C3 : CustomizableToolbarContent, C4 : CustomizableToolbarContent, C5 : CustomizableToolbarContent, C6 : CustomizableToolbarContent, C7 : CustomizableToolbarContent, C8 : CustomizableToolbarContent, C9 : CustomizableToolbarContent

}

/// The customization behavior of customizable toolbar content.
///
/// Customizable toolbar content support different types of customization
/// behaviors. For example, some customizable content may not be removed by
/// the user. Some content may be placed in a toolbar that supports
/// customization overall, but not for that particular content.
///
/// Use this type in conjunction with the
/// ``CustomizableToolbarContent/customizationBehavior(_:)`` modifier.
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct ToolbarCustomizationBehavior : Sendable {

    /// The default customization behavior.
    ///
    /// Items with this behavior start in the toolbar and can be
    /// moved or removed from the toolbar by the user.
    public static var `default`: ToolbarCustomizationBehavior { get }

    /// The reorderable customization behavior.
    ///
    /// Items with this behavior start in the toolbar and can be moved within
    /// the toolbar by the user, but can not be removed from the toolbar.
    public static var reorderable: ToolbarCustomizationBehavior { get }

    /// The disabled customization behavior.
    ///
    /// Items with this behavior may not be removed or moved by the user.
    /// They will be placed before other customizatable items. Use this
    /// behavior for the most important items that users need for the app
    /// to do common functionality.
    public static var disabled: ToolbarCustomizationBehavior { get }
}

/// Options that influence the default customization behavior of
/// customizable toolbar content.
///
/// Use this type in conjunction with the
/// ``CustomizableToolbarContent/defaultCustomization(_:options:)`` modifier.
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct ToolbarCustomizationOptions : OptionSet, Sendable {

    /// The raw type that can be used to represent all values of the conforming
    /// type.
    ///
    /// Every distinct value of the conforming type has a corresponding unique
    /// value of the `RawValue` type, but there may be values of the `RawValue`
    /// type that don't have a corresponding value of the conforming type.
    public typealias RawValue = Int

    /// Configures default customizable toolbar content to always be
    /// present in the toolbar.
    ///
    /// In iOS, default customizable toolbar content have the option of always
    /// being available in the toolbar regardless of the customization status
    /// of the user. These items will always be in the overflow menu of the
    /// toolbar. Users can customize whether the items are present as controls
    /// in the toolbar itself but will still always be able to access the item
    /// if they remove it from the toolbar itself.
    ///
    /// Consider using this for items that users should always be able to
    /// access, but may not be important enough to always occupy space in
    /// the toolbar itself.
    public static var alwaysAvailable: ToolbarCustomizationOptions { get }

    /// The corresponding value of the raw type.
    ///
    /// A new instance initialized with `rawValue` will be equivalent to this
    /// instance. For example:
    ///
    ///     enum PaperSize: String {
    ///         case A4, A5, Letter, Legal
    ///     }
    ///
    ///     let selectedSize = PaperSize.Letter
    ///     print(selectedSize.rawValue)
    ///     // Prints "Letter"
    ///
    ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
    ///     // Prints "true"
    public var rawValue: Int

    /// Creates a new option set from the given raw value.
    ///
    /// This initializer always succeeds, even if the value passed as `rawValue`
    /// exceeds the static properties declared as part of the option set. This
    /// example creates an instance of `ShippingOptions` with a raw value beyond
    /// the highest element, with a bit mask that effectively contains all the
    /// declared static members.
    ///
    ///     let extraOptions = ShippingOptions(rawValue: 255)
    ///     print(extraOptions.isStrictSuperset(of: .all))
    ///     // Prints "true"
    ///
    /// - Parameter rawValue: The raw value of the option set to create. Each bit
    ///   of `rawValue` potentially represents an element of the option set,
    ///   though raw values may include bits that are not defined as distinct
    ///   values of the `OptionSet` type.
    public init(rawValue: Int)

    /// The type of the elements of an array literal.
    @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
    public typealias ArrayLiteralElement = ToolbarCustomizationOptions

    /// The element type of the option set.
    ///
    /// To inherit all the default implementations from the `OptionSet` protocol,
    /// the `Element` type must be `Self`, the default.
    @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
    public typealias Element = ToolbarCustomizationOptions
}

/// A kind of toolbar item a `View` adds by default.
///
/// `View`s can add toolbar items clients may wish to remove or customize. A
/// default item kind can be passed to the ``View/toolbar(removing:)`` modifier
/// to remove the item. Documentation on the `View` placing the default item
/// should reference the `ToolbarDefaultItemKind` used to remove the item.
@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
public struct ToolbarDefaultItemKind {

    /// The sidebar toggle toolbar item a `NavigationSplitView` adds by default.
    public static let sidebarToggle: ToolbarDefaultItemKind

    /// The title and subtitle shown in title bar / navigation bar.
    @available(iOS 18.0, macOS 15.0, visionOS 2.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public static let title: ToolbarDefaultItemKind
}

/// A model that represents an item which can be placed in the toolbar
/// or navigation bar.
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public struct ToolbarItem<ID, Content> : ToolbarContent where Content : View {

    /// The type of content representing the body of this toolbar content.
    @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
    public typealias Body = Never
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ToolbarItem where ID == () {

    /// Creates a toolbar item with the specified placement and content.
    ///
    /// - Parameters:
    ///   - placement: Which section of the toolbar
    ///     the item should be placed in.
    ///   - content: The content of the item.
    nonisolated public init(placement: ToolbarItemPlacement = .automatic, @ViewBuilder content: () -> Content)
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ToolbarItem : CustomizableToolbarContent where ID == String {

    /// Creates a toolbar item with the specified placement and content,
    /// which allows for user customization.
    ///
    /// - Parameters:
    ///   - id: A unique identifier for this item.
    ///   - placement: Which section of the toolbar
    ///     the item should be placed in.
    ///   - content: The content of the item.
    @available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
    nonisolated public init(id: String, placement: ToolbarItemPlacement = .automatic, @ViewBuilder content: () -> Content)

    /// Creates a toolbar item with the specified placement and content,
    /// which allows for user customization.
    ///
    /// - Parameters:
    ///   - id: A unique identifier for this item.
    ///   - placement: Which section of the toolbar
    ///     the item should be placed in.
    ///   - showsByDefault: Whether the item appears by default in the toolbar,
    ///     or only shows if the user explicitly adds it via customization.
    ///   - content: The content of the item.
    @available(iOS, introduced: 14.0, deprecated: 100000.0, message: "Use the CustomizableToolbarContent/defaultCustomization(_:options) modifier with a value of .hidden")
    @available(macOS, introduced: 11.0, deprecated: 100000.0, message: "Use the CustomizableToolbarContent/defaultCustomization(_:options) modifier with a value of .hidden")
    @available(tvOS, introduced: 14.0, deprecated: 100000.0, message: "Use the CustomizableToolbarContent/defaultCustomization(_:options) modifier with a value of .hidden")
    @available(watchOS, introduced: 7.0, deprecated: 100000.0, message: "Use the CustomizableToolbarContent/defaultCustomization(_:options) modifier with a value of .hidden")
    nonisolated public init(id: String, placement: ToolbarItemPlacement = .automatic, showsByDefault: Bool, @ViewBuilder content: () -> Content)
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ToolbarItem : Identifiable where ID : Hashable {

    /// The stable identity of the entity associated with this instance.
    public var id: ID { get }
}

/// A model that represents a group of `ToolbarItem`s which can be placed in
/// the toolbar or navigation bar.
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public struct ToolbarItemGroup<Content> : ToolbarContent where Content : View {

    /// Creates a toolbar item group with a specified placement and content.
    ///
    /// - Parameters:
    ///  - placement: Which section of the toolbar all of its vended
    ///    `ToolbarItem`s should be placed in.
    ///  - content: The content of the group. Each view specified in the
    ///    `ViewBuilder` will be given its own `ToolbarItem` in the toolbar.
    public init(placement: ToolbarItemPlacement = .automatic, @ViewBuilder content: () -> Content)

    /// The type of content representing the body of this toolbar content.
    @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
    public typealias Body = Never
}

@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension ToolbarItemGroup {

    /// Creates a toolbar item group with the specified placement, content,
    /// and a label describing that content.
    ///
    /// A toolbar item group provided a label wraps its content within a
    /// ``ControlGroup`` which allows the content to collapse down into a
    /// menu that presents its content based on available space.
    ///
    /// - Parameters:
    ///   - placement: Which section of the toolbar
    ///     the item should be placed in.
    ///   - content: The content of the item.
    ///   - label: The label describing the content of the item.
    nonisolated public init<C, L>(placement: ToolbarItemPlacement = .automatic, @ViewBuilder content: () -> C, @ViewBuilder label: () -> L) where Content == LabeledToolbarItemGroupContent<C, L>, C : View, L : View
}

/// A structure that defines the placement of a toolbar item.
///
/// There are two types of placements:
/// - Semantic placements, such as ``ToolbarItemPlacement/principal`` and
///   ``ToolbarItemPlacement/navigation``, denote the intent of the
///   item being added. SwiftUI determines the appropriate placement for
///   the item based on this intent and its surrounding context, like the
///   current platform.
/// - Positional placements, such as
///   ``ToolbarItemPlacement/navigationBarLeading``, denote a precise
///   placement for the item, usually for a particular platform.
///
/// In iOS, iPadOS, and macOS, the system uses the space available to the
/// toolbar when determining how many items to render in the toolbar. If not
/// all items fit in the available space, an overflow menu may be created
/// and remaining items placed in that menu.
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public struct ToolbarItemPlacement {

    /// The system places the item automatically, depending on many factors
    /// including the platform, size class, or presence of other items.
    ///
    /// In macOS and in Mac Catalyst apps, the system places items in the
    /// current toolbar section in order of leading to trailing. On watchOS,
    /// only the first item appears, pinned beneath the navigation bar.
    ///
    /// In iPadOS, the system places items in the center of the navigation bar
    /// if the navigation bar supports customization. Otherwise, it places
    /// items in the trailing position of the navigation bar.
    ///
    /// In iOS, and tvOS, the system places items in the trailing
    /// position of the navigation bar.
    ///
    /// In iOS, iPadOS, and macOS, the system uses the space available to the
    /// toolbar when determining how many items to render in the toolbar. If not
    /// all items fit in the available space, an overflow menu may be created
    /// and remaining items placed in that menu.
    public static let automatic: ToolbarItemPlacement

    /// The system places the item in the principal item section.
    ///
    /// Principal actions are key units of functionality that receive prominent
    /// placement. For example, the location field for a web browser is a
    /// principal item.
    ///
    /// In macOS and in Mac Catalyst apps, the system places the principal item
    /// in the center of the toolbar.
    ///
    /// In iOS, iPadOS, and tvOS, the system places the principal item in the
    /// center of the navigation bar. This item takes precedent over a title
    /// specified through ``View/navigationTitle``.
    @available(watchOS, unavailable)
    public static let principal: ToolbarItemPlacement

    /// The item represents a navigation action.
    ///
    /// Navigation actions allow the user to move between contexts.
    /// For example, the forward and back buttons of a web browser
    /// are navigation actions.
    ///
    /// In macOS and in Mac Catalyst apps, the system places navigation items
    /// in the leading edge of the toolbar ahead of the inline title if that is
    /// present in the toolbar.
    ///
    /// In iOS, iPadOS, and tvOS, navigation items appear in the leading
    /// edge of the navigation bar. If a system navigation item such as a back
    /// button is present in a compact width, it instead appears in
    /// the ``ToolbarItemPlacement/primaryAction`` placement.
    @available(watchOS, unavailable)
    public static let navigation: ToolbarItemPlacement

    /// The item represents a primary action.
    ///
    /// A primary action is a more frequently used action for the current
    /// context. For example, a button the user clicks or taps to compose a new
    /// message in a chat app.
    ///
    /// In macOS and in Mac Catalyst apps, the location for the primary action
    /// is the leading edge of the toolbar.
    ///
    /// In iOS, iPadOS, and tvOS, the location for the primary action is
    /// the trailing edge of the navigation bar.
    ///
    /// In watchOS the system places the primary action beneath the
    /// navigation bar; the user reveals the action by scrolling.
    public static let primaryAction: ToolbarItemPlacement

    /// The item represents a secondary action.
    ///
    /// A secondary action is a frequently used action for the current context
    /// but is not a requirement for the current context to function.
    @available(iOS 16.0, macOS 13.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public static let secondaryAction: ToolbarItemPlacement

    /// The item represents a change in status for the current context.
    ///
    /// Status items are informational in nature, and don't represent an
    /// action that can be taken by the user. For example, a message that
    /// indicates the time of the last communication with the server to check
    /// for new messages.
    ///
    /// In macOS and in Mac Catalyst apps, the system places status items in
    /// the center of the toolbar.
    ///
    /// In iOS and iPadOS, the system places status items in the center of the
    /// bottom toolbar.
    ///
    /// In tvOS, this placement is only available from within the sidebar of a
    /// ``NavigationSplitView``.  The system places status items in the center
    /// of the bottom toolbar within the navigation sidebar.  It has no effect
    /// if used elsewhere.
    @available(tvOS 18.0, *)
    @available(watchOS, unavailable)
    public static let status: ToolbarItemPlacement

    /// The item represents a confirmation action for a modal interface.
    ///
    /// Use confirmation actions to receive user confirmation of a
    /// particular action. An example of a confirmation action would be
    /// an action with the label "Add" to add a new event to the calendar.
    ///
    /// In macOS and in Mac Catalyst apps, the system places
    /// `confirmationAction` items on the trailing edge
    /// in the trailing-most position of the sheet and gain the apps accent
    /// color as a background color.
    ///
    /// In iOS, iPadOS, and tvOS, the system places `confirmationAction` items
    /// in the same location as a ``ToolbarItemPlacement/primaryAction``
    /// placement.
    ///
    /// In watchOS, the system places `confirmationAction` items in the
    /// trailing edge of the navigation bar.
    public static let confirmationAction: ToolbarItemPlacement

    /// The item represents a cancellation action for a modal interface.
    ///
    /// Cancellation actions dismiss the modal interface without taking any
    /// action, usually by tapping or clicking a Cancel button.
    ///
    /// In macOS and in Mac Catalyst apps, the system places
    /// `cancellationAction` items on the trailing edge of the sheet but
    /// places them before any ``confirmationAction`` items.
    ///
    /// In iOS, iPadOS, tvOS, and watchOS, the system places
    /// `cancellationAction` items on the leading edge of the navigation bar.
    public static let cancellationAction: ToolbarItemPlacement

    /// The item represents a destructive action for a modal interface.
    ///
    /// Destructive actions represent the opposite of a confirmation action.
    /// For example, a button labeled "Don't Save" that allows the user to
    /// discard unsaved changes to a document before quitting.
    ///
    /// In macOS and in Mac Catalyst apps, the system places `destructiveAction`
    /// items in the leading edge of the sheet and gives them a special
    /// appearance to caution against accidental use.
    ///
    /// In iOS, tvOS, and watchOS, the system places `destructiveAction` items
    /// in the trailing edge of the navigation bar.
    public static let destructiveAction: ToolbarItemPlacement

    /// The item is placed in the keyboard section.
    ///
    /// On iOS, keyboard items are above the software keyboard when present,
    /// or at the bottom of the screen when a hardware keyboard is attached.
    ///
    /// On macOS, keyboard items will be placed inside the Touch Bar.
    ///
    /// A `FocusedValue`can be used to adjust the content of the keyboard bar
    /// based on the currently focused view. In the example below, the keyboard
    /// bar gains additional buttons only when the appropriate `TextField` is
    /// focused.
    ///
    ///     enum Field {
    ///         case suit
    ///         case rank
    ///     }
    ///
    ///     struct KeyboardBarDemo : View {
    ///         @FocusedValue(\.field) var field: Field?
    ///
    ///         var body: some View {
    ///             HStack {
    ///                 TextField("Suit", text: $suitText)
    ///                     .focusedValue(\.field, .suit)
    ///                 TextField("Rank", text: $rankText)
    ///                     .focusedValue(\.field, .rank)
    ///             }
    ///             .toolbar {
    ///                 ToolbarItemGroup(placement: .keyboard) {
    ///                     if field == .suit {
    ///                         Button("", action: {})
    ///                         Button("", action: {})
    ///                         Button("", action: {})
    ///                         Button("", action: {})
    ///                     }
    ///                     DoneButton()
    ///                 }
    ///             }
    ///         }
    ///     }
    ///
    @available(iOS 15.0, macOS 12.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    @available(visionOS, unavailable)
    public static let keyboard: ToolbarItemPlacement

    /// Places the item in the leading edge of the top bar.
    ///
    /// On watchOS, iOS, and tvOS, the top bar is the navigation bar.
    @available(iOS 14.0, tvOS 14.0, watchOS 10.0, *)
    @backDeployed(before: iOS 17.0, tvOS 17.0)
    @available(macOS, unavailable)
    public static var topBarLeading: ToolbarItemPlacement { get }

    /// Places the item in the trailing edge of the top bar.
    ///
    /// On watchOS, iOS, and tvOS, the top bar is the navigation bar.
    @available(iOS 14.0, tvOS 14.0, watchOS 10.0, *)
    @backDeployed(before: iOS 17.0, tvOS 17.0)
    @available(macOS, unavailable)
    public static var topBarTrailing: ToolbarItemPlacement { get }

    /// Places the item in the leading edge of the navigation bar.
    @available(iOS, introduced: 14.0, deprecated: 100000.0, message: "use topBarLeading instead")
    @available(tvOS, introduced: 14.0, deprecated: 100000.0, message: "use topBarLeading instead")
    @available(macOS, unavailable)
    @available(watchOS, unavailable)
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "use topBarLeading instead")
    public static let navigationBarLeading: ToolbarItemPlacement

    /// Places the item in the trailing edge of the navigation bar.
    @available(iOS, introduced: 14.0, deprecated: 100000.0, message: "use topBarTrailing instead")
    @available(tvOS, introduced: 14.0, deprecated: 100000.0, message: "use topBarTrailing instead")
    @available(macOS, unavailable)
    @available(watchOS, unavailable)
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "use topBarTrailing instead")
    public static let navigationBarTrailing: ToolbarItemPlacement

    /// Places the item in the bottom toolbar.
    ///
    /// On tvOS, this applies only within the sidebar of a
    /// ``NavigationSplitView``.  It has no effect if used elsewhere.
    @available(tvOS 18.0, watchOS 10.0, *)
    @available(macOS, unavailable)
    public static let bottomBar: ToolbarItemPlacement
}

/// The label style of a toolbar.
///
/// Use this type in conjunction with modifiers like ``Scene/windowToolbarLabelStyle(fixed:)``
/// and ``Scene/windowToolbarLabelStyle(_:)`` to customize the appearance of window toolbars
/// managed by SwiftUI.
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct ToolbarLabelStyle : Sendable, Equatable {

    /// The automatic label style. The toolbar will use a labelStyle that best fits
    /// the `Scene` it is applied to.
    public static var automatic: ToolbarLabelStyle { get }

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ToolbarLabelStyle, b: ToolbarLabelStyle) -> Bool
}

/// The placement of a toolbar.
///
/// Use this type in conjunction with modifiers like
/// ``View/toolbarBackground(_:for:)`` and ``View/toolbar(_:for:)`` to
/// customize the appearance of different bars managed by SwiftUI. Not all bars
/// support all types of customizations.
///
/// See ``ToolbarItemPlacement`` to learn about the different regions of these
/// toolbars that you can place your own controls into.
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct ToolbarPlacement {

    /// The primary toolbar.
    ///
    /// Depending on the context, this may refer to the navigation bar of an
    /// app on iOS, or watchOS, the tab bar of an app on tvOS, or the window
    /// toolbar / window titlebar of an app on macOS.
    public static var automatic: ToolbarPlacement { get }

    /// The bottom toolbar of an app.
    @available(watchOS 10.0, *)
    @available(macOS, unavailable)
    @available(tvOS, unavailable)
    public static var bottomBar: ToolbarPlacement { get }

    /// The navigation bar of an app.
    @available(macOS, unavailable)
    public static var navigationBar: ToolbarPlacement { get }

    /// The tab bar of an app.
    @available(macOS, unavailable)
    @available(watchOS, unavailable)
    public static var tabBar: ToolbarPlacement { get }
}

/// The purpose of content that populates the toolbar.
///
/// A toolbar role provides a description of the purpose of content that
/// populates the toolbar. The purpose of the content influences how a toolbar
/// renders its content. For example, a ``ToolbarRole/browser`` will
/// automatically leading align the title of a toolbar in iPadOS.
///
/// Provide this type to the ``View/toolbarRole(_:)`` modifier:
///
///     ContentView()
///         .navigationTitle("Browser")
///         .toolbarRole(.browser)
///         .toolbar {
///             ToolbarItem(placement: .primaryAction) {
///                 AddButton()
///             }
///          }
///
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct ToolbarRole : Sendable {

    /// The automatic role.
    ///
    /// In iOS, tvOS, and watchOS this resolves to the
    /// ``ToolbarRole/navigationStack`` role. In macOS, this resolves to the
    /// ``ToolbarRole/editor`` role.
    public static var automatic: ToolbarRole { get }

    /// The navigationStack role.
    ///
    /// Use this role for content that can be pushed and popped.
    @available(macOS, unavailable)
    public static var navigationStack: ToolbarRole { get }

    /// The browser role.
    ///
    /// Use this role for content that can be navigated forwards
    /// and backwards. In iPadOS, this will leading align the navigation title
    /// and allow for toolbar items to occupy the center of the navigation bar.
    @available(macOS, unavailable)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public static var browser: ToolbarRole { get }

    /// The editor role.
    ///
    /// Use this role for a toolbar that primarily displays controls
    /// geared towards editing document-like content. In iPadOS, this will
    /// leading align the navigation title, allow for toolbar items to occupy
    /// the center of the navigation bar, and provide a custom appearance
    /// for any back button present in the toolbar.
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public static var editor: ToolbarRole { get }
}

/// A type that defines the behavior of title of a toolbar.
///
/// Use the ``View/toolbarTitleDisplayMode(_:)`` modifier to configure
/// the title display behavior of your toolbar:
///
///     NavigationStack {
///         ContentView()
///             .toolbarTitleDisplayMode(.inlineLarge)
///     }
///
@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
public struct ToolbarTitleDisplayMode {

    /// The automatic mode.
    ///
    /// For root content in a navigation stack in iOS, iPadOS, or tvOS
    /// this behavior will:
    ///   - Default to ``ToolbarTitleDisplayMode/large``
    ///     when a navigation title is configured.
    ///   - Default to ``ToolbarTitleDisplayMode/inline``
    ///     when no navigation title is provided.
    ///
    /// In all platforms, content pushed onto a navigation stack will use the
    /// behavior of the content already on the navigation stack. This
    /// has no effect in macOS.
    public static var automatic: ToolbarTitleDisplayMode { get }

    /// The large mode.
    ///
    /// In iOS, and watchOS, this displays the toolbar title below the
    /// content of the navigation bar when scrollable content is scrolled
    /// to the top and transitions to the center of the toolbar as
    /// content is scrolled.
    @available(macOS, unavailable)
    @available(tvOS, unavailable)
    public static var large: ToolbarTitleDisplayMode { get }

    /// The inline large mode.
    ///
    /// In iOS, this behavior displays the title as large inside the toolbar
    /// and moves any leading or centered toolbar items into the overflow menu
    /// of the toolbar. This has no effect in macOS.
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public static var inlineLarge: ToolbarTitleDisplayMode { get }

    /// The inline mode.
    ///
    /// In iOS, tvOS, and watchOS this mode displays the title with a
    /// smaller size in the middle of the toolbar. This has no effect
    /// in macOS.
    public static var inline: ToolbarTitleDisplayMode { get }
}

/// The title menu of a toolbar.
///
/// A title menu represents common functionality that can be done on the
/// content represented by your app's toolbar or navigation title. This
/// menu may be populated from your app's commands like
/// ``CommandGroupPlacement/saveItem`` or
/// ``CommandGroupPlacement/printItem``.
///
///     ContentView()
///         .toolbar {
///             ToolbarTitleMenu()
///         }
///
/// You can provide your own set of actions to override this behavior.
///
///     ContentView()
///         .toolbar {
///             ToolbarTitleMenu {
///                 DuplicateButton()
///                 PrintButton()
///             }
///         }
///
/// In iOS and iPadOS, this will construct a menu that can be presented by
/// tapping the navigation title in the app's navigation bar.
@available(iOS 16.0, macOS 13.0, watchOS 9.0, tvOS 16.0, *)
public struct ToolbarTitleMenu<Content> : ToolbarContent, CustomizableToolbarContent where Content : View {

    /// Creates a toolbar title menu where actions are inferred from your
    /// apps commands.
    public init() where Content == EmptyView

    /// Creates a toolbar title menu.
    ///
    /// - Parameter content: The content of the toolbar title menu.
    public init(@ViewBuilder content: () -> Content)

    /// The type of content representing the body of this toolbar content.
    @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
    public typealias Body = Never
}

/// A type of table column content that creates table columns created from a
/// Swift tuple of table columns.
///
/// Don't use this type directly; instead, SwiftUI uses this type as the return value
/// from the various `buildBlock` methods in ``TableColumnBuilder``. The size of
/// the tuple corresponds to how many columns you create in the `columns`
/// closure you provide to the ``Table`` initializer.
@available(iOS 16.0, macOS 12.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@frozen public struct TupleTableColumnContent<RowValue, Sort, T> : TableColumnContent where RowValue : Identifiable, Sort : SortComparator {

    /// The type of value of rows presented by this column content.
    public typealias TableRowValue = RowValue

    /// The type of sort comparator associated with this table column content.
    public typealias TableColumnSortComparator = Sort

    /// The value of a row presented by this column content.
    public var value: T

    /// The type of content representing the body of this table column content.
    @available(iOS 16.0, macOS 12.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias TableColumnBody = Never
}

/// A type of table column content that creates table rows created from a
/// Swift tuple of table rows.
///
/// Don't use this type directly; instead, SwiftUI uses this type as the return value
/// from the various `buildBlock` methods in ``TableRowBuilder``. The size of
/// the tuple corresponds to how many columns you create in the `rows`
/// closure you provide to the ``Table`` initializer.
@available(iOS 16.0, macOS 12.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@frozen public struct TupleTableRowContent<Value, T> : TableRowContent where Value : Identifiable {

    /// The type of value represented by this table row content.
    public typealias TableRowValue = Value

    public var value: T

    /// The type of content representing the body of this table row content.
    @available(iOS 16.0, macOS 12.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias TableRowBody = Never
}

/// A property wrapper type that you use to create a UIKit app delegate.
///
/// To handle app delegate callbacks in an app that uses the
/// SwiftUI life cycle, define a type that conforms to the
/// <doc://com.apple.documentation/documentation/UIKit/UIApplicationDelegate>
/// protocol, and implement the delegate methods that you need. For example,
/// you can implement the
/// <doc://com.apple.documentation/documentation/UIKit/UIApplicationDelegate/1622958-application>
/// method to handle remote notification registration:
///
///     class MyAppDelegate: NSObject, UIApplicationDelegate, ObservableObject {
///         func application(
///             _ application: UIApplication,
///             didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data
///         ) {
///             // Record the device token.
///         }
///     }
///
/// Then use the `UIApplicationDelegateAdaptor` property wrapper inside your
/// ``App`` declaration to tell SwiftUI about the delegate type:
///
///     @main
///     struct MyApp: App {
///         @UIApplicationDelegateAdaptor private var appDelegate: MyAppDelegate
///
///         var body: some Scene { ... }
///     }
///
/// SwiftUI instantiates the delegate and calls the delegate's
/// methods in response to life cycle events. Define the delegate adaptor
/// only in your ``App`` declaration, and only once for a given app. If
/// you declare it more than once, SwiftUI generates a runtime error.
///
/// If your app delegate conforms to the
/// <doc://com.apple.documentation/documentation/Combine/ObservableObject>
/// protocol, as in the example above, then SwiftUI puts the delegate it
/// creates into the ``Environment``. You can access the delegate from
/// any scene or view in your app using the ``EnvironmentObject`` property
/// wrapper:
///
///     @EnvironmentObject private var appDelegate: MyAppDelegate
///
/// This enables you to use the dollar sign (`$`) prefix to get a binding to
/// published properties that you declare in the delegate. For more information,
/// see ``projectedValue``.
///
/// > Important: Manage an app's life cycle events without using an app
/// delegate whenever possible. For example, prefer to handle changes
/// in ``ScenePhase`` instead of relying on delegate callbacks, like
/// <doc://com.apple.documentation/documentation/UIKit/UIApplicationDelegate/1622921-application>.
///
/// ### Scene delegates
///
/// Some iOS apps define a
/// <doc://com.apple.documentation/documentation/UIKit/UIWindowSceneDelegate>
/// to handle scene-based events, like app shortcuts:
///
///     class MySceneDelegate: NSObject, UIWindowSceneDelegate, ObservableObject {
///         func windowScene(
///             _ windowScene: UIWindowScene,
///             performActionFor shortcutItem: UIApplicationShortcutItem
///         ) async -> Bool {
///             // Do something with the shortcut...
///
///             return true
///         }
///     }
///
/// You can provide this kind of delegate to a SwiftUI app by returning the
/// scene delegate's type from the
/// <doc://com.apple.documentation/documentation/UIKit/UIApplicationDelegate/3197905-application>
/// method inside your app delegate:
///
///     extension MyAppDelegate {
///         func application(
///             _ application: UIApplication,
///             configurationForConnecting connectingSceneSession: UISceneSession,
///             options: UIScene.ConnectionOptions
///         ) -> UISceneConfiguration {
///
///             let configuration = UISceneConfiguration(
///                                     name: nil,
///                                     sessionRole: connectingSceneSession.role)
///             if connectingSceneSession.role == .windowApplication {
///                 configuration.delegateClass = MySceneDelegate.self
///             }
///             return configuration
///         }
///     }
///
/// When you configure the
/// <doc://com.apple.documentation/documentation/UIKit/UISceneConfiguration>
/// instance, you only need to indicate the delegate class, and not a scene
/// class or storyboard. SwiftUI creates and manages the delegate instance,
/// and sends it any relevant delegate callbacks.
///
/// As with the app delegate, if you make your scene delegate an observable
/// object, SwiftUI automatically puts it in the ``Environment``, from where
/// you can access it with the ``EnvironmentObject`` property wrapper, and
/// create bindings to its published properties.
@available(iOS 14.0, tvOS 14.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
@MainActor @preconcurrency @propertyWrapper public struct UIApplicationDelegateAdaptor<DelegateType> : DynamicProperty where DelegateType : NSObject, DelegateType : UIApplicationDelegate {

    /// The underlying app delegate.
    @MainActor @preconcurrency public var wrappedValue: DelegateType { get }

    /// Creates a UIKit app delegate adaptor.
    ///
    /// Call this initializer indirectly by creating a property with the
    /// ``UIApplicationDelegateAdaptor`` property wrapper from inside your
    /// ``App`` declaration:
    ///
    ///     @main
    ///     struct MyApp: App {
    ///         @UIApplicationDelegateAdaptor private var appDelegate: MyAppDelegate
    ///
    ///         var body: some Scene { ... }
    ///     }
    ///
    /// SwiftUI initializes the delegate and manages its lifetime, calling upon
    /// it to handle application delegate callbacks.
    ///
    /// If you want SwiftUI to put the instantiated delegate in the
    /// ``Environment``, make sure the delegate class also conforms to the
    /// <doc://com.apple.documentation/documentation/Combine/ObservableObject>
    /// protocol. That causes SwiftUI to invoke the ``init(_:)-8vsx1``
    /// initializer rather than this one.
    ///
    /// - Parameter delegateType: The type of application delegate that you
    ///   define in your app, which conforms to the
    ///   <doc://com.apple.documentation/documentation/UIKit/UIApplicationDelegate>
    ///   protocol.
    @MainActor @preconcurrency public init(_ delegateType: DelegateType.Type = DelegateType.self)
}

@available(iOS 14.0, tvOS 14.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension UIApplicationDelegateAdaptor where DelegateType : ObservableObject {

    /// Creates a UIKit app delegate adaptor using a delegate that's
    /// an observable object.
    ///
    /// Call this initializer indirectly by creating a property with the
    /// ``UIApplicationDelegateAdaptor`` property wrapper from inside your
    /// ``App`` declaration:
    ///
    ///     @main
    ///     struct MyApp: App {
    ///         @UIApplicationDelegateAdaptor private var appDelegate: MyAppDelegate
    ///
    ///         var body: some Scene { ... }
    ///     }
    ///
    /// SwiftUI initializes the delegate and manages its lifetime, calling it
    /// as needed to handle application delegate callbacks.
    ///
    /// SwiftUI invokes this method when your app delegate conforms to the
    /// <doc://com.apple.documentation/documentation/Combine/ObservableObject>
    /// protocol. In this case, SwiftUI automatically places the delegate in the
    /// ``Environment``. You can access such a delegate from any scene or
    /// view in your app using the ``EnvironmentObject`` property wrapper:
    ///
    ///     @EnvironmentObject private var appDelegate: MyAppDelegate
    ///
    /// If your delegate isn't an observable object, SwiftUI invokes the
    /// ``init(_:)-59sfu`` initializer rather than this one, and doesn't
    /// put the delegate instance in the environment.
    ///
    /// - Parameter delegateType: The type of application delegate that you
    ///   define in your app, which conforms to the
    ///   <doc://com.apple.documentation/documentation/UIKit/UIApplicationDelegate>
    ///   and
    ///   <doc://com.apple.documentation/documentation/Combine/ObservableObject>
    ///   protocols.
    @MainActor @preconcurrency public init(_ delegateType: DelegateType.Type = DelegateType.self)

    /// A projection of the observed object that provides bindings to its
    /// properties.
    ///
    /// Use the projected value to get a binding to a value that the delegate
    /// publishes. Access the projected value by prefixing the name of the
    /// delegate instance with a dollar sign (`$`). For example, you might
    /// publish a Boolean value in your application delegate:
    ///
    ///     class MyAppDelegate: NSObject, UIApplicationDelegate, ObservableObject {
    ///         @Published var isEnabled = false
    ///
    ///         // ...
    ///     }
    ///
    /// If you declare the delegate in your ``App`` using the
    /// ``UIApplicationDelegateAdaptor`` property wrapper, you can get
    /// the delegate that SwiftUI instantiates from the environment and
    /// access a binding to its published values from any view in your app:
    ///
    ///     struct MyView: View {
    ///         @EnvironmentObject private var appDelegate: MyAppDelegate
    ///
    ///         var body: some View {
    ///             Toggle("Enabled", isOn: $appDelegate.isEnabled)
    ///         }
    ///     }
    ///
    @MainActor @preconcurrency public var projectedValue: ObservedObject<DelegateType>.Wrapper { get }
}

@available(iOS 17.0, tvOS 17.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension UIApplicationDelegateAdaptor where DelegateType : Observable {

    /// Creates a UIKit app delegate adaptor using an observable delegate.
    ///
    /// Call this initializer indirectly by creating a property with the
    /// ``UIApplicationDelegateAdaptor`` property wrapper from inside your
    /// ``App`` declaration:
    ///
    ///     @main
    ///     struct MyApp: App {
    ///         @UIApplicationDelegateAdaptor private var appDelegate: MyAppDelegate
    ///
    ///         var body: some Scene { ... }
    ///     }
    ///
    /// SwiftUI initializes the delegate and manages its lifetime, calling it
    /// as needed to handle application delegate callbacks.
    ///
    /// SwiftUI invokes this method when your app delegate conforms to the
    /// <doc://com.apple.documentation/documentation/Observation/Observable>
    /// protocol. In this case, SwiftUI automatically places the delegate in the
    /// ``Environment``. You can access such a delegate from any scene or
    /// view in your app using the ``Environment`` property wrapper:
    ///
    ///     @Environment(MyAppDelegate.self) private var appDelegate
    ///
    /// If your delegate isn't observable, SwiftUI invokes the
    /// ``init(_:)-59sfu`` initializer rather than this one, and doesn't
    /// put the delegate instance in the environment.
    ///
    /// - Parameter delegateType: The type of application delegate that you
    ///   define in your app, which conforms to the
    ///   <doc://com.apple.documentation/documentation/UIKit/UIApplicationDelegate>
    ///   and
    ///   <doc://com.apple.documentation/documentation/Observation/Observable>
    ///   protocols.
    @MainActor @preconcurrency public init(_ delegateType: DelegateType.Type = DelegateType.self)
}

@available(iOS 14.0, tvOS 14.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension UIApplicationDelegateAdaptor : Sendable {
}

/// A wrapper for a `UIGestureRecognizer` that you use to integrate that gesture
/// recognizer into your SwiftUI hierarchy.
///
/// Use a ``UIGestureRecognizerRepresentable`` instance to create and manage a
/// <doc://com.apple.documentation/documentation/UIKit/UIGestureRecognizer>
/// object in your SwiftUI interface.
///
/// To add your gesture recognizer to a SwiftUI view, create an instance of
/// ``UIGestureRecognizerRepresentable`` and use the ``View/gesture(_:)``
/// modifier to attach it. The system calls the methods of your representable
/// instance at appropriate times to create and update the gesture recognizer.
///
/// The following example shows the inclusion of a custom `MyGestureRecognizer`
/// structure in the view hierarchy.
///
///     struct ContentView: View {
///        var body: some View {
///           VStack {
///              Image("Mountain").gesture(MyGestureRecognizer())
///           }
///        }
///     }
///
/// Because your ``UIGestureRecognizerRepresentable`` is a struct, it can
/// use the environment, have data dependencies, and is more similar to views in
/// SwiftUI. The system will call the appropriate methods on your instance to
/// propagate the latest data.
///
/// ## Handling Gesture Recognizer Actions
///
/// SwiftUI automatically installs a target to handle the gesture recognizer's
/// action on your behalf. Implement the `handleUIGestureRecognizerAction`
/// method to react to the gesture recognizing its action.
///
/// You can optionally include a coordinator object to forward delegate messages
/// from your gesture recognizer or add additional targets.
///
/// ## Coordinate Space Conversions
///
/// The gesture recognizer you create may not be attached to a UIView in the
/// hierarchy, or it may return a view with different geometry than your SwiftUI
/// view.
///
/// To handle this, use the converter on the context to perform coordinate space
/// conversions from the global coordinate space. You can pass the gesture
/// recognizer and a SwiftUI coordinate space to the converter to retrieve a
/// final converted point. Passing the ``CoordinateSpaceProtocol/local``
/// coordinate space (the default) will provide the point in the SwiftUI view
/// the gesture recognizer is attached to.
@available(iOS 18.0, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@available(visionOS, unavailable)
@MainActor @preconcurrency public protocol UIGestureRecognizerRepresentable {

    /// The type of `UIGestureRecognizer` to be presented.
    associatedtype UIGestureRecognizerType : UIGestureRecognizer

    /// A type to coordinate with the gesture recognizer.
    associatedtype Coordinator = Void

    /// Contextual information about the state of the system that you use to
    /// create and update your gesture recognizer.
    typealias Context = UIGestureRecognizerRepresentableContext<Self>

    /// A type used to convert coordinates to/from coordinate spaces in the
    /// hierarchy of the associated SwiftUI view.
    typealias CoordinateSpaceConverter = UIGestureRecognizerRepresentableCoordinateSpaceConverter

    /// Creates the custom object that you use to communicate state changes from
    /// your gesture recognizer to other parts of your SwiftUI interface.
    ///
    /// You access the resulting coordinator via the `Context` passed into other
    /// methods in this protocol.
    ///
    /// - Parameter converter: A structure used to convert locations  to/from
    ///   coordinate spaces in the hierarchy of the associated SwiftUI view.
    @MainActor @preconcurrency func makeCoordinator(converter: Self.CoordinateSpaceConverter) -> Self.Coordinator

    /// Creates an instance of the represented gesture recognizer.
    ///
    /// - Parameter context: A context structure containing information about
    ///   the current state of the system, such as the current coordinator
    ///   instance.
    ///
    /// > Note: Gesture recognizers are created on-demand and torn down when an
    ///   event sequence ends, so do not perform expensive work in this method.
    @MainActor @preconcurrency func makeUIGestureRecognizer(context: Self.Context) -> Self.UIGestureRecognizerType

    /// Updates the `UIGestureRecognizer` (and coordinator) to the latest
    /// configuration.
    ///
    /// - Parameter recognizer: An instance of the represented gesture
    ///   recognizer.
    /// - Parameter context: A context structure containing information about
    ///   the current state of the system, such as the current coordinator
    ///   instance.
    @MainActor @preconcurrency func updateUIGestureRecognizer(_ recognizer: Self.UIGestureRecognizerType, context: Self.Context)

    /// Handles recognition of the represented `UIGestureRecognizer`.
    ///
    /// If you implement this method, SwiftUI calls it when the wrapped
    /// gesture recognizer is recognized.
    ///
    /// - Parameter recognizer: An instance of the represented gesture
    ///   recognizer.
    /// - Parameter context: A context structure containing information about
    ///   the current state of the system, such as the current coordinator
    ///   instance.
    @MainActor @preconcurrency func handleUIGestureRecognizerAction(_ recognizer: Self.UIGestureRecognizerType, context: Self.Context)
}

@available(iOS 18.0, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@available(visionOS, unavailable)
extension UIGestureRecognizerRepresentable {

    /// Updates the `UIGestureRecognizer` (and coordinator) to the latest
    /// configuration.
    ///
    /// - Parameter recognizer: An instance of the represented gesture
    ///   recognizer.
    /// - Parameter context: A context structure containing information about
    ///   the current state of the system, such as the current coordinator
    ///   instance.
    @MainActor @preconcurrency public func updateUIGestureRecognizer(_ recognizer: Self.UIGestureRecognizerType, context: Self.Context)

    /// Handles recognition of the represented `UIGestureRecognizer`.
    ///
    /// If you implement this method, SwiftUI calls it when the wrapped
    /// gesture recognizer is recognized.
    ///
    /// - Parameter recognizer: An instance of the represented gesture
    ///   recognizer.
    /// - Parameter context: A context structure containing information about
    ///   the current state of the system, such as the current coordinator
    ///   instance.
    @MainActor @preconcurrency public func handleUIGestureRecognizerAction(_ recognizer: Self.UIGestureRecognizerType, context: Self.Context)
}

@available(iOS 18.0, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@available(visionOS, unavailable)
extension UIGestureRecognizerRepresentable where Self.Coordinator == () {

    /// Creates the custom object that you use to communicate state changes from
    /// your gesture recognizer to other parts of your SwiftUI interface.
    ///
    /// You access the resulting coordinator via the `Context` passed into other
    /// methods in this protocol.
    ///
    /// - Parameter converter: A structure used to convert locations  to/from
    ///   coordinate spaces in the hierarchy of the associated SwiftUI view.
    @MainActor @preconcurrency public func makeCoordinator(converter: Self.CoordinateSpaceConverter)
}

/// Contextual information about the state of the system that you use to create
/// and update a represented gesture recognizer.
@available(iOS 18.0, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@available(visionOS, unavailable)
public struct UIGestureRecognizerRepresentableContext<Representable> where Representable : UIGestureRecognizerRepresentable {

    /// The custom object that you use to communicate state changes from your
    /// gesture recognizer to other parts of your SwiftUI interface.
    public let coordinator: Representable.Coordinator

    /// A structure used to convert locations to/from coordinate spaces in
    /// the hierarchy of the associated SwiftUI view.
    public let converter: UIGestureRecognizerRepresentableCoordinateSpaceConverter
}

/// A proxy structure used to convert locations to/from coordinate spaces in the
/// hierarchy of the SwiftUI view associated with a
/// ``UIGestureRecognizerRepresentable``.
@available(iOS 18.0, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@available(visionOS, unavailable)
public struct UIGestureRecognizerRepresentableCoordinateSpaceConverter {

    /// The represented gesture recognizer's current location in the coordinate
    /// space of the SwiftUI view it's attached to.
    public var localLocation: CGPoint { get }

    /// Converts a point in the global coordinate space to a SwiftUI coordinate
    /// space of an ancestor of the view the gesture recognizer is attached to.
    ///
    /// - Parameter globalPoint: The point in the global coordinate space.
    /// - Parameter coordinateSpace: The SwiftUI coordinate space to convert to.
    public func convert(globalPoint: CGPoint, to coordinateSpace: some CoordinateSpaceProtocol = .local) -> CGPoint

    /// Converts the represented gesture recognizer's current location to a
    /// SwiftUI coordinate space  of an ancestor of the view the gesture
    /// recognizer is attached to.
    ///
    /// - Parameter coordinateSpace: The SwiftUI coordinate space to convert to.
    public func location(in coordinateSpace: some CoordinateSpaceProtocol) -> CGPoint

    /// The represented gesture recognizer's current velocity in the coordinate
    /// space of the SwiftUI view it's attached to.
    ///
    /// If the gesture recognizer does not implement a `velocityInView:` method,
    /// returns nil.
    public var localVelocity: CGPoint? { get }

    /// Converts the represented gesture recognizer's current velocity to a
    /// SwiftUI coordinate space of an ancestor of the view the gesture
    /// recognizer is attached to.
    ///
    /// If the gesture recognizer does not implement a `velocityInView:` method,
    /// returns nil.
    ///
    /// - Parameter coordinateSpace: The SwiftUI coordinate space to convert to.
    public func velocity(in coordinateSpace: some CoordinateSpaceProtocol) -> CGPoint?

    /// The represented gesture recognizer's current translation in the
    /// coordinate space of the SwiftUI view it's attached to.
    ///
    /// If the gesture recognizer does not implement a `translationInView:`
    /// method, returns nil.
    public var localTranslation: CGPoint? { get }

    /// Converts the represented gesture recognizer's current translation to a
    /// SwiftUI coordinate space of an ancestor of the view the gesture
    /// recognizer is attached to.
    ///
    /// If the gesture recognizer does not implement a `velocityInView:` method,
    /// returns nil.
    ///
    /// - Parameter coordinateSpace: The SwiftUI coordinate space to convert to.
    public func translation(in coordinateSpace: some CoordinateSpaceProtocol) -> CGPoint?
}

/// A content configuration suitable for hosting a hierarchy of SwiftUI views.
///
/// Use a value of this type, which conforms to the
/// <doc://com.apple.documentation/documentation/UIKit/UIContentConfiguration>
/// protocol, with a
/// <doc://com.apple.documentation/documentation/UIKit/UICollectionViewCell> or
/// <doc://com.apple.documentation/documentation/UIKit/UITableViewCell> to host
/// a hierarchy of SwiftUI views in a collection or table view, respectively.
/// For example, the following shows a stack with an image and text inside the
/// cell:
///
///     myCell.contentConfiguration = UIHostingConfiguration {
///         HStack {
///             Image(systemName: "star").foregroundStyle(.purple)
///             Text("Favorites")
///             Spacer()
///         }
///     }
///
/// You can also customize the background of the containing cell. The following
/// example draws a blue background:
///
///     myCell.contentConfiguration = UIHostingConfiguration {
///         HStack {
///             Image(systemName: "star").foregroundStyle(.purple)
///             Text("Favorites")
///             Spacer()
///         }
///     }
///     .background {
///         Color.blue
///     }
///
/// When used in a list layout, certain APIs are bridged automatically, like
/// swipe actions and separator alignment. The following example shows a
/// trailing yellow star swipe action:
///
///     cell.contentConfiguration = UIHostingConfiguration {
///         HStack {
///             Image(systemName: "airplane")
///             Text("Flight 123")
///             Spacer()
///         }
///         .swipeActions {
///             Button { ... } label: {
///                 Label("Favorite", systemImage: "star")
///             }
///             .tint(.yellow)
///         }
///     }
///
@available(iOS 16.0, tvOS 16.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
public struct UIHostingConfiguration<Content, Background> : UIContentConfiguration where Content : View, Background : View {

    /// Sets the background contents for the hosting configuration's enclosing
    /// cell.
    ///
    /// The following example sets a custom view to the background of the cell:
    ///
    ///     UIHostingConfiguration {
    ///         Text("My Contents")
    ///     }
    ///     .background {
    ///         MyBackgroundView()
    ///     }
    ///
    /// - Parameter background: The contents of the SwiftUI hierarchy to be
    ///   shown inside the background of the cell.
    public func background<B>(@ViewBuilder content: () -> B) -> UIHostingConfiguration<Content, B> where B : View

    /// Sets the background contents for the hosting configuration's enclosing
    /// cell.
    ///
    /// The following example sets a custom view to the background of the cell:
    ///
    ///     UIHostingConfiguration {
    ///         Text("My Contents")
    ///     }
    ///     .background(Color.blue)
    ///
    /// - Parameter style: The shape style to be used as the background of the
    ///   cell.
    public func background<S>(_ style: S) -> UIHostingConfiguration<Content, _UIHostingConfigurationBackgroundView<S>> where S : ShapeStyle

    /// Sets the margins around the content of the configuration.
    ///
    /// Use this modifier to replace the default margins applied to the root of
    /// the configuration. The following example creates 20 points of space
    /// between the content and the background on the horizontal edges.
    ///
    ///     UIHostingConfiguration {
    ///         Text("My Contents")
    ///     }
    ///     .margins(.horizontal, 20.0)
    ///
    /// - Parameters:
    ///    - edges: The edges to apply the insets. Any edges not specified will
    ///      use the system default values. The default value is
    ///      ``Edge/Set/all``.
    ///    - length: The amount to apply.
    public func margins(_ edges: Edge.Set = .all, _ length: CGFloat) -> UIHostingConfiguration<Content, Background>

    /// Sets the margins around the content of the configuration.
    ///
    /// Use this modifier to replace the default margins applied to the root of
    /// the configuration. The following example creates 10 points of space
    /// between the content and the background on the leading edge and 20 points
    /// of space on the trailing edge:
    ///
    ///     UIHostingConfiguration {
    ///         Text("My Contents")
    ///     }
    ///     .margins(.horizontal, 20.0)
    ///
    /// - Parameters:
    ///    - edges: The edges to apply the insets. Any edges not specified will
    ///      use the system default values. The default value is
    ///      ``Edge/Set/all``.
    ///    - insets: The insets to apply.
    public func margins(_ edges: Edge.Set = .all, _ insets: EdgeInsets) -> UIHostingConfiguration<Content, Background>

    /// Sets the minimum size for the configuration.
    ///
    /// Use this modifier to indicate that a configuration's associated cell can
    /// be resized to a specific minimum. The following example allows the cell
    /// to be compressed to zero size:
    ///
    ///     UIHostingConfiguration {
    ///         Text("My Contents")
    ///     }
    ///     .minSize(width: 0, height: 0)
    ///
    /// - Parameter width: The value to use for the width dimension. A value of
    ///   `nil` indicates that the system default should be used.
    /// - Parameter height: The value to use for the height dimension. A value
    ///   of `nil` indicates that the system default should be used.
    public func minSize(width: CGFloat? = nil, height: CGFloat? = nil) -> UIHostingConfiguration<Content, Background>

    /// Sets the minimum size for the configuration.
    ///
    /// Use the version with parameters instead.
    @available(*, deprecated, message: "Please pass one or more parameters.")
    public func minSize() -> UIHostingConfiguration<Content, Background>

    @MainActor public func makeContentView() -> any UIView & UIContentView

    public func updated(for state: any UIConfigurationState) -> UIHostingConfiguration<Content, Background>
}

@available(iOS 16.0, tvOS 16.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension UIHostingConfiguration where Background == EmptyView {

    /// Creates a hosting configuration with the given contents.
    ///
    /// - Parameter content: The contents of the SwiftUI hierarchy to be shown
    ///   inside the cell.
    public init(@ViewBuilder content: () -> Content)
}

/// A UIKit view controller that manages a SwiftUI view hierarchy.
///
/// Create a `UIHostingController` object when you want to integrate SwiftUI
/// views into a UIKit view hierarchy. At creation time, specify the SwiftUI
/// view you want to use as the root view for this view controller; you can
/// change that view later using the ``SwiftUI/UIHostingController/rootView``
/// property. Use the hosting controller like you would any other view
/// controller, by presenting it or embedding it as a child view controller
/// in your interface.
@available(iOS 13.0, tvOS 13.0, *)
@available(macOS, unavailable)
@MainActor @preconcurrency open class UIHostingController<Content> : UIViewController where Content : View {

    @MainActor @preconcurrency override dynamic open var undoManager: UndoManager? { get }

    @MainActor @preconcurrency override dynamic open var keyCommands: [UIKeyCommand]? { get }

    /// Creates a hosting controller object that wraps the specified SwiftUI
    /// view.
    ///
    /// - Parameter rootView: The root view of the SwiftUI view hierarchy that
    ///   you want to manage using the hosting view controller.
    ///
    /// - Returns: A `UIHostingController` object initialized with the
    ///   specified SwiftUI view.
    @MainActor @preconcurrency public init(rootView: Content)

    /// Creates a hosting controller object from an archive and the specified
    /// SwiftUI view.
    /// - Parameters:
    ///   - coder: The decoder to use during initialization.
    ///   - rootView: The root view of the SwiftUI view hierarchy that you want
    ///     to manage using this view controller.
    ///
    /// - Returns: A `UIViewController` object that you can present from your
    ///   interface.
    @MainActor @preconcurrency public init?(coder aDecoder: NSCoder, rootView: Content)

    /// Creates a hosting controller object from the contents of the specified
    /// archive.
    ///
    /// The default implementation of this method throws an exception. To create
    /// your view controller from an archive, override this method and
    /// initialize the superclass using the ``init(coder:rootView:)`` method
    /// instead.
    ///
    /// -Parameter coder: The decoder to use during initialization.
    @MainActor @preconcurrency required dynamic public init?(coder aDecoder: NSCoder)

    @MainActor @preconcurrency override dynamic open func loadView()

    /// Notifies the view controller that its view is about to be added to a
    /// view hierarchy.
    ///
    /// SwiftUI calls this method before adding the hosting controller's root
    /// view to the view hierarchy. You can override this method to perform
    /// custom tasks associated with the appearance of the view. If you
    /// override this method, you must call `super` at some point in your
    /// implementation.
    ///
    /// - Parameter animated: If `true`, the view is being added
    ///   using an animation.
    @MainActor @preconcurrency override dynamic open func viewWillAppear(_ animated: Bool)

    /// Notifies the view controller that its view has been added to a
    /// view hierarchy.
    ///
    /// SwiftUI calls this method after adding the hosting controller's root
    /// view to the view hierarchy. You can override this method to perform
    /// custom tasks associated with the appearance of the view. If you
    /// override this method, you must call `super` at some point in your
    /// implementation.
    ///
    /// - Parameter animated: If `true`, the view is being added
    ///   using an animation.
    @MainActor @preconcurrency override dynamic open func viewDidAppear(_ animated: Bool)

    /// Notifies the view controller that its view will be removed from a
    /// view hierarchy.
    ///
    /// SwiftUI calls this method before removing the hosting controller's root
    /// view from the view hierarchy. You can override this method to perform
    /// custom tasks associated with the disappearance of the view. If you
    /// override this method, you must call `super` at some point in your
    /// implementation.
    ///
    /// - Parameter animated: If `true`, the view is being removed
    ///   using an animation.
    @MainActor @preconcurrency override dynamic open func viewWillDisappear(_ animated: Bool)

    @MainActor @preconcurrency override dynamic open func viewDidDisappear(_ animated: Bool)

    @MainActor @preconcurrency override dynamic open func viewWillLayoutSubviews()

    @MainActor @preconcurrency override dynamic open var isModalInPresentation: Bool

    /// The root view of the SwiftUI view hierarchy managed by this view
    /// controller.
    @MainActor @preconcurrency public var rootView: Content

    /// The options for how the hosting controller tracks changes to the size
    /// of its SwiftUI content.
    ///
    /// The default value is the empty set.
    @available(iOS 16.0, tvOS 16.0, *)
    @available(macOS, unavailable)
    @available(watchOS, unavailable)
    @MainActor @preconcurrency public var sizingOptions: UIHostingControllerSizingOptions

    /// Calculates and returns the most appropriate size for the current view.
    ///
    /// - Parameter size: The proposed new size for the view.
    ///
    /// - Returns: The size that offers the best fit for the root view and its
    ///   contents.
    @MainActor @preconcurrency public func sizeThatFits(in size: CGSize) -> CGSize

    @MainActor @preconcurrency override dynamic open func preferredContentSizeDidChange(forChildContentContainer container: any UIContentContainer)

    /// The preferred status bar style for the view controller.
    @MainActor @preconcurrency override dynamic open var preferredStatusBarStyle: UIStatusBarStyle { get }

    /// A Boolean value that indicates whether the view controller prefers the
    /// status bar to be hidden or shown.
    @MainActor @preconcurrency override dynamic open var prefersStatusBarHidden: Bool { get }

    /// The animation style to use when hiding or showing the status bar for
    /// this view controller.
    @MainActor @preconcurrency override dynamic open var preferredStatusBarUpdateAnimation: UIStatusBarAnimation { get }

    @MainActor @preconcurrency override dynamic open var childForStatusBarStyle: UIViewController? { get }

    @MainActor @preconcurrency override dynamic open var childForStatusBarHidden: UIViewController? { get }

    @MainActor @preconcurrency override dynamic open func viewWillTransition(to size: CGSize, with coordinator: any UIViewControllerTransitionCoordinator)

    @MainActor @preconcurrency override dynamic open func willMove(toParent parent: UIViewController?)

    @MainActor @preconcurrency override dynamic open func didMove(toParent parent: UIViewController?)

    /// Sets the screen edge from which you want your gesture to take
    /// precedence over the system gesture.
    @MainActor @preconcurrency override dynamic open var preferredScreenEdgesDeferringSystemGestures: UIRectEdge { get }

    @MainActor @preconcurrency override dynamic open var childForScreenEdgesDeferringSystemGestures: UIViewController? { get }

    /// A Boolean value that indicates whether the view controller prefers the
    /// home indicator to be hidden or shown.
    @MainActor @preconcurrency override dynamic open var prefersHomeIndicatorAutoHidden: Bool { get }

    @MainActor @preconcurrency override dynamic open var childForHomeIndicatorAutoHidden: UIViewController? { get }

    @MainActor @preconcurrency override dynamic open func target(forAction action: Selector, withSender sender: Any?) -> Any?
}

@available(iOS 16.4, tvOS 16.4, *)
@available(macOS, unavailable)
extension UIHostingController {

    /// The safe area regions that this view controller adds to its view.
    ///
    /// An example of when this is appropriate to use is when hosting content
    /// that you know should never be affected by the safe area, such as a
    /// custom scrollable container. Disabling a safe area region omits it from
    /// the SwiftUI layout system altogether.
    ///
    /// The default value is ``SafeAreaRegions.all``.
    @available(iOS 16.4, tvOS 16.4, *)
    @available(macOS, unavailable)
    @MainActor @preconcurrency public var safeAreaRegions: SafeAreaRegions
}

/// Options for how a hosting controller tracks its content's size.
@available(iOS 16.0, tvOS 16.0, *)
@available(macOS, unavailable)
public struct UIHostingControllerSizingOptions : OptionSet, Sendable {

    /// The raw value.
    public let rawValue: Int

    /// Creates a new option set from a raw value.
    public init(rawValue: Int)

    /// The hosting controller tracks its content's ideal size in its
    /// preferred content size.
    ///
    /// Use this option when using a hosting controller with a container view
    /// controller that requires up-to-date knowledge of the hosting
    /// controller's ideal size.
    ///
    /// - Note: This option comes with a performance cost because it
    ///   asks for the ideal size of the content using the
    ///   ``ProposedViewSize/unspecified`` size proposal.
    public static let preferredContentSize: UIHostingControllerSizingOptions

    /// The hosting controller's view automatically invalidate its intrinsic
    /// content size when its ideal size changes.
    ///
    /// Use this option when the hosting controller's view is being laid out
    /// with Auto Layout.
    ///
    /// - Note: This option comes with a performance cost because it
    ///   asks for the ideal size of the content using the
    ///   ``ProposedViewSize/unspecified`` size proposal.
    public static let intrinsicContentSize: UIHostingControllerSizingOptions

    /// The type of the elements of an array literal.
    @available(iOS 16.0, tvOS 16.0, *)
    @available(macOS, unavailable)
    public typealias ArrayLiteralElement = UIHostingControllerSizingOptions

    /// The element type of the option set.
    ///
    /// To inherit all the default implementations from the `OptionSet` protocol,
    /// the `Element` type must be `Self`, the default.
    @available(iOS 16.0, tvOS 16.0, *)
    @available(macOS, unavailable)
    public typealias Element = UIHostingControllerSizingOptions

    /// The raw type that can be used to represent all values of the conforming
    /// type.
    ///
    /// Every distinct value of the conforming type has a corresponding unique
    /// value of the `RawValue` type, but there may be values of the `RawValue`
    /// type that don't have a corresponding value of the conforming type.
    @available(iOS 16.0, tvOS 16.0, *)
    @available(macOS, unavailable)
    public typealias RawValue = Int
}

/// An environment key that is bridged to a UIKit trait.
///
/// Use this protocol to allow the same underlying data to be accessed using an
/// environment key in SwiftUI and trait in UIKit. As the bridging is
/// bidirectional, values written to the trait in UIKit can be read using the
/// environment key in SwiftUI, and values written to the environment key in
/// SwiftUI can be read from the trait in UIKit.
///
/// Given a custom UIKit trait named `MyTrait` with `myTrait` properties on
/// both `UITraitCollection` and `UIMutableTraits`:
///
///     struct MyTrait: UITraitDefinition {
///         static let defaultValue = "Default value"
///     }
///
///     extension UITraitCollection {
///         var myTrait: String {
///             self[MyTrait.self]
///         }
///     }
///
///     extension UIMutableTraits {
///         var myTrait: String {
///             get { self[MyTrait.self] }
///             set { self[MyTrait.self] = newValue }
///         }
///     }
///
/// You can declare an environment key to represent the same data:
///
///     struct MyEnvironmentKey: EnvironmentKey {
///         static let defaultValue = "Default value"
///     }
///
/// Bridge the environment key and the trait by conforming to the
/// `UITraitBridgedEnvironmentKey` protocol, providing implementations
/// of ``read(from:)`` and ``write(to:value:)`` to losslessly convert
/// the environment value from and to the corresponding trait value:
///
///     extension MyEnvironmentKey: UITraitBridgedEnvironmentKey {
///         static func read(
///             from traitCollection: UITraitCollection
///         ) -> String {
///             traitCollection.myTrait
///         }
///
///         static func write(
///             to mutableTraits: inout UIMutableTraits, value: String
///         ) {
///             mutableTraits.myTrait = value
///         }
///     }
///
@available(iOS 17.0, tvOS 17.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
public protocol UITraitBridgedEnvironmentKey : EnvironmentKey {

    /// Reads the trait value from the trait collection, and returns
    /// the equivalent environment value.
    ///
    /// - Parameter traitCollection: The trait collection to read from.
    static func read(from traitCollection: UITraitCollection) -> Self.Value

    /// Writes the equivalent trait value for the environment value into
    /// the mutable traits.
    ///
    /// - Parameter mutableTraits: The mutable traits to write to.
    /// - Parameter value: The environment value to write.
    static func write(to mutableTraits: inout any UIMutableTraits, value: Self.Value)
}

/// A view that represents a UIKit view controller.
///
/// Use a ``UIViewControllerRepresentable`` instance to create and manage a
/// <doc://com.apple.documentation/documentation/UIKit/UIViewController> object in your
/// SwiftUI interface. Adopt this protocol in one of your app's custom
/// instances, and use its methods to create, update, and tear down your view
/// controller. The creation and update processes parallel the behavior of
/// SwiftUI views, and you use them to configure your view controller with your
/// app's current state information. Use the teardown process to remove your
/// view controller cleanly from your SwiftUI. For example, you might use the
/// teardown process to notify other objects that the view controller is
/// disappearing.
///
/// To add your view controller into your SwiftUI interface, create your
/// ``UIViewControllerRepresentable`` instance and add it to your SwiftUI
/// interface. The system calls the methods of your custom instance at
/// appropriate times.
///
/// The system doesn't automatically communicate changes occurring within your
/// view controller to other parts of your SwiftUI interface. When you want your
/// view controller to coordinate with other SwiftUI views, you must provide a
/// ``NSViewControllerRepresentable/Coordinator`` instance to facilitate those
/// interactions. For example, you use a coordinator to forward target-action
/// and delegate messages from your view controller to any SwiftUI views.
///
/// - Warning: SwiftUI fully controls the layout of the UIKit view controller's
/// view using the view's
/// <doc://com.apple.documentation/documentation/UIKit/UIView/1622627-center>,
/// <doc://com.apple.documentation/documentation/UIKit/UIView/1622580-bounds>,
/// <doc://com.apple.documentation/documentation/UIKit/UIView/1622621-frame>, and
/// <doc://com.apple.documentation/documentation/UIKit/UIView/1622459-transform>
/// properties. Don't directly set these layout-related properties on the view
/// managed by a `UIViewControllerRepresentable` instance from your own
/// code because that conflicts with SwiftUI and results in undefined behavior.
@available(iOS 13.0, tvOS 13.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
@MainActor @preconcurrency public protocol UIViewControllerRepresentable : View where Self.Body == Never {

    /// The type of view controller to present.
    associatedtype UIViewControllerType : UIViewController

    /// Creates the view controller object and configures its initial state.
    ///
    /// You must implement this method and use it to create your view controller
    /// object. Create the view controller using your app's current data and
    /// contents of the `context` parameter. The system calls this method only
    /// once, when it creates your view controller for the first time. For all
    /// subsequent updates, the system calls the
    /// ``UIViewControllerRepresentable/updateUIViewController(_:context:)``
    /// method.
    ///
    /// - Parameter context: A context structure containing information about
    ///   the current state of the system.
    ///
    /// - Returns: Your UIKit view controller configured with the provided
    ///   information.
    @MainActor @preconcurrency func makeUIViewController(context: Self.Context) -> Self.UIViewControllerType

    /// Updates the state of the specified view controller with new information
    /// from SwiftUI.
    ///
    /// When the state of your app changes, SwiftUI updates the portions of your
    /// interface affected by those changes. SwiftUI calls this method for any
    /// changes affecting the corresponding UIKit view controller. Use this
    /// method to update the configuration of your view controller to match the
    /// new state information provided in the `context` parameter.
    ///
    /// - Parameters:
    ///   - uiViewController: Your custom view controller object.
    ///   - context: A context structure containing information about the current
    ///     state of the system.
    @MainActor @preconcurrency func updateUIViewController(_ uiViewController: Self.UIViewControllerType, context: Self.Context)

    /// Cleans up the presented view controller (and coordinator) in
    /// anticipation of their removal.
    ///
    /// Use this method to perform additional clean-up work related to your
    /// custom view controller. For example, you might use this method to remove
    /// observers or update other parts of your SwiftUI interface.
    ///
    /// - Parameters:
    ///   - uiViewController: Your custom view controller object.
    ///   - coordinator: The custom coordinator instance you use to communicate
    ///     changes back to SwiftUI. If you do not use a custom coordinator, the
    ///     system provides a default instance.
    @MainActor @preconcurrency static func dismantleUIViewController(_ uiViewController: Self.UIViewControllerType, coordinator: Self.Coordinator)

    /// A type to coordinate with the view controller.
    associatedtype Coordinator = Void

    /// Creates the custom instance that you use to communicate changes from
    /// your view controller to other parts of your SwiftUI interface.
    ///
    /// Implement this method if changes to your view controller might affect
    /// other parts of your app. In your implementation, create a custom Swift
    /// instance that can communicate with other parts of your interface. For
    /// example, you might provide an instance that binds its variables to
    /// SwiftUI properties, causing the two to remain synchronized. If your view
    /// controller doesn't interact with other parts of your app, providing a
    /// coordinator is unnecessary.
    ///
    /// SwiftUI calls this method before calling the
    /// ``UIViewControllerRepresentable/makeUIViewController(context:)`` method.
    /// The system provides your coordinator either directly or as part of a
    /// context structure when calling the other methods of your representable
    /// instance.
    @MainActor @preconcurrency func makeCoordinator() -> Self.Coordinator

    /// Given a proposed size, returns the preferred size of the composite view.
    ///
    /// This method may be called more than once with different proposed sizes
    /// during the same layout pass. SwiftUI views choose their own size, so one
    /// of the values returned from this function will always be used as the
    /// actual size of the composite view.
    ///
    /// - Parameters:
    ///   - proposal: The proposed size for the view controller.
    ///   - uiViewController: Your custom view controller object.
    ///   - context: A context structure containing information about the
    ///     current state of the system.
    ///
    /// - Returns: The composite size of the represented view controller.
    ///   Returning a value of `nil` indicates that the system should use the
    ///   default sizing algorithm.
    @available(iOS 16.0, tvOS 16.0, *)
    @MainActor @preconcurrency func sizeThatFits(_ proposal: ProposedViewSize, uiViewController: Self.UIViewControllerType, context: Self.Context) -> CGSize?

    typealias Context = UIViewControllerRepresentableContext<Self>

    @available(iOS 17.0, tvOS 17.0, *)
    typealias LayoutOptions
}

@available(iOS 13.0, tvOS 13.0, watchOS 6.0, *)
@available(macOS, unavailable)
extension UIViewControllerRepresentable where Self.Coordinator == () {

    /// Creates the custom instance that you use to communicate changes from
    /// your view controller to other parts of your SwiftUI interface.
    ///
    /// Implement this method if changes to your view controller might affect
    /// other parts of your app. In your implementation, create a custom Swift
    /// instance that can communicate with other parts of your interface. For
    /// example, you might provide an instance that binds its variables to
    /// SwiftUI properties, causing the two to remain synchronized. If your view
    /// controller doesn't interact with other parts of your app, providing a
    /// coordinator is unnecessary.
    ///
    /// SwiftUI calls this method before calling the
    /// ``UIViewControllerRepresentable/makeUIViewController(context:)`` method.
    /// The system provides your coordinator either directly or as part of a
    /// context structure when calling the other methods of your representable
    /// instance.
    @MainActor @preconcurrency public func makeCoordinator() -> Self.Coordinator
}

@available(iOS 13.0, tvOS 13.0, watchOS 6.0, *)
@available(macOS, unavailable)
extension UIViewControllerRepresentable {

    /// Given a proposed size, returns the preferred size of the composite view.
    ///
    /// This method may be called more than once with different proposed sizes
    /// during the same layout pass. SwiftUI views choose their own size, so one
    /// of the values returned from this function will always be used as the
    /// actual size of the composite view.
    ///
    /// - Parameters:
    ///   - proposal: The proposed size for the view controller.
    ///   - uiViewController: Your custom view controller object.
    ///   - context: A context structure containing information about the
    ///     current state of the system.
    ///
    /// - Returns: The composite size of the represented view controller.
    ///   Returning a value of `nil` indicates that the system should use the
    ///   default sizing algorithm.
    @available(iOS 16.0, tvOS 16.0, watchOS 9.0, *)
    @MainActor @preconcurrency public func sizeThatFits(_ proposal: ProposedViewSize, uiViewController: Self.UIViewControllerType, context: Self.Context) -> CGSize?

    /// Cleans up the presented view controller (and coordinator) in
    /// anticipation of their removal.
    ///
    /// Use this method to perform additional clean-up work related to your
    /// custom view controller. For example, you might use this method to remove
    /// observers or update other parts of your SwiftUI interface.
    ///
    /// - Parameters:
    ///   - uiViewController: Your custom view controller object.
    ///   - coordinator: The custom coordinator instance you use to communicate
    ///     changes back to SwiftUI. If you do not use a custom coordinator, the
    ///     system provides a default instance.
    @MainActor @preconcurrency public static func dismantleUIViewController(_ uiViewController: Self.UIViewControllerType, coordinator: Self.Coordinator)

    /// Declares the content and behavior of this view.
    @MainActor @preconcurrency public var body: Never { get }
}

/// Contextual information about the state of the system that you use to create
/// and update your UIKit view controller.
///
/// A ``UIViewControllerRepresentableContext`` structure contains details about
/// the current state of the system. When creating and updating your view
/// controller, the system creates one of these structures and passes it to the
/// appropriate method of your custom ``UIViewControllerRepresentable``
/// instance. Use the information in this structure to configure your view
/// controller. For example, use the provided environment values to configure
/// the appearance of your view controller and views. Don't create this
/// structure yourself.
@available(iOS 13.0, tvOS 13.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
@MainActor @preconcurrency public struct UIViewControllerRepresentableContext<Representable> where Representable : UIViewControllerRepresentable {

    /// The view's associated coordinator.
    @MainActor @preconcurrency public let coordinator: Representable.Coordinator

    /// The current transaction.
    @MainActor @preconcurrency public var transaction: Transaction { get }

    /// Environment values that describe the current state of the system.
    ///
    /// Use the environment values to configure the state of your UIKit view
    /// controller when creating or updating it.
    @MainActor @preconcurrency public var environment: EnvironmentValues { get }

    /// Animates changes using the animation in the current transaction.
    ///
    /// This combines
    /// <doc://com.apple.documentation/documentation/UIKit/UIView/4429628-animate> with the
    /// with the current transaction's animation. When you start a SwiftUI
    /// animation using ``SwiftUI/withAnimation(_:_:)`` and have a mutated
    /// SwiftUI state that causes the representable object to update, use
    /// this method to animate changes in the representable object using the
    /// same `Animation` timing.
    ///
    ///     struct ContentView: View {
    ///         @State private var isCollapsed = false
    ///         var body: some View {
    ///             ZStack {
    ///                 MyDetailView(isCollapsed: isCollapsed)
    ///                 MyRepresentable(isCollapsed: $isCollapsed)
    ///                 Button("Collapse Content") {
    ///                     withAnimation(.bouncy) {
    ///                         isCollapsed = true
    ///                     }
    ///                 }
    ///             }
    ///         }
    ///     }
    ///
    ///     struct MyRepresentable: UIViewControllerRepresentable {
    ///         @Binding var isCollapsed: Bool
    ///
    ///         func updateUIViewController(_ uiViewController: UIViewControllerType, context: Context) {
    ///             if isCollapsed && !uiViewController.view.isCollapsed {
    ///                 context.animate {
    ///                     uiViewController.collapseSubview()
    ///                     uiView.layout()
    ///                 }
    ///             }
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - changes: A closure that changes animatable properties.
    ///   - completion: A closure to execute after the animation completes.
    @available(iOS 18.0, tvOS 18.0, visionOS 2.0, *)
    @available(macOS, unavailable)
    @available(watchOS, unavailable)
    @MainActor @preconcurrency public func animate(changes: () -> Void, completion: (() -> Void)? = nil)
}

@available(iOS 13.0, tvOS 13.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension UIViewControllerRepresentableContext : Sendable {
}

/// A wrapper for a UIKit view that you use to integrate that view into your
/// SwiftUI view hierarchy.
///
/// Use a ``UIViewRepresentable`` instance to create and manage a
/// <doc://com.apple.documentation/documentation/UIKit/UIView> object in your SwiftUI
/// interface. Adopt this protocol in one of your app's custom instances, and
/// use its methods to create, update, and tear down your view. The creation and
/// update processes parallel the behavior of SwiftUI views, and you use them to
/// configure your view with your app's current state information. Use the
/// teardown process to remove your view cleanly from your SwiftUI. For example,
/// you might use the teardown process to notify other objects that the view is
/// disappearing.
///
/// To add your view into your SwiftUI interface, create your
/// ``UIViewRepresentable`` instance and add it to your SwiftUI interface. The
/// system calls the methods of your representable instance at appropriate times
/// to create and update the view. The following example shows the inclusion of
/// a custom `MyRepresentedCustomView` structure in the view hierarchy.
///
///     struct ContentView: View {
///        var body: some View {
///           VStack {
///              Text("Global Sales")
///              MyRepresentedCustomView()
///           }
///        }
///     }
///
/// The system doesn't automatically communicate changes occurring within your
/// view to other parts of your SwiftUI interface. When you want your view to
/// coordinate with other SwiftUI views, you must provide a
/// ``NSViewControllerRepresentable/Coordinator`` instance to facilitate those
/// interactions. For example, you use a coordinator to forward target-action
/// and delegate messages from your view to any SwiftUI views.
///
/// - Warning: SwiftUI fully controls the layout of the UIKit view's
/// <doc://com.apple.documentation/documentation/UIKit/UIView/1622627-center>,
/// <doc://com.apple.documentation/documentation/UIKit/UIView/1622580-bounds>,
/// <doc://com.apple.documentation/documentation/UIKit/UIView/1622621-frame>, and
/// <doc://com.apple.documentation/documentation/UIKit/UIView/1622459-transform>
/// properties. Don't directly set these layout-related properties on the view
/// managed by a `UIViewRepresentable` instance from your own
/// code because that conflicts with SwiftUI and results in undefined behavior.```
@available(iOS 13.0, tvOS 13.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
@MainActor @preconcurrency public protocol UIViewRepresentable : View where Self.Body == Never {

    /// The type of view to present.
    associatedtype UIViewType : UIView

    /// Creates the view object and configures its initial state.
    ///
    /// You must implement this method and use it to create your view object.
    /// Configure the view using your app's current data and contents of the
    /// `context` parameter. The system calls this method only once, when it
    /// creates your view for the first time. For all subsequent updates, the
    /// system calls the ``UIViewRepresentable/updateUIView(_:context:)``
    /// method.
    ///
    /// - Parameter context: A context structure containing information about
    ///   the current state of the system.
    ///
    /// - Returns: Your UIKit view configured with the provided information.
    @MainActor @preconcurrency func makeUIView(context: Self.Context) -> Self.UIViewType

    /// Updates the state of the specified view with new information from
    /// SwiftUI.
    ///
    /// When the state of your app changes, SwiftUI updates the portions of your
    /// interface affected by those changes. SwiftUI calls this method for any
    /// changes affecting the corresponding UIKit view. Use this method to
    /// update the configuration of your view to match the new state information
    /// provided in the `context` parameter.
    ///
    /// - Parameters:
    ///   - uiView: Your custom view object.
    ///   - context: A context structure containing information about the current
    ///     state of the system.
    @MainActor @preconcurrency func updateUIView(_ uiView: Self.UIViewType, context: Self.Context)

    /// Cleans up the presented UIKit view (and coordinator) in anticipation of
    /// their removal.
    ///
    /// Use this method to perform additional clean-up work related to your
    /// custom view. For example, you might use this method to remove observers
    /// or update other parts of your SwiftUI interface.
    ///
    /// - Parameters:
    ///   - uiView: Your custom view object.
    ///   - coordinator: The custom coordinator instance you use to communicate
    ///     changes back to SwiftUI. If you do not use a custom coordinator, the
    ///     system provides a default instance.
    @MainActor @preconcurrency static func dismantleUIView(_ uiView: Self.UIViewType, coordinator: Self.Coordinator)

    /// A type to coordinate with the view.
    associatedtype Coordinator = Void

    /// Creates the custom instance that you use to communicate changes from
    /// your view to other parts of your SwiftUI interface.
    ///
    /// Implement this method if changes to your view might affect other parts
    /// of your app. In your implementation, create a custom Swift instance that
    /// can communicate with other parts of your interface. For example, you
    /// might provide an instance that binds its variables to SwiftUI
    /// properties, causing the two to remain synchronized. If your view doesn't
    /// interact with other parts of your app, providing a coordinator is
    /// unnecessary.
    ///
    /// SwiftUI calls this method before calling the
    /// ``UIViewRepresentable/makeUIView(context:)`` method. The system provides
    /// your coordinator either directly or as part of a context structure when
    /// calling the other methods of your representable instance.
    @MainActor @preconcurrency func makeCoordinator() -> Self.Coordinator

    /// Given a proposed size, returns the preferred size of the composite view.
    ///
    /// This method may be called more than once with different proposed sizes
    /// during the same layout pass. SwiftUI views choose their own size, so one
    /// of the values returned from this function will always be used as the
    /// actual size of the composite view.
    ///
    /// - Parameters:
    ///   - proposal: The proposed size for the view.
    ///   - uiView: Your custom view object.
    ///   - context: A context structure containing information about the
    ///     current state of the system.
    ///
    /// - Returns: The composite size of the represented view controller.
    ///   Returning a value of `nil` indicates that the system should use the
    ///   default sizing algorithm.
    @available(iOS 16.0, tvOS 16.0, *)
    @MainActor @preconcurrency func sizeThatFits(_ proposal: ProposedViewSize, uiView: Self.UIViewType, context: Self.Context) -> CGSize?

    typealias Context = UIViewRepresentableContext<Self>

    @available(iOS 17.0, tvOS 17.0, *)
    typealias LayoutOptions
}

@available(iOS 13.0, tvOS 13.0, watchOS 6.0, *)
@available(macOS, unavailable)
extension UIViewRepresentable where Self.Coordinator == () {

    /// Creates the custom instance that you use to communicate changes from
    /// your view to other parts of your SwiftUI interface.
    ///
    /// Implement this method if changes to your view might affect other parts
    /// of your app. In your implementation, create a custom Swift instance that
    /// can communicate with other parts of your interface. For example, you
    /// might provide an instance that binds its variables to SwiftUI
    /// properties, causing the two to remain synchronized. If your view doesn't
    /// interact with other parts of your app, providing a coordinator is
    /// unnecessary.
    ///
    /// SwiftUI calls this method before calling the
    /// ``UIViewRepresentable/makeUIView(context:)`` method. The system provides
    /// your coordinator either directly or as part of a context structure when
    /// calling the other methods of your representable instance.
    @MainActor @preconcurrency public func makeCoordinator() -> Self.Coordinator
}

@available(iOS 13.0, tvOS 13.0, watchOS 6.0, *)
@available(macOS, unavailable)
extension UIViewRepresentable {

    /// Cleans up the presented UIKit view (and coordinator) in anticipation of
    /// their removal.
    ///
    /// Use this method to perform additional clean-up work related to your
    /// custom view. For example, you might use this method to remove observers
    /// or update other parts of your SwiftUI interface.
    ///
    /// - Parameters:
    ///   - uiView: Your custom view object.
    ///   - coordinator: The custom coordinator instance you use to communicate
    ///     changes back to SwiftUI. If you do not use a custom coordinator, the
    ///     system provides a default instance.
    @MainActor @preconcurrency public static func dismantleUIView(_ uiView: Self.UIViewType, coordinator: Self.Coordinator)

    /// Given a proposed size, returns the preferred size of the composite view.
    ///
    /// This method may be called more than once with different proposed sizes
    /// during the same layout pass. SwiftUI views choose their own size, so one
    /// of the values returned from this function will always be used as the
    /// actual size of the composite view.
    ///
    /// - Parameters:
    ///   - proposal: The proposed size for the view.
    ///   - uiView: Your custom view object.
    ///   - context: A context structure containing information about the
    ///     current state of the system.
    ///
    /// - Returns: The composite size of the represented view controller.
    ///   Returning a value of `nil` indicates that the system should use the
    ///   default sizing algorithm.
    @available(iOS 16.0, tvOS 16.0, watchOS 9.0, *)
    @available(macOS, unavailable)
    @MainActor @preconcurrency public func sizeThatFits(_ proposal: ProposedViewSize, uiView: Self.UIViewType, context: Self.Context) -> CGSize?

    /// Declares the content and behavior of this view.
    @MainActor @preconcurrency public var body: Never { get }
}

/// Contextual information about the state of the system that you use to create
/// and update your UIKit view.
///
/// A ``UIViewRepresentableContext`` structure contains details about the
/// current state of the system. When creating and updating your view, the
/// system creates one of these structures and passes it to the appropriate
/// method of your custom ``UIViewRepresentable`` instance. Use the information
/// in this structure to configure your view. For example, use the provided
/// environment values to configure the appearance of your view. Don't create
/// this structure yourself.
@available(iOS 13.0, tvOS 13.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
@MainActor @preconcurrency public struct UIViewRepresentableContext<Representable> where Representable : UIViewRepresentable {

    /// The view's associated coordinator.
    @MainActor @preconcurrency public let coordinator: Representable.Coordinator

    /// The current transaction.
    @MainActor @preconcurrency public var transaction: Transaction { get }

    /// The current environment.
    ///
    /// Use the environment values to configure the state of your view when
    /// creating or updating it.
    @MainActor @preconcurrency public var environment: EnvironmentValues { get }

    /// Animates changes using the animation in the current transaction.
    ///
    /// This combines
    /// <doc://com.apple.documentation/documentation/UIKit/UIView/4429628-animate>
    /// with the current transaction's animation. When you start a SwiftUI
    /// animation using ``SwiftUI/withAnimation(_:_:)`` and have a mutated
    /// SwiftUI state that causes the representable object to update, use
    /// this method to animate changes in the representable object using the
    /// same `Animation` timing.
    ///
    ///     struct ContentView: View {
    ///         @State private var isCollapsed = false
    ///         var body: some View {
    ///             ZStack {
    ///                 MyDetailView(isCollapsed: isCollapsed)
    ///                 MyRepresentable(isCollapsed: $isCollapsed)
    ///                 Button("Collapse Content") {
    ///                     withAnimation(.bouncy) {
    ///                         isCollapsed = true
    ///                     }
    ///                 }
    ///             }
    ///         }
    ///     }
    ///
    ///     struct MyRepresentable: UIViewRepresentable {
    ///         @Binding var isCollapsed: Bool
    ///
    ///         func updateUIView(_ uiView: UIViewType, context: Context) {
    ///             if isCollapsed && !uiView.isCollapsed {
    ///                 context.animate {
    ///                     uiView.collapseSubview()
    ///                     uiView.layout()
    ///                 }
    ///             }
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - changes: A closure that changes animatable properties.
    ///   - completion: A closure to execute after the animation completes.
    @available(iOS 18.0, tvOS 18.0, visionOS 2.0, *)
    @available(macOS, unavailable)
    @available(watchOS, unavailable)
    @MainActor @preconcurrency public func animate(changes: () -> Void, completion: (() -> Void)? = nil)
}

@available(iOS 13.0, tvOS 13.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension UIViewRepresentableContext : Sendable {
}

/// The scroll behavior that aligns scroll targets to view-based geometry.
///
/// You use this behavior when a scroll view should always align its
/// scroll targets to a rectangle that's aligned to the geometry of a view. In
/// the following example, the scroll view always picks an item view
/// to settle on.
///
///     ScrollView(.horizontal) {
///         LazyHStack(spacing: 10.0) {
///             ForEach(items) { item in
///               ItemView(item)
///             }
///         }
///         .scrollTargetLayout()
///     }
///     .scrollTargetBehavior(.viewAligned)
///     .padding(.horizontal, 20.0)
///
/// You configure which views should be used for settling using the
/// ``View/scrollTargetLayout(isEnabled:)`` modifier. Apply this modifier to a
/// layout container like ``LazyVStack`` or ``HStack`` and each individual
/// view in that layout will be considered for alignment.
///
/// You can customize whether the view aligned behavior limits the
/// number of views that can be scrolled at a time by using the
/// ``ViewAlignedScrollTargetBehavior/LimitBehavior`` type. Provide a value of
/// ``ViewAlignedScrollTargetBehavior/LimitBehavior/always`` to always have
/// the behavior only allow a few views to be scrolled at a time.
///
/// By default, the view aligned behavior will limit the number of views
/// it scrolls when in a compact horizontal size class when scrollable
/// in the horizontal axis, when in a compact vertical size class when
/// scrollable in the vertical axis, and otherwise does not impose any
/// limit on the number of views that can be scrolled.
///
@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
public struct ViewAlignedScrollTargetBehavior : ScrollTargetBehavior {

    /// A type that defines the amount of views that can be scrolled at a time.
    public struct LimitBehavior {

        /// The automatic limit behavior.
        ///
        /// By default, the behavior will be limited in compact horizontal
        /// size classes and will not be limited otherwise.
        public static var automatic: ViewAlignedScrollTargetBehavior.LimitBehavior { get }

        /// The always limit behavior.
        ///
        /// Always limit the amount of views that can be scrolled.
        public static var always: ViewAlignedScrollTargetBehavior.LimitBehavior { get }

        /// The always-by-few limit behavior.
        ///
        /// Limit the number of views that can be scrolled by a single
        /// interaction to a small number of views, rather than
        /// a single view at a time. The number of views is
        /// determined automatically.
        @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
        public static var alwaysByFew: ViewAlignedScrollTargetBehavior.LimitBehavior { get }

        /// The always-by-one limit behavior.
        ///
        /// Limit the number of views that can be scrolled by
        /// a single interaction to a single view.
        @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
        public static var alwaysByOne: ViewAlignedScrollTargetBehavior.LimitBehavior { get }

        /// The never limit behavior.
        ///
        /// Never limit the amount of views that can be scrolled.
        public static var never: ViewAlignedScrollTargetBehavior.LimitBehavior { get }
    }

    /// Creates a view aligned scroll behavior.
    public init(limitBehavior: ViewAlignedScrollTargetBehavior.LimitBehavior = .automatic)

    /// Updates the proposed target that a scrollable view should scroll to.
    ///
    /// The system calls this method in two main cases:
    /// - When a scroll gesture ends, it calculates where it would naturally
    ///   scroll to using its deceleration rate. The system
    ///   provides this calculated value as the target of this method.
    /// - When a scrollable view's size changes, it calculates where it should
    ///   be scrolled given the new size and provides this calculates value
    ///   as the target of this method.
    ///
    /// You can implement this method to override the calculated target
    /// which will have the scrollable view scroll to a different position
    /// than it would otherwise.
    public func updateTarget(_ target: inout ScrollTarget, context: ViewAlignedScrollTargetBehavior.TargetContext)
}

/// A view that adapts to the available space by providing the first
/// child view that fits.
///
/// `ViewThatFits` evaluates its child views in the order you provide them
/// to the initializer. It selects the first child whose ideal size on the
/// constrained axes fits within the proposed size. This means that you
/// provide views in order of preference. Usually this order is largest to
/// smallest, but since a view might fit along one constrained axis but not the
/// other, this isn't always the case. By default, `ViewThatFits` constrains
/// in both the horizontal and vertical axes.
///
/// The following example shows an `UploadProgressView` that uses `ViewThatFits`
/// to display the upload progress in one of three ways. In order, it attempts
/// to display:
///
/// * An ``HStack`` that contains a ``Text`` view and a ``ProgressView``.
/// * Only the `ProgressView`.
/// * Only the `Text` view.
///
/// The progress views are fixed to a 100-point width.
///
///     struct UploadProgressView: View {
///         var uploadProgress: Double
///
///         var body: some View {
///             ViewThatFits(in: .horizontal) {
///                 HStack {
///                     Text("\(uploadProgress.formatted(.percent))")
///                     ProgressView(value: uploadProgress)
///                         .frame(width: 100)
///                 }
///                 ProgressView(value: uploadProgress)
///                     .frame(width: 100)
///                 Text("\(uploadProgress.formatted(.percent))")
///             }
///         }
///     }
///
/// This use of `ViewThatFits` evaluates sizes only on the horizontal axis. The
/// following code fits the `UploadProgressView` to several fixed widths:
///
///     VStack {
///         UploadProgressView(uploadProgress: 0.75)
///             .frame(maxWidth: 200)
///         UploadProgressView(uploadProgress: 0.75)
///             .frame(maxWidth: 100)
///         UploadProgressView(uploadProgress: 0.75)
///             .frame(maxWidth: 50)
///     }
///
/// ![A vertical stack showing three expressions of progress, constrained by
/// the available horizontal space. The first line shows the text, 75%, and a
/// three-quarters-full progress bar. The second line shows only the progress
/// view. The third line shows only the text.](ViewThatFits-1)
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
@frozen public struct ViewThatFits<Content> : View where Content : View {

    /// Produces a view constrained in the given axes from one of several
    /// alternatives provided by a view builder.
    ///
    /// - Parameters:
    ///     - axes: A set of axes to constrain children to. The set may
    ///       contain ``Axis/horizontal``, ``Axis/vertical``, or both of these.
    ///       `ViewThatFits` chooses the first child whose size fits within the
    ///       proposed size on these axes. If `axes` is an empty set,
    ///       `ViewThatFits` uses the first child view. By default,
    ///       `ViewThatFits` uses both axes.
    ///     - content: A view builder that provides the child views for this
    ///       container, in order of preference. The builder chooses the first
    ///       child view that fits within the proposed width, height, or both,
    ///       as defined by `axes`.
    @inlinable public init(in axes: Axis.Set = [.horizontal, .vertical], @ViewBuilder content: () -> Content)

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
    public typealias Body = Never
}

/// The visibility of a UI element, chosen automatically based on
/// the platform, current context, and other factors.
///
/// For example, the preferred visibility of list row separators can be
/// configured using the ``View/listRowSeparator(_:edges:)``.
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
@frozen public enum Visibility : Hashable, CaseIterable {

    /// The element may be visible or hidden depending on the policies of the
    /// component accepting the visibility configuration.
    ///
    /// For example, some components employ different automatic behavior
    /// depending on factors including the platform, the surrounding container,
    /// user settings, etc.
    case automatic

    /// The element may be visible.
    ///
    /// Some APIs may use this value to represent a hint or preference, rather
    /// than a mandatory assertion. For example, setting list row separator
    /// visibility to `visible` using the
    /// ``View/listRowSeparator(_:edges:)`` modifier may not always
    /// result in any visible separators, especially for list styles that do not
    /// include separators as part of their design.
    case visible

    /// The element may be hidden.
    ///
    /// Some APIs may use this value to represent a hint or preference, rather
    /// than a mandatory assertion. For example, setting confirmation dialog
    /// title visibility to `hidden` using the
    /// ``View/confirmationDialog(_:isPresented:titleVisibility:actions:)``
    /// modifier may not always hide the dialog title, which is required on
    /// some platforms.
    case hidden

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: Visibility, b: Visibility) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// A type that can represent a collection of all values of this type.
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias AllCases = [Visibility]

    /// A collection of all values of this type.
    nonisolated public static var allCases: [Visibility] { get }

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension Visibility : Sendable {
}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension Visibility : BitwiseCopyable {
}

/// A date picker style that displays each component as columns in a scrollable
/// wheel.
///
/// You can also use ``DatePickerStyle/wheel`` to construct this style.
@available(iOS 13.0, watchOS 10.0, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
@MainActor @preconcurrency public struct WheelDatePickerStyle : DatePickerStyle {

    /// Creates an instance of the wheel date picker style.
    @MainActor @preconcurrency public init()

    /// Returns the appearance and interaction content for a `DatePicker`.
    ///
    /// The system calls this method for each ``DatePicker`` instance in a view
    /// hierarchy where this style is the current date picker style.
    ///
    /// - Parameter configuration : The properties of the date picker.
    @available(iOS 16.0, *)
    @MainActor @preconcurrency public func makeBody(configuration: WheelDatePickerStyle.Configuration) -> some View


    /// A view representing the appearance and interaction of a `DatePicker`.
    @available(iOS 13.0, watchOS 10.0, *)
    @available(tvOS, unavailable)
    @available(macOS, unavailable)
    public typealias Body = some View
}

/// A picker style that presents the options in a scrollable wheel that shows
/// the selected option and a few neighboring options.
///
/// You can also use ``PickerStyle/wheel`` to construct this style.
@available(iOS 13.0, watchOS 6.0, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
public struct WheelPickerStyle : PickerStyle {

    /// Sets the picker style to display an item wheel from which the user makes
    /// a selection.
    public init()
}

/// The configuration and content of a widget to display on the Home screen or
/// in Notification Center.
///
/// Widgets show glanceable and relevant content from your app right on the iOS
/// Home screen or in Notification Center on macOS. Users can add, configure, and
/// arrange widgets to suit their individual needs. You can provide multiple
/// types of widgets, each presenting a specific kind of information. When
/// users want more information, like to read the full article for a headline
/// or to see the details of a package delivery, the widget lets them get to
/// the information in your app quickly.
///
/// There are three key components to a widget:
///
/// * A configuration that determines whether the widget is configurable,
///   identifies the widget, and defines the SwiftUI views that show the
///   widget's content.
/// * A timeline provider that drives the process of updating the widget's view
///   over time.
/// * SwiftUI views used by WidgetKit to display the widget.
///
/// For information about adding a widget extension to your app, and keeping
/// your widget up to date, see
/// <doc://com.apple.documentation/documentation/WidgetKit/Creating-a-Widget-Extension>
/// and
/// <doc://com.apple.documentation/documentation/WidgetKit/Keeping-a-Widget-Up-To-Date>,
/// respectively.
///
/// By adding a custom SiriKit intent definition, you can let users customize
/// their widgets to show the information that's most relevant to them. If
/// you've already added support for Siri or Shortcuts, you're well on your way
/// to supporting customizable widgets. For more information, see
/// <doc://com.apple.documentation/documentation/WidgetKit/Making-a-Configurable-Widget>.
@available(iOS 14.0, macOS 11.0, watchOS 9.0, *)
@available(tvOS, unavailable)
@MainActor @preconcurrency public protocol Widget {

    /// The type of configuration representing the content of the widget.
    ///
    /// When you create a custom widget, Swift infers this type from your
    /// implementation of the required ``Widget/body-swift.property`` property.
    associatedtype Body : WidgetConfiguration

    /// Creates a widget using `body` as its content.
    @MainActor @preconcurrency init()

    /// The content and behavior of the widget.
    ///
    /// For any widgets that you create, provide a computed `body` property that
    /// defines the widget as a composition of SwiftUI views.
    ///
    /// Swift infers the widget's ``SwiftUI/Scene/Body-swift.associatedtype``
    /// associated type based on the contents of the `body` property.
    @MainActor @preconcurrency var body: Self.Body { get }
}

/// A container used to expose multiple widgets from a single widget extension.
///
/// To support multiple types of widgets, add the `@main` attribute to a
/// structure that conforms to `WidgetBundle`. For example, a game might have
/// one widget to display summary information about the game and a second
/// widget to display detailed information about individual characters.
///
///     @main
///     struct GameWidgets: WidgetBundle {
///        var body: some Widget {
///            GameStatusWidget()
///            CharacterDetailWidget()
///        }
///     }
///
@available(iOS 14.0, macOS 11.0, watchOS 9.0, *)
@available(tvOS, unavailable)
@MainActor @preconcurrency public protocol WidgetBundle {

    /// The type of widget that represents the content of the bundle.
    ///
    /// When you support more than one widget, Swift infers this type from your
    /// implementation of the required ``WidgetBundle/body-swift.property``
    /// property.
    associatedtype Body : Widget

    /// Creates a widget bundle using the bundle's body as its content.
    @MainActor @preconcurrency init()

    /// Declares the group of widgets that an app supports.
    ///
    /// The order that the widgets appear in this property determines the order
    /// they are shown to the user when adding a widget. The following example
    /// shows how to use a widget bundle builder to define a body showing
    /// a game status widget first and a character detail widget second:
    ///
    ///     @main
    ///     struct GameWidgets: WidgetBundle {
    ///        var body: some Widget {
    ///            GameStatusWidget()
    ///            CharacterDetailWidget()
    ///        }
    ///     }
    ///
    @WidgetBundleBuilder @MainActor @preconcurrency var body: Self.Body { get }
}

/// A custom attribute that constructs a widget bundle's body.
///
/// Use the `@WidgetBundleBuilder` attribute to group multiple widgets listed
/// in the ``WidgetBundle/body-swift.property`` property of a widget bundle.
/// For example, the following code defines a widget bundle that consists of
/// two widgets.
///
///     @main
///     struct GameWidgets: WidgetBundle {
///        @WidgetBundleBuilder
///        var body: some Widget {
///            GameStatusWidget()
///            CharacterDetailWidget()
///        }
///     }
@available(iOS 14.0, macOS 11.0, watchOS 9.0, *)
@available(tvOS, unavailable)
@resultBuilder public struct WidgetBundleBuilder {

    /// Builds an expression within the builder.
    public static func buildExpression<Content>(_ content: Content) -> Content where Content : Widget

    /// Builds an empty Widget from a block containing no statements, `{ }`.
    public static func buildBlock() -> some Widget


    /// Builds a single Widget written as a child view (e..g, `{ MyWidget() }`)
    /// through unmodified.
    public static func buildBlock<Content>(_ content: Content) -> some Widget where Content : Widget


    public static func buildBlock<each C>(_ c: repeat each C) -> some Widget where repeat each C : Widget

}

@available(iOS 14.0, macOS 11.0, watchOS 9.0, *)
@available(tvOS, unavailable)
extension WidgetBundleBuilder {

    /// Produces an optional widget for conditional statements in multi-statement
    /// closures that's only visible when the condition evaluates to true.
    ///
    /// Conditional statements in a ``WidgetBundleBuilder`` can contain an `if`
    /// statement but not an `else` statement, and the condition can only
    /// perform a compiler check for availability, like in the following code:
    ///
    ///     var body: some Widget {
    ///         if #available(iOS 16, *) {
    ///             WindowGroup {
    ///                 ContentView()
    ///             }
    ///         }
    ///     }
    public static func buildOptional(_ widget: (any Widget & _LimitedAvailabilityWidgetMarker)?) -> some Widget


    /// Processes widget content for a conditional compiler-control
    /// statement that performs an availability check.
    @available(iOS 16.1, macOS 13.0, watchOS 9.1, *)
    public static func buildLimitedAvailability(_ widget: some Widget) -> any Widget & _LimitedAvailabilityWidgetMarker
}

@available(iOS 18.0, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@available(visionOS, unavailable)
extension WidgetBundleBuilder {

    /// Builds an expression within the builder.
    public static func buildExpression<Content>(_ content: Content) -> some Widget where Content : ControlWidget


    /// Builds an availability check within the builder
    public static func buildLimitedAvailability(_ widget: some ControlWidget) -> any Widget & _LimitedAvailabilityWidgetMarker
}

/// A type that describes a widget's content.
@available(iOS 14.0, macOS 11.0, watchOS 9.0, *)
@available(tvOS, unavailable)
@MainActor @preconcurrency public protocol WidgetConfiguration {

    /// The type of widget configuration representing the body of
    /// this configuration.
    ///
    /// When you create a custom widget, Swift infers this type from your
    /// implementation of the required `body` property.
    associatedtype Body : WidgetConfiguration

    /// The content and behavior of this widget.
    @MainActor @preconcurrency var body: Self.Body { get }
}

@available(iOS 16.0, macOS 13.0, watchOS 9.0, *)
@available(tvOS, unavailable)
extension WidgetConfiguration {

    /// Runs the given action when the system provides a background task.
    ///
    /// When the system wakes your app or extension for one or more background
    /// tasks, it will call any actions associated with matching tasks. When your
    /// async actions return, the system will put your app back into a suspended
    /// state. In Widget Extensions, this modifier can be used to handle URL Session
    /// background tasks with ``BackgroundTask/urlSession``.
    ///
    /// - Parameters:
    ///    - task: The type of task the action responds to.
    ///    - action: The closure that is called when the system provides
    ///      a task matching the provided task.
    nonisolated public func backgroundTask<D, R>(_ task: BackgroundTask<D, R>, action: @escaping @Sendable (D) async -> R) -> some WidgetConfiguration where D : Sendable, R : Sendable

}

/// A style appropriate for elements that should match the background
/// of their containing window.
@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
@available(visionOS, unavailable)
public struct WindowBackgroundShapeStyle : ShapeStyle {

    /// Creates a new window background shape style instance.
    public init()

    /// The type of shape style this will resolve to.
    ///
    /// When you create a custom shape style, Swift infers this type
    /// from your implementation of the required `resolve` function.
    @available(iOS 17.0, tvOS 17.0, watchOS 10.0, macOS 14.0, *)
    @available(visionOS, unavailable)
    public typealias Resolved = Never
}

/// A scene that presents a group of identically structured windows.
///
/// Use a `WindowGroup` as a container for a view hierarchy that your app
/// presents. The hierarchy that you declare as the group's content serves as a
/// template for each window that the app creates from that group:
///
///     @main
///     struct Mail: App {
///         var body: some Scene {
///             WindowGroup {
///                 MailViewer() // Define a view hierarchy for the window.
///             }
///         }
///     }
///
/// SwiftUI takes care of certain platform-specific behaviors. For example,
/// on platforms that support it, like macOS and iPadOS, people can open more
/// than one window from the group simultaneously. In macOS, people
/// can gather open windows together in a tabbed interface. Also in macOS,
/// window groups automatically provide commands for standard window
/// management.
///
/// > Important: To enable an iPadOS app to simultaneously display multiple
/// windows, be sure to include the
/// <doc://com.apple.documentation/documentation/bundleresources/information_property_list/uiapplicationscenemanifest/uiapplicationsupportsmultiplescenes>
/// key with a value of `true` in the
/// <doc://com.apple.documentation/documentation/bundleresources/information_property_list/uiapplicationscenemanifest>
/// dictionary of your app's Information Property List.
///
/// Every window in the group maintains independent state. For example, the
/// system allocates new storage for any ``State`` or ``StateObject`` variables
/// instantiated by the scene's view hierarchy for each window that it creates.
///
/// For document-based apps, use ``DocumentGroup`` to define windows instead.
///
/// ### Open windows programmatically
///
/// If you initialize a window group with an identifier, a presentation type,
/// or both, you can programmatically open a window from the group. For example,
/// you can give the mail viewer scene from the previous example an identifier:
///
///     WindowGroup(id: "mail-viewer") { // Identify the window group.
///         MailViewer()
///     }
///
/// Elsewhere in your code, you can use the ``EnvironmentValues/openWindow``
/// action from the environment to create a new window from the group:
///
///     struct NewViewerButton: View {
///         @Environment(\.openWindow) private var openWindow
///
///         var body: some View {
///             Button("Open new mail viewer") {
///                 openWindow(id: "mail-viewer") // Match the group's identifier.
///             }
///         }
///     }
///
/// Be sure to use unique strings for identifiers that you apply to window
/// groups in your app.
///
/// ### Present data in a window
///
/// If you initialize a window group with a presentation type, you can pass
/// data of that type to the window when you open it. For example, you can
/// define a second window group for the Mail app that displays a specified
/// message:
///
///     @main
///     struct Mail: App {
///         var body: some Scene {
///             WindowGroup {
///                 MailViewer(id: "mail-viewer")
///             }
///
///             // A window group that displays messages.
///             WindowGroup(for: Message.ID.self) { $messageID in
///                 MessageDetail(messageID: messageID)
///             }
///         }
///     }
///
/// When you call the ``EnvironmentValues/openWindow`` action with a
/// value, SwiftUI finds the window group with the matching type
/// and passes a binding to the value into the window group's content closure.
/// For example, you can define a button that opens a message by passing
/// the message's identifier:
///
///     struct NewMessageButton: View {
///         var message: Message
///         @Environment(\.openWindow) private var openWindow
///
///         var body: some View {
///             Button("Open message") {
///                 openWindow(value: message.id)
///             }
///         }
///     }
///
/// Be sure that the type you present conforms to both the
/// <doc://com.apple.documentation/documentation/Swift/Hashable>
/// and <doc://com.apple.documentation/documentation/Swift/Codable> protocols.
/// Also, prefer lightweight data for the presentation value.
/// For model values that conform to the
/// <doc://com.apple.documentation/documentation/Swift/Identifiable> protocol,
/// the value's identifier works well as a presentation type, as the above
/// example demonstrates.
///
/// If a window with a binding to the same value that you pass to the
/// `openWindow` action already appears in the user interface, the system
/// brings the existing window to the front rather than opening a new window.
/// If SwiftUI doesn't have a value to provide --- for example, when someone
/// opens a window by choosing File > New Window from the macOS menu bar ---
/// SwiftUI passes a binding to a `nil` value instead. To avoid receiving a
/// `nil` value, you can optionally specify a default value in your window
/// group initializer. For example, for the message viewer, you can present
/// a new empty message:
///
///     WindowGroup(for: Message.ID.self) { $messageID in
///         MessageDetail(messageID: messageID)
///     } defaultValue: {
///         model.makeNewMessage().id // A new message that your model stores.
///     }
///
/// SwiftUI persists the value of the binding for the purposes of state
/// restoration, and reapplies the same value when restoring the window. If the
/// restoration process results in an error, SwiftUI sets the binding to the
/// default value if you provide one, or `nil` otherwise.
///
/// ### Title your app's windows
///
/// To help people distinguish among windows from different groups,
/// include a title as the first parameter in the group's initializer:
///
///     WindowGroup("Message", for: Message.ID.self) { $messageID in
///         MessageDetail(messageID: messageID)
///     }
///
/// SwiftUI uses this title when referring to the window in:
///
/// * The list of new windows that someone can open using the File > New menu.
/// * The window's title bar.
/// * The list of open windows that the Window menu displays.
///
/// If you don't provide a title for a window, the system refers to the window
/// using the app's name instead.
///
/// > Note: You can override the title that SwiftUI uses for a window in the
///   window's title bar and the menu's list of open windows by adding one of
///   the ``View/navigationTitle(_:)`` modifiers to the window's content.
///   This enables you to customize and dynamically update the title for each
///   individual window instance.
///
/// ### Distinguish windows that present like data
///
/// To programmatically distinguish between windows that present the same type
/// of data, like when you use a
/// <doc://com.apple.documentation/documentation/Foundation/UUID>
/// as the identifier for more than one model type, add the `id` parameter
/// to the group's initializer to provide a unique string identifier:
///
///     WindowGroup("Message", id: "message", for: UUID.self) { $uuid in
///         MessageDetail(uuid: uuid)
///     }
///     WindowGroup("Account", id: "account-info", for: UUID.self) { $uuid in
///         AccountDetail(uuid: uuid)
///     }
///
/// Then use both the identifer and a value to open the window:
///
///     struct ActionButtons: View {
///         var messageID: UUID
///         var accountID: UUID
///
///         @Environment(\.openWindow) private var openWindow
///
///         var body: some View {
///             HStack {
///                 Button("Open message") {
///                     openWindow(id: "message", value: messageID)
///                 }
///                 Button("Edit account information") {
///                     openWindow(id: "account-info", value: accountID)
///                 }
///             }
///         }
///     }
///
/// ### Dismiss a window programmatically
///
/// The system provides people with platform-appropriate controls to dismiss a
/// window. You can also dismiss windows programmatically by calling the
/// ``EnvironmentValues/dismiss`` action from within the window's view
/// hierarchy. For example, you can include a button in the account detail
/// view from the previous example that dismisses the view:
///
///     struct AccountDetail: View {
///         var uuid: UUID?
///         @Environment(\.dismiss) private var dismiss
///
///         var body: some View {
///             VStack {
///                 // ...
///
///                 Button("Dismiss") {
///                     dismiss()
///                 }
///             }
///         }
///     }
///
/// The dismiss action doesn't close the window if you call it from a
/// modal --- like a sheet or a popover --- that you present
/// from the window. In that case, the action dismisses the modal presentation
/// instead.
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public struct WindowGroup<Content> : Scene where Content : View {

    /// Creates a window group with an identifier.
    ///
    /// The window group uses the given view as a
    /// template to form the content of each window in the group.
    ///
    /// - Parameters:
    ///   - id: A string that uniquely identifies the window group. Identifiers
    ///     must be unique among the window groups in your app.
    ///   - content: A closure that creates the content for each instance
    ///     of the group.
    @available(iOS, introduced: 14.0, deprecated: 18.0, renamed: "init(id:makeContent:)", message: "Use the initializer which takes an escaping view builder instead.")
    @available(macOS, introduced: 11.0, deprecated: 15.0, renamed: "init(id:makeContent:)", message: "Use the initializer which takes an escaping view builder instead.")
    @available(tvOS, introduced: 14.0, deprecated: 18.0, renamed: "init(id:makeContent:)", message: "Use the initializer which takes an escaping view builder instead.")
    @available(watchOS, introduced: 7.0, deprecated: 11.0, renamed: "init(id:makeContent:)", message: "Use the initializer which takes an escaping view builder instead.")
    @available(visionOS, introduced: 1.0, deprecated: 2.0, renamed: "init(id:makeContent:)", message: "Use the initializer which takes an escaping view builder instead.")
    public init(id: String, @ViewBuilder content: () -> Content)

    /// Creates a window group with a text view title and an identifier.
    ///
    /// The window group uses the specified content as a
    /// template to create each window in the group.
    /// The system uses the title to distinguish the window group in the user
    /// interface, such as in the name of commands associated with the group.
    ///
    /// > Important: The system ignores any text styling that you apply to
    ///   the ``Text`` view title, like bold or italics. However, you can use
    ///   the formatting controls that the view offers, like for localization,
    ///   dates, and numerical representations.
    ///
    /// - Parameters:
    ///   - title: The ``Text`` view to use for the group's title.
    ///   - id: A string that uniquely identifies the window group. Identifiers
    ///     must be unique among the window groups in your app.
    ///   - content: A closure that creates the content for each instance
    ///     of the group.
    @available(iOS, introduced: 14.0, deprecated: 18.0, renamed: "init(_:id:makeContent:)", message: "Use the initializer which takes an escaping view builder instead.")
    @available(macOS, introduced: 11.0, deprecated: 15.0, renamed: "init(_:id:makeContent:)", message: "Use the initializer which takes an escaping view builder instead.")
    @available(tvOS, introduced: 14.0, deprecated: 18.0, renamed: "init(_:id:makeContent:)", message: "Use the initializer which takes an escaping view builder instead.")
    @available(watchOS, introduced: 7.0, deprecated: 11.0, renamed: "init(_:id:makeContent:)", message: "Use the initializer which takes an escaping view builder instead.")
    @available(visionOS, introduced: 1.0, deprecated: 2.0, renamed: "init(_:id:makeContent:)")
    public init(_ title: Text, id: String, @ViewBuilder content: () -> Content)

    /// Creates a window group with a localized title string and an
    /// identifier.
    ///
    /// The window group uses the specified content as a
    /// template to create each window in the group.
    /// The system uses the title to distinguish the window group in the user
    /// interface, such as in the name of commands associated with the group.
    ///
    /// - Parameters:
    ///   - titleKey: The title key to use for the title of the group.
    ///   - id: A string that uniquely identifies the window group. Identifiers
    ///     must be unique among the window groups in your app.
    ///   - content: A closure that creates the content for each instance
    ///     of the group.
    @available(iOS, introduced: 14.0, deprecated: 18.0, renamed: "init(_:id:makeContent:)", message: "Use the initializer which takes an escaping view builder instead.")
    @available(macOS, introduced: 11.0, deprecated: 15.0, renamed: "init(_:id:makeContent:)", message: "Use the initializer which takes an escaping view builder instead.")
    @available(tvOS, introduced: 14.0, deprecated: 18.0, renamed: "init(_:id:makeContent:)", message: "Use the initializer which takes an escaping view builder instead.")
    @available(watchOS, introduced: 7.0, deprecated: 11.0, renamed: "init(_:id:makeContent:)", message: "Use the initializer which takes an escaping view builder instead.")
    @available(visionOS, introduced: 1.0, deprecated: 2.0, renamed: "init(_:id:makeContent:)", message: "Use the initializer which takes an escaping view builder instead.")
    public init(_ titleKey: LocalizedStringKey, id: String, @ViewBuilder content: () -> Content)

    /// Creates a window group with a title string and an identifier.
    ///
    /// The window group uses the specified content as a
    /// template to create each window in the group.
    /// The system uses the title to distinguish the window group in the user
    /// interface, such as in the name of commands associated with the group.
    ///
    /// - Parameters:
    ///   - title: The string to use for the title of the group.
    ///   - id: A string that uniquely identifies the window group. Identifiers
    ///     must be unique among the window groups in your app.
    ///   - content: A closure that creates the content for each instance
    ///     of the group.
    @available(iOS, introduced: 14.0, deprecated: 18.0, renamed: "init(_:id:makeContent:)", message: "Use the initializer which takes an escaping view builder instead.")
    @available(macOS, introduced: 11.0, deprecated: 15.0, renamed: "init(_:id:makeContent:)", message: "Use the initializer which takes an escaping view builder instead.")
    @available(tvOS, introduced: 14.0, deprecated: 18.0, renamed: "init(_:id:makeContent:)", message: "Use the initializer which takes an escaping view builder instead.")
    @available(watchOS, introduced: 7.0, deprecated: 11.0, renamed: "init(_:id:makeContent:)", message: "Use the initializer which takes an escaping view builder instead.")
    @available(visionOS, introduced: 1.0, deprecated: 2.0, renamed: "init(_:id:makeContent:)")
    public init<S>(_ title: S, id: String, @ViewBuilder content: () -> Content) where S : StringProtocol

    /// Creates a window group.
    ///
    /// The window group uses the given view as a template to form the
    /// content of each window in the group.
    ///
    /// - Parameter content: A closure that creates the content for each
    ///   instance of the group.
    @available(iOS, introduced: 14.0, deprecated: 18.0, renamed: "init(makeContent:)", message: "Use the initializer which takes an escaping view builder instead.")
    @available(macOS, introduced: 11.0, deprecated: 15.0, renamed: "init(makeContent:)", message: "Use the initializer which takes an escaping view builder instead.")
    @available(tvOS, introduced: 14.0, deprecated: 18.0, renamed: "init(makeContent:)", message: "Use the initializer which takes an escaping view builder instead.")
    @available(watchOS, introduced: 7.0, deprecated: 11.0, renamed: "init(makeContent:)", message: "Use the initializer which takes an escaping view builder instead.")
    @available(visionOS, introduced: 1.0, deprecated: 2.0, renamed: "init(makeContent:)")
    public init(@ViewBuilder content: () -> Content)

    /// Creates a window group with a text view title.
    ///
    /// The window group uses the given view as a
    /// template to form the content of each window in the group.
    /// The system uses the title to distinguish the window group in the user
    /// interface, such as in the name of commands associated with the group.
    ///
    /// > Important: The system ignores any text styling that you apply to
    ///   the ``Text`` view title, like bold or italics. However, you can use
    ///   the formatting controls that the view offers, like for localization,
    ///   dates, and numerical representations.
    ///
    /// - Parameters:
    ///   - title: The ``Text`` view to use for the group's title.
    ///   - content: A closure that creates the content for each instance
    ///     of the group.
    @available(iOS, introduced: 14.0, deprecated: 18.0, renamed: "init(_:makeContent:)", message: "Use the initializer which takes an escaping view builder instead.")
    @available(macOS, introduced: 11.0, deprecated: 15.0, renamed: "init(_:makeContent:)", message: "Use the initializer which takes an escaping view builder instead.")
    @available(tvOS, introduced: 14.0, deprecated: 18.0, renamed: "init(_:makeContent:)", message: "Use the initializer which takes an escaping view builder instead.")
    @available(watchOS, introduced: 7.0, deprecated: 11.0, renamed: "init(_:makeContent:)", message: "Use the initializer which takes an escaping view builder instead.")
    @available(visionOS, introduced: 1.0, deprecated: 2.0, renamed: "init(_:makeContent:)", message: "Use the initializer which takes an escaping view builder instead.")
    public init(_ title: Text, @ViewBuilder content: () -> Content)

    /// Creates a window group with a localized title string.
    ///
    /// The window group uses the specified content as a
    /// template to create each window in the group.
    /// The system uses the title to distinguish the window group in the user
    /// interface, such as in the name of commands associated with the group.
    ///
    /// - Parameters:
    ///   - titleKey: The title key to use for the group's title.
    ///   - content: A closure that creates the content for each instance
    ///     of the group.
    @available(iOS, introduced: 14.0, deprecated: 18.0, renamed: "init(_:makeContent:)", message: "Use the initializer which takes an escaping view builder instead.")
    @available(macOS, introduced: 11.0, deprecated: 15.0, renamed: "init(_:makeContent:)", message: "Use the initializer which takes an escaping view builder instead.")
    @available(tvOS, introduced: 14.0, deprecated: 18.0, renamed: "init(_:makeContent:)", message: "Use the initializer which takes an escaping view builder instead.")
    @available(watchOS, introduced: 7.0, deprecated: 11.0, renamed: "init(_:makeContent:)", message: "Use the initializer which takes an escaping view builder instead.")
    @available(visionOS, introduced: 1.0, deprecated: 2.0, renamed: "init(_:makeContent:)", message: "Use the initializer which takes an escaping view builder instead.")
    public init(_ titleKey: LocalizedStringKey, @ViewBuilder content: () -> Content)

    /// Creates a window group with a title string.
    ///
    /// The window group uses the specified content as a
    /// template to create each window in the group.
    /// The system uses the title to distinguish the window group in the user
    /// interface, such as in the name of commands associated with the group.
    ///
    /// - Parameters:
    ///   - title: The string to use for the title of the group.
    ///   - content: A closure that creates the content for each instance
    ///     of the group.
    @available(iOS, introduced: 14.0, deprecated: 18.0, renamed: "init(_:makeContent:)", message: "Use the initializer which takes an escaping view builder instead.")
    @available(macOS, introduced: 11.0, deprecated: 15.0, renamed: "init(_:makeContent:)", message: "Use the initializer which takes an escaping view builder instead.")
    @available(tvOS, introduced: 14.0, deprecated: 18.0, renamed: "init(_:makeContent:)", message: "Use the initializer which takes an escaping view builder instead.")
    @available(watchOS, introduced: 7.0, deprecated: 11.0, renamed: "init(_:makeContent:)", message: "Use the initializer which takes an escaping view builder instead.")
    @available(visionOS, introduced: 1.0, deprecated: 2.0, renamed: "init(_:makeContent:)", message: "Use the initializer which takes an escaping view builder instead.")
    public init<S>(_ title: S, @ViewBuilder content: () -> Content) where S : StringProtocol

    /// The content and behavior of the scene.
    ///
    /// For any scene that you create, provide a computed `body` property that
    /// defines the scene as a composition of other scenes. You can assemble a
    /// scene from built-in scenes that SwiftUI provides, as well as other
    /// scenes that you've defined.
    ///
    /// Swift infers the scene's ``SwiftUI/Scene/Body-swift.associatedtype``
    /// associated type based on the contents of the `body` property.
    @MainActor @preconcurrency public var body: some Scene { get }

    /// The type of scene that represents the body of this scene.
    ///
    /// When you create a custom scene, Swift infers this type from your
    /// implementation of the required ``SwiftUI/Scene/body-swift.property``
    /// property.
    @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
    public typealias Body = some Scene
}

@available(iOS 16.0, macOS 13.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension WindowGroup {

    /// Creates a data-presenting window group with an identifier.
    ///
    /// The window group uses the specified content as a
    /// template to create each window in the group.
    ///
    /// SwiftUI creates a window from the group when you present a value
    /// of the specified type using the ``EnvironmentValues/openWindow`` action.
    ///
    /// - Parameters:
    ///   - id: A string that uniquely identifies the window group. Identifiers
    ///     must be unique among the window groups in your app.
    ///   - type: The type of presented data this window group accepts.
    ///   - content: A closure that creates the content for each instance
    ///     of the group. The closure receives a binding to the value that you
    ///     pass into the ``EnvironmentValues/openWindow`` action when you open
    ///     the window. SwiftUI automatically persists and restores the value
    ///     of this binding as part of the state restoration process.
    nonisolated public init<D, C>(id: String, for type: D.Type, @ViewBuilder content: @escaping (Binding<D?>) -> C) where Content == PresentedWindowContent<D, C>, D : Decodable, D : Encodable, D : Hashable, C : View

    /// Creates a data-presenting window group with a text view title and an
    /// identifier.
    ///
    /// The window group uses the specified content as a
    /// template to create each window in the group.
    ///
    /// The system uses the title to distinguish the window group in the user
    /// interface, such as in the name of commands associated with the group.
    ///
    /// > Important: The system ignores any text styling that you apply to
    ///   the ``Text`` view title, like bold or italics. However, you can use
    ///   the formatting controls that the view offers, like for localization,
    ///   dates, and numerical representations.
    ///
    /// SwiftUI creates a window from the group when you present a value
    /// of the specified type using the ``EnvironmentValues/openWindow`` action.
    ///
    /// - Parameters:
    ///   - title: The ``Text`` view to use for the group's title.
    ///   - id: A string that uniquely identifies the window group. Identifiers
    ///     must be unique among the window groups in your app.
    ///   - type: The type of presented data this window group accepts.
    ///   - content: A closure that creates the content for each instance
    ///     of the group. The closure receives a binding to the value that you
    ///     pass into the ``EnvironmentValues/openWindow`` action when you open
    ///     the window. SwiftUI automatically persists and restores the value
    ///     of this binding as part of the state restoration process.
    nonisolated public init<D, C>(_ title: Text, id: String, for type: D.Type, @ViewBuilder content: @escaping (Binding<D?>) -> C) where Content == PresentedWindowContent<D, C>, D : Decodable, D : Encodable, D : Hashable, C : View

    /// Creates a data-presenting window group with a localized title
    /// string and an identifier.
    ///
    /// The window group uses the specified content as a
    /// template to create each window in the group.
    ///
    /// The system uses the title to distinguish the window group in the user
    /// interface, such as in the name of commands associated with the group.
    ///
    /// SwiftUI creates a window from the group when you present a value
    /// of the specified type using the ``EnvironmentValues/openWindow`` action.
    ///
    /// - Parameters:
    ///   - titleKey: The title key to use for the group's title.
    ///   - id: A string that uniquely identifies the window group. Identifiers
    ///     must be unique among the window groups in your app.
    ///   - type: The type of presented data this window group accepts.
    ///   - content: A closure that creates the content for each instance
    ///     of the group. The closure receives a binding to the value that you
    ///     pass into the ``EnvironmentValues/openWindow`` action when you open
    ///     the window. SwiftUI automatically persists and restores the value
    ///     of this binding as part of the state restoration process.
    nonisolated public init<D, C>(_ titleKey: LocalizedStringKey, id: String, for type: D.Type, @ViewBuilder content: @escaping (Binding<D?>) -> C) where Content == PresentedWindowContent<D, C>, D : Decodable, D : Encodable, D : Hashable, C : View

    /// Creates a data-presenting window group with a title string and an
    /// identifier.
    ///
    /// The window group uses the specified content as a
    /// template to create each window in the group.
    ///
    /// The system uses the title to distinguish the window group in the user
    /// interface, such as in the name of commands associated with the group.
    ///
    /// SwiftUI creates a window from the group when you present a value
    /// of the specified type using the ``EnvironmentValues/openWindow`` action.
    ///
    /// - Parameters:
    ///   - title: The string to use for the title of the group.
    ///   - id: A string that uniquely identifies the window group. Identifiers
    ///     must be unique among the window groups in your app.
    ///   - type: The type of presented data this window group accepts.
    ///   - content: A closure that creates the content for each instance
    ///     of the group. The closure receives a binding to the value that you
    ///     pass into the ``EnvironmentValues/openWindow`` action when you open
    ///     the window. SwiftUI automatically persists and restores the value
    ///     of this binding as part of the state restoration process.
    nonisolated public init<S, D, C>(_ title: S, id: String, for type: D.Type, @ViewBuilder content: @escaping (Binding<D?>) -> C) where Content == PresentedWindowContent<D, C>, S : StringProtocol, D : Decodable, D : Encodable, D : Hashable, C : View

    /// Creates a data-presenting window group.
    ///
    /// The window group uses the given view as a template to form the
    /// content of each window in the group.
    ///
    /// SwiftUI creates a window from the group when you present a value
    /// of the specified type using the ``EnvironmentValues/openWindow`` action.
    ///
    /// - Parameters:
    ///   - type: The type of presented data this window group accepts.
    ///   - content: A closure that creates the content for each instance
    ///     of the group. The closure receives a binding to the value that you
    ///     pass into the ``EnvironmentValues/openWindow`` action when you open
    ///     the window. SwiftUI automatically persists and restores the value
    ///     of this binding as part of the state restoration process.
    nonisolated public init<D, C>(for type: D.Type, @ViewBuilder content: @escaping (Binding<D?>) -> C) where Content == PresentedWindowContent<D, C>, D : Decodable, D : Encodable, D : Hashable, C : View

    /// Creates a data-presenting window group with a text view title.
    ///
    /// The window group uses the given view as a
    /// template to form the content of each window in the group.
    ///
    /// The system uses the title to distinguish the window group in the user
    /// interface, such as in the name of commands associated with the group.
    ///
    /// > Important: The system ignores any text styling that you apply to
    ///   the ``Text`` view title, like bold or italics. However, you can use
    ///   the formatting controls that the view offers, like for localization,
    ///   dates, and numerical representations.
    ///
    /// SwiftUI creates a window from the group when you present a value
    /// of the specified type using the ``EnvironmentValues/openWindow`` action.
    ///
    /// - Parameters:
    ///   - title: The ``Text`` view to use for the group's title.
    ///   - type: The type of presented data this window group accepts.
    ///   - content: A closure that creates the content for each instance
    ///     of the group. The closure receives a binding to the value that you
    ///     pass into the ``EnvironmentValues/openWindow`` action when you open
    ///     the window. SwiftUI automatically persists and restores the value
    ///     of this binding as part of the state restoration process.
    nonisolated public init<D, C>(_ title: Text, for type: D.Type, @ViewBuilder content: @escaping (Binding<D?>) -> C) where Content == PresentedWindowContent<D, C>, D : Decodable, D : Encodable, D : Hashable, C : View

    /// Creates a data-presenting window group with a localized title
    /// string.
    ///
    /// The window group uses the specified content as a
    /// template to create each window in the group.
    ///
    /// The system uses the title to distinguish the window group in the user
    /// interface, such as in the name of commands associated with the group.
    ///
    /// SwiftUI creates a window from the group when you present a value
    /// of the specified type using the ``EnvironmentValues/openWindow`` action.
    ///
    /// - Parameters:
    ///   - titleKey: The title key to use for the group's title.
    ///   - type: The type of presented data this window group accepts.
    ///   - content: A closure that creates the content for each instance
    ///     of the group. The closure receives a binding to the value that you
    ///     pass into the ``EnvironmentValues/openWindow`` action when you open
    ///     the window. SwiftUI automatically persists and restores the value
    ///     of this binding as part of the state restoration process.
    nonisolated public init<D, C>(_ titleKey: LocalizedStringKey, for type: D.Type, @ViewBuilder content: @escaping (Binding<D?>) -> C) where Content == PresentedWindowContent<D, C>, D : Decodable, D : Encodable, D : Hashable, C : View

    /// Creates a data-presenting window group with a title string.
    ///
    /// The window group uses the specified content as a
    /// template to create each window in the group.
    ///
    /// The system uses the title to distinguish the window group in the user
    /// interface, such as in the name of commands associated with the group.
    ///
    /// SwiftUI creates a window from the group when you present a value
    /// of the specified type using the ``EnvironmentValues/openWindow`` action.
    ///
    /// - Parameters:
    ///   - title: The string to use for the title of the group.
    ///   - type: The type of presented data this window group accepts.
    ///   - content: A closure that creates the content for each instance
    ///     of the group. The closure receives a binding to the value that you
    ///     pass into the ``EnvironmentValues/openWindow`` action when you open
    ///     the window. SwiftUI automatically persists and restores the value
    ///     of this binding as part of the state restoration process.
    nonisolated public init<S, D, C>(_ title: S, for type: D.Type, @ViewBuilder content: @escaping (Binding<D?>) -> C) where Content == PresentedWindowContent<D, C>, S : StringProtocol, D : Decodable, D : Encodable, D : Hashable, C : View

    /// Creates a data-presenting window group with an identifier and a default
    /// value.
    ///
    /// The window group uses the given view as a
    /// template to form the content of each window in the group.
    ///
    /// SwiftUI creates a window from the group when you present a value
    /// of the specified type using the ``EnvironmentValues/openWindow`` action.
    ///
    /// - Parameters:
    ///   - id: A string that uniquely identifies the window group. Identifiers
    ///     must be unique among the window groups in your app.
    ///   - type: The type of presented data this window group accepts.
    ///   - content: A closure that creates the content for each instance
    ///     of the group. The closure receives a binding to the value that you
    ///     pass into the ``EnvironmentValues/openWindow`` action when you open
    ///     the window. SwiftUI automatically persists and restores the value
    ///     of this binding as part of the state restoration process.
    ///   - defaultValue: A closure that returns a default value to present.
    ///     SwiftUI calls this closure when it has no data to provide, like
    ///     when someone opens a new window from the File > New Window menu
    ///     item.
    nonisolated public init<D, C>(id: String, for type: D.Type = D.self, @ViewBuilder content: @escaping (Binding<D>) -> C, defaultValue: @escaping () -> D) where Content == PresentedWindowContent<D, C>, D : Decodable, D : Encodable, D : Hashable, C : View

    /// Creates a data-presenting window group with a text view title, an
    /// identifier, and a default value.
    ///
    /// The window group uses the specified content as a
    /// template to create each window in the group.
    ///
    /// The system uses the title to distinguish the window group in the user
    /// interface, such as in the name of commands associated with the group.
    ///
    /// > Important: The system ignores any text styling that you apply to
    ///   the ``Text`` view title, like bold or italics. However, you can use
    ///   the formatting controls that the view offers, like for localization,
    ///   dates, and numerical representations.
    ///
    /// SwiftUI creates a window from the group when you present a value
    /// of the specified type using the ``EnvironmentValues/openWindow`` action.
    ///
    /// - Parameters:
    ///   - title: The ``Text`` view to use for the group's title.
    ///   - id: A string that uniquely identifies the window group. Identifiers
    ///     must be unique among the window groups in your app.
    ///   - type: The type of presented data this window group accepts.
    ///   - content: A closure that creates the content for each instance
    ///     of the group. The closure receives a binding to the value that you
    ///     pass into the ``EnvironmentValues/openWindow`` action when you open
    ///     the window. SwiftUI automatically persists and restores the value
    ///     of this binding as part of the state restoration process.
    ///   - defaultValue: A closure that returns a default value to present.
    ///     SwiftUI calls this closure when it has no data to provide, like
    ///     when someone opens a new window from the File > New Window menu
    ///     item.
    nonisolated public init<D, C>(_ title: Text, id: String, for type: D.Type = D.self, @ViewBuilder content: @escaping (Binding<D>) -> C, defaultValue: @escaping () -> D) where Content == PresentedWindowContent<D, C>, D : Decodable, D : Encodable, D : Hashable, C : View

    /// Creates a data-presenting window group with a localized title
    /// string, an identifier, and a default value.
    ///
    /// The window group uses the specified content as a
    /// template to create each window in the group.
    ///
    /// The system uses the title to distinguish the window group in the user
    /// interface, such as in the name of commands associated with the group.
    ///
    /// SwiftUI creates a window from the group when you present a value
    /// of the specified type using the ``EnvironmentValues/openWindow`` action.
    ///
    /// - Parameters:
    ///   - titleKey: The title key to use for the group's title.
    ///   - id: A string that uniquely identifies the window group. Identifiers
    ///     must be unique among the window groups in your app.
    ///   - type: The type of presented data this window group accepts.
    ///   - content: A closure that creates the content for each instance
    ///     of the group. The closure receives a binding to the value that you
    ///     pass into the ``EnvironmentValues/openWindow`` action when you open
    ///     the window. SwiftUI automatically persists and restores the value
    ///     of this binding as part of the state restoration process.
    ///   - defaultValue: A closure that returns a default value to present.
    ///     SwiftUI calls this closure when it has no data to provide, like
    ///     when someone opens a new window from the File > New Window menu
    ///     item.
    nonisolated public init<D, C>(_ titleKey: LocalizedStringKey, id: String, for type: D.Type = D.self, @ViewBuilder content: @escaping (Binding<D>) -> C, defaultValue: @escaping () -> D) where Content == PresentedWindowContent<D, C>, D : Decodable, D : Encodable, D : Hashable, C : View

    /// Creates a data-presenting window group with a title string, an
    /// identifier, and a default value.
    ///
    /// The window group uses the specified content as a
    /// template to create each window in the group.
    ///
    /// The system uses the title to distinguish the window group in the user
    /// interface, such as in the name of commands associated with the group.
    ///
    /// SwiftUI creates a window from the group when you present a value
    /// of the specified type using the ``EnvironmentValues/openWindow`` action.
    ///
    /// - Parameters:
    ///   - title: The string to use for the title of the group.
    ///   - id: A string that uniquely identifies the window group. Identifiers
    ///     must be unique among the window groups in your app.
    ///   - type: The type of presented data this window group accepts.
    ///   - content: A closure that creates the content for each instance
    ///     of the group. The closure receives a binding to the value that you
    ///     pass into the ``EnvironmentValues/openWindow`` action when you open
    ///     the window. SwiftUI automatically persists and restores the value
    ///     of this binding as part of the state restoration process.
    ///   - defaultValue: A closure that returns a default value to present.
    ///     SwiftUI calls this closure when it has no data to provide, like
    ///     when someone opens a new window from the File > New Window menu
    ///     item.
    nonisolated public init<S, D, C>(_ title: S, id: String, for type: D.Type = D.self, @ViewBuilder content: @escaping (Binding<D>) -> C, defaultValue: @escaping () -> D) where Content == PresentedWindowContent<D, C>, S : StringProtocol, D : Decodable, D : Encodable, D : Hashable, C : View

    /// Creates a data-presenting window group with a default value.
    ///
    /// The window group using the given view as a template to form the
    /// content of each window in the group.
    ///
    /// SwiftUI creates a window from the group when you present a value
    /// of the specified type using the ``EnvironmentValues/openWindow`` action.
    ///
    /// - Parameters:
    ///   - type:The type of presented data this window group accepts.
    ///   - content: A closure that creates the content for each instance
    ///     of the group. The closure receives a binding to the value that you
    ///     pass into the ``EnvironmentValues/openWindow`` action when you open
    ///     the window. SwiftUI automatically persists and restores the value
    ///     of this binding as part of the state restoration process.
    ///   - defaultValue: A closure that returns a default value to present.
    ///     SwiftUI calls this closure when it has no data to provide, like
    ///     when someone opens a new window from the File > New Window menu
    ///     item.
    nonisolated public init<D, C>(for type: D.Type = D.self, @ViewBuilder content: @escaping (Binding<D>) -> C, defaultValue: @escaping () -> D) where Content == PresentedWindowContent<D, C>, D : Decodable, D : Encodable, D : Hashable, C : View

    /// Creates a data-presenting window group with a text view title and a
    /// default value.
    ///
    /// The window group uses the given view as a
    /// template to form the content of each window in the group.
    ///
    /// The system uses the title to distinguish the window group in the user
    /// interface, such as in the name of commands associated with the group.
    ///
    /// > Important: The system ignores any text styling that you apply to
    ///   the ``Text`` view title, like bold or italics. However, you can use
    ///   the formatting controls that the view offers, like for localization,
    ///   dates, and numerical representations.
    ///
    /// SwiftUI creates a window from the group when you present a value
    /// of the specified type using the ``EnvironmentValues/openWindow`` action.
    ///
    /// - Parameters:
    ///   - title: The ``Text`` view to use for the group's title.
    ///   - type: The type of presented data this window group accepts.
    ///   - content: A closure that creates the content for each instance
    ///     of the group. The closure receives a binding to the value that you
    ///     pass into the ``EnvironmentValues/openWindow`` action when you open
    ///     the window. SwiftUI automatically persists and restores the value
    ///     of this binding as part of the state restoration process.
    ///   - defaultValue: A closure that returns a default value to present.
    ///     SwiftUI calls this closure when it has no data to provide, like
    ///     when someone opens a new window from the File > New Window menu
    ///     item.
    nonisolated public init<D, C>(_ title: Text, for type: D.Type = D.self, @ViewBuilder content: @escaping (Binding<D>) -> C, defaultValue: @escaping () -> D) where Content == PresentedWindowContent<D, C>, D : Decodable, D : Encodable, D : Hashable, C : View

    /// Creates a data-presenting window group with a localized title
    /// string and a default value.
    ///
    /// The window group uses the specified content as a
    /// template to create each window in the group.
    ///
    /// The system uses the title to distinguish the window group in the user
    /// interface, such as in the name of commands associated with the group.
    ///
    /// SwiftUI creates a window from the group when you present a value
    /// of the specified type using the ``EnvironmentValues/openWindow`` action.
    ///
    /// - Parameters:
    ///   - titleKey: The title key to use for the group's title.
    ///   - type: The type of presented data this window group accepts.
    ///   - content: A closure that creates the content for each instance
    ///     of the group. The closure receives a binding to the value that you
    ///     pass into the ``EnvironmentValues/openWindow`` action when you open
    ///     the window. SwiftUI automatically persists and restores the value
    ///     of this binding as part of the state restoration process.
    ///   - defaultValue: A closure that returns a default value to present.
    ///     SwiftUI calls this closure when it has no data to provide, like
    ///     when someone opens a new window from the File > New Window menu
    ///     item.
    nonisolated public init<D, C>(_ titleKey: LocalizedStringKey, for type: D.Type = D.self, @ViewBuilder content: @escaping (Binding<D>) -> C, defaultValue: @escaping () -> D) where Content == PresentedWindowContent<D, C>, D : Decodable, D : Encodable, D : Hashable, C : View

    /// Creates a data-presenting window group with a title string and a default
    /// value.
    ///
    /// The window group uses the specified content as a
    /// template to create each window in the group.
    ///
    /// The system uses the title to distinguish the window group in the user
    /// interface, such as in the name of commands associated with the group.
    ///
    /// SwiftUI creates a window from the group when you present a value
    /// of the specified type using the ``EnvironmentValues/openWindow`` action.
    ///
    /// - Parameters:
    ///   - title: The string to use for the title of the group.
    ///   - type: The type of presented data this window group accepts.
    ///   - content: A closure that creates the content for each instance
    ///     of the group. The closure receives a binding to the value that you
    ///     pass into the ``EnvironmentValues/openWindow`` action when you open
    ///     the window. SwiftUI automatically persists and restores the value
    ///     of this binding as part of the state restoration process.
    ///   - defaultValue: A closure that returns a default value to present.
    ///     SwiftUI calls this closure when it has no data to provide, like
    ///     when someone opens a new window from the File > New Window menu
    ///     item.
    nonisolated public init<S, D, C>(_ title: S, for type: D.Type = D.self, @ViewBuilder content: @escaping (Binding<D>) -> C, defaultValue: @escaping () -> D) where Content == PresentedWindowContent<D, C>, S : StringProtocol, D : Decodable, D : Encodable, D : Hashable, C : View
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, visionOS 1.0, *)
extension WindowGroup {

    /// Creates a window group with an identifier.
    ///
    /// The window group uses the given view as a
    /// template to form the content of each window in the group.
    ///
    /// - Parameters:
    ///   - id: A string that uniquely identifies the window group. Identifiers
    ///     must be unique among the window groups in your app.
    ///   - makeContent: A closure that creates the content for each instance
    ///     of the group.
    nonisolated public init(id: String, @ViewBuilder makeContent: @escaping () -> Content)

    /// Creates a window group with a text view title and an identifier.
    ///
    /// The window group uses the specified content as a
    /// template to create each window in the group.
    /// The system uses the title to distinguish the window group in the user
    /// interface, such as in the name of commands associated with the group.
    ///
    /// > Important: The system ignores any text styling that you apply to
    ///   the ``Text`` view title, like bold or italics. However, you can use
    ///   the formatting controls that the view offers, like for localization,
    ///   dates, and numerical representations.
    ///
    /// - Parameters:
    ///   - title: The ``Text`` view to use for the group's title.
    ///   - id: A string that uniquely identifies the window group. Identifiers
    ///     must be unique among the window groups in your app.
    ///   - makeContent: A closure that creates the content for each instance
    ///     of the group.
    nonisolated public init(_ title: Text, id: String, @ViewBuilder makeContent: @escaping () -> Content)

    /// Creates a window group with a localized title string and an
    /// identifier.
    ///
    /// The window group uses the specified content as a
    /// template to create each window in the group.
    /// The system uses the title to distinguish the window group in the user
    /// interface, such as in the name of commands associated with the group.
    ///
    /// - Parameters:
    ///   - titleKey: The title key to use for the title of the group.
    ///   - id: A string that uniquely identifies the window group. Identifiers
    ///     must be unique among the window groups in your app.
    ///   - makeContent: A closure that creates the content for each instance
    ///     of the group.
    nonisolated public init(_ titleKey: LocalizedStringKey, id: String, @ViewBuilder makeContent: @escaping () -> Content)

    /// Creates a window group with a title string and an identifier.
    ///
    /// The window group uses the specified content as a
    /// template to create each window in the group.
    /// The system uses the title to distinguish the window group in the user
    /// interface, such as in the name of commands associated with the group.
    ///
    /// - Parameters:
    ///   - title: The string to use for the title of the group.
    ///   - id: A string that uniquely identifies the window group. Identifiers
    ///     must be unique among the window groups in your app.
    ///   - makeContent: A closure that creates the content for each instance
    ///     of the group.
    nonisolated public init<S>(_ title: S, id: String, @ViewBuilder makeContent: @escaping () -> Content) where S : StringProtocol

    /// Creates a window group.
    ///
    /// The window group uses the given view as a template to form the
    /// content of each window in the group.
    ///
    /// - Parameter makeContent: A closure that creates the content for each
    ///   instance of the group.
    nonisolated public init(@ViewBuilder makeContent: @escaping () -> Content)

    /// Creates a window group with a text view title.
    ///
    /// The window group uses the given view as a
    /// template to form the content of each window in the group.
    /// The system uses the title to distinguish the window group in the user
    /// interface, such as in the name of commands associated with the group.
    ///
    /// > Important: The system ignores any text styling that you apply to
    ///   the ``Text`` view title, like bold or italics. However, you can use
    ///   the formatting controls that the view offers, like for localization,
    ///   dates, and numerical representations.
    ///
    /// - Parameters:
    ///   - title: The ``Text`` view to use for the group's title.
    ///   - makeContent: A closure that creates the content for each instance
    ///     of the group.
    nonisolated public init(_ title: Text, @ViewBuilder makeContent: @escaping () -> Content)

    /// Creates a window group with a localized title string.
    ///
    /// The window group uses the specified content as a
    /// template to create each window in the group.
    /// The system uses the title to distinguish the window group in the user
    /// interface, such as in the name of commands associated with the group.
    ///
    /// - Parameters:
    ///   - titleKey: The title key to use for the group's title.
    ///   - makeContent: A closure that creates the content for each instance
    ///     of the group.
    nonisolated public init(_ titleKey: LocalizedStringKey, @ViewBuilder makeContent: @escaping () -> Content)

    /// Creates a window group with a title string.
    ///
    /// The window group uses the specified content as a
    /// template to create each window in the group.
    /// The system uses the title to distinguish the window group in the user
    /// interface, such as in the name of commands associated with the group.
    ///
    /// - Parameters:
    ///   - title: The string to use for the title of the group.
    ///   - makeContent: A closure that creates the content for each instance
    ///     of the group.
    nonisolated public init<S>(_ title: S, @ViewBuilder makeContent: @escaping () -> Content) where S : StringProtocol
}

/// Options for defining how a scene's windows behave when used within a managed
/// window context, such as full screen mode and Stage Manager.
///
/// Use values of this type in conjunction with the
/// ``Scene/windowManagerRole(_:)`` modifier to override the default system
/// behavior.
///
/// For example, you can specify that a secondary `Window` scene should use the
/// principal role for full screen and Stage Manager:
///
///     struct MyApp: App {
///         var body: some Scene {
///             WindowGroup {
///                 ContentView()
///             }
///             Window("Organizer", id: "organizer") {
///                 OrganizerView()
///             }
///             .windowManagerRole(.principal)
///         }
///     }
///
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct WindowManagerRole : Sendable {

    /// The automatic role. The type and configuration of the scene will be
    /// used to determine how its windows behave in full screen and Stage
    /// Manager.
    ///
    /// On macOS, ``WindowGroup`` and ``DocumentGroup`` scenes will use the
    /// `principal` role. ``Window`` scenes will use the `principal`
    /// role when they are specified as the first scene in the app's
    /// definition, and use the `associated` role otherwise. ``Settings``
    /// will use the `associated` role.
    public static let automatic: WindowManagerRole
}

/// The resizability of a window.
///
/// Use the ``Scene/windowResizability(_:)`` scene modifier to apply a value
/// of this type to a ``Scene`` that you define in your ``App`` declaration.
/// The value that you specify indicates the strategy the system uses to
/// place minimum and maximum size restrictions on windows that it creates
/// from that scene.
///
/// For example, you can create a window group that people can resize to
/// between 100 and 400 points in both dimensions by applying both a frame
/// with those constraints to the scene's content, and the
/// ``WindowResizability/contentSize`` resizability to the scene:
///
///     @main
///     struct MyApp: App {
///         var body: some Scene {
///             WindowGroup {
///                 ContentView()
///                     .frame(
///                         minWidth: 100, maxWidth: 400,
///                         minHeight: 100, maxHeight: 400)
///             }
///             .windowResizability(.contentSize)
///         }
///     }
///
/// The default value for all scenes if you don't apply the modifier is
/// ``WindowResizability/automatic``. With that strategy, ``Settings``
/// windows use the ``WindowResizability/contentSize`` strategy, while
/// all others use ``WindowResizability/contentMinSize``. Windows on visionOS
/// with a window style of ``WindowStyle/volumetric`` also use the
/// ``WindowResizability/contentSize`` strategy.
@available(iOS 17.0, macOS 13.0, visionOS 1.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct WindowResizability : Sendable {

    /// The automatic window resizability.
    ///
    /// When you use automatic resizability, SwiftUI applies a resizing
    /// strategy that's appropriate for the scene type:
    /// * Windows from ``WindowGroup``, ``Window``, and ``DocumentGroup``
    ///   scene declarations use the ``contentMinSize`` strategy.
    /// * A window from a ``Settings`` scene declaration uses the
    ///   ``contentSize`` strategy.
    /// * Windows on visionOS with a window style of ``WindowStyle/volumetric``
    ///   use the ``contentSize`` strategy.
    ///
    /// Automatic resizability is the default if you don't specify another
    /// value using the ``Scene/windowResizability(_:)`` scene modifier.
    public static var automatic: WindowResizability

    /// A window resizability that's derived from the window's content.
    ///
    /// Windows that use this resizability have:
    /// * A minimum size that matches the minimum size of the window's content.
    /// * A maximum size that matches the maximum size of the window's content.
    public static var contentSize: WindowResizability

    /// A window resizability that's partially derived from the window's
    /// content.
    ///
    /// Windows that use this resizability have:
    /// * A minimum size that matches the minimum size of the window's content.
    /// * No maximum size.
    public static var contentMinSize: WindowResizability
}

/// The visibility of the window toolbar with respect to full screen mode.
///
/// Use values of this type in conjunction with the
/// ``View/windowToolbarFullScreenVisibility(_:)`` modifier to configure how
/// the window toolbar displays itself when the window enters full screen mode.
///
/// For example, you can specify that the window toolbar should be hidden by
/// default, and only show when the mouse moves into the area occupied by the
/// menu bar:
///
///     struct RootView: View {
///         var body: some View {
///             ContentView()
///                 .toolbar {
///                     ...
///                 }
///                 .windowToolbarFullScreenVisibility(.onHover)
///         }
///     }
///
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct WindowToolbarFullScreenVisibility : Sendable {

    /// The window toolbar visibility will be defined by the system default
    /// behavior.
    public static let automatic: WindowToolbarFullScreenVisibility
}

/// The Writing Tools editing experience for text and text input.
@available(iOS 18.0, macOS 15.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@available(visionOS, unavailable)
public struct WritingToolsBehavior : Sendable, Hashable {

    /// An appropriate editing experience will be provided based on context,
    /// which may include disabling the writing tools.
    public static let automatic: WritingToolsBehavior

    /// The complete inline-editing experience is provided if possible.
    public static let complete: WritingToolsBehavior

    /// The limited, overlay-panel experience is provided if possible.
    public static let limited: WritingToolsBehavior

    /// The writing tools are disabled.
    public static let disabled: WritingToolsBehavior

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: WritingToolsBehavior, b: WritingToolsBehavior) -> Bool

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

/// A navigation transition that zooms the appearing view from a given
/// source view. Indicate the source view using the
/// ``View/matchedTransitionSource(id:namespace:)`` modifier.
@available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
@available(macOS, unavailable)
public struct ZoomNavigationTransition : NavigationTransition {
}

/// Returns the result of recomputing the view's body with the provided
/// animation, and runs the completion when all animations are complete.
///
/// This function sets the given ``Animation`` as the ``Transaction/animation``
/// property of the thread's current ``Transaction`` as well as calling
/// ``Transaction/addAnimationCompletion`` with the specified completion.
///
/// The completion callback will always be fired exactly one time. If no
/// animations are created by the changes in `body`, then the callback will be
/// called immediately after `body`.
@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
public func withAnimation<Result>(_ animation: Animation? = .default, completionCriteria: AnimationCompletionCriteria = .logicallyComplete, _ body: () throws -> Result, completion: @escaping () -> Void) rethrows -> Result

@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension View {

    /// Adds a textual description of the value that the view contains.
    ///
    /// Use this method to describe the value represented by a view, but only
    /// if that's different than the view's label. For example, for a slider
    /// that you label as "Volume" using accessibilityLabel(), you can provide
    /// the current volume setting, like "60%", using accessibilityValue().
    ///
    /// - Parameters:
    ///   - valueDescription: The accessibility value to apply.
    ///   - isEnabled: If true the accessibility value is applied; otherwise
    ///     the accessibility value is unchanged.
    nonisolated public func accessibilityValue(_ valueDescription: Text, isEnabled: Bool) -> ModifiedContent<Self, AccessibilityAttachmentModifier>

    /// Adds a textual description of the value that the view contains.
    ///
    /// Use this method to describe the value represented by a view, but only
    /// if that's different than the view's label. For example, for a slider
    /// that you label as "Volume" using accessibilityLabel(), you can provide
    /// the current volume setting, like "60%", using accessibilityValue().
    ///
    /// - Parameters:
    ///   - valueKey: The accessibility value to apply.
    ///   - isEnabled: If true the accessibility value is applied; otherwise
    ///     the accessibility value is unchanged.
    nonisolated public func accessibilityValue(_ valueKey: LocalizedStringKey, isEnabled: Bool) -> ModifiedContent<Self, AccessibilityAttachmentModifier>

    /// Adds a textual description of the value that the view contains.
    ///
    /// Use this method to describe the value represented by a view, but only
    /// if that's different than the view's label. For example, for a slider
    /// that you label as "Volume" using accessibilityLabel(), you can provide
    /// the current volume setting, like "60%", using accessibilityValue().
    ///
    /// - Parameters:
    ///   - value: The accessibility value to apply.
    ///   - isEnabled: If true the accessibility value is applied; otherwise
    ///     the accessibility value is unchanged.
    nonisolated public func accessibilityValue<S>(_ value: S, isEnabled: Bool) -> ModifiedContent<Self, AccessibilityAttachmentModifier> where S : StringProtocol
}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension ModifiedContent where Modifier == AccessibilityAttachmentModifier {

    /// Adds a textual description of the value that the view contains.
    ///
    /// Use this method to describe the value represented by a view, but only
    /// if that's different than the view's label. For example, for a slider
    /// that you label as "Volume" using accessibilityLabel(), you can provide
    /// the current volume setting, like "60%", using accessibilityValue().
    ///
    /// - Parameters:
    ///   - valueDescription: The accessibility value to apply.
    ///   - isEnabled: If true the accessibility value is applied; otherwise
    ///     the accessibility value is unchanged.
    nonisolated public func accessibilityValue(_ valueDescription: Text, isEnabled: Bool) -> ModifiedContent<Content, Modifier>

    /// Adds a textual description of the value that the view contains.
    ///
    /// Use this method to describe the value represented by a view, but only
    /// if that's different than the view's label. For example, for a slider
    /// that you label as "Volume" using accessibilityLabel(), you can provide
    /// the current volume setting, like "60%", using accessibilityValue().
    ///
    /// - Parameters:
    ///   - valueKey: The accessibility value to apply.
    ///   - isEnabled: If true the accessibility value is applied; otherwise
    ///     the accessibility value is unchanged.
    nonisolated public func accessibilityValue(_ valueKey: LocalizedStringKey, isEnabled: Bool) -> ModifiedContent<Content, Modifier>

    /// Adds a textual description of the value that the view contains.
    ///
    /// Use this method to describe the value represented by a view, but only
    /// if that's different than the view's label. For example, for a slider
    /// that you label as "Volume" using accessibilityLabel(), you can provide
    /// the current volume setting, like "60%", using accessibilityValue().
    ///
    /// - Parameters:
    ///   - value: The accessibility value to apply. When the value
    ///     is `nil`, the view will not provide any accessibility value.
    ///   - isEnabled: If true the accessibility value is applied; otherwise
    ///     the accessibility value is unchanged.
    nonisolated public func accessibilityValue<S>(_ value: S, isEnabled: Bool) -> ModifiedContent<Content, Modifier> where S : StringProtocol
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension View {

    /// Adds a textual description of the value that the view contains.
    ///
    /// Use this method to describe the value represented by a view, but only if that's different than the
    /// view's label. For example, for a slider that you label as "Volume" using accessibilityLabel(),
    /// you can provide the current volume setting, like "60%", using accessibilityValue().
    nonisolated public func accessibilityValue(_ valueDescription: Text) -> ModifiedContent<Self, AccessibilityAttachmentModifier>

    /// Adds a textual description of the value that the view contains.
    ///
    /// Use this method to describe the value represented by a view, but only if that's different than the
    /// view's label. For example, for a slider that you label as "Volume" using accessibilityLabel(),
    /// you can provide the current volume setting, like "60%", using accessibilityValue().
    nonisolated public func accessibilityValue(_ valueKey: LocalizedStringKey) -> ModifiedContent<Self, AccessibilityAttachmentModifier>

    /// Adds a textual description of the value that the view contains.
    ///
    /// Use this method to describe the value represented by a view, but only if that's different than the
    /// view's label. For example, for a slider that you label as "Volume" using accessibilityLabel(),
    /// you can provide the current volume setting, like "60%", using accessibilityValue().
    nonisolated public func accessibilityValue<S>(_ value: S) -> ModifiedContent<Self, AccessibilityAttachmentModifier> where S : StringProtocol
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ModifiedContent where Modifier == AccessibilityAttachmentModifier {

    /// Adds a textual description of the value that the view contains.
    ///
    /// Use this method to describe the value represented by a view, but only if that's different than the
    /// view's label. For example, for a slider that you label as "Volume" using accessibilityLabel(),
    /// you can provide the current volume setting, like "60%", using accessibilityValue().
    nonisolated public func accessibilityValue(_ valueDescription: Text) -> ModifiedContent<Content, Modifier>
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ModifiedContent where Modifier == AccessibilityAttachmentModifier {

    /// Adds a textual description of the value that the view contains.
    ///
    /// Use this method to describe the value represented by a view, but only if that's different than the
    /// view's label. For example, for a slider that you label as "Volume" using accessibilityLabel(),
    /// you can provide the current volume setting, like "60%", using accessibilityValue().
    nonisolated public func accessibilityValue(_ valueKey: LocalizedStringKey) -> ModifiedContent<Content, Modifier>

    /// Adds a textual description of the value that the view contains.
    ///
    /// Use this method to describe the value represented by a view, but only if that's different than the
    /// view's label. For example, for a slider that you label as "Volume" using accessibilityLabel(),
    /// you can provide the current volume setting, like "60%", using accessibilityValue().
    nonisolated public func accessibilityValue<S>(_ value: S) -> ModifiedContent<Content, Modifier> where S : StringProtocol
}

extension View {

    /// Adds a textual description of the value that the view contains.
    ///
    /// Use this method to describe the value represented by a view, but only if that's different than the
    /// view's label. For example, for a slider that you label as "Volume" using accessibility(label:),
    /// you can provide the current volume setting, like "60%", using accessibility(value:).
    @available(iOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityValue(_:)")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, renamed: "accessibilityValue(_:)")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityValue(_:)")
    @available(watchOS, introduced: 6, deprecated: 100000.0, renamed: "accessibilityValue(_:)")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, renamed: "accessibilityValue(_:)")
    nonisolated public func accessibility(value: Text) -> ModifiedContent<Self, AccessibilityAttachmentModifier>
}

extension ModifiedContent where Modifier == AccessibilityAttachmentModifier {

    /// Adds a textual description of the value that the view contains.
    ///
    /// Use this method to describe the value represented by a view, but only if that's different than the
    /// view's label. For example, for a slider that you label as "Volume" using accessibility(label:),
    /// you can provide the current volume setting, like "60%", using accessibility(value:).
    @available(iOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityValue(_:)")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, renamed: "accessibilityValue(_:)")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityValue(_:)")
    @available(watchOS, introduced: 6, deprecated: 100000.0, renamed: "accessibilityValue(_:)")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, renamed: "accessibilityValue(_:)")
    nonisolated public func accessibility(value: Text) -> ModifiedContent<Content, Modifier>
}

extension EnvironmentValues {

    /// Whether the Large Content Viewer is enabled.
    ///
    /// The system can automatically provide a large content view
    /// with ``View/accessibilityShowsLargeContentViewer()``
    /// or you can provide your own with ``View/accessibilityShowsLargeContentViewer(_:)``.
    ///
    /// While it is not necessary to check this value before adding
    /// a large content view, it may be helpful if you need to
    /// adjust the behavior of a gesture. For example, a button with
    /// a long press handler might increase its long press duration
    /// so the user can read the text in the large content viewer first.
    @available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
    public var accessibilityLargeContentViewerEnabled: Bool { get }
}

extension View {

    /// Adds a custom large content view to be shown by
    /// the large content viewer.
    ///
    /// Rely on the large content viewer only in situations
    /// where items must remain small due to unavoidable
    /// design constraints. For example, buttons in a tab bar
    /// remain small to leave more room for the main app content.
    ///
    /// The following example shows how to add a custom large
    /// content view:
    ///
    ///     var body: some View {
    ///         Button(action: newMessage) {
    ///             Image(systemName: "plus")
    ///         }
    ///         .accessibilityShowsLargeContentViewer {
    ///             Label("New Message", systemImage: "plus")
    ///         }
    ///     }
    ///
    /// Dont use the large content viewer as a replacement for proper
    /// Dynamic Type support. For example, Dynamic Type allows items
    /// in a list to grow or shrink vertically to accommodate the users preferred
    /// font size. Rely on the large content viewer only in situations where
    /// items must remain small due to unavoidable design constraints.
    ///
    /// For example, views that have their Dynamic Type size constrained
    /// with ``View/dynamicTypeSize(_:)`` may require a
    /// large content view.
    @available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
    nonisolated public func accessibilityShowsLargeContentViewer<V>(@ViewBuilder _ largeContentView: () -> V) -> some View where V : View


    /// Adds a default large content view to be shown by
    /// the large content viewer.
    ///
    /// Rely on the large content viewer only in situations
    /// where items must remain small due to unavoidable
    /// design constraints. For example, buttons in a tab bar
    /// remain small to leave more room for the main app content.
    ///
    /// The following example shows how to add a custom large
    /// content view:
    ///
    ///     var body: some View {
    ///         Button("New Message", action: newMessage)
    ///             .accessibilityShowsLargeContentViewer()
    ///     }
    ///
    /// Dont use the large content viewer as a replacement for proper
    /// Dynamic Type support. For example, Dynamic Type allows items
    /// in a list to grow or shrink vertically to accommodate the users preferred
    /// font size. Rely on the large content viewer only in situations where
    /// items must remain small due to unavoidable design constraints.
    ///
    /// For example, views that have their Dynamic Type size constrained
    /// with ``View/dynamicTypeSize(_:)`` may require a
    /// large content view.
    @available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
    nonisolated public func accessibilityShowsLargeContentViewer() -> some View

}

@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension View {

    /// Sets a fixed, preferred width for the column containing this view.
    ///
    /// Apply this modifier to the content of a column in a
    /// ``NavigationSplitView`` to specify a fixed preferred width for the
    /// column. Use ``View/navigationSplitViewColumnWidth(min:ideal:max:)`` if
    /// you need to specify a flexible width.
    ///
    /// The following example shows a three-column navigation split view where
    /// the first column has a preferred width of 150 points, and the second
    /// column has a flexible, preferred width between 150 and 400 points:
    ///
    ///     NavigationSplitView {
    ///         MySidebar()
    ///             .navigationSplitViewColumnWidth(150)
    ///     } contents: {
    ///         MyContents()
    ///             .navigationSplitViewColumnWidth(
    ///                 min: 150, ideal: 200, max: 400)
    ///     } detail: {
    ///         MyDetail()
    ///     }
    ///
    /// Only some platforms enable resizing columns. If
    /// you specify a width that the current presentation environment doesn't
    /// support, SwiftUI may use a different width for your column.
    nonisolated public func navigationSplitViewColumnWidth(_ width: CGFloat) -> some View


    /// Sets a flexible, preferred width for the column containing this view.
    ///
    /// Apply this modifier to the content of a column in a
    /// ``NavigationSplitView`` to specify a preferred flexible width for the
    /// column. Use ``View/navigationSplitViewColumnWidth(_:)`` if you need to
    /// specify a fixed width.
    ///
    /// The following example shows a three-column navigation split view where
    /// the first column has a preferred width of 150 points, and the second
    /// column has a flexible, preferred width between 150 and 400 points:
    ///
    ///     NavigationSplitView {
    ///         MySidebar()
    ///             .navigationSplitViewColumnWidth(150)
    ///     } contents: {
    ///         MyContents()
    ///             .navigationSplitViewColumnWidth(
    ///                 min: 150, ideal: 200, max: 400)
    ///     } detail: {
    ///         MyDetail()
    ///     }
    ///
    /// Only some platforms enable resizing columns. If
    /// you specify a width that the current presentation environment doesn't
    /// support, SwiftUI may use a different width for your column.
    nonisolated public func navigationSplitViewColumnWidth(min: CGFloat? = nil, ideal: CGFloat, max: CGFloat? = nil) -> some View

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension View {

    /// Links multiple accessibility elements so that the user can quickly
    /// navigate from one element to another, even when the elements are not near
    /// each other in the accessibility hierarchy.
    ///
    /// This can be useful to allow quickly jumping between content in a list and
    /// the same content shown in a detail view, for example. All elements marked
    /// with `accessibilityLinkedGroup` with the same namespace and identifier will be
    /// linked together.
    ///
    /// - Parameters:
    ///   - id: A hashable identifier used to separate sets of linked elements
    ///     within the same namespace. Elements with matching `namespace` and `id`
    ///     will be linked together.
    ///   - namespace: The namespace to use to organize linked accessibility
    ///     elements. All elements marked with `accessibilityLink` in this
    ///     namespace and with the specified `id` will be linked together.
    nonisolated public func accessibilityLinkedGroup<ID>(id: ID, in namespace: Namespace.ID) -> some View where ID : Hashable


    /// Pairs an accessibility element representing a label with the element
    /// for the matching content.
    ///
    /// Use `accessibilityLabeledPair` with a role of `AccessibilityLabeledPairRole.label`
    /// to identify the label, and a role of `AccessibilityLabeledPairRole.content`
    /// to identify the content.
    /// This improves the behavior of accessibility features such as VoiceOver
    /// when navigating such elements, allowing users to better understand the
    /// relationship between them.
    ///
    /// - Parameters:
    ///   - role: Determines whether this element should be used as the label
    ///     in the pair, or the content in the pair.
    ///   - id: The identifier for the label / content pair. Elements with
    ///     matching identifiers within the same namespace will be paired
    ///     together.
    ///   - namespace: The namespace used to organize label and content. Label
    ///     and content under the same namespace with matching identifiers will
    ///     be paired together.
    nonisolated public func accessibilityLabeledPair<ID>(role: AccessibilityLabeledPairRole, id: ID, in namespace: Namespace.ID) -> some View where ID : Hashable

}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, *)
@available(visionOS, unavailable)
extension View {

    /// Assigns a hand gesture shortcut to the modified control.
    ///
    /// Performing the control's shortcut while the control is anywhere in the
    /// frontmost scene is equivalent to direct interaction with the control to
    /// perform its primary action.
    ///
    /// The following example lets users of a watchOS music app toggle playback
    /// by double-tapping their thumb and index finger together:
    ///
    ///     struct PlaybackControls: View {
    ///         let model: TrackModel
    ///
    ///         var body: some View {
    ///             HStack {
    ///                 Button("Skip Back") {
    ///                     model.skipBack()
    ///                 }
    ///
    ///                 Button("Play/Pause") {
    ///                     model.playPause()
    ///                 }
    ///                 .handGestureShortcut(.primaryAction)
    ///
    ///                 Button("Skip Forward") {
    ///                     model.skipForward()
    ///                 }
    ///             }
    ///         }
    ///     }
    ///
    /// The target of a hand gesture shortcut is resolved in a
    /// leading-to-trailing traversal of the active scene.
    ///
    /// - Parameters:
    ///     - shortcut: The shortcut to associate with this control.
    ///     - isEnabled: A Boolean value that indicates whether the shortcut is
    ///       is enabled for this control.
    nonisolated public func handGestureShortcut(_ shortcut: HandGestureShortcut, isEnabled: Bool = true) -> some View

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// Sets the style for lists within this view.
    nonisolated public func listStyle<S>(_ style: S) -> some View where S : ListStyle

}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension View {

    /// Adds multiple accessibility actions to the view with a specific
    /// category. Actions allow assistive technologies, such as VoiceOver,
    /// to interact with the view by invoking the action and are grouped by
    /// their category. When multiple action modifiers with an equal category
    /// are applied to the view, the actions are combined together.
    ///
    ///    var body: some View {
    ///        EditorView()
    ///             .accessibilityActions(category: .edit) {
    ///                 ForEach(editActions) { action in
    ///                     Button(action.title) {
    ///                         action()
    ///                     }
    ///                 }
    ///                 if hasTextSuggestions {
    ///                     Button("Show Text Suggestions") {
    ///                         presentTextSuggestions()
    ///                     }
    ///                 }
    ///             }
    ///    }
    ///
    /// - Parameters:
    ///   - category: The category the accessibility actions are grouped by.
    ///   - content: The accessibility actions added to the view.
    nonisolated public func accessibilityActions<Content>(category: AccessibilityActionCategory, @ViewBuilder _ content: () -> Content) -> some View where Content : View

}

extension View {

    /// Presents an action sheet using the given item as a data source for the
    /// sheet's content.
    ///
    /// Use this method when you need to populate the fields of an action sheet
    /// with content from a data source. The example below shows a custom data
    /// source, `FileDetails`, that provides data to populate the action sheet:
    ///
    ///     struct FileDetails: Identifiable {
    ///         var id: String { name }
    ///         let name: String
    ///         let fileType: UTType
    ///     }
    ///
    ///     struct ConfirmFileImport: View {
    ///         @State private var sheetDetail: FileDetails?
    ///
    ///         var body: some View {
    ///             Button("Show Action Sheet") {
    ///                 sheetDetail = FileDetails(name: "MyImageFile.png",
    ///                                           fileType: .png)
    ///             }
    ///             .actionSheet(item: $sheetDetail) { detail in
    ///                 ActionSheet(
    ///                     title: Text("File Import"),
    ///                     message: Text("""
    ///                              Import \(detail.name)?
    ///                              File Type: \(detail.fileType.description)
    ///                              """),
    ///                     buttons: [
    ///                         .destructive(Text("Import"),
    ///                                      action: importFile),
    ///                         .cancel()
    ///                     ])
    ///             }
    ///         }
    ///
    ///         func importFile() {
    ///             // Handle import action.
    ///         }
    ///     }
    ///
    /// ![A screenshot showing an action sheet populated using a custom data
    /// source that describes a file and file
    /// format.](SwiftUI-View-ActionSheetItemContent.png)
    ///
    /// - Parameters:
    ///   - item: A binding to an optional source of truth for the action
    ///     sheet. When `item` is non-`nil`, the system passes
    ///     the contents to the modifier's closure. You use this content
    ///     to populate the fields of an action sheet that you create that the
    ///     system displays to the user. If `item` changes, the system
    ///     dismisses the currently displayed action sheet and replaces it
    ///     with a new one using the same process.
    ///   - content: A closure returning the ``ActionSheet`` you create.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, message: "use `confirmationDialog(title:isPresented:titleVisibility:presenting::actions:)`instead.")
    @available(macOS, unavailable)
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, message: "use `confirmationDialog(title:isPresented:titleVisibility:presenting:actions:)`instead.")
    @available(watchOS, introduced: 6.0, deprecated: 100000.0, message: "use `confirmationDialog(title:isPresented:titleVisibility:presenting:actions:)`instead.")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "use `confirmationDialog(title:isPresented:titleVisibility:presenting:actions:)`instead.")
    nonisolated public func actionSheet<T>(item: Binding<T?>, content: (T) -> ActionSheet) -> some View where T : Identifiable


    /// Presents an action sheet when a given condition is true.
    ///
    /// In the example below, a button conditionally presents an action sheet
    /// depending upon the value of a bound Boolean variable. When the Boolean
    /// value is set to `true`, the system displays an action sheet with both
    /// destructive and default actions:
    ///
    ///     struct ConfirmEraseItems: View {
    ///         @State private var isShowingSheet = false
    ///         var body: some View {
    ///             Button("Show Action Sheet", action: {
    ///                 isShowingSheet = true
    ///             })
    ///             .actionSheet(isPresented: $isShowingSheet) {
    ///                 ActionSheet(
    ///                     title: Text("Permanently erase the items in the Trash?"),
    ///                     message: Text("You can't undo this action."),
    ///                     buttons:[
    ///                         .destructive(Text("Empty Trash"),
    ///                                      action: emptyTrashAction),
    ///                         .cancel()
    ///                     ]
    ///                 )}
    ///         }
    ///
    ///         func emptyTrashAction() {
    ///             // Handle empty trash action.
    ///         }
    ///     }
    ///
    /// ![An action sheet with a title and message showing the use of default
    /// and destructive button
    /// types.](SwiftUI-View-ActionSheetisPresentedContent.png)
    ///
    /// > Note: In regular size classes in iOS, the system renders alert sheets
    ///    as a popover that the user dismisses by tapping anywhere outside the
    ///    popover, rather than displaying the default dismiss button.
    ///
    /// - Parameters:
    ///   - isPresented: A binding to a Boolean value that determines whether
    ///     to present the action sheet that you create in the modifier's
    ///     `content` closure. When the user presses or taps the sheet's default
    ///     action button the system sets this value to `false` dismissing
    ///     the sheet.
    ///   - content: A closure returning the `ActionSheet` to present.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, message: "use `confirmationDialog(title:isPresented:titleVisibility:presenting::actions:)`instead.")
    @available(macOS, unavailable)
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, message: "use `confirmationDialog(title:isPresented:titleVisibility:presenting:actions:)`instead.")
    @available(watchOS, introduced: 6.0, deprecated: 100000.0, message: "use `confirmationDialog(title:isPresented:titleVisibility:presenting:actions:)`instead.")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "use `confirmationDialog(title:isPresented:titleVisibility:presenting:actions:)`instead.")
    nonisolated public func actionSheet(isPresented: Binding<Bool>, content: () -> ActionSheet) -> some View

}

@available(iOS 17.4, macOS 14.4, visionOS 1.1, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension Optional : TableColumnContent where Wrapped : TableColumnContent {

    /// The type of value of rows presented by this column content.
    public typealias TableRowValue = Wrapped.TableRowValue

    /// The type of sort comparator associated with this table column content.
    public typealias TableColumnSortComparator = Wrapped.TableColumnSortComparator

    /// The type of content representing the body of this table row content.
    public typealias TableRowBody = Never

    /// The type of content representing the body of this table column content.
    @available(iOS 17.4, visionOS 1.1, macOS 14.4, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias TableColumnBody = Never
}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension View {

    /// Adds a label to the view that describes its contents.
    ///
    /// Use this method to provide an accessibility label for a view that
    /// doesn't display text, like an icon. For example, you could use this
    /// method to label a button that plays music with the text "Play". Don't
    /// include text in the label that repeats information that users already
    /// have. For example, don't use the label "Play button" because a button
    /// already has a trait that identifies it as a button.
    ///
    /// - Parameters:
    ///   - label: The accessibility label to apply.
    ///   - isEnabled: If true the accessibility label is applied; otherwise
    ///     the accessibility label is unchanged.
    nonisolated public func accessibilityLabel(_ label: Text, isEnabled: Bool) -> ModifiedContent<Self, AccessibilityAttachmentModifier>

    /// Adds a label to the view that describes its contents.
    ///
    /// Use this method to provide an accessibility label for a view that
    /// doesn't display text, like an icon. For example, you could use this
    /// method to label a button that plays music with the text "Play". Don't
    /// include text in the label that repeats information that users already
    /// have. For example, don't use the label "Play button" because a button
    /// already has a trait that identifies it as a button.
    ///
    /// - Parameters:
    ///   - labelKey: The accessibility label to apply.
    ///   - isEnabled: If true the accessibility label is applied; otherwise
    ///     the accessibility label is unchanged.
    nonisolated public func accessibilityLabel(_ labelKey: LocalizedStringKey, isEnabled: Bool) -> ModifiedContent<Self, AccessibilityAttachmentModifier>

    /// Adds a label to the view that describes its contents.
    ///
    /// Use this method to provide an accessibility label for a view that
    /// doesn't display text, like an icon. For example, you could use this
    /// method to label a button that plays music with the text "Play". Don't
    /// include text in the label that repeats information that users already
    /// have. For example, don't use the label "Play button" because a button
    /// already has a trait that identifies it as a button.
    ///
    /// - Parameters:
    ///   - label: The accessibility label to apply.
    ///   - isEnabled: If true the accessibility label is applied; otherwise
    ///     the accessibility label is unchanged.
    nonisolated public func accessibilityLabel<S>(_ label: S, isEnabled: Bool) -> ModifiedContent<Self, AccessibilityAttachmentModifier> where S : StringProtocol
}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension ModifiedContent where Modifier == AccessibilityAttachmentModifier {

    /// Adds a label to the view that describes its contents.
    ///
    /// Use this method to provide an accessibility label for a view that
    /// doesn't display text, like an icon. For example, you could use this
    /// method to label a button that plays music with the text "Play". Don't
    /// include text in the label that repeats information that users already
    /// have. For example, don't use the label "Play button" because a button
    /// already has a trait that identifies it as a button.
    ///
    /// - Parameters:
    ///   - label: The accessibility label to apply.
    ///   - isEnabled: If true the accessibility label is applied; otherwise
    ///     the accessibility label is unchanged.
    nonisolated public func accessibilityLabel(_ label: Text, isEnabled: Bool) -> ModifiedContent<Content, Modifier>

    /// Adds a label to the view that describes its contents.
    ///
    /// Use this method to provide an accessibility label for a view that
    /// doesn't display text, like an icon. For example, you could use this
    /// method to label a button that plays music with the text "Play". Don't
    /// include text in the label that repeats information that users already
    /// have. For example, don't use the label "Play button" because a button
    /// already has a trait that identifies it as a button.
    ///
    /// - Parameters:
    ///   - labelKey: The accessibility label to apply.
    ///   - isEnabled: If true the accessibility label is applied; otherwise
    ///     the accessibility label is unchanged.
    nonisolated public func accessibilityLabel(_ labelKey: LocalizedStringKey, isEnabled: Bool) -> ModifiedContent<Content, Modifier>

    /// Adds a label to the view that describes its contents.
    ///
    /// Use this method to provide an accessibility label for a view that
    /// doesn't display text, like an icon. For example, you could use this
    /// method to label a button that plays music with the text "Play". Don't
    /// include text in the label that repeats information that users already
    /// have. For example, don't use the label "Play button" because a button
    /// already has a trait that identifies it as a button.
    ///
    /// - Parameters:
    ///   - label: The accessibility label to apply.
    ///   - isEnabled: If true the accessibility label is applied; otherwise
    ///     the accessibility label is unchanged.
    nonisolated public func accessibilityLabel<S>(_ label: S, isEnabled: Bool) -> ModifiedContent<Content, Modifier> where S : StringProtocol
}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension View {

    /// Adds a label to the view that describes its contents.
    ///
    /// Use this method to append content to the accessibility label for a view.
    /// For example, you could use this method to label a badge or alert that
    /// is custom drawn without removing the existing accessibility label.
    /// - Parameters:
    ///   - content: A view builder closure that takes a proxy
    ///     value representing the modified view. You can combine the modified
    ///     view with other content to create a new accessibility label for
    ///     the original view.
    nonisolated public func accessibilityLabel<V>(@ViewBuilder content: (_ label: PlaceholderContentView<Self>) -> V) -> some View where V : View

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension View {

    /// Adds a label to the view that describes its contents.
    ///
    /// Use this method to provide an accessibility label for a view that doesn't display text, like an icon.
    /// For example, you could use this method to label a button that plays music with the text "Play".
    /// Don't include text in the label that repeats information that users already have. For example,
    /// don't use the label "Play button" because a button already has a trait that identifies it as a button.
    nonisolated public func accessibilityLabel(_ label: Text) -> ModifiedContent<Self, AccessibilityAttachmentModifier>

    /// Adds a label to the view that describes its contents.
    ///
    /// Use this method to provide an accessibility label for a view that doesn't display text, like an icon.
    /// For example, you could use this method to label a button that plays music with the text "Play".
    /// Don't include text in the label that repeats information that users already have. For example,
    /// don't use the label "Play button" because a button already has a trait that identifies it as a button.
    nonisolated public func accessibilityLabel(_ labelKey: LocalizedStringKey) -> ModifiedContent<Self, AccessibilityAttachmentModifier>

    /// Adds a label to the view that describes its contents.
    ///
    /// Use this method to provide an accessibility label for a view that doesn't display text, like an icon.
    /// For example, you could use this method to label a button that plays music with the text "Play".
    /// Don't include text in the label that repeats information that users already have. For example,
    /// don't use the label "Play button" because a button already has a trait that identifies it as a button.
    nonisolated public func accessibilityLabel<S>(_ label: S) -> ModifiedContent<Self, AccessibilityAttachmentModifier> where S : StringProtocol
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ModifiedContent where Modifier == AccessibilityAttachmentModifier {

    /// Adds a label to the view that describes its contents.
    ///
    /// Use this method to provide an accessibility label for a view that doesn't display text, like an icon.
    /// For example, you could use this method to label a button that plays music with the text "Play".
    /// Don't include text in the label that repeats information that users already have. For example,
    /// don't use the label "Play button" because a button already has a trait that identifies it as a button.
    nonisolated public func accessibilityLabel(_ label: Text) -> ModifiedContent<Content, Modifier>

    /// Adds a label to the view that describes its contents.
    ///
    /// Use this method to provide an accessibility label for a view that doesn't display text, like an icon.
    /// For example, you could use this method to label a button that plays music with the text "Play".
    /// Don't include text in the label that repeats information that users already have. For example,
    /// don't use the label "Play button" because a button already has a trait that identifies it as a button.
    nonisolated public func accessibilityLabel(_ labelKey: LocalizedStringKey) -> ModifiedContent<Content, Modifier>

    /// Adds a label to the view that describes its contents.
    ///
    /// Use this method to provide an accessibility label for a view that doesn't display text, like an icon.
    /// For example, you could use this method to label a button that plays music with the text "Play".
    /// Don't include text in the label that repeats information that users already have. For example,
    /// don't use the label "Play button" because a button already has a trait that identifies it as a button.
    nonisolated public func accessibilityLabel<S>(_ label: S) -> ModifiedContent<Content, Modifier> where S : StringProtocol
}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension EnvironmentValues {

    /// A Boolean value that indicates whether the VoiceOver screen reader is in use.
    ///
    /// The state changes as the user turns on or off the VoiceOver screen reader.
    public var accessibilityVoiceOverEnabled: Bool { get }

    /// A Boolean value that indicates whether the Switch Control motor accessibility feature is in use.
    ///
    /// The state changes as the user turns on or off the Switch Control feature.
    public var accessibilitySwitchControlEnabled: Bool { get }
}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension EnvironmentValues {

    /// A Boolean value that indicates whether Assistive Access is in use.
    public var accessibilityAssistiveAccessEnabled: Bool { get }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// Applies an inset to the rows in a list.
    ///
    /// Use `listRowInsets(_:)` to change the default padding of the content of
    /// list items.
    ///
    /// In the example below, the `Flavor` enumeration provides content for list
    /// items. The SwiftUI ``ForEach`` structure computes views for each element
    /// of the `Flavor` enumeration and extracts the raw value of each of its
    /// elements using the resulting text to create each list row item. The
    /// `listRowInsets(_:)` modifier then changes the edge insets of each row
    /// of the list according to the ``EdgeInsets`` provided:
    ///
    ///     struct ContentView: View {
    ///         enum Flavor: String, CaseIterable, Identifiable {
    ///             var id: String { self.rawValue }
    ///             case vanilla, chocolate, strawberry
    ///         }
    ///
    ///         var body: some View {
    ///             List {
    ///                 ForEach(Flavor.allCases) {
    ///                     Text($0.rawValue)
    ///                         .listRowInsets(.init(top: 0,
    ///                                              leading: 25,
    ///                                              bottom: 0,
    ///                                              trailing: 0))
    ///                 }
    ///             }
    ///         }
    ///     }
    ///
    /// ![A screenshot showing a list with leading 25 point inset on each row.](SwiftUI-View-ListRowInsets.png)
    ///
    /// - Parameter insets: The ``EdgeInsets`` to apply to the edges of the
    ///   view.
    /// - Returns: A view that uses the given edge insets when used as a list
    ///   cell.
    @inlinable nonisolated public func listRowInsets(_ insets: EdgeInsets?) -> some View

}

@available(iOS 17.0, macOS 13.0, tvOS 17.0, watchOS 10.0, *)
@available(visionOS, unavailable)
extension View {

    /// Configures the icon used by dialogs within this view.
    ///
    /// On macOS, this icon replaces the default icon of the app.
    ///
    /// On watchOS, this icon will be shown in any dialogs presented.
    ///
    /// This modifier has no effect on other platforms.
    ///
    /// The following example configures a `confirmationDialog` with a custom image.
    ///
    ///     Button("Delete items") {
    ///         isShowingDialog = true
    ///     }
    ///     .confirmationDialog(
    ///         "Are you sure you want to erase these items?",
    ///             isPresented: $isShowingDialog
    ///     ) {
    ///         Button("Erase", role: .destructive) {
    ///             // Handle item deletion.
    ///         }
    ///         Button("Cancel", role: .cancel) {
    ///             isShowingDialog = false
    ///         }
    ///     }
    ///     .dialogIcon(Image(...))
    ///
    /// - Parameter icon: The custom icon to use for confirmation dialogs and alerts.
    ///   Passing `nil` will use the default app icon.
    nonisolated public func dialogIcon(_ icon: Image?) -> some View

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// Presents an alert to the user.
    ///
    /// Use this method when you need to show an alert that contains
    /// information from a binding to an optional data source that you provide.
    /// The example below shows a custom data source `FileInfo` whose
    /// properties configure the alert's `message` field:
    ///
    ///     struct FileInfo: Identifiable {
    ///         var id: String { name }
    ///         let name: String
    ///         let fileType: UTType
    ///     }
    ///
    ///     struct ConfirmImportAlert: View {
    ///         @State private var alertDetails: FileInfo?
    ///         var body: some View {
    ///             Button("Show Alert") {
    ///                 alertDetails = FileInfo(name: "MyImageFile.png",
    ///                                         fileType: .png)
    ///             }
    ///             .alert(item: $alertDetails) { details in
    ///                 Alert(title: Text("Import Complete"),
    ///                       message: Text("""
    ///                         Imported \(details.name) \n File
    ///                         type: \(details.fileType.description).
    ///                         """),
    ///                       dismissButton: .default(Text("Dismiss")))
    ///             }
    ///         }
    ///     }
    ///
    ///
    /// ![An alert showing information from a data source that describes the
    /// result of a file import process. The alert displays the name of the
    /// file imported, MyImageFile.png and its file type, the PNG image
    /// file format along with a default OK button for dismissing the
    /// alert.](SwiftUI-View-AlertItemContent.png)
    ///
    /// - Parameters:
    ///   - item: A binding to an optional source of truth for the alert.
    ///     if `item` is non-`nil`, the system passes the contents to
    ///     the modifier's closure. You use this content to populate the fields
    ///     of an alert that you create that the system displays to the user.
    ///     If `item` changes, the system dismisses the currently displayed
    ///     alert and replaces it with a new one using the same process.
    ///   - content: A closure returning the alert to present.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, message: "use `alert(title:isPresented:presenting::actions:) instead.")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, message: "use `alert(title:isPresented:presenting::actions:) instead.")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, message: "use `alert(title:isPresented:presenting::actions:) instead.")
    @available(watchOS, introduced: 6.0, deprecated: 100000.0, message: "use `alert(title:isPresented:presenting::actions:) instead.")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "use `alert(title:isPresented:presenting::actions:) instead.")
    nonisolated public func alert<Item>(item: Binding<Item?>, content: (Item) -> Alert) -> some View where Item : Identifiable


    /// Presents an alert to the user.
    ///
    /// Use this method when you need to show an alert to the user. The example
    /// below displays an alert that is shown when the user toggles a
    /// Boolean value that controls the presentation of the alert:
    ///
    ///     struct OrderCompleteAlert: View {
    ///         @State private var isPresented = false
    ///         var body: some View {
    ///             Button("Show Alert", action: {
    ///                 isPresented = true
    ///             })
    ///             .alert(isPresented: $isPresented) {
    ///                 Alert(title: Text("Order Complete"),
    ///                       message: Text("Thank you for shopping with us."),
    ///                       dismissButton: .default(Text("OK")))
    ///             }
    ///         }
    ///     }
    ///
    /// ![An alert whose title reads Order Complete, with the
    /// message, Thank you for shopping with us placed underneath. The alert
    /// also includes an OK button for dismissing the
    /// alert.](SwiftUI-View-AlertIsPresentedContent.png)
    /// - Parameters:
    ///   - isPresented: A binding to a Boolean value that determines whether
    ///     to present the alert that you create in the modifier's `content` closure. When the
    ///      user presses or taps OK the system sets `isPresented` to `false`
    ///     which dismisses the alert.
    ///   - content: A closure returning the alert to present.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, message: "use `alert(title:isPresented:presenting::actions:) instead.")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, message: "use `alert(title:isPresented:presenting::actions:) instead.")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, message: "use `alert(title:isPresented:presenting::actions:) instead.")
    @available(watchOS, introduced: 6.0, deprecated: 100000.0, message: "use `alert(title:isPresented:presenting::actions:) instead.")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "use `alert(title:isPresented:presenting::actions:) instead.")
    nonisolated public func alert(isPresented: Binding<Bool>, content: () -> Alert) -> some View

}

@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension EnvironmentValues {

    /// A Boolean value that indicates whether the current platform supports
    /// opening multiple windows.
    ///
    /// Read this property from the environment to determine if your app can
    /// use the ``EnvironmentValues/openWindow`` action to open new windows:
    ///
    ///     struct NewMailViewerButton: View {
    ///         @Environment(\.supportsMultipleWindows) private var supportsMultipleWindows
    ///         @Environment(\.openWindow) private var openWindow
    ///
    ///         var body: some View {
    ///             Button("Open New Window") {
    ///                 openWindow(id: "mail-viewer")
    ///             }
    ///             .disabled(!supportsMultipleWindows)
    ///         }
    ///     }
    ///
    /// The reported value depends on both the platform and how you configure
    /// your app:
    ///
    /// * In macOS, this property returns `true` for any app that uses the
    ///   SwiftUI app lifecycle.
    /// * In iPadOS, this property returns `true` for any app that uses the
    ///   SwiftUI app lifecycle and has the Information Property List key
    /// <doc://com.apple.documentation/documentation/bundleresources/information_property_list/uiapplicationscenemanifest/uiapplicationsupportsmultiplescenes> set to `true`.
    /// * For all other platforms and configurations, the value returns `false`.
    ///
    /// If the value is false and you try to open a window, SwiftUI
    /// ignores the action and logs a runtime error.
    public var supportsMultipleWindows: Bool { get }
}

extension View {

    /// Sets the scroll behavior of views scrollable in the provided axes.
    ///
    /// A scrollable view calculates where scroll gestures should end using its
    /// deceleration rate and the state of its scroll gesture by default. A
    /// scroll behavior allows for customizing this logic. You can provide
    /// your own ``ScrollTargetBehavior`` or use one of the built in behaviors
    /// provided by SwiftUI.
    ///
    /// ### Paging Behavior
    ///
    /// SwiftUI offers a ``PagingScrollTargetBehavior`` behavior which uses the
    /// geometry of the scroll view to decide where to allow scrolls to end.
    ///
    /// In the following example, every view in the lazy stack is flexible
    /// in both directions and the scroll view will settle to container aligned
    /// boundaries.
    ///
    ///     ScrollView {
    ///         LazyVStack(spacing: 0.0) {
    ///             ForEach(items) { item in
    ///                 FullScreenItem(item)
    ///             }
    ///         }
    ///     }
    ///     .scrollTargetBehavior(.paging)
    ///
    /// ### View Aligned Behavior
    ///
    /// SwiftUI offers a ``ViewAlignedScrollTargetBehavior`` scroll behavior
    /// that will always settle on the geometry of individual views.
    ///
    ///     ScrollView(.horizontal) {
    ///         LazyHStack(spacing: 10.0) {
    ///             ForEach(items) { item in
    ///                 ItemView(item)
    ///             }
    ///         }
    ///         .scrollTargetLayout()
    ///     }
    ///     .scrollTargetBehavior(.viewAligned)
    ///     .safeAreaPadding(.horizontal, 20.0)
    ///
    /// You configure which views should be used for settling using the
    /// ``View/scrollTargetLayout(isEnabled:)`` modifier. Apply this modifier to
    /// a layout container like ``LazyVStack`` or ``HStack`` and each individual
    /// view in that layout will be considered for alignment.
    @available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
    nonisolated public func scrollTargetBehavior(_ behavior: some ScrollTargetBehavior) -> some View

}

extension View {

    /// Configures the outermost layout as a scroll target layout.
    ///
    /// This modifier works together with the
    /// ``ViewAlignedScrollTargetBehavior`` to ensure that scroll views align
    /// to view based content.
    ///
    /// Apply this modifier to layout containers like ``LazyHStack`` or
    /// ``VStack`` within a ``ScrollView`` that contain the main repeating
    /// content of your ``ScrollView``.
    ///
    ///     ScrollView(.horizontal) {
    ///         LazyHStack(spacing: 10.0) {
    ///             ForEach(items) { item in
    ///                 ItemView(item)
    ///             }
    ///         }
    ///         .scrollTargetLayout()
    ///     }
    ///     .scrollTargetBehavior(.viewAligned)
    ///
    /// Scroll target layouts act as a convenience for applying a
    /// ``View/scrollTarget(isEnabled:)`` modifier to each views in
    /// the layout.
    ///
    /// A scroll target layout will ensure that any target layout
    /// nested within the primary one will not also become a scroll
    /// target layout.
    ///
    ///     LazyHStack { // a scroll target layout
    ///         VStack { ... } // not a scroll target layout
    ///         LazyHStack { ... } // also not a scroll target layout
    ///     }
    ///     .scrollTargetLayout()
    ///
    @available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
    nonisolated public func scrollTargetLayout(isEnabled: Bool = true) -> some View

}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension EnvironmentValues {

    /// An action that dismisses the current presentation.
    ///
    /// Use this environment value to get the ``DismissAction`` instance
    /// for the current ``Environment``. Then call the instance
    /// to perform the dismissal. You call the instance directly because
    /// it defines a ``DismissAction/callAsFunction()``
    /// method that Swift calls when you call the instance.
    ///
    /// You can use this action to:
    ///  * Dismiss a modal presentation, like a sheet or a popover.
    ///  * Pop the current view from a ``NavigationStack``.
    ///
    ///  On apps targetting iOS 18 and aligned releases, you also use the
    ///  dismiss action to pop the implicit stack of a collapsed
    ///  ``NavigationSplitView``, or clear the equivalent state in an expanded
    ///  split view.
    ///
    /// The specific behavior of the action depends on where you call it from.
    /// For example, you can create a button that calls the ``DismissAction``
    /// inside a view that acts as a sheet:
    ///
    ///     private struct SheetContents: View {
    ///         @Environment(\.dismiss) private var dismiss
    ///
    ///         var body: some View {
    ///             Button("Done") {
    ///                 dismiss()
    ///             }
    ///         }
    ///     }
    ///
    /// When you present the `SheetContents` view, someone can dismiss
    /// the sheet by tapping or clicking the sheet's button:
    ///
    ///     private struct DetailView: View {
    ///         @State private var isSheetPresented = false
    ///
    ///         var body: some View {
    ///             Button("Show Sheet") {
    ///                 isSheetPresented = true
    ///             }
    ///             .sheet(isPresented: $isSheetPresented) {
    ///                 SheetContents()
    ///             }
    ///         }
    ///     }
    ///
    /// Be sure that you define the action in the appropriate environment.
    /// For example, don't reorganize the `DetailView` in the example above
    /// so that it creates the `dismiss` property and calls it from the
    /// ``View/sheet(item:onDismiss:content:)`` view modifier's `content`
    /// closure:
    ///
    ///     private struct DetailView: View {
    ///         @State private var isSheetPresented = false
    ///         @Environment(\.dismiss) private var dismiss // Applies to DetailView.
    ///
    ///         var body: some View {
    ///             Button("Show Sheet") {
    ///                 isSheetPresented = true
    ///             }
    ///             .sheet(isPresented: $isSheetPresented) {
    ///                 Button("Done") {
    ///                     dismiss() // Fails to dismiss the sheet.
    ///                 }
    ///             }
    ///         }
    ///     }
    ///
    /// If you do this, the sheet fails to dismiss because the action applies
    /// to the environment where you declared it, which is that of the detail
    /// view, rather than the sheet. In fact, in macOS and iPadOS, if the
    /// `DetailView` is the root view of a window, the dismiss action closes
    /// the window instead.
    ///
    /// The dismiss action has no effect on a view that isn't currently
    /// presented. If you need to query whether SwiftUI is currently presenting
    /// a view, read the ``EnvironmentValues/isPresented`` environment value.
    ///
    /// - Note: While the dismiss action can be used to a close window that you
    ///   create with ``WindowGroup`` or ``Window``, prefer
    ///   ``DismissWindowAction`` for that use case instead.
    public var dismiss: DismissAction { get }

    /// A Boolean value that indicates whether the view associated with this
    /// environment is currently presented.
    ///
    /// You can read this value like any of the other ``EnvironmentValues``
    /// by creating a property with the ``Environment`` property wrapper:
    ///
    ///     @Environment(\.isPresented) private var isPresented
    ///
    /// Read the value inside a view if you need to know when SwiftUI
    /// presents that view. For example, you can take an action when SwiftUI
    /// presents a view by using the ``View/onChange(of:initial:_:)``
    /// modifier:
    ///
    ///     .onChange(of: isPresented) { _, isPresented in
    ///         if isPresented {
    ///             // Do something when first presented.
    ///         }
    ///     }
    ///
    /// This behaves differently than ``View/onAppear(perform:)``, which
    /// SwiftUI can call more than once for a given presentation, like
    /// when you navigate back to a view that's already in the
    /// navigation hierarchy.
    ///
    /// To dismiss the currently presented view, use
    /// ``EnvironmentValues/dismiss``.
    public var isPresented: Bool { get }
}

extension View {

    /// Positions this view within an invisible frame with a size relative
    /// to the nearest container.
    ///
    /// Use this modifier to specify a size for a view's width, height,
    /// or both that is dependent on the size of the nearest container.
    /// Different things can represent a "container" including:
    ///   - The window presenting a view on iPadOS or macOS, or the
    ///     screen of a device on iOS.
    ///   - A column of a NavigationSplitView
    ///   - A NavigationStack
    ///   - A tab of a TabView
    ///   - A scrollable view like ScrollView or List
    ///
    /// The size provided to this modifier is the size of a container like
    /// the ones listed above subtracting any safe area insets that might
    /// be applied to that container.
    ///
    /// The following example will have each purple rectangle occupy the full
    /// size of the screen on iOS:
    ///
    ///     ScrollView(.horizontal) {
    ///         LazyHStack(spacing: 0.0) {
    ///             ForEach(items) { item in
    ///                 Rectangle()
    ///                     .fill(.purple)
    ///                     .containerRelativeFrame([.horizontal, .vertical])
    ///             }
    ///         }
    ///     }
    ///
    /// Use the ``View/containerRelativeFrame(_:count:span:spacing:alignment:)``
    /// modifier to size a view such that multiple views will be visible in
    /// the container. When using this modifier, the count refers to the
    /// total number of rows or columns that the length of the container size
    /// in a particular axis should be divided into. The span refers to the
    /// number of rows or columns that the modified view should actually
    /// occupy. Thus the size of the element can be described like so:
    ///
    ///     let availableWidth = (containerWidth - (spacing * (count - 1)))
    ///     let columnWidth = (availableWidth / count)
    ///     let itemWidth = (columnWidth * span) + ((span - 1) * spacing)
    ///
    /// The following example only uses the nearest container size in the
    /// horizontal axis, allowing the vertical axis to be determined using
    /// the ``View/aspectRatio(_:contentMode:)`` modifier.
    ///
    ///     ScrollView(.horizontal) {
    ///         LazyHStack(spacing: 10.0) {
    ///             ForEach(items) { item in
    ///                 Rectangle()
    ///                     .fill(.purple)
    ///                     .aspectRatio(3.0 / 2.0, contentMode: .fit)
    ///                     .containerRelativeFrame(
    ///                         .horizontal, count: 4, span: 3, spacing: 10.0)
    ///             }
    ///         }
    ///     }
    ///     .safeAreaPadding(.horizontal, 20.0)
    ///
    /// Use the ``View/containerRelativeFrame(_:alignment:_:)``
    /// modifier to apply your own custom logic to adjust the size
    /// of the nearest container for your view. The following example will
    /// result in the container frame's width being divided by 3 and using
    /// that value as the width of the purple rectangle.
    ///
    ///     Rectangle()
    ///         .fill(.purple)
    ///         .aspectRatio(1.0, contentMode: .fill)
    ///         .containerRelativeFrame(
    ///             .horizontal, alignment: .topLeading
    ///         ) { length, axis in
    ///             if axis == .vertical {
    ///                 return length / 3.0
    ///             } else {
    ///                 return length / 5.0
    ///             }
    ///         }
    ///
    @available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
    nonisolated public func containerRelativeFrame(_ axes: Axis.Set, alignment: Alignment = .center) -> some View


    /// Positions this view within an invisible frame with a size relative
    /// to the nearest container.
    ///
    /// Use the ``View/containerRelativeFrame(_:alignment:)`` modifier
    /// to specify a size for a view's width, height, or both that
    /// is dependent on the size of the nearest container. Different
    /// things can represent a "container" including:
    ///   - The window presenting a view on iPadOS or macOS, or the
    ///     screen of a device on iOS.
    ///   - A column of a NavigationSplitView
    ///   - A NavigationStack
    ///   - A tab of a TabView
    ///   - A scrollable view like ScrollView or List
    ///
    /// The size provided to this modifier is the size of a container like
    /// the ones listed above subtracting any safe area insets that might
    /// be applied to that container.
    ///
    /// The following example will have each purple rectangle occupy the full
    /// size of the screen on iOS:
    ///
    ///     ScrollView(.horizontal) {
    ///         LazyHStack(spacing: 0.0) {
    ///             ForEach(items) { item in
    ///                 Rectangle()
    ///                     .fill(.purple)
    ///                     .containerRelativeFrame([.horizontal, .vertical])
    ///             }
    ///         }
    ///     }
    ///
    /// Use this modifier to size a view such that multiple views will be
    /// visible in the container. When using this modifier, the count refers
    /// to the total number of rows or columns that the length of the
    /// container size in a particular axis should be divided into. The span
    /// refers to the number of rows or columns that the modified view
    /// should actually occupy. Thus the size of the element can be
    /// described like so:
    ///
    ///     let availableWidth = (containerWidth - (spacing * (count - 1)))
    ///     let columnWidth = (availableWidth / count)
    ///     let itemWidth = (columnWidth * span) + ((span - 1) * spacing)
    ///
    /// The following example only uses the nearest container size in the
    /// horizontal axis, allowing the vertical axis to be determined using
    /// the ``View/aspectRatio(_:contentMode:)`` modifier.
    ///
    ///     ScrollView(.horizontal) {
    ///         LazyHStack(spacing: 10.0) {
    ///             ForEach(items) { item in
    ///                 Rectangle()
    ///                     .fill(.purple)
    ///                     .aspectRatio(3.0 / 2.0, contentMode: .fit)
    ///                     .containerRelativeFrame(
    ///                         .horizontal, count: 4, span: 3, spacing: 10.0)
    ///             }
    ///         }
    ///     }
    ///     .safeAreaPadding(.horizontal, 20.0)
    ///
    /// Use the ``View/containerRelativeFrame(_:alignment:_:)``
    /// modifier to apply your own custom logic to adjust the size
    /// of the nearest container for your view. The following example will
    /// result in the container frame's width being divided by 3 and using
    /// that value as the width of the purple rectangle.
    ///
    ///     Rectangle()
    ///         .fill(.purple)
    ///         .aspectRatio(1.0, contentMode: .fill)
    ///         .containerRelativeFrame(
    ///             .horizontal, alignment: .topLeading
    ///         ) { length, axis in
    ///             if axis == .vertical {
    ///                 return length / 3.0
    ///             } else {
    ///                 return length / 5.0
    ///             }
    ///         }
    ///
    @available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
    nonisolated public func containerRelativeFrame(_ axes: Axis.Set, count: Int, span: Int = 1, spacing: CGFloat, alignment: Alignment = .center) -> some View


    /// Positions this view within an invisible frame with a size relative
    /// to the nearest container.
    ///
    /// Use the ``View/containerRelativeFrame(_:alignment:)`` modifier
    /// to specify a size for a view's width, height, or both that
    /// is dependent on the size of the nearest container. Different
    /// things can represent a "container" including:
    ///   - The window presenting a view on iPadOS or macOS, or the
    ///     screen of a device on iOS.
    ///   - A column of a NavigationSplitView
    ///   - A NavigationStack
    ///   - A tab of a TabView
    ///   - A scrollable view like ScrollView or List
    ///
    /// The size provided to this modifier is the size of a container like
    /// the ones listed above subtracting any safe area insets that might
    /// be applied to that container.
    ///
    /// The following example will have each purple rectangle occupy the full
    /// size of the screen on iOS:
    ///
    ///     ScrollView(.horizontal) {
    ///         LazyHStack(spacing: 0.0) {
    ///             ForEach(items) { item in
    ///                 Rectangle()
    ///                     .fill(.purple)
    ///                     .containerRelativeFrame([.horizontal, .vertical])
    ///             }
    ///         }
    ///     }
    ///
    /// Use the ``View/containerRelativeFrame(_:count:spacing:alignment:)``
    /// modifier to size a view such that multiple views will be
    /// visible in the container. When using this modifier, the count
    /// refers to the total number of rows or columns that the length of
    /// the container size in a particular axis should be divided into.
    /// The span refers to the number of rows or columns that the modified
    /// view should actually occupy. Thus the size of the element can
    /// be described like so:
    ///
    ///     let availableWidth = (containerWidth - (spacing * (count - 1)))
    ///     let columnWidth = (availableWidth / count)
    ///     let itemWidth = (columnWidth * span) + ((span - 1) * spacing)
    ///
    /// The following example only uses the nearest container size in the
    /// horizontal axis, allowing the vertical axis to be determined using
    /// the ``View/aspectRatio(_:contentMode:)`` modifier.
    ///
    ///     ScrollView(.horizontal) {
    ///         LazyHStack(spacing: 10.0) {
    ///             ForEach(items) { item in
    ///                 Rectangle()
    ///                     .fill(.purple)
    ///                     .aspectRatio(3.0 / 2.0, contentMode: .fit)
    ///                     .containerRelativeFrame(
    ///                         .horizontal, count: 4, span: 3, spacing: 10.0)
    ///             }
    ///         }
    ///     }
    ///     .safeAreaPadding(.horizontal, 20.0)
    ///
    /// Use this modifier to apply your own custom logic to adjust the size
    /// of the nearest container for your view. The following example will
    /// result in the container frame's width being divided by 3 and using
    /// that value as the width of the purple rectangle.
    ///
    ///     Rectangle()
    ///         .fill(.purple)
    ///         .aspectRatio(1.0, contentMode: .fill)
    ///         .containerRelativeFrame(
    ///             .horizontal, alignment: .topLeading
    ///         ) { length, axis in
    ///             if axis == .vertical {
    ///                 return length / 3.0
    ///             } else {
    ///                 return length / 5.0
    ///             }
    ///         }
    ///
    @available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
    nonisolated public func containerRelativeFrame(_ axes: Axis.Set, alignment: Alignment = .center, _ length: @escaping (CGFloat, Axis) -> CGFloat) -> some View

}

@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension View {

    /// Associates a destination view with a presented data type for use within
    /// a navigation stack.
    ///
    /// Add this view modifier to a view inside a ``NavigationStack`` to
    /// describe the view that the stack displays when presenting
    /// a particular kind of data. Use a ``NavigationLink`` to present
    /// the data. For example, you can present a `ColorDetail` view for
    /// each presentation of a ``Color`` instance:
    ///
    ///     NavigationStack {
    ///         List {
    ///             NavigationLink("Mint", value: Color.mint)
    ///             NavigationLink("Pink", value: Color.pink)
    ///             NavigationLink("Teal", value: Color.teal)
    ///         }
    ///         .navigationDestination(for: Color.self) { color in
    ///             ColorDetail(color: color)
    ///         }
    ///         .navigationTitle("Colors")
    ///     }
    ///
    /// You can add more than one navigation destination modifier to the stack
    /// if it needs to present more than one kind of data.
    ///
    /// Do not put a navigation destination modifier inside a "lazy" container,
    /// like ``List`` or ``LazyVStack``. These containers create child views
    /// only when needed to render on screen. Add the navigation destination
    /// modifier outside these containers so that the navigation stack can
    /// always see the destination.
    ///
    /// - Parameters:
    ///   - data: The type of data that this destination matches.
    ///   - destination: A view builder that defines a view to display
    ///     when the stack's navigation state contains a value of
    ///     type `data`. The closure takes one argument, which is the value
    ///     of the data to present.
    nonisolated public func navigationDestination<D, C>(for data: D.Type, @ViewBuilder destination: @escaping (D) -> C) -> some View where D : Hashable, C : View


    /// Associates a destination view with a binding that can be used to push
    /// the view onto a ``NavigationStack``.
    ///
    /// In general, favor binding a path to a navigation stack for programmatic
    /// navigation. Add this view modifier to a view inside a ``NavigationStack``
    /// to programmatically push a single view onto the stack. This is useful
    /// for building components that can push an associated view. For example,
    /// you can present a `ColorDetail` view for a particular color:
    ///
    ///     @State private var showDetails = false
    ///     var favoriteColor: Color
    ///
    ///     NavigationStack {
    ///         VStack {
    ///             Circle()
    ///                 .fill(favoriteColor)
    ///             Button("Show details") {
    ///                 showDetails = true
    ///             }
    ///         }
    ///         .navigationDestination(isPresented: $showDetails) {
    ///             ColorDetail(color: favoriteColor)
    ///         }
    ///         .navigationTitle("My Favorite Color")
    ///     }
    ///
    /// Do not put a navigation destination modifier inside a "lazy" container,
    /// like ``List`` or ``LazyVStack``. These containers create child views
    /// only when needed to render on screen. Add the navigation destination
    /// modifier outside these containers so that the navigation stack can
    /// always see the destination.
    ///
    /// - Parameters:
    ///   - isPresented: A binding to a Boolean value that indicates whether
    ///     `destination` is currently presented.
    ///   - destination: A view to present.
    nonisolated public func navigationDestination<V>(isPresented: Binding<Bool>, @ViewBuilder destination: () -> V) -> some View where V : View

}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension View {

    /// Associates a destination view with a bound value for use within a
    /// navigation stack or navigation split view
    ///
    /// Add this view modifier to a view inside a ``NavigationStack`` or
    /// ``NavigationSplitView`` to describe the view that the stack displays
    /// when presenting a particular kind of data. Programmatically update
    /// the binding to display or remove the view. For example, you can replace
    /// the view showing in the detail column of a navigation split view:
    ///
    ///     @State private var colorShown: Color?
    ///
    ///     NavigationSplitView {
    ///         List {
    ///             Button("Mint") { colorShown = .mint }
    ///             Button("Pink") { colorShown = .pink }
    ///             Button("Teal") { colorShown = .teal }
    ///         }
    ///         .navigationDestination(item: $colorShown) { color in
    ///             ColorDetail(color: color)
    ///         }
    ///     } detail: {
    ///         Text("Select a color")
    ///     }
    ///
    /// When the person using the app taps on the Mint button, the mint color
    /// shows in the detail and `colorShown` gets the value `Color.mint`. You
    /// can reset the navigation split view to show the message "Select a color"
    /// by setting `colorShown` back to `nil`.
    ///
    /// You can add more than one navigation destination modifier to the stack
    /// if it needs to present more than one kind of data.
    ///
    /// Do not put a navigation destination modifier inside a "lazy" container,
    /// like ``List`` or ``LazyVStack``. These containers create child views
    /// only when needed to render on screen. Add the navigation destination
    /// modifier outside these containers so that the navigation split view can
    /// always see the destination.
    ///
    /// - Parameters:
    ///   - item: A binding to the data presented, or `nil` if nothing is
    ///     currently presented.
    ///   - destination: A view builder that defines a view to display
    ///     when `item` is not `nil`.
    nonisolated public func navigationDestination<D, C>(item: Binding<D?>, @ViewBuilder destination: @escaping (D) -> C) -> some View where D : Hashable, C : View

}

extension View {

    /// Specifies the Writing Tools behavior for text and text input in the
    /// environment.
    ///
    /// Use this view modifier to customize or disable the Writing Tools editing
    /// experience for ``Text`` (when selectable), ``TextField``, and
    /// ``TextEditor`` views.
    ///
    /// Parameters:
    /// - Parameter behavior: The Writing Tools behavior for text and text input in the
    ///   environment.
    ///
    /// - Returns: A view preferring the specified Writing Tools behavior.
    @available(iOS 18.0, macOS 15.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    @available(visionOS, unavailable)
    @MainActor @inlinable @preconcurrency public func writingToolsBehavior(_ behavior: WritingToolsBehavior) -> some View

}

@available(iOS 15.0, macOS 12.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension View {

    /// Controls whether people can select text within this view.
    ///
    /// People sometimes need to copy useful information from ``Text`` views ---
    /// including error messages, serial numbers, or IP addresses --- so they
    /// can then paste the text into another context. Enable text selection
    /// to let people select text in a platform-appropriate way.
    ///
    /// You can apply this method to an individual text view, or to a
    /// container to make each contained text view selectable. In the following
    /// example, the person using the app can select text that shows the date of
    /// an event or the name or email of any of the event participants:
    ///
    ///     var body: some View {
    ///         VStack {
    ///             Text("Event Invite")
    ///                 .font(.title)
    ///             Text(invite.date.formatted(date: .long, time: .shortened))
    ///                 .textSelection(.enabled)
    ///
    ///             List(invite.recipients) { recipient in
    ///                 VStack (alignment: .leading) {
    ///                     Text(recipient.name)
    ///                     Text(recipient.email)
    ///                         .foregroundStyle(.secondary)
    ///                 }
    ///             }
    ///             .textSelection(.enabled)
    ///         }
    ///         .navigationTitle("New Invitation")
    ///     }
    ///
    /// On macOS, people use the mouse or trackpad to select a range of text,
    /// which they can quickly copy by choosing Edit > Copy, or with the
    /// standard keyboard shortcut.
    ///
    /// ![A macOS window titled New Invitation, with header Event Invite and
    /// the date and time of the event below it. The date --- July 31, 2022 ---
    /// is selected. Below this, a list of invitees by name and
    /// email.](View-textSelection-1)
    ///
    /// On iOS, the person using the app touches and holds on a selectable
    /// `Text` view, which brings up a system menu with menu items appropriate
    /// for the current context. These menu items operate on the entire contents
    /// of the `Text` view; the person can't select a range of text like they
    /// can on macOS.
    ///
    /// ![A portion of an iOS view, with header Event Invite and
    /// the date and time of the event below it. Below the date and time, a
    /// menu shows two items: Copy and Share. Below this, a list of invitees by
    /// name and email.](View-textSelection-2)
    ///
    /// - Note: ``Button`` views don't support text selection.
    nonisolated public func textSelection<S>(_ selectability: S) -> some View where S : TextSelectability

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// Adds an accessibility adjustable action to the view. Actions allow
    /// assistive technologies, such as the VoiceOver, to interact with the
    /// view by invoking the action.
    ///
    /// For example, this is how an adjustable action to navigate
    /// through pages could be added to a view.
    ///
    ///     var body: some View {
    ///         PageControl()
    ///             .accessibilityAdjustableAction { direction in
    ///                 switch direction {
    ///                 case .increment:
    ///                     // Go to next page
    ///                 case .decrement:
    ///                     // Go to previous page
    ///                 }
    ///             }
    ///     }
    ///
    nonisolated public func accessibilityAdjustableAction(_ handler: @escaping (AccessibilityAdjustmentDirection) -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension ModifiedContent where Modifier == AccessibilityAttachmentModifier {

    /// Adds an accessibility adjustable action to the view. Actions allow
    /// assistive technologies, such as the VoiceOver, to interact with the
    /// view by invoking the action.
    ///
    /// For example, this is how an adjustable action to navigate
    /// through pages could be added to a view.
    ///
    ///     var body: some View {
    ///         PageControl()
    ///             .accessibilityAdjustableAction { direction in
    ///                 switch direction {
    ///                 case .increment:
    ///                     // Go to next page
    ///                 case .decrement:
    ///                     // Go to previous page
    ///                 }
    ///             }
    ///     }
    ///
    nonisolated public func accessibilityAdjustableAction(_ handler: @escaping (AccessibilityAdjustmentDirection) -> Void) -> ModifiedContent<Content, Modifier>
}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension Text {

    /// Sets an accessibility text content type.
    ///
    /// Use this modifier to set the content type of this accessibility
    /// element. Assistive technologies can use this property to choose
    /// an appropriate way to output the text. For example, when
    /// encountering a source coding context, VoiceOver could
    /// choose to speak all punctuation.
    ///
    /// If you don't set a value with this method, the default content type
    /// is ``AccessibilityTextContentType/plain``.
    ///
    /// - Parameter value: The accessibility content type from the available
    /// ``AccessibilityTextContentType`` options.
    nonisolated public func accessibilityTextContentType(_ value: AccessibilityTextContentType) -> Text

    /// Sets the accessibility level of this heading.
    ///
    /// Use this modifier to set the level of this heading in relation to other headings. The system speaks
    /// the level number of levels ``AccessibilityHeadingLevel/h1`` through
    /// ``AccessibilityHeadingLevel/h6`` alongside the text.
    ///
    /// The default heading level if you don't use this modifier
    /// is ``AccessibilityHeadingLevel/unspecified``.
    ///
    /// - Parameter level: The heading level to associate with this element
    ///   from the available ``AccessibilityHeadingLevel`` levels.
    nonisolated public func accessibilityHeading(_ level: AccessibilityHeadingLevel) -> Text

    /// Adds a label to the view that describes its contents.
    ///
    /// Use this method to provide an alternative accessibility label
    /// to the text that is displayed. For example, you can give an alternate label to a navigation title:
    ///
    ///     var body: some View {
    ///         NavigationView {
    ///             ContentView()
    ///                 .navigationTitle(Text("").accessibilityLabel("Inbox"))
    ///         }
    ///     }
    ///
    /// You can't style the label that you add
    ///
    /// - Parameter label: The text view to add the label to.
    nonisolated public func accessibilityLabel(_ label: Text) -> Text

    /// Adds a label to the view that describes its contents.
    ///
    /// Use this method to provide an alternative accessibility label to the text that is displayed.
    /// For example, you can give an alternate label to a navigation title:
    ///
    ///     var body: some View {
    ///         NavigationView {
    ///             ContentView()
    ///                 .navigationTitle(Text("").accessibilityLabel("Inbox"))
    ///         }
    ///     }
    ///
    /// - Parameter labelKey: The string key for the alternative
    ///   accessibility label.
    nonisolated public func accessibilityLabel(_ labelKey: LocalizedStringKey) -> Text

    /// Adds a label to the view that describes its contents.
    ///
    /// Use this method to provide an alternative accessibility label to the text that is displayed.
    /// For example, you can give an alternate label to a navigation title:
    ///
    ///     var body: some View {
    ///         NavigationView {
    ///             ContentView()
    ///                 .navigationTitle(Text("").accessibilityLabel("Inbox"))
    ///         }
    ///     }
    ///
    /// - Parameter label: The string for the alternative accessibility label.
    nonisolated public func accessibilityLabel<S>(_ label: S) -> Text where S : StringProtocol
}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension View {

    /// Sets an accessibility text content type.
    ///
    /// Use this modifier to set the content type of this accessibility
    /// element. Assistive technologies can use this property to choose
    /// an appropriate way to output the text. For example, when
    /// encountering a source coding context, VoiceOver could
    /// choose to speak all punctuation.
    ///
    /// The default content type ``AccessibilityTextContentType/plain``.
    ///
    /// - Parameter value: The accessibility content type from the available
    /// ``AccessibilityTextContentType`` options.
    nonisolated public func accessibilityTextContentType(_ value: AccessibilityTextContentType) -> ModifiedContent<Self, AccessibilityAttachmentModifier>

    /// Sets the accessibility level of this heading.
    ///
    /// Use this modifier to set the level of this heading in relation to other headings. The system speaks
    /// the level number of levels ``AccessibilityHeadingLevel/h1`` through
    ///  ``AccessibilityHeadingLevel/h6`` alongside the text.
    ///
    /// The default heading level if you dont use this modifier
    /// is ``AccessibilityHeadingLevel/unspecified``.
    ///
    /// - Parameter level: The heading level to associate with this element
    ///   from the available ``AccessibilityHeadingLevel`` levels.
    nonisolated public func accessibilityHeading(_ level: AccessibilityHeadingLevel) -> ModifiedContent<Self, AccessibilityAttachmentModifier>
}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension ModifiedContent where Modifier == AccessibilityAttachmentModifier {

    /// Sets an accessibility text content type.
    ///
    /// Use this modifier to set the content type of this accessibility
    /// element. Assistive technologies can use this property to choose
    /// an appropriate way to output the text. For example, when
    /// encountering a source coding context, VoiceOver could
    /// choose to speak all punctuation.
    ///
    /// The default content type ``AccessibilityTextContentType/plain``.
    ///
    /// - Parameter value: The accessibility content type from the available
    /// ``AccessibilityTextContentType`` options.
    nonisolated public func accessibilityTextContentType(_ textContentType: AccessibilityTextContentType) -> ModifiedContent<Content, Modifier>

    /// Set the level of this heading.
    ///
    /// Use this modifier to set the level of this heading in relation to other headings. The system speaks
    ///  the level number of levels ``AccessibilityHeadingLevel/h1``
    ///  through ``AccessibilityHeadingLevel/h6`` alongside the text.
    ///
    /// The default heading level if you dont use this modifier
    /// is ``AccessibilityHeadingLevel/unspecified``.
    ///
    /// - Parameter level: The heading level to associate with this element
    ///   from the available ``AccessibilityHeadingLevel`` levels.
    nonisolated public func accessibilityHeading(_ level: AccessibilityHeadingLevel) -> ModifiedContent<Content, Modifier>
}

@available(iOS 13.0, tvOS 13.0, watchOS 6.0, *)
@available(macOS, unavailable)
extension Image {

    /// Creates a SwiftUI image from a UIKit image instance.
    /// - Parameter uiImage: The UIKit image to wrap with a SwiftUI ``Image``
    /// instance.
    public init(uiImage: UIImage)
}

@available(iOS 18.0, macOS 15.0, visionOS 2.0, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
extension View {

    /// Configures whether gestures in this view hierarchy can handle events
    /// that activate the containing window.
    ///
    /// Views higher in the hierarchy can override the value you set on this
    /// view. In the following example, the tap gesture on the `Rectangle` won't
    /// handle events that activate the containing window because the outer
    /// `allowsWindowActivationEvents(_:)` view modifier overrides the
    /// inner one:
    ///
    /// ```
    /// HStack {
    ///     Rectangle()
    ///         .onTapGesture { ... }
    ///         .allowsWindowActivationEvents(true)
    /// }
    /// .allowsWindowActivationEvents(false)
    /// ```
    ///
    /// > Note: Its only possible to disallow handling events that activate the
    /// > containing window for views that allow it by default or that inherit
    /// > this behavior from their ancestors. Views that explicitly already
    /// > disallow this functionality cant have it turned on.
    ///
    /// - Parameters:
    ///     - value: A Boolean value that indicates whether gestures in this
    ///       view hierarchy can handle events that activate the containing
    ///       window. If `nil`, or if the modifier is not present, the behavior
    ///       will be inherited from the views ancestors.
    nonisolated public func allowsWindowActivationEvents(_ value: Bool? = true) -> some View

}

@available(iOS 18.1, macOS 15.1, tvOS 18.1, watchOS 11.1, visionOS 2.1, *)
extension View {

    /// Creates an accessibility element only visible to automation clients.
    nonisolated public func automationElement() -> some View

}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
@available(visionOS, unavailable)
extension View {

    /// Plays the specified `feedback` when the provided `trigger` value
    /// changes.
    ///
    /// For example, you could play feedback when a state value changes:
    ///
    ///     struct MyView: View {
    ///         @State private var showAccessory = false
    ///
    ///         var body: some View {
    ///             ContentView()
    ///                 .sensoryFeedback(.selection, trigger: showAccessory)
    ///                 .onLongPressGesture {
    ///                     showAccessory.toggle()
    ///                 }
    ///
    ///             if showAccessory {
    ///                 AccessoryView()
    ///             }
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - feedback: Which type of feedback to play.
    ///   - trigger: A value to monitor for changes to determine when to play.
    nonisolated public func sensoryFeedback<T>(_ feedback: SensoryFeedback, trigger: T) -> some View where T : Equatable


    /// Plays the specified `feedback` when the provided `trigger` value changes
    /// and the `condition` closure returns `true`.
    ///
    /// For example, you could play feedback for certain state transitions:
    ///
    ///     struct MyView: View {
    ///         @State private var phase = Phase.inactive
    ///
    ///         var body: some View {
    ///             ContentView(phase: $phase)
    ///                 .sensoryFeedback(.selection, trigger: phase) { old, new in
    ///                     old == .inactive || new == .expanded
    ///                 }
    ///         }
    ///
    ///         enum Phase {
    ///             case inactive
    ///             case preparing
    ///             case active
    ///             case expanded
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - feedback: Which type of feedback to play.
    ///   - trigger: A value to monitor for changes to determine when to play.
    ///   - condition: A closure to determine whether to play the feedback when
    ///     `trigger` changes.
    nonisolated public func sensoryFeedback<T>(_ feedback: SensoryFeedback, trigger: T, condition: @escaping (_ oldValue: T, _ newValue: T) -> Bool) -> some View where T : Equatable


    /// Plays feedback when returned from the `feedback` closure after the
    /// provided `trigger` value changes.
    ///
    /// For example, you could play different feedback for different state
    /// transitions:
    ///
    ///     struct MyView: View {
    ///         @State private var phase = Phase.inactive
    ///
    ///         var body: some View {
    ///             ContentView(phase: $phase)
    ///                 .sensoryFeedback(trigger: phase) { old, new in
    ///                     switch (old, new) {
    ///                         case (.inactive, _): return .success
    ///                         case (_, .expanded): return .impact
    ///                         default: return nil
    ///                     }
    ///                 }
    ///         }
    ///
    ///         enum Phase {
    ///             case inactive
    ///             case preparing
    ///             case active
    ///             case expanded
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - trigger: A value to monitor for changes to determine when to play.
    ///   - feedback: A closure to determine whether to play the feedback and
    ///     what type of feedback to play when `trigger` changes.
    nonisolated public func sensoryFeedback<T>(trigger: T, _ feedback: @escaping (_ oldValue: T, _ newValue: T) -> SensoryFeedback?) -> some View where T : Equatable

}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension ShapeStyle where Self == FillShapeStyle {

    /// An overlay fill style for filling shapes.
    ///
    /// This shape style is appropriate for items situated on top of an existing
    /// background color. It incorporates transparency to allow the background
    /// color to show through.
    ///
    /// Use the primary version of this style to fill thin or small shapes, such
    /// as the track of a slider on iOS.
    /// Use the secondary version of this style to fill medium-size shapes, such
    /// as the background of a switch on iOS.
    /// Use the tertiary version of this style to fill large shapes, such as
    /// input fields, search bars, or buttons on iOS.
    /// Use the quaternary version of this style to fill large areas that
    /// contain complex content, such as an expanded table cell on iOS.
    public static var fill: FillShapeStyle { get }
}

@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension View {

    /// Defines the destination of a drag-and-drop operation that handles the
    /// dropped content with a closure that you specify.
    ///
    /// The drop destination is the same size and position as this view.
    ///
    /// - Parameters:
    ///   - supportedContentTypes: The uniform type identifiers that describe the
    ///     types of content this view can accept through drag and drop.
    ///     If the drag-and-drop operation doesn't contain any of the supported
    ///     types, then this drop destination doesn't activate and `isTargeted`
    ///     doesn't update.
    ///   - isTargeted: A binding that updates when a drag and drop operation
    ///     enters or exits the drop target area. The binding's value is `true` when
    ///     the cursor is inside the area, and `false` when the cursor is outside.
    ///   - action: A closure that takes the dropped content and responds
    ///     appropriately. The parameter to `action` contains the dropped
    ///     items, with types specified by `supportedContentTypes`. Return `true`
    ///     if the drop operation was successful; otherwise, return `false`.
    ///
    /// - Returns: A view that provides a drop destination for a drag
    ///   operation of the specified types.
    nonisolated public func onDrop(of supportedContentTypes: [UTType], isTargeted: Binding<Bool>?, perform action: @escaping (_ providers: [NSItemProvider]) -> Bool) -> some View


    /// Defines the destination of a drag and drop operation that handles the
    /// dropped content with a closure that you specify.
    ///
    /// The drop destination is the same size and position as this view.
    ///
    /// - Parameters:
    ///   - supportedContentTypes: The uniform type identifiers that describe
    ///     the types of content this view can accept through drag and drop.
    ///     If the drag and drop operation doesn't contain any of the supported
    ///     types, then this drop destination doesn't activate and `isTargeted`
    ///     doesn't update.
    ///   - isTargeted: A binding that updates when a drag and drop operation
    ///     enters or exits the drop target area. The binding's value is `true` when
    ///     the cursor is inside the area, and `false` when the cursor is outside.
    ///   - action: A closure that takes the dropped content and responds
    ///     appropriately. The first parameter to `action` contains the dropped
    ///     items, with types specified by `supportedContentTypes`. The second
    ///     parameter contains the drop location in this view's coordinate
    ///     space. Return `true` if the drop operation was successful;
    ///     otherwise, return `false`.
    ///
    /// - Returns: A view that provides a drop destination for a drag
    ///   operation of the specified types.
    nonisolated public func onDrop(of supportedContentTypes: [UTType], isTargeted: Binding<Bool>?, perform action: @escaping (_ providers: [NSItemProvider], _ location: CGPoint) -> Bool) -> some View


    /// Defines the destination of a drag and drop operation using behavior
    /// controlled by the delegate that you provide.
    ///
    /// The drop destination is the same size and position as this view.
    ///
    /// - Parameters:
    ///   - supportedContentTypes: The uniform type identifiers that describe the
    ///     types of content this view can accept through drag and drop.
    ///     If the drag and drop operation doesn't contain any of the supported
    ///     types, then this drop destination doesn't activate and `isTargeted`
    ///     doesn't update.
    ///   - delegate: A type that conforms to the ``DropDelegate`` protocol. You
    ///     have comprehensive control over drop behavior when you use a
    ///     delegate.
    ///
    /// - Returns: A view that provides a drop destination for a drag
    ///   operation of the specified types.
    nonisolated public func onDrop(of supportedContentTypes: [UTType], delegate: any DropDelegate) -> some View

}

extension View {

    /// Defines the destination of a drag and drop operation that handles the
    /// dropped content with a closure that you specify.
    ///
    /// The dropped content can be provided as binary data, file URLs, or file promises.
    ///
    /// The drop destination is the same size and position as this view.
    ///
    ///     @State private var isDropTargeted = false
    ///
    ///     var body: some View {
    ///         Color.pink
    ///             .frame(width: 400, height: 400)
    ///             .dropDestination(for: String.self) { receivedTitles, location in
    ///                 animateDrop(at: location)
    ///                 process(titles: receivedTitles)
    ///             } isTargeted: {
    ///                 isDropTargeted = $0
    ///             }
    ///     }
    ///
    ///     func process(titles: [String]) { ... }
    ///     func animateDrop(at: CGPoint) { ... }
    ///
    /// - Parameters:
    ///   - payloadType: The expected type of the dropped models.
    ///   - action: A closure that takes the dropped content and responds
    ///     appropriately. The first parameter to `action` contains the dropped
    ///     items. The second
    ///     parameter contains the drop location in this view's coordinate
    ///     space. Return `true` if the drop operation was successful;
    ///     otherwise, return `false`.
    ///   - isTargeted: A closure that is called when a drag and drop operation
    ///     enters or exits the drop target area. The received value is `true` when
    ///     the cursor is inside the area, and `false` when the cursor is outside.
    ///
    /// - Returns: A view that provides a drop destination for a drag
    ///   operation of the specified type.
    @available(iOS 16.0, macOS 13.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    nonisolated public func dropDestination<T>(for payloadType: T.Type = T.self, action: @escaping (_ items: [T], _ location: CGPoint) -> Bool, isTargeted: @escaping (Bool) -> Void = { _ in }) -> some View where T : Transferable

}

@available(iOS, introduced: 13.4, deprecated: 100000.0, message: "Provide `UTType`s as the `supportedContentTypes` instead.")
@available(macOS, introduced: 10.15, deprecated: 100000.0, message: "Provide `UTType`s as the `supportedContentTypes` instead.")
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Provide `UTType`s as the `supportedContentTypes` instead.")
extension View {

    /// Defines the destination for a drag and drop operation, using the same
    /// size and position as this view, handling dropped content with the given
    /// closure.
    ///
    /// - Parameters:
    ///   - supportedTypes: The uniform type identifiers that describe the
    ///     types of content this view can accept through drag and drop.
    ///     If the drag and drop operation doesn't contain any of the supported
    ///     types, then this drop destination doesn't activate and `isTargeted`
    ///     doesn't update.
    ///   - isTargeted: A binding that updates when a drag and drop operation
    ///     enters or exits the drop target area. The binding's value is `true`
    ///     when the cursor is inside the area, and `false` when the cursor is
    ///     outside.
    ///   - action: A closure that takes the dropped content and responds
    ///     appropriately. The parameter to `action` contains the dropped
    ///     items, with types specified by `supportedTypes`. Return `true`
    ///     if the drop operation was successful; otherwise, return `false`.
    /// - Returns: A view that provides a drop destination for a drag
    ///   operation of the specified types.
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    nonisolated public func onDrop(of supportedTypes: [String], isTargeted: Binding<Bool>?, perform action: @escaping (_ providers: [NSItemProvider]) -> Bool) -> some View


    /// Defines the destination for a drag and drop operation with the same size
    /// and position as this view, handling dropped content and the drop
    /// location with the given closure.
    ///
    /// - Parameters:
    ///   - supportedTypes: The uniform type identifiers that describe the
    ///     types of content this view can accept through drag and drop.
    ///     If the drag and drop operation doesn't contain any of the supported
    ///     types, then this drop destination doesn't activate and `isTargeted`
    ///     doesn't update.
    ///   - isTargeted: A binding that updates when a drag and drop operation
    ///     enters or exits the drop target area. The binding's value is `true`
    ///     when the cursor is inside the area, and `false` when the cursor is
    ///     outside.
    ///   - action: A closure that takes the dropped content and responds
    ///     appropriately. The first parameter to `action` contains the dropped
    ///     items, with types specified by `supportedTypes`. The second
    ///     parameter contains the drop location in this view's coordinate
    ///     space. Return `true` if the drop operation was successful;
    ///     otherwise, return `false`.
    /// - Returns: A view that provides a drop destination for a drag
    ///   operation of the specified types.
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    nonisolated public func onDrop(of supportedTypes: [String], isTargeted: Binding<Bool>?, perform action: @escaping (_ providers: [NSItemProvider], _ location: CGPoint) -> Bool) -> some View


    /// Defines the destination for a drag and drop operation with the same size
    /// and position as this view, with behavior controlled by the given
    /// delegate.
    ///
    /// - Parameters:
    ///   - supportedTypes: The uniform type identifiers that describe the
    ///     types of content this view can accept through drag and drop.
    ///     If the drag and drop operation doesn't contain any of the supported
    ///     types, then this drop destination doesn't activate and `isTargeted`
    ///     doesn't update.
    ///   - delegate: A type that conforms to the `DropDelegate` protocol. You
    ///     have comprehensive control over drop behavior when you use a
    ///     delegate.
    /// - Returns: A view that provides a drop destination for a drag
    ///   operation of the specified types.
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    nonisolated public func onDrop(of supportedTypes: [String], delegate: any DropDelegate) -> some View

}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension View {

    /// Mark the receiver as their content might be invalidated.
    ///
    /// Use this modifier to annotate views that display values that are derived
    /// from the current state of your data and might be invalidated in
    /// response of, for example, user interaction.
    ///
    /// The view will change its appearance when ``RedactionReasons.invalidated``
    /// is present in the environment.
    ///
    /// In an interactive widget a view is invalidated from the moment the user
    /// interacts with a control on the widget to the moment when a new timeline
    /// update has been presented.
    ///
    /// - Parameters:
    ///   - invalidatable: Whether the receiver content might be invalidated.
    nonisolated public func invalidatableContent(_ invalidatable: Bool = true) -> some View

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Gesture {

    /// Sequences a gesture with another one to create a new gesture, which
    /// results in the second gesture only receiving events after the first
    /// gesture succeeds.
    ///
    /// - Parameter other: A gesture you want to combine with another gesture to
    ///   create a new, sequenced gesture.
    ///
    /// - Returns: A gesture that's a sequence of two gestures.
    @MainActor @inlinable @preconcurrency public func sequenced<Other>(before other: Other) -> SequenceGesture<Self, Other> where Other : Gesture
}

@available(iOS 17.0, macOS 14.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension Transaction {

    /// The behavior for how windows will dismiss programmatically when used in
    /// conjunction with ``DismissWindowAction``.
    ///
    /// The default value is `.interactive`.
    ///
    /// You can use this property to dismiss windows which may be showing a
    /// modal presentation by using the `.destructive` value:
    ///
    ///     struct DismissWindowButton: View {
    ///         @Environment(\.dismissWindow) private var dismissWindow
    ///
    ///         var body: some View {
    ///             Button("Close Auxiliary Window") {
    ///                 withTransaction(\.dismissBehavior, .destructive) {
    ///                     dismissWindow(id: "auxiliary")
    ///                 }
    ///             }
    ///         }
    ///     }
    public var dismissBehavior: DismissBehavior
}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension PreviewTrait where T == Preview.ViewTraits {

    /// Attach a `PreviewModifier` to the preview.
    ///
    /// You can compose modifiers by passing more than one instance of this
    /// trait. Composed modifiers will be applied to the preview in order: the first
    /// modifier will apply to the body of the preview, the second modifier to the
    /// body of the first modifier, and so on.
    @MainActor public static func modifier(_ modifier: some PreviewModifier) -> PreviewTrait<T>
}

@available(iOS 16.0, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension View {

    /// Programmatically presents the find and replace interface for text
    /// editor views.
    ///
    /// Add this modifier to a ``TextEditor``, or to a view hierarchy that
    /// contains at least one text editor, to control the presentation of
    /// the find and replace interface. When you set the `isPresented` binding
    /// to `true`, the system shows the interface, and when you set it to
    /// `false`, the system hides the interface. The following example shows
    /// and hides the interface based on the state of a toolbar button:
    ///
    ///     TextEditor(text: $text)
    ///         .findNavigator(isPresented: $isPresented)
    ///         .toolbar {
    ///             Toggle(isOn: $isPresented) {
    ///                 Label("Find", systemImage: "magnifyingglass")
    ///             }
    ///         }
    ///
    /// The find and replace interface allows people to search for instances
    /// of a specified string in the text editor, and optionally to replace
    /// instances of the search string with another string. They can also
    /// show and hide the interface using built-in controls, like menus and
    /// keyboard shortcuts. SwiftUI updates `isPresented` to reflect the
    /// users's actions.
    ///
    /// If the text editor view isn't currently in focus, the system still
    /// presents the find and replace interface when you set `isPresented`
    /// to `true`. If the view hierarchy contains multiple editors, the one
    /// that shows the find and replace interface is nondeterministic.
    ///
    /// You can disable the find and replace interface for a text editor by
    /// applying the ``View/findDisabled(_:)`` modifier to the editor. If you
    /// do that, setting this modifier's `isPresented` binding to `true` has
    /// no effect, but only if the disabling modifier appears closer to the
    /// text editor, like this:
    ///
    ///     TextEditor(text: $text)
    ///         .findDisabled(isDisabled)
    ///         .findNavigator(isPresented: $isPresented)
    ///
    /// - Parameter isPresented: A binding to a Boolean value that controls the
    ///   presentation of the find and replace interface.
    ///
    /// - Returns: A view that presents the find and replace interface when
    ///   `isPresented` is `true`.
    nonisolated public func findNavigator(isPresented: Binding<Bool>) -> some View


    /// Prevents find and replace operations in a text editor.
    ///
    /// Add this modifier to ensure that people can't activate the find
    /// and replace interface for a ``TextEditor``:
    ///
    ///     TextEditor(text: $text)
    ///         .findDisabled()
    ///
    /// When you disable the find operation, you also implicitly disable the
    /// replace operation. If you want to only disable replace, use
    /// ``View/replaceDisabled(_:)`` instead.
    ///
    /// Using this modifer also prevents programmatic find and replace
    /// interface presentation using the ``View/findNavigator(isPresented:)``
    /// method. Be sure to place the disabling modifier closer to the text
    /// editor for this to work:
    ///
    ///     TextEditor(text: $text)
    ///         .findDisabled(isDisabled)
    ///         .findNavigator(isPresented: $isPresented)
    ///
    /// If you apply this modifer at multiple levels of a view hierarchy,
    /// the call closest to the text editor takes precedence. For example,
    /// people can activate find and replace for the first text editor
    /// in the following example, but not the second:
    ///
    ///     VStack {
    ///         TextEditor(text: $text1)
    ///             .findDisabled(false)
    ///         TextEditor(text: $text2)
    ///     }
    ///     .findDisabled(true)
    ///
    /// - Parameter isDisabled: A Boolean value that indicates whether to
    ///   disable the find and replace interface for a text editor.
    ///
    /// - Returns: A view that disables the find and replace interface.
    nonisolated public func findDisabled(_ isDisabled: Bool = true) -> some View


    /// Prevents replace operations in a text editor.
    ///
    /// Add this modifier to ensure that people can't activate the replace
    /// feature of a find and replace interface for a ``TextEditor``:
    ///
    ///     TextEditor(text: $text)
    ///         .replaceDisabled()
    ///
    /// If you want to disable both find and replace, use the
    /// ``View/findDisabled(_:)`` modifier instead.
    ///
    /// Using this modifer also disables the replace feature of a find and
    /// replace interface that you present programmatically using the
    /// ``View/findNavigator(isPresented:)`` method. Be sure to place the
    /// disabling modifier closer to the text editor for this to work:
    ///
    ///     TextEditor(text: $text)
    ///         .replaceDisabled(isDisabled)
    ///         .findNavigator(isPresented: $isPresented)
    ///
    /// If you apply this modifer at multiple levels of a view hierarchy,
    /// the call closest to the text editor takes precedence. For example,
    /// people can activate find and replace for the first text editor
    /// in the following example, but only find for the second:
    ///
    ///     VStack {
    ///         TextEditor(text: $text1)
    ///             .replaceDisabled(false)
    ///         TextEditor(text: $text2)
    ///     }
    ///     .replaceDisabled(true)
    ///
    /// - Parameter isDisabled: A Boolean value that indicates whether text
    ///   replacement in the find and replace interface is disabled.
    ///
    /// - Returns: A view that disables the replace feature of a find and
    ///   replace interface.
    nonisolated public func replaceDisabled(_ isDisabled: Bool = true) -> some View

}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension Text {

    /// Sets whether VoiceOver should always speak all punctuation in the text
    /// view.
    ///
    /// Use this modifier to control whether the system speaks punctuation
    /// characters in the text. You might use this for code or other text where
    /// the punctuation is relevant, or where you want VoiceOver to speak a
    /// verbatim transcription of the text you provide. For example, given the
    /// text:
    ///
    ///     Text("All the world's a stage, " +
    ///          "And all the men and women merely players;")
    ///          .speechAlwaysIncludesPunctuation()
    ///
    /// VoiceOver would speak "All the world apostrophe s a stage comma and all
    /// the men and women merely players semicolon".
    ///
    /// By default, VoiceOver voices punctuation based on surrounding context.
    ///
    /// - Parameter value: A Boolean value that you set to `true` if
    ///   VoiceOver should speak all punctuation in the text. Defaults to `true`.
    public func speechAlwaysIncludesPunctuation(_ value: Bool = true) -> Text

    /// Sets whether VoiceOver should speak the contents of the text view
    /// character by character.
    ///
    /// Use this modifier when you want VoiceOver to speak text as individual
    /// letters, character by character. This is important for text that is not
    /// meant to be spoken together, like:
    /// - An acronym that isn't a word, like APPL, spoken as "A-P-P-L".
    /// - A number representing a series of digits, like 25, spoken as "two-five"
    ///   rather than "twenty-five".
    ///
    /// - Parameter value: A Boolean value that when `true` indicates
    ///    VoiceOver should speak text as individual characters. Defaults
    ///    to `true`.
    public func speechSpellsOutCharacters(_ value: Bool = true) -> Text

    /// Raises or lowers the pitch of spoken text.
    ///
    /// Use this modifier when you want to change the pitch of spoken text.
    /// The value indicates how much higher or lower to change the pitch.
    ///
    /// - Parameter value: The amount to raise or lower the pitch.
    ///   Values between `-1` and `0` result in a lower pitch while
    ///   values between `0` and `1` result in a higher pitch.
    ///   The method clamps values to the range `-1` to `1`.
    public func speechAdjustedPitch(_ value: Double) -> Text

    /// Controls whether to queue pending announcements behind existing speech
    /// rather than interrupting speech in progress.
    ///
    /// Use this modifier when you want affect the order in which the
    /// accessibility system delivers spoken text. Announcements can
    /// occur automatically when the label or value of an accessibility
    /// element changes.
    ///
    /// - Parameter value: A Boolean value that determines if VoiceOver speaks
    ///   changes to text immediately or enqueues them behind existing speech.
    ///   Defaults to `true`.
    public func speechAnnouncementsQueued(_ value: Bool = true) -> Text
}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension View {

    /// Sets whether VoiceOver should always speak all punctuation in the text
    /// view.
    ///
    /// Use this modifier to control whether the system speaks punctuation
    /// characters in the text. You might use this for code or other text where
    /// the punctuation is relevant, or where you want VoiceOver to speak a
    /// verbatim transcription of the text you provide. For example, given the
    /// text:
    ///
    ///     Text("All the world's a stage, " +
    ///          "And all the men and women merely players;")
    ///          .speechAlwaysIncludesPunctuation()
    ///
    /// VoiceOver would speak "All the world apostrophe s a stage comma and all
    /// the men and women merely players semicolon".
    ///
    /// By default, VoiceOver voices punctuation based on surrounding context.
    ///
    /// - Parameter value: A Boolean value that you set to `true` if
    ///   VoiceOver should speak all punctuation in the text. Defaults to `true`.
    nonisolated public func speechAlwaysIncludesPunctuation(_ value: Bool = true) -> some View


    /// Sets whether VoiceOver should speak the contents of the text view
    /// character by character.
    ///
    /// Use this modifier when you want VoiceOver to speak text as individual
    /// letters, character by character. This is important for text that is not
    /// meant to be spoken together, like:
    /// - An acronym that isn't a word, like APPL, spoken as "A-P-P-L".
    /// - A number representing a series of digits, like 25, spoken as "two-five"
    ///   rather than "twenty-five".
    ///
    /// - Parameter value: A Boolean value that when `true` indicates
    ///    VoiceOver should speak text as individual characters. Defaults
    ///    to `true`.
    nonisolated public func speechSpellsOutCharacters(_ value: Bool = true) -> some View


    /// Raises or lowers the pitch of spoken text.
    ///
    /// Use this modifier when you want to change the pitch of spoken text.
    /// The value indicates how much higher or lower to change the pitch.
    ///
    /// - Parameter value: The amount to raise or lower the pitch.
    ///   Values between `-1` and `0` result in a lower pitch while
    ///   values between `0` and `1` result in a higher pitch.
    ///   The method clamps values to the range `-1` to `1`.
    nonisolated public func speechAdjustedPitch(_ value: Double) -> some View


    /// Controls whether to queue pending announcements behind existing speech
    /// rather than interrupting speech in progress.
    ///
    /// Use this modifier when you want affect the order in which the
    /// accessibility system delivers spoken text. Announcements can
    /// occur automatically when the label or value of an accessibility
    /// element changes.
    ///
    /// - Parameter value: A Boolean value that determines if VoiceOver speaks
    ///   changes to text immediately or enqueues them behind existing speech.
    ///   Defaults to `true`.
    nonisolated public func speechAnnouncementsQueued(_ value: Bool = true) -> some View

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// Sets the view's horizontal alignment.
    ///
    /// Use `alignmentGuide(_:computeValue:)` to calculate specific offsets
    /// to reposition views in relationship to one another. You can return a
    /// constant or can use the ``ViewDimensions`` argument to the closure to
    /// calculate a return value.
    ///
    /// In the example below, the ``HStack`` is offset by a constant of 50
    /// points to the right of center:
    ///
    ///     VStack {
    ///         Text("Today's Weather")
    ///             .font(.title)
    ///             .border(.gray)
    ///         HStack {
    ///             Text("")
    ///             Text("Rain & Thunderstorms")
    ///             Text("")
    ///         }
    ///         .alignmentGuide(HorizontalAlignment.center) { _ in  50 }
    ///         .border(.gray)
    ///     }
    ///     .border(.gray)
    ///
    /// Changing the alignment of one view may have effects on surrounding
    /// views. Here the offset values inside a stack and its contained views is
    /// the difference of their absolute offsets.
    ///
    /// ![A view showing the two emoji offset from a text element using a
    /// horizontal alignment guide.](SwiftUI-View-HAlignmentGuide.png)
    ///
    /// - Parameters:
    ///   - g: A ``HorizontalAlignment`` value at which to base the offset.
    ///   - computeValue: A closure that returns the offset value to apply to
    ///     this view.
    ///
    /// - Returns: A view modified with respect to its horizontal alignment
    ///   according to the computation performed in the method's closure.
    @preconcurrency @inlinable nonisolated public func alignmentGuide(_ g: HorizontalAlignment, computeValue: @escaping @Sendable (ViewDimensions) -> CGFloat) -> some View


    /// Sets the view's vertical alignment.
    ///
    /// Use `alignmentGuide(_:computeValue:)` to calculate specific offsets
    /// to reposition views in relationship to one another. You can return a
    /// constant or can use the ``ViewDimensions`` argument to the closure to
    /// calculate a return value.
    ///
    /// In the example below, the weather emoji are offset 20 points from the
    /// vertical center of the ``HStack``.
    ///
    ///     VStack {
    ///         Text("Today's Weather")
    ///             .font(.title)
    ///             .border(.gray)
    ///
    ///         HStack {
    ///             Text("")
    ///                 .alignmentGuide(VerticalAlignment.center) { _ in -20 }
    ///                 .border(.gray)
    ///             Text("Rain & Thunderstorms")
    ///                 .border(.gray)
    ///             Text("")
    ///                 .alignmentGuide(VerticalAlignment.center) { _ in 20 }
    ///                 .border(.gray)
    ///         }
    ///     }
    ///
    /// Changing the alignment of one view may have effects on surrounding
    /// views. Here the offset values inside a stack and its contained views is
    /// the difference of their absolute offsets.
    ///
    /// ![A view showing the two emoji offset from a text element using a
    /// vertical alignment guide.](SwiftUI-View-VAlignmentGuide.png)
    ///
    /// - Parameters:
    ///   - g: A ``VerticalAlignment`` value at which to base the offset.
    ///   - computeValue: A closure that returns the offset value to apply to
    ///     this view.
    ///
    /// - Returns: A view modified with respect to its vertical alignment
    ///   according to the computation performed in the method's closure.
    @preconcurrency @inlinable nonisolated public func alignmentGuide(_ g: VerticalAlignment, computeValue: @escaping @Sendable (ViewDimensions) -> CGFloat) -> some View

}

extension View {

    /// Configures the search scopes for this view.
    ///
    /// To enable people to narrow the scope of their searches, you can
    /// create a type that represents the possible scopes, and then create a
    /// state variable to hold the current selection. For example, you can
    /// scope the product search to just fruits or just vegetables:
    ///
    ///     enum ProductScope {
    ///         case fruit
    ///         case vegetable
    ///     }
    ///
    ///     @State private var scope: ProductScope = .fruit
    ///
    /// Provide a binding to the scope, as well as a view that represents each
    /// scope:
    ///
    ///     ProductList()
    ///         .searchable(text: $text, tokens: $tokens) { token in
    ///             switch token {
    ///             case .apple: Text("Apple")
    ///             case .pear: Text("Pear")
    ///             case .banana: Text("Banana")
    ///             }
    ///         }
    ///         .searchScopes($scope) {
    ///             Text("Fruit").tag(ProductScope.fruit)
    ///             Text("Vegetable").tag(ProductScope.vegetable)
    ///         }
    ///
    /// SwiftUI uses this binding and view to add a ``Picker`` with the search
    /// field. In iOS, iPadOS, macOS, and tvOS, the picker appears below the
    /// search field when search is active. To ensure that the picker operates
    /// correctly, match the type of the scope binding with the type of each
    /// view's tag. Then modify your search to account for the current value of
    /// the `scope` state property.
    ///
    /// For more information about using searchable modifiers, see
    /// <doc:Adding-a-search-interface-to-your-app>.
    ///
    /// - Parameters:
    ///   - scope: The active scope of the search field.
    ///   - scopes: A view builder that represents the scoping options
    ///     SwiftUI uses to populate a ``Picker``.
    @available(iOS 16.0, macOS 13.0, tvOS 16.4, *)
    @available(watchOS, unavailable)
    nonisolated public func searchScopes<V, S>(_ scope: Binding<V>, @ViewBuilder scopes: () -> S) -> some View where V : Hashable, S : View

}

extension View {

    /// Configures the search scopes for this view with the specified
    /// activation strategy.
    ///
    /// To enable people to narrow the scope of their searches, you can
    /// create a type that represents the possible scopes, and then create a
    /// state variable to hold the current selection. For example, you can
    /// scope the product search to just fruits or just vegetables:
    ///
    ///     enum ProductScope {
    ///         case fruit
    ///         case vegetable
    ///     }
    ///
    ///     @State private var scope: ProductScope = .fruit
    ///
    /// Provide a binding to the scope, as well as a view that represents each
    /// scope:
    ///
    ///     ProductList()
    ///         .searchable(text: $text, tokens: $tokens) { token in
    ///             switch token {
    ///             case .apple: Text("Apple")
    ///             case .pear: Text("Pear")
    ///             case .banana: Text("Banana")
    ///             }
    ///         }
    ///         .searchScopes($scope) {
    ///             Text("Fruit").tag(ProductScope.fruit)
    ///             Text("Vegetable").tag(ProductScope.vegetable)
    ///         }
    ///
    /// SwiftUI uses this binding and view to add a ``Picker`` below the search
    /// field. In iOS, macOS, and tvOS, the picker appears below the search
    /// field when search is active. To ensure that the picker operates
    /// correctly, match the type of the scope binding with the type of each
    /// view's tag. Then condition your search on the current value of the
    /// `scope` state property.
    ///
    /// By default, the appearance of scopes varies by platform:
    ///   - In iOS and iPadOS, search scopes appear when someone enters text
    ///     into the search field and disappear when someone cancels the search.
    ///   - In macOS, search scopes appear when SwiftUI presents search and
    ///     disappear when someone cancels the search.
    ///
    /// However, you can use the `activation` parameter with a value of
    /// ``SearchScopeActivation/onTextEntry`` or
    /// ``SearchScopeActivation/onSearchPresentation`` to configure this
    /// behavior:
    ///
    ///     .searchScopes($scope, activation: .onSearchPresentation) {
    ///         Text("Fruit").tag(ProductScope.fruit)
    ///         Text("Vegetable").tag(ProductScope.vegetable)
    ///     }
    ///
    /// For more information about using searchable modifiers, see
    /// <doc:Adding-a-search-interface-to-your-app>.
    ///
    /// - Parameters:
    ///   - scope: The active scope of the search field.
    ///   - activation: The activation style of the search field's scopes.
    ///   - scopes: A view builder that represents the scoping options
    ///     SwiftUI uses to populate a ``Picker``.
    @available(iOS 16.4, macOS 13.3, tvOS 16.4, *)
    @available(watchOS, unavailable)
    nonisolated public func searchScopes<V, S>(_ scope: Binding<V>, activation: SearchScopeActivation, @ViewBuilder _ scopes: () -> S) -> some View where V : Hashable, S : View

}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension View {

    /// Returns a new view with its inherited symbol image effects
    /// either removed or left unchanged.
    ///
    /// The following example adds a repeating pulse effect to two
    /// symbol images, but then disables the effect on one of them:
    ///
    ///     VStack {
    ///         Image(systemName: "bolt.slash.fill") // does not pulse
    ///             .symbolEffectsRemoved()
    ///         Image(systemName: "folder.fill.badge.person.crop") // pulses
    ///     }
    ///     .symbolEffect(.pulse)
    ///
    /// - Parameter isEnabled: Whether to remove inherited symbol
    ///   effects or not.
    ///
    /// - Returns: a copy of the view with its symbol effects either
    ///   removed or left unchanged.
    nonisolated public func symbolEffectsRemoved(_ isEnabled: Bool = true) -> some View

}

extension View {

    /// Adds a condition that controls whether users can select this view.
    ///
    /// Use this modifier to control the selectability of views in
    /// selectable containers like ``List`` or ``Table``. In the example,
    /// below, the user can't select the first item in the list.
    ///
    ///     @Binding var selection: Item.ID?
    ///     @Binding var items: [Item]
    ///
    ///     var body: some View {
    ///         List(selection: $selection) {
    ///             ForEach(items) { item in
    ///                 ItemView(item: item)
    ///                     .selectionDisabled(item.id == items.first?.id)
    ///             }
    ///         }
    ///     }
    ///
    /// You can also use this modifier to specify the selectability of views
    /// within a `Picker`. The following example represents a flavor picker
    /// that disables selection on flavors that are unavailable.
    ///
    ///     Picker("Flavor", selection: $selectedFlavor) {
    ///         ForEach(Flavor.allCases) { flavor in
    ///             Text(flavor.rawValue.capitalized)
    ///                 .selectionDisabled(isSoldOut(flavor))
    ///         }
    ///     }
    ///
    /// - Parameter isDisabled: A Boolean value that determines whether users can
    ///   select this view.
    @available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
    nonisolated public func selectionDisabled(_ isDisabled: Bool = true) -> some View

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension View {

    /// Advertises a user activity type.
    ///
    /// You can use `userActivity(_:isActive:_:)` to start, stop, or modify the
    /// advertisement of a specific type of user activity.
    ///
    /// The scope of the activity applies only to the scene or window the
    /// view is in.
    ///
    /// - Parameters:
    ///   - activityType: The type of activity to advertise.
    ///   - isActive: When `false`, avoids advertising the activity. Defaults
    ///     to `true`.
    ///   - update: A function that modifies the passed-in activity for
    ///     advertisement.
    nonisolated public func userActivity(_ activityType: String, isActive: Bool = true, _ update: @escaping (NSUserActivity) -> ()) -> some View


    /// Advertises a user activity type.
    ///
    /// The scope of the activity applies only to the scene or window the
    /// view is in.
    ///
    /// - Parameters:
    ///   - activityType: The type of activity to advertise.
    ///   - element: If the element is `nil`, the handler will not be
    ///     associated with the activity (and if there are no handlers, no
    ///     activity is advertised). The method passes the non-`nil` element to
    ///     the handler as a convenience so the handlers don't all need to
    ///     implement an early exit with
    ///     `guard element = element else { return }`.
    ///    - update: A function that modifies the passed-in activity for
    ///    advertisement.
    nonisolated public func userActivity<P>(_ activityType: String, element: P?, _ update: @escaping (P, NSUserActivity) -> ()) -> some View


    /// Registers a handler to invoke in response to a user activity that your
    /// app receives.
    ///
    /// Use this view modifier to receive
    /// <doc://com.apple.documentation/documentation/Foundation/NSUserActivity>
    /// instances in a particular scene within your app. The scene that SwiftUI
    /// routes the incoming user activity to depends on the structure of your
    /// app, what scenes are active, and other configuration. For more
    /// information, see ``Scene/handlesExternalEvents(matching:)``.
    ///
    /// UI frameworks traditionally pass Universal Links to your app using a
    /// user activity. However, SwiftUI passes a Universal Link to your app
    /// directly as a URL. To receive a Universal Link, use the
    /// ``View/onOpenURL(perform:)`` modifier instead.
    ///
    /// - Parameters:
    ///   - activityType: The type of activity that the `action` closure
    ///     handles. Be sure that this string matches one of the values that
    ///     you list in the
    ///     <doc://com.apple.documentation/documentation/bundleresources/information_property_list/nsuseractivitytypes>
    ///     array in your app's Information Property List.
    ///   - action: A closure that SwiftUI calls when your app receives a user
    ///     activity of the specified type. The closure takes the activity as
    ///     an input parameter.
    ///
    /// - Returns: A view that handles incoming user activities.
    nonisolated public func onContinueUserActivity(_ activityType: String, perform action: @escaping (NSUserActivity) -> ()) -> some View


    /// Registers a handler to invoke in response to a URL that your app
    /// receives.
    ///
    /// Use this view modifier to receive URLs in a particular scene within your
    /// app. The scene that SwiftUI routes the incoming URL to depends on the
    /// structure of your app, what scenes are active, and other configuration.
    /// For more information, see ``Scene/handlesExternalEvents(matching:)``.
    ///
    /// UI frameworks traditionally pass Universal Links to your app using an
    /// <doc://com.apple.documentation/documentation/Foundation/NSUserActivity>.
    /// However, SwiftUI passes a Universal Link to your app directly as a URL,
    /// which you receive using this modifier. To receive other user activities,
    /// like when your app participates in Handoff, use the
    /// ``View/onContinueUserActivity(_:perform:)`` modifier instead.
    ///
    /// For more information about linking into your app, see
    /// <doc://com.apple.documentation/documentation/Xcode/allowing-apps-and-websites-to-link-to-your-content>.
    ///
    /// - Parameter action: A closure that SwiftUI calls when your app receives
    ///   a Universal Link or a custom
    ///   <doc://com.apple.documentation/documentation/Foundation/URL>.
    ///   The closure takes the URL as an input parameter.
    ///
    /// - Returns: A view that handles incoming URLs.
    nonisolated public func onOpenURL(perform action: @escaping (URL) -> ()) -> some View

}

@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension View {

    /// Specifies the external events that the view's scene handles
    /// if the scene is already open.
    ///
    /// Apply this modifier to a view to indicate whether an open scene that
    /// contains the view handles specified user activities or URLs that your
    /// app receives. Specify two sets of string identifiers to distinguish
    /// between the kinds of events that the scene _prefers_ to handle
    /// and those that it _can_ handle. You can dynamically update the
    /// identifiers in each set to reflect changing app state.
    ///
    /// When your app receives an event on a platform that supports multiple
    /// simultaneous scenes, SwiftUI sends the event to the first
    /// open scene it finds that prefers to handle the event. Otherwise,
    /// it sends the event to the first open scene it finds that can handle
    /// the event. If it finds neither --- including when you don't add
    /// this view modifier --- SwiftUI creates a new scene for the event.
    ///
    /// > Important: Don't confuse this view modifier with the
    ///   ``Scene/handlesExternalEvents(matching:)`` _scene_ modifier. You use
    ///   the view modifier to indicate that an open scene handles certain
    ///   events, whereas you use the scene modifier to help SwiftUI choose a
    ///   new scene to open when no open scene handles the event.
    ///
    /// On platforms that support only a single scene, SwiftUI ignores this
    /// modifier and sends all external events to the one open scene.
    ///
    /// ### Matching an event
    ///
    /// To find an open scene that handles a particular external event, SwiftUI
    /// compares a property of the event against the strings that you specify
    /// in the `preferring` and `allowing` sets. SwiftUI examines the
    /// following event properties to perform the comparison:
    ///
    /// * For an
    ///   <doc://com.apple.documentation/documentation/Foundation/NSUserActivity>,
    ///   like when your app handles Handoff, SwiftUI uses the activity's
    ///   <doc://com.apple.documentation/documentation/Foundation/NSUserActivity/3238062-targetContentIdentifier>
    ///   property, or if that's `nil`, its
    ///   <doc://com.apple.documentation/documentation/Foundation/NSUserActivity/1418086-webpageurl>
    ///   property rendered as an
    ///   <doc://com.apple.documentation/documentation/Foundation/URL/1779984-absoluteString>.
    /// * For a
    ///   <doc://com.apple.documentation/documentation/Foundation/URL>,
    ///   like when another process opens a URL that your app handles,
    ///   SwiftUI uses the URL's
    ///   <doc://com.apple.documentation/documentation/Foundation/URL/1779984-absoluteString>.
    ///
    /// For both parameter sets, an empty set of strings never matches.
    /// Similarly, empty strings never match. Conversely, as a special case,
    /// the string that contains only an asterisk (`*`) matches anything.
    /// The modifier performs string comparisons that are case and
    /// diacritic insensitive.
    ///
    /// If you specify multiple instances of this view modifier inside a single
    /// scene, the scene uses the union of the respective `preferring` and
    /// `allowing` sets from all the modifiers.
    ///
    /// ### Handling a user activity in an open scene
    ///
    /// As an example, the following view --- which participates in Handoff
    /// through the ``View/userActivity(_:isActive:_:)`` and
    /// ``View/onContinueUserActivity(_:perform:)`` methods --- updates its
    /// `preferring` set according to the current selection. The enclosing
    /// scene prefers to handle an event for a contact that's already selected,
    /// but doesn't volunteer itself as a preferred scene when no contact is
    /// selected:
    ///
    ///     private struct ContactList: View {
    ///         var store: ContactStore
    ///         @State private var selectedContact: UUID?
    ///
    ///         var body: some View {
    ///             NavigationSplitView {
    ///                 List(store.contacts, selection: $selectedContact) { contact in
    ///                     NavigationLink(contact.name) {
    ///                         Text(contact.name)
    ///                     }
    ///                 }
    ///             } detail: {
    ///                 Text("Select a contact")
    ///             }
    ///             .handlesExternalEvents(
    ///                 preferring: selectedContact == nil
    ///                     ? []
    ///                     : [selectedContact!.uuidString],
    ///                 allowing: selectedContact == nil
    ///                     ? ["*"]
    ///                     : []
    ///             )
    ///             .onContinueUserActivity(Contact.userActivityType) { activity in
    ///                 if let identifier = activity.targetContentIdentifier {
    ///                     selectedContact = UUID(uuidString: identifier)
    ///                 }
    ///             }
    ///             .userActivity(
    ///                 Contact.userActivityType,
    ///                 isActive: selectedContact != nil
    ///             ) { activity in
    ///                 activity.title = "Contact"
    ///                 activity.targetContentIdentifier = selectedContact?.uuidString
    ///                 activity.isEligibleForHandoff = true
    ///             }
    ///         }
    ///     }
    ///
    /// The above code also updates the `allowing` set to indicate that the
    /// scene can handle any incoming event when there's no current selection,
    /// but that it can't handle any event if the view already displays a
    /// contact. The `preferring` set takes precedence in the special case
    /// where the incoming event exactly matches the currently selected contact.
    ///
    /// - Parameters:
    ///   - preferring: A set of strings that SwiftUI compares against the
    ///     incoming user activity or URL to see if the view's
    ///     scene prefers to handle the external event.
    ///   - allowing: A set of strings that SwiftUI compares against the
    ///     incoming user activity or URL to see if the view's
    ///     scene can handle the exernal event.
    ///
    /// - Returns: A view whose enclosing scene --- if already open ---
    ///   handles incoming external events.
    nonisolated public func handlesExternalEvents(preferring: Set<String>, allowing: Set<String>) -> some View

}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension View {

    /// Communicates to the user what happens after performing the view's
    /// action.
    ///
    /// Provide a hint in the form of a brief phrase, like "Purchases the item"
    /// or "Downloads the attachment".
    ///
    /// > Note: On macOS, if the view does not have an action and it has been
    ///   made into a container with ``accessibilityElement(children: .contain)``,
    ///   this will be used to describe the container. For example, if the
    ///   container is for a graph, the hint could be "graph".
    ///
    /// - Parameters:
    ///   - hint: The accessibility hint to apply.
    ///   - isEnabled: If true the accessibility hint is applied; otherwise the
    ///     accessibility hint is unchanged.
    nonisolated public func accessibilityHint(_ hint: Text, isEnabled: Bool) -> ModifiedContent<Self, AccessibilityAttachmentModifier>

    /// Communicates to the user what happens after performing the view's
    /// action.
    ///
    /// Provide a hint in the form of a brief phrase, like "Purchases the item"
    /// or "Downloads the attachment".
    ///
    /// - Parameters:
    ///   - hintKey: The accessibility hint to apply.
    ///   - isEnabled: If true the accessibility hint is applied; otherwise the
    ///     accessibility hint is unchanged.
    nonisolated public func accessibilityHint(_ hintKey: LocalizedStringKey, isEnabled: Bool) -> ModifiedContent<Self, AccessibilityAttachmentModifier>

    /// Communicates to the user what happens after performing the view's
    /// action.
    ///
    /// Provide a hint in the form of a brief phrase, like "Purchases the item"
    /// or "Downloads the attachment".
    ///
    /// - Parameters:
    ///   - hint: The accessibility hint to apply.
    ///   - isEnabled: If true the accessibility hint is applied; otherwise the
    ///     accessibility hint is unchanged.
    nonisolated public func accessibilityHint<S>(_ hint: S, isEnabled: Bool) -> ModifiedContent<Self, AccessibilityAttachmentModifier> where S : StringProtocol
}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension ModifiedContent where Modifier == AccessibilityAttachmentModifier {

    /// Communicates to the user what happens after performing the view's
    /// action.
    ///
    /// Provide a hint in the form of a brief phrase, like "Purchases the item"
    /// or "Downloads the attachment".
    ///
    /// > Note: On macOS, if the view does not have an action and it has been
    ///   made into a container with ``accessibilityElement(children: .contain)``,
    ///   this will be used to describe the container. For example, if the
    ///   container is for a graph, the hint could be "graph".
    ///
    /// - Parameters:
    ///   - hint: The accessibility hint to apply.
    ///   - isEnabled: If true the accessibility hint is applied; otherwise the
    ///     accessibility hint is unchanged.
    nonisolated public func accessibilityHint(_ hint: Text, isEnabled: Bool) -> ModifiedContent<Content, Modifier>

    /// Communicates to the user what happens after performing the view's
    /// action.
    ///
    /// Provide a hint in the form of a brief phrase, like "Purchases the item"
    /// or "Downloads the attachment".
    ///
    /// - Parameters:
    ///   - hintKey: The accessibility hint to apply.
    ///   - isEnabled: If true the accessibility hint is applied; otherwise the
    ///     accessibility hint is unchanged.
    nonisolated public func accessibilityHint(_ hintKey: LocalizedStringKey, isEnabled: Bool) -> ModifiedContent<Content, Modifier>

    /// Communicates to the user what happens after performing the view's
    /// action.
    ///
    /// Provide a hint in the form of a brief phrase, like "Purchases the item"
    /// or "Downloads the attachment".
    ///
    /// - Parameters:
    ///   - hint: The accessibility hint to apply.
    ///   - isEnabled: If true the accessibility hint is applied; otherwise the
    ///     accessibility hint is unchanged.
    nonisolated public func accessibilityHint<S>(_ hint: S, isEnabled: Bool) -> ModifiedContent<Content, Modifier> where S : StringProtocol
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension View {

    /// Communicates to the user what happens after performing the view's
    /// action.
    ///
    /// Provide a hint in the form of a brief phrase, like "Purchases the item"
    /// or "Downloads the attachment".
    ///
    /// > Note: On macOS, if the view does not have an action and it has been
    ///   made into a container with ``accessibilityElement(children: .contain)``,
    ///   this will be used to describe the container. For example, if the
    ///   container is for a graph, the hint could be "graph".
    nonisolated public func accessibilityHint(_ hint: Text) -> ModifiedContent<Self, AccessibilityAttachmentModifier>

    /// Communicates to the user what happens after performing the view's
    /// action.
    ///
    /// Provide a hint in the form of a brief phrase, like "Purchases the item"
    /// or "Downloads the attachment".
    nonisolated public func accessibilityHint(_ hintKey: LocalizedStringKey) -> ModifiedContent<Self, AccessibilityAttachmentModifier>

    /// Communicates to the user what happens after performing the view's
    /// action.
    ///
    /// Provide a hint in the form of a brief phrase, like "Purchases the item"
    /// or "Downloads the attachment".
    nonisolated public func accessibilityHint<S>(_ hint: S) -> ModifiedContent<Self, AccessibilityAttachmentModifier> where S : StringProtocol
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ModifiedContent where Modifier == AccessibilityAttachmentModifier {

    /// Communicates to the user what happens after performing the view's
    /// action.
    ///
    /// Provide a hint in the form of a brief phrase, like "Purchases the item"
    /// or "Downloads the attachment".
    ///
    /// > Note: On macOS, if the view does not have an action and it has been
    ///   made into a container with ``accessibilityElement(children: .contain)``,
    ///   this will be used to describe the container. For example, if the
    ///   container is for a graph, the hint could be "graph".
    nonisolated public func accessibilityHint(_ hint: Text) -> ModifiedContent<Content, Modifier>

    /// Communicates to the user what happens after performing the view's
    /// action.
    ///
    /// Provide a hint in the form of a brief phrase, like "Purchases the item"
    /// or "Downloads the attachment".
    nonisolated public func accessibilityHint(_ hintKey: LocalizedStringKey) -> ModifiedContent<Content, Modifier>

    /// Communicates to the user what happens after performing the view's
    /// action.
    ///
    /// Provide a hint in the form of a brief phrase, like "Purchases the item"
    /// or "Downloads the attachment".
    nonisolated public func accessibilityHint<S>(_ hint: S) -> ModifiedContent<Content, Modifier> where S : StringProtocol
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// Adds an action to perform when this view detects data emitted by the
    /// given publisher.
    ///
    /// - Parameters:
    ///   - publisher: The publisher to subscribe to.
    ///   - action: The action to perform when an event is emitted by
    ///     `publisher`. The event emitted by publisher is passed as a
    ///     parameter to `action`.
    ///
    /// - Returns: A view that triggers `action` when `publisher` emits an
    ///   event.
    @inlinable nonisolated public func onReceive<P>(_ publisher: P, perform action: @escaping (P.Output) -> Void) -> some View where P : Publisher, P.Failure == Never

}

@available(iOS 14.0, macOS 11.0, tvOS 17.0, *)
@available(watchOS, unavailable)
extension View {

    /// Sets the style for menus within this view.
    ///
    /// To set a specific style for all menu instances within a view, use the
    /// `menuStyle(_:)` modifier:
    ///
    ///     Menu("PDF") {
    ///         Button("Open in Preview", action: openInPreview)
    ///         Button("Save as PDF", action: saveAsPDF)
    ///     }
    ///     .menuStyle(ButtonMenuStyle())
    ///
    nonisolated public func menuStyle<S>(_ style: S) -> some View where S : MenuStyle

}

@available(iOS 16.0, macOS 13.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension EnvironmentValues {

    /// A window presentation action stored in a view's environment.
    ///
    /// Use the `openWindow` environment value to get an ``OpenWindowAction``
    /// instance for a given ``Environment``. Then call the instance to open
    /// a window. You call the instance directly because it defines a
    /// ``OpenWindowAction/callAsFunction(id:)`` method that Swift calls
    /// when you call the instance.
    ///
    /// For example, you can define a button that opens a new mail viewer
    /// window:
    ///
    ///     @main
    ///     struct Mail: App {
    ///         var body: some Scene {
    ///             WindowGroup(id: "mail-viewer") {
    ///                 MailViewer()
    ///             }
    ///         }
    ///     }
    ///
    ///     struct NewViewerButton: View {
    ///         @Environment(\.openWindow) private var openWindow
    ///
    ///         var body: some View {
    ///             Button("Open new mail viewer") {
    ///                 openWindow(id: "mail-viewer")
    ///             }
    ///         }
    ///     }
    ///
    /// You indicate which scene to open by providing one of the following:
    ///  * A string identifier that you pass through the `id` parameter,
    ///    as in the above example.
    ///  * A `value` parameter that has a type that matches the type that
    ///    you specify in the scene's initializer.
    ///  * Both an identifier and a value. This enables you to define
    ///    multiple window groups that take input values of the same type like a
    ///    <doc://com.apple.documentation/documentation/Foundation/UUID>.
    ///
    /// Use the first option to target either a ``WindowGroup`` or a
    /// ``Window`` scene in your app that has a matching identifier. For a
    /// `WindowGroup`, the system creates a new window for the group. If
    /// the window group presents data, the system provides the default value
    /// or `nil` to the window's root view. If the targeted scene is a
    /// `Window`, the system orders it to the front.
    ///
    /// Use the other two options to target a `WindowGroup` and provide
    /// a value to present. If the interface already has a window from
    /// the group that's presenting the specified value, the system brings the
    /// window to the front. Otherwise, the system creates a new window and
    /// passes a binding to the specified value.
    public var openWindow: OpenWindowAction { get }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// Sets whether this view mirrors its contents horizontally when the layout
    /// direction is right-to-left.
    ///
    /// Use `flipsForRightToLeftLayoutDirection(_:)` when you need the system to
    /// horizontally mirror the contents of the view when presented in
    /// a right-to-left layout.
    ///
    /// To override the layout direction for a specific view, use the
    /// ``View/environment(_:_:)`` view modifier to explicitly override
    /// the ``EnvironmentValues/layoutDirection`` environment value for
    /// the view.
    ///
    /// - Parameter enabled: A Boolean value that indicates whether this view
    ///   should have its content flipped horizontally when the layout
    ///   direction is right-to-left. By default, views will adjust their layouts
    ///   automatically in a right-to-left context and do not need to be mirrored.
    ///
    /// - Returns: A view that conditionally mirrors its contents
    ///   horizontally when the layout direction is right-to-left.
    @inlinable nonisolated public func flipsForRightToLeftLayoutDirection(_ enabled: Bool) -> some View

}

@available(iOS 17.0, macOS 14.0, visionOS 1.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension View {

    /// Sets the style for text editors within this view.
    nonisolated public func textEditorStyle(_ style: some TextEditorStyle) -> some View

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// Sets the style for toggles in a view hierarchy.
    ///
    /// Use this modifier on a ``Toggle`` instance to set a style that defines
    /// the control's appearance and behavior. For example, you can choose
    /// the ``ToggleStyle/switch`` style:
    ///
    ///     Toggle("Vibrate on Ring", isOn: $vibrateOnRing)
    ///         .toggleStyle(.switch)
    ///
    /// Built-in styles typically have a similar appearance across platforms,
    /// tailored to the platform's overall style:
    ///
    /// | Platform    | Appearance |
    /// |-------------|------------|
    /// | iOS, iPadOS | ![A screenshot of the text Vibrate on Ring appearing to the left of a toggle switch that's on. The toggle's tint color is green. The toggle and its text appear in a rounded rectangle.](View-toggleStyle-1-iOS) |
    /// | macOS       | ![A screenshot of the text Vibrate on Ring appearing to the left of a toggle switch that's on. The toggle's tint color is blue. The toggle and its text appear on a neutral background.](View-toggleStyle-1-macOS) |
    ///
    /// ### Styling toggles in a hierarchy
    ///
    /// You can set a style for all toggle instances within a view hierarchy
    /// by applying the style modifier to a container view. For example, you
    /// can apply the ``ToggleStyle/button`` style to an ``HStack``:
    ///
    ///     HStack {
    ///         Toggle(isOn: $isFlagged) {
    ///             Label("Flag", systemImage: "flag.fill")
    ///         }
    ///         Toggle(isOn: $isMuted) {
    ///             Label("Mute", systemImage: "speaker.slash.fill")
    ///         }
    ///     }
    ///     .toggleStyle(.button)
    ///
    /// The example above has the following appearance when `isFlagged` is
    /// `true` and `isMuted` is `false`:
    ///
    /// | Platform    | Appearance |
    /// |-------------|------------|
    /// | iOS, iPadOS | ![A screenshot of two buttons arranged horizontally. The first has the image of a flag and is active with a blue tint. The second has an image of a speaker with a line through it and is inactive with a neutral tint.](View-toggleStyle-2-iOS) |
    /// | macOS       | ![A screenshot of two buttons arranged horizontally. The first has the image of a flag and is active with a blue tint. The second has an image of a speaker with a line through it and is inactive with a neutral tint.](View-toggleStyle-2-macOS) |
    ///
    /// ### Automatic styling
    ///
    /// If you don't set a style, SwiftUI assumes a value of
    /// ``ToggleStyle/automatic``, which corresponds to a context-specific
    /// default. Specify the automatic style explicitly to override a
    /// container's style and revert to the default:
    ///
    ///     HStack {
    ///         Toggle(isOn: $isShuffling) {
    ///             Label("Shuffle", systemImage: "shuffle")
    ///         }
    ///         Toggle(isOn: $isRepeating) {
    ///             Label("Repeat", systemImage: "repeat")
    ///         }
    ///
    ///         Divider()
    ///
    ///         Toggle("Enhance Sound", isOn: $isEnhanced)
    ///             .toggleStyle(.automatic) // Revert to the default style.
    ///     }
    ///     .toggleStyle(.button) // Use button style for toggles in the stack.
    ///     .labelStyle(.iconOnly) // Omit the title from any labels.
    ///
    /// The style that SwiftUI uses as the default depends on both the platform
    /// and the context. In macOS, the default in most contexts is a
    /// ``ToggleStyle/checkbox``, while in iOS, the default toggle style is a
    /// ``ToggleStyle/switch``:
    ///
    /// | Platform    | Appearance |
    /// |-------------|------------|
    /// | iOS, iPadOS | ![A screenshot of several horizontally arranged items: two buttons, a vertical divider line, the text Enhance sound, and a switch. The first button has two right facing arrows that cross over in the middle and is active with a blue tint. The second button has one right and one left facing arrow and is inactive with neutral tint. The switch is on and has a green tint.](View-toggleStyle-3-iOS) |
    /// | macOS       | ![A screenshot of several horizontally arranged items: two buttons, a vertical divider line, a checkbox, and the text Enhance sound. The first button has two right facing arrows that cross over in the middle and is active with a blue tint. The second button has one right and one left facing arrow and is inactive with a neutral tint. The check box is checked and has a blue tint.](View-toggleStyle-3-macOS) |
    ///
    /// > Note: Like toggle style does for toggles, the ``View/labelStyle(_:)``
    /// modifier sets the style for ``Label`` instances in the hierarchy. The
    /// example above demostrates the compact ``LabelStyle/iconOnly`` style,
    /// which is useful for button toggles in space-constrained contexts.
    /// Always include a descriptive title for better accessibility.
    ///
    /// For more information about how SwiftUI chooses a default toggle style,
    /// see the ``ToggleStyle/automatic`` style.
    ///
    /// - Parameter style: The toggle style to set. Use one of the built-in
    ///   values, like ``ToggleStyle/switch`` or ``ToggleStyle/button``,
    ///   or a custom style that you define by creating a type that conforms
    ///   to the ``ToggleStyle`` protocol.
    ///
    /// - Returns: A view that uses the specified toggle style for itself
    ///   and its child views.
    nonisolated public func toggleStyle<S>(_ style: S) -> some View where S : ToggleStyle

}

extension View {

    /// Sets the visibility of the status bar.
    ///
    /// - Parameter hidden: A Boolean value that indicates whether to hide the
    ///   status bar.
    @available(iOS 13.0, *)
    @available(macOS, unavailable)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    nonisolated public func statusBarHidden(_ hidden: Bool = true) -> some View

}

extension View {

    /// Sets the visibility of the status bar.
    ///
    /// Use `statusBar(hidden:)` to show or hide the status bar.
    ///
    /// - Parameter hidden: A Boolean value that indicates whether to hide the
    ///   status bar.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, renamed: "statusBarHidden(_:)")
    @available(macOS, unavailable)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, renamed: "statusBarHidden(_:)")
    nonisolated public func statusBar(hidden: Bool) -> some View

}

extension View {

    /// Sets the keyboard type for this view.
    ///
    /// Use `keyboardType(_:)` to specify the keyboard type to use for text
    /// entry. A number of different keyboard types are available to meet
    /// specialized input needs, such as entering email addresses or phone
    /// numbers.
    ///
    /// The example below presents a ``TextField`` to input an email address.
    /// Setting the text field's keyboard type to `.emailAddress` ensures the
    /// user can only enter correctly formatted email addresses.
    ///
    ///     TextField("someone@example.com", text: $emailAddress)
    ///         .keyboardType(.emailAddress)
    ///
    /// There are several different kinds of specialized keyboard types
    /// available though the
    /// <doc://com.apple.documentation/documentation/UIKit/UIKeyboardType> enumeration. To
    /// specify the default system keyboard type, use `.default`.
    ///
    /// ![A screenshot showing the use of a specialized keyboard type with a
    /// text field.](SwiftUI-View-keyboardType.png)
    ///
    /// - Parameter type: One of the keyboard types defined in the
    /// <doc://com.apple.documentation/documentation/UIKit/UIKeyboardType> enumeration.
    @available(iOS 13.0, tvOS 13.0, *)
    @available(macOS, unavailable)
    @available(watchOS, unavailable)
    nonisolated public func keyboardType(_ type: UIKeyboardType) -> some View

}

extension View {

    /// Sets whether to apply auto-capitalization to this view.
    ///
    /// Use `autocapitalization(_:)` when you need to automatically capitalize
    /// words, sentences, or other text like proper nouns.
    ///
    /// In example below, as the user enters text each word is automatically
    /// capitalized:
    ///
    ///     TextField("Last, First", text: $fullName)
    ///         .autocapitalization(UITextAutocapitalizationType.words)
    ///
    /// The <doc://com.apple.documentation/documentation/UIKit/UITextAutocapitalizationType>
    /// enumeration defines the available capitalization modes. The default is
    /// <doc://com.apple.documentation/documentation/UIKit/UITextAutocapitalizationType/sentences>.
    ///
    /// - Parameter style: One of the autocapitalization modes defined in the
    /// <doc://com.apple.documentation/documentation/UIKit/UITextAutocapitalizationType>
    /// enumeration.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, message: "use textInputAutocapitalization(_:)")
    @available(macOS, unavailable)
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, message: "use textInputAutocapitalization(_:)")
    @available(watchOS, unavailable)
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "use textInputAutocapitalization(_:)")
    nonisolated public func autocapitalization(_ style: UITextAutocapitalizationType) -> some View

}

@available(iOS 15.0, tvOS 15.0, watchOS 8.0, *)
@available(macOS, unavailable)
extension View {

    /// Sets how often the shift key in the keyboard is automatically enabled.
    ///
    /// Use `textInputAutocapitalization(_:)` when you need to automatically
    /// capitalize words, sentences, or other text like proper nouns.
    ///
    /// In example below, as the user enters text the shift key is
    /// automatically enabled before every word:
    ///
    ///     TextField("Last, First", text: $fullName)
    ///         .textInputAutocapitalization(.words)
    ///
    /// The ``TextInputAutocapitalization`` struct defines the available
    /// autocapitalizing behavior. Providing `nil` to  this view modifier does
    /// not change the autocapitalization behavior. The default is
    /// ``TextInputAutocapitalization.sentences``.
    ///
    /// - Parameter autocapitalization: One of the capitalizing behaviors
    /// defined in the ``TextInputAutocapitalization`` struct or nil.
    nonisolated public func textInputAutocapitalization(_ autocapitalization: TextInputAutocapitalization?) -> some View

}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, *)
@available(watchOS, unavailable)
extension VisualEffect {

    /// Returns a new visual effect that applies `shader` to `self` as
    /// a filter effect on the color of each pixel.
    ///
    /// For a shader function to act as a color filter it must have a
    /// function signature matching:
    ///
    ///     [[ stitchable ]] half4 name(float2 position, half4 color, args...)
    ///
    /// where `position` is the user-space coordinates of the pixel
    /// applied to the shader and `color` its source color, as a
    /// pre-multiplied color in the destination color space. `args...`
    /// should be compatible with the uniform arguments bound to
    /// `shader`. The function should return the modified color value.
    ///
    /// > Important: Views backed by AppKit or UIKit views may not
    ///   render into the filtered layer. Instead, they log a warning
    ///   and display a placeholder image to highlight the error.
    ///
    /// - Parameters:
    ///   - shader: The shader to apply to `self` as a color filter.
    ///   - isEnabled: Whether the effect is enabled or not.
    ///
    /// - Returns: A new view that renders `self` with the shader
    ///   applied as a color filter.
    public func colorEffect(_ shader: Shader, isEnabled: Bool = true) -> some VisualEffect


    /// Returns a new visual effect that applies `shader` to `self` as
    /// a geometric distortion effect on the location of each pixel.
    ///
    /// For a shader function to act as a distortion effect it must
    /// have a function signature matching:
    ///
    ///     [[ stitchable ]] float2 name(float2 position, args...)
    ///
    /// where `position` is the user-space coordinates of the
    /// destination pixel applied to the shader. `args...` should be
    /// compatible with the uniform arguments bound to `shader`. The
    /// function should return the user-space coordinates of the
    /// corresponding source pixel.
    ///
    /// > Important: Views backed by AppKit or UIKit views may not
    ///   render into the filtered layer. Instead, they log a warning
    ///   and display a placeholder image to highlight the error.
    ///
    /// - Parameters:
    ///   - shader: The shader to apply as a distortion effect.
    ///   - maxSampleOffset: The maximum distance in each axis between
    ///     the returned source pixel position and the destination pixel
    ///     position, for all source pixels.
    ///   - isEnabled: Whether the effect is enabled or not.
    ///
    /// - Returns: A new view that renders `self` with the shader
    ///   applied as a distortion effect.
    public func distortionEffect(_ shader: Shader, maxSampleOffset: CGSize, isEnabled: Bool = true) -> some VisualEffect


    /// Returns a new visual effect that applies `shader` to `self` as
    /// a filter on the raster layer created from `self`.
    ///
    /// For a shader function to act as a layer effect it must
    /// have a function signature matching:
    ///
    ///     [[ stitchable ]] half4 name(float2 position,
    ///       SwiftUI::Layer layer, args...)
    ///
    /// where `position` is the user-space coordinates of the
    /// destination pixel applied to the shader, and `layer` is a
    /// subregion of the rasterized contents of `self`. `args...`
    /// should be compatible with the uniform arguments bound to
    /// `shader`.
    ///
    /// The `SwiftUI::Layer` type is defined in the
    /// `<SwiftUI/SwiftUI.h>` header file. It exports a single
    /// `sample()` function that returns a linearly-filtered pixel
    /// value from a position in the source content, as a premultiplied
    /// RGBA pixel value:
    ///
    ///     namespace SwiftUI {
    ///       struct Layer {
    ///         half4 sample(float2 position) const;
    ///       };
    ///     };
    ///
    /// The function should return the color mapping to the destination
    /// pixel, typically by sampling one or more pixels from `layer` at
    /// location(s) derived from `position` and them applying some kind
    /// of transformation to produce a new color.
    ///
    /// > Important: Views backed by AppKit or UIKit views may not
    ///   render into the filtered layer. Instead, they log a warning
    ///   and display a placeholder image to highlight the error.
    ///
    /// - Parameters:
    ///   - shader: The shader to apply as a layer effect.
    ///   - maxSampleOffset: If the shader function samples from the
    ///     layer at locations not equal to the destination position,
    ///     this value must specify the maximum sampling distance in
    ///     each axis, for all source pixels.
    ///   - isEnabled: Whether the effect is enabled or not.
    ///
    /// - Returns: A new view that renders `self` with the shader
    ///   applied as a distortion effect.
    public func layerEffect(_ shader: Shader, maxSampleOffset: CGSize, isEnabled: Bool = true) -> some VisualEffect

}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension View {

    /// Sets the focused value for the given object type.
    ///
    /// - Important: This initializer only accepts objects conforming to the
    ///   `Observable` protocol. For reading environment objects that conform to
    ///   `ObservableObject`, use `focusedObject(_:)`, instead.
    ///
    /// To read this value, use the `FocusedValue` property wrapper.
    nonisolated public func focusedValue<T>(_ object: T?) -> some View where T : AnyObject, T : Observable


    /// Sets the focused value for the given object type at a scene-wide scope.
    ///
    /// - Important: This initializer only accepts objects conforming to the
    ///   `Observable` protocol. For reading environment objects that conform to
    ///   `ObservableObject`, use `focusedObject(_:)`, instead.
    ///
    /// To read this value, use the `FocusedValue` property wrapper.
    nonisolated public func focusedSceneValue<T>(_ object: T?) -> some View where T : AnyObject, T : Observable

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Gesture {

    /// Updates the provided gesture state property as the gesture's value
    /// changes.
    ///
    /// Use this callback to update transient UI state as described in
    /// <doc:Adding-Interactivity-with-Gestures>.
    ///
    /// - Parameters:
    ///   - state: A binding to a view's ``GestureState`` property.
    ///   - body: The callback that SwiftUI invokes as the gesture's value
    ///     changes. Its `currentState` parameter is the updated state of the
    ///     gesture. The `gestureState` parameter is the previous state of the
    ///     gesture, and the `transaction` is the context of the gesture.
    ///
    /// - Returns: A version of the gesture that updates the provided `state` as
    ///   the originating gesture's value changes and that resets the `state`
    ///   to its initial value when the user or the system ends or cancels the
    ///   gesture.
    @MainActor @inlinable @preconcurrency public func updating<State>(_ state: GestureState<State>, body: @escaping (Self.Value, inout State, inout Transaction) -> Void) -> GestureStateGesture<Self, State>
}

@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Color : Transferable {

    /// One group of colorsconstant colorscreated with explicitly specified
    /// component values are transferred as is.
    ///
    /// Another group of colorsstandard colors, like `Color.mint`,
    /// and semantic colors, like `Color.accentColor`are rendered on screen
    /// differently depending on the current ``SwiftUI/Environment``. For transferring,
    /// they are resolved against the default environment and might produce
    /// a slightly different result at the destination if the source of drag
    /// or copy uses a non-default environment.
    @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
    public static var transferRepresentation: some TransferRepresentation { get }

    /// The type of the representation used to import and export the item.
    ///
    /// Swift infers this type from the return value of the
    /// ``transferRepresentation`` property.
    @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
    public typealias Representation = some TransferRepresentation
}

@available(iOS 14.0, tvOS 14.0, watchOS 8.0, *)
@available(macOS, unavailable)
extension View {

    /// Sets the style for the index view within the current environment.
    ///
    /// - Parameter style: The style to apply to this view.
    nonisolated public func indexViewStyle<S>(_ style: S) -> some View where S : IndexViewStyle

}

extension View {

    /// Sets the preferred order of items for menus presented from this view.
    ///
    /// Use this modifier to override the default menu order. On supported
    /// platforms, ``MenuOrder/priority`` order keeps the first items closer
    /// to the users point of interaction, whereas ``MenuOrder/fixed`` order
    /// always orders items from top to bottom.
    ///
    /// On iOS, the ``MenuOrder/automatic`` order resolves to
    /// ``MenuOrder/fixed`` for menus presented within scrollable content.
    /// Pickers that use the ``PickerStyle/menu`` style also default to
    /// ``MenuOrder/fixed`` order. In all other cases, menus default to
    /// ``MenuOrder/priority`` order.
    ///
    /// On macOS, tvOS and watchOS, the ``MenuOrder/automatic`` order always
    /// resolves to ``MenuOrder/fixed`` order.
    ///
    /// The following example creates a menu that presents its content in a
    /// fixed order from top to bottom:
    ///
    ///     Menu {
    ///         Button("Select", action: selectFolders)
    ///         Button("New Folder", action: createFolder)
    ///         Picker("Appearance", selection: $appearance) {
    ///             Label("Icons", systemImage: "square.grid.2x2").tag(Appearance.icons)
    ///             Label("List", systemImage: "list.bullet").tag(Appearance.list)
    ///         }
    ///     } label: {
    ///         Label("Settings", systemImage: "ellipsis.circle")
    ///     }
    ///     .menuOrder(.fixed)
    ///
    /// You can use this modifier on controls that present a menu.
    /// For example, the code below creates a ``Picker`` using the
    /// ``PickerStyle/menu`` style with a priority-based order:
    ///
    ///     Picker("Flavor", selection: $selectedFlavor) {
    ///         Text("Chocolate").tag(Flavor.chocolate)
    ///         Text("Vanilla").tag(Flavor.vanilla)
    ///         Text("Strawberry").tag(Flavor.strawberry)
    ///     }
    ///     .pickerStyle(.menu)
    ///     .menuOrder(.priority)
    ///
    /// You can also use this modifier on context menus. The example below
    /// creates a context menu that presents its content in a fixed order:
    ///
    ///     Text("Favorite Card Suit")
    ///         .padding()
    ///         .contextMenu {
    ///             Button(" - Hearts", action: selectHearts)
    ///             Button(" - Clubs", action: selectClubs)
    ///             Button(" - Spades", action: selectSpades)
    ///             Button(" - Diamonds", action: selectDiamonds)
    ///         }
    ///         .menuOrder(.fixed)
    ///
    /// The modifier has no effect when applied to a subsection or
    /// submenu of a menu.
    ///
    /// - Parameter order: The menu item ordering strategy to apply.
    ///
    /// - Returns: A view that uses the specified menu ordering strategy.
    @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
    nonisolated public func menuOrder(_ order: MenuOrder) -> some View

}

@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension EnvironmentValues {

    /// The preferred order of items for menus presented from this view.
    ///
    /// Set this value for a view hierarchy by calling the
    /// ``View/menuOrder(_:)`` view modifier.
    public var menuOrder: MenuOrder
}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension ShapeStyle where Self == PlaceholderTextShapeStyle {

    /// A style appropriate for placeholder text.
    ///
    /// For information about how to use shape styles, see ``ShapeStyle``.
    public static var placeholder: PlaceholderTextShapeStyle { get }
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension View {

    /// Sets the style for the tab view within the current environment.
    ///
    /// - Parameter style: The style to apply to this tab view.
    nonisolated public func tabViewStyle<S>(_ style: S) -> some View where S : TabViewStyle

}

extension View {

    /// Configures the content margin for a provided placement.
    ///
    /// Use this modifier to customize the content margins of different
    /// kinds of views. For example, you can use this modifier to customize
    /// the margins of scrollable views like ``ScrollView``. In the
    /// following example, the scroll view will automatically inset
    /// its content by the safe area plus an additional 20 points
    /// on the leading and trailing edge.
    ///
    ///     ScrollView(.horizontal) {
    ///         // ...
    ///     }
    ///     .contentMargins(.horizontal, 20.0)
    ///
    /// You can provide a ``ContentMarginPlacement`` to target specific
    /// parts of a view to customize. For example, provide a
    /// ``ContentMargingPlacement/scrollContent`` placement to
    /// inset the content of a ``TextEditor`` without affecting the
    /// insets of its scroll indicators.
    ///
    ///     TextEditor(text: $text)
    ///         .contentMargins(.horizontal, 20.0, for: .scrollContent)
    ///
    /// Similarly, you can customize the insets of scroll indicators
    /// separately from scroll content. Consider doing this when applying
    /// a custom clip shape that may clip the indicators.
    ///
    ///     ScrollView {
    ///         // ...
    ///     }
    ///     .clipShape(.rect(cornerRadius: 20.0))
    ///     .contentMargins(10.0, for: .scrollIndicators)
    ///
    /// When applying multiple contentMargins modifiers, modifiers with
    /// the same placement will override modifiers higher up in the view
    /// hierarchy.
    ///
    /// - Parameters:
    ///   - edges: The edges to add the margins to.
    ///   - insets: The amount of margins to add.
    ///   - placement: Where the margins should be added.
    @available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
    nonisolated public func contentMargins(_ edges: Edge.Set = .all, _ insets: EdgeInsets, for placement: ContentMarginPlacement = .automatic) -> some View


    /// Configures the content margin for a provided placement.
    ///
    /// Use this modifier to customize the content margins of different
    /// kinds of views. For example, you can use this modifier to customize
    /// the margins of scrollable views like ``ScrollView``. In the
    /// following example, the scroll view will automatically inset
    /// its content by the safe area plus an additional 20 points
    /// on the leading and trailing edge.
    ///
    ///     ScrollView(.horizontal) {
    ///         // ...
    ///     }
    ///     .contentMargins(.horizontal, 20.0)
    ///
    /// You can provide a ``ContentMarginPlacement`` to target specific
    /// parts of a view to customize. For example, provide a
    /// ``ContentMargingPlacement/scrollContent`` placement to
    /// inset the content of a ``TextEditor`` without affecting the
    /// insets of its scroll indicators.
    ///
    ///     TextEditor(text: $text)
    ///         .contentMargins(.horizontal, 20.0, for: .scrollContent)
    ///
    /// Similarly, you can customize the insets of scroll indicators
    /// separately from scroll content. Consider doing this when applying
    /// a custom clip shape that may clip the indicators.
    ///
    ///     ScrollView {
    ///         // ...
    ///     }
    ///     .clipShape(.rect(cornerRadius: 20.0))
    ///     .contentMargins(10.0, for: .scrollIndicators)
    ///
    /// When applying multiple contentMargins modifiers, modifiers with
    /// the same placement will override modifiers higher up in the view
    /// hierarchy.
    ///
    /// - Parameters:
    ///   - edges: The edges to add the margins to.
    ///   - length: The amount of margins to add.
    ///   - placement: Where the margins should be added.
    @available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
    nonisolated public func contentMargins(_ edges: Edge.Set = .all, _ length: CGFloat?, for placement: ContentMarginPlacement = .automatic) -> some View


    /// Configures the content margin for a provided placement.
    ///
    /// Use this modifier to customize the content margins of different
    /// kinds of views. For example, you can use this modifier to customize
    /// the margins of scrollable views like ``ScrollView``. In the
    /// following example, the scroll view will automatically inset
    /// its content by the safe area plus an additional 20 points
    /// on the leading and trailing edge.
    ///
    ///     ScrollView(.horizontal) {
    ///         // ...
    ///     }
    ///     .contentMargins(.horizontal, 20.0)
    ///
    /// You can provide a ``ContentMarginPlacement`` to target specific
    /// parts of a view to customize. For example, provide a
    /// ``ContentMargingPlacement/scrollContent`` placement to
    /// inset the content of a ``TextEditor`` without affecting the
    /// insets of its scroll indicators.
    ///
    ///     TextEditor(text: $text)
    ///         .contentMargins(.horizontal, 20.0, for: .scrollContent)
    ///
    /// Similarly, you can customize the insets of scroll indicators
    /// separately from scroll content. Consider doing this when applying
    /// a custom clip shape that may clip the indicators.
    ///
    ///     ScrollView {
    ///         // ...
    ///     }
    ///     .clipShape(.rect(cornerRadius: 20.0))
    ///     .contentMargins(10.0, for: .scrollIndicators)
    ///
    /// When applying multiple contentMargins modifiers, modifiers with
    /// the same placement will override modifiers higher up in the view
    /// hierarchy.
    ///
    /// - Parameters:
    ///   - length: The amount of margins to add on all edges.
    ///   - placement: Where the margins should be added.
    @available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
    nonisolated public func contentMargins(_ length: CGFloat, for placement: ContentMarginPlacement = .automatic) -> some View

}

@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension View {

    /// Sets the style for disclosure groups within this view.
    @available(iOS 16.0, macOS 13.0, *)
    @available(watchOS, unavailable)
    nonisolated public func disclosureGroupStyle<S>(_ style: S) -> some View where S : DisclosureGroupStyle

}

@available(iOS 17.0, visionOS 1.0, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension EnvironmentValues {

    /// The current capture state.
    ///
    /// Use this value to determine whether the scene is actively being cloned
    /// to another destination (like during AirPlay) or is being mirrored or
    /// recorded.
    ///
    /// Your app can respond to changes in this value to take appropriate action,
    /// like obscuring content.
    public var isSceneCaptured: Bool
}

extension View {

    /// Defines a region of the window in which default focus is evaluated by
    /// assigning a value to a given focus state binding.
    ///
    /// By default, SwiftUI evaluates default focus when the window first
    /// appears, and when a focus state binding update moves focus
    /// automatically, but not when responding to user-driven navigation
    /// commands.
    ///
    /// Clients can override the default behavior by specifying an evaluation
    /// priority of ``DefaultFocusEvaluationPriority/userInitiated``, which
    /// causes SwiftUI to use the client's preferred default focus in response
    /// to user-driven focus navigation as well as automatic changes.
    ///
    /// In the following example, focus automatically goes to the second of the
    /// two text fields when the view is first presented in the window.
    ///
    ///     WindowGroup {
    ///         VStack {
    ///             TextField(...)
    ///                 .focused($focusedField, equals: .firstField)
    ///             TextField(...)
    ///                 .focused($focusedField, equals: .secondField)
    ///         }
    ///         .defaultFocus($focusedField, .secondField)
    ///     }
    ///
    /// - Parameters:
    ///   - binding: A focus state binding to update when evaluating default
    ///     focus in the modified view hierarchy.
    ///   - value: The value to set the binding to during evaluation.
    ///   - priority: An indication of how to prioritize the preferred default
    ///     focus target when focus moves into the modified view hierarchy.
    ///     The default value is `automatic`, which means the preference will
    ///     be given priority when focus is being initialized or relocated
    ///     programmatically, but not when responding to user-directed
    ///     navigation commands.
    /// - Returns: The modified view.
    @available(iOS 17.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
    nonisolated public func defaultFocus<V>(_ binding: FocusState<V>.Binding, _ value: V, priority: DefaultFocusEvaluationPriority = .automatic) -> some View where V : Hashable

}

extension View {

    /// Adds an action to perform when the pointer enters, moves within, and
    /// exits the view's bounds.
    ///
    /// Call this method to define a region for detecting pointer movement with
    /// the size and position of this view.
    /// The following example updates `hoverLocation` and `isHovering` to be
    /// based on the phase provided to the closure:
    ///
    ///     @State private var hoverLocation: CGPoint = .zero
    ///     @State private var isHovering = false
    ///
    ///     var body: some View {
    ///         VStack {
    ///             Color.red
    ///                 .frame(width: 400, height: 400)
    ///                 .onContinuousHover { phase in
    ///                     switch phase {
    ///                     case .active(let location):
    ///                         hoverLocation = location
    ///                         isHovering = true
    ///                     case .ended:
    ///                         isHovering = false
    ///                     }
    ///                 }
    ///                 .overlay {
    ///                     Rectangle()
    ///                         .frame(width: 50, height: 50)
    ///                         .foregroundColor(isHovering ? .green : .blue)
    ///                         .offset(x: hoverLocation.x, y: hoverLocation.y)
    ///                 }
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///    - coordinateSpace: The coordinate space for the
    ///    location values. Defaults to ``CoordinateSpace/local``.
    ///    - action: The action to perform whenever the pointer enters,
    ///    moves within, or exits the view's bounds. The `action` closure
    ///    passes the ``HoverPhase/active(_:)`` phase with the pointer's
    ///    coordinates if the pointer is in the view's bounds; otherwise, it
    ///    passes ``HoverPhase/ended``.
    ///
    /// - Returns: A view that calls `action` when the pointer enters,
    ///   moves within, or exits the view's bounds.
    @available(iOS, introduced: 16.0, deprecated: 100000.0, message: "use overload that accepts a CoordinateSpaceProtocol instead")
    @available(macOS, introduced: 13.0, deprecated: 100000.0, message: "use overload that accepts a CoordinateSpaceProtocol instead")
    @available(tvOS, introduced: 16.0, deprecated: 100000.0, message: "use overload that accepts a CoordinateSpaceProtocol instead")
    @available(watchOS, unavailable)
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "use overload that accepts a CoordinateSpaceProtocol instead")
    nonisolated public func onContinuousHover(coordinateSpace: CoordinateSpace = .local, perform action: @escaping (HoverPhase) -> Void) -> some View

}

extension View {

    /// Adds an action to perform when the pointer enters, moves within, and
    /// exits the view's bounds.
    ///
    /// Use this modifier to define a region for detecting pointer movement with
    /// a view. The following example updates a small rectangle's position
    /// and style by modifying `hoverLocation` and `isHovering` as the pointer
    /// moves within the larger, red rectangle:
    ///
    ///     @State private var hoverLocation: CGPoint = .zero
    ///     @State private var isHovering = false
    ///
    ///     var body: some View {
    ///         Color.red
    ///             .frame(width: 400, height: 400)
    ///             .onContinuousHover { phase in
    ///                 switch phase {
    ///                 case .active(let location):
    ///                     hoverLocation = location
    ///                     isHovering = true
    ///                 case .ended:
    ///                     isHovering = false
    ///                 }
    ///             }
    ///             .overlay {
    ///                 Rectangle()
    ///                     .frame(width: 50, height: 50)
    ///                     .foregroundStyle(isHovering ? .green : .blue)
    ///                     .offset(x: hoverLocation.x, y: hoverLocation.y)
    ///             }
    ///     }
    ///
    /// - Parameters:
    ///   - coordinateSpace: The coordinate space for the
    ///     location values. The default value is ``CoordinateSpace/local``.
    ///   - action: The action to perform whenever the pointer enters,
    ///     moves within, or exits the view's bounds. The closure takes
    ///     a `phase` input that has the value ``HoverPhase/active(_:)`` and
    ///     contains the pointer's coordinates if the pointer is within the
    ///     view's bounds. The closure receives the ``HoverPhase/ended``
    ///     phase when the pointer leaves the view's bounds.
    ///
    /// - Returns: A view that calls `action` when the pointer enters,
    ///   moves within, or exits the view's bounds.
    @available(iOS 17.0, macOS 14.0, tvOS 17.0, *)
    @available(watchOS, unavailable)
    nonisolated public func onContinuousHover(coordinateSpace: some CoordinateSpaceProtocol = .local, perform action: @escaping (HoverPhase) -> Void) -> some View

}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension View {

    /// Returns a new view with a symbol effect added to it.
    ///
    /// The following example adds a repeating pulse effect to two
    /// symbol images:
    ///
    ///     VStack {
    ///         Image(systemName: "bolt.slash.fill")
    ///         Image(systemName: "folder.fill.badge.person.crop")
    ///     }
    ///     .symbolEffect(.pulse)
    ///
    /// - Parameters:
    ///   - effect: A symbol effect to add to the view. Existing effects
    ///     added by ancestors of the view are preserved, but may be
    ///     overridden by the new effect. Added effects will be applied
    ///     to the ``SwiftUI/Image` views contained by the child view.
    ///   - isActive: whether the effect is active or inactive.
    ///
    /// - Returns: a copy of the view with a symbol effect added.
    nonisolated public func symbolEffect<T>(_ effect: T, options: SymbolEffectOptions = .default, isActive: Bool = true) -> some View where T : IndefiniteSymbolEffect, T : SymbolEffect


    /// Returns a new view with a symbol effect added to it.
    ///
    /// The following example adds a bounce effect to two symbol
    /// images, the animation will play each time `counter` changes:
    ///
    ///     VStack {
    ///         Image(systemName: "bolt.slash.fill")
    ///         Image(systemName: "folder.fill.badge.person.crop")
    ///     }
    ///     .symbolEffect(.bounce, value: counter)
    ///
    /// - Parameters:
    ///   - effect: A symbol effect to add to the view. Existing effects
    ///     added by ancestors of the view are preserved, but may be
    ///     overridden by the new effect. Added effects will be applied
    ///     to the ``SwiftUI/Image` views contained by the child view.
    ///   - value: the value to monitor for changes, the animation is
    ///     triggered each time the value changes.
    ///
    /// - Returns: a copy of the view with a symbol effect added.
    nonisolated public func symbolEffect<T, U>(_ effect: T, options: SymbolEffectOptions = .default, value: U) -> some View where T : DiscreteSymbolEffect, T : SymbolEffect, U : Equatable

}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension Transition where Self == SymbolEffectTransition {

    /// Creates a transition that applies the provided effect to symbol
    /// images within the inserted or removed view hierarchy. Other
    /// views are unaffected by this transition.
    ///
    /// - Parameter effect: the symbol effect value.
    ///
    /// - Returns: a new transition.
    @MainActor @preconcurrency public static func symbolEffect<T>(_ effect: T, options: SymbolEffectOptions = .default) -> SymbolEffectTransition where T : SymbolEffect, T : TransitionSymbolEffect

    /// A transition that applies the default symbol effect transition
    /// to symbol images within the inserted or removed view hierarchy.
    /// Other views are unaffected by this transition.
    @MainActor @preconcurrency public static var symbolEffect: SymbolEffectTransition { get }
}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension ContentTransition {

    /// Creates a content transition that applies the symbol Replace
    /// animation to symbol images that it is applied to.
    ///
    /// - Parameter config: the animation configuration value.
    ///
    /// - Returns: a new content transition.
    public static func symbolEffect<T>(_ effect: T, options: SymbolEffectOptions = .default) -> ContentTransition where T : ContentTransitionSymbolEffect, T : SymbolEffect

    /// A content transition that applies the default symbol effect
    /// transition to symbol images within the inserted or removed view
    /// hierarchy. Other views are unaffected by this transition.
    public static var symbolEffect: ContentTransition { get }
}

extension WiggleSymbolEffect {

    /// Returns a copy of the effect requesting an animation that moves
    /// back and forth along an axis with the passed in angle.
    @available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
    public func custom(angle: Angle) -> WiggleSymbolEffect
}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Group {

    /// Constructs a group from the subviews of the given view.
    ///
    /// Use this initializer to create a group that gives you programmatic
    /// access to the group's subviews. The following `CardsView` defines the
    /// group's structure based on the set of views that you provide to it:
    ///
    ///     struct CardsView<Content: View>: View {
    ///         var content: Content
    ///
    ///         init(@ViewBuilder content: () -> Content) {
    ///             self.content = content()
    ///         }
    ///
    ///         var body: some View {
    ///             VStack {
    ///                 Group(subviews: content) { subviews in
    ///                     HStack {
    ///                         if subviews.count >= 2 {
    ///                             SecondaryCard { subview[1] }
    ///                         }
    ///                         if let first = subviews.first {
    ///                             FeatureCard { first }
    ///                         }
    ///                         if subviews.count >= 3 {
    ///                             SecondaryCard { subviews[2] }
    ///                         }
    ///                     }
    ///                     if subviews.count > 3 {
    ///                         subviews[3...]
    ///                     }
    ///                 }
    ///             }
    ///         }
    ///     }
    ///
    /// You can use `CardsView` with its view builder-based initializer to
    /// arrange a collection of subviews:
    ///
    ///     CardsView {
    ///         NavigationLink("What's New!") { WhatsNewView() }
    ///         NavigationLink("Latest Hits") { LatestHitsView() }
    ///         NavigationLink("Favorites") { FavoritesView() }
    ///         NavigationLink("Playlists") { MyPlaylists() }
    ///     }
    ///
    /// Subviews collection constructs subviews on demand, so only access the
    /// part of the collection you need to create the resulting content.
    ///
    /// Subviews are proxies to the view they represent, which means
    /// that modifiers that you apply to the original view take effect before
    /// modifiers that you apply to the subview. SwiftUI resolves the view
    /// using the environment of its container rather than the environment of
    /// its subview proxy. Additionally, because subviews represent a
    /// single view or container, a subview might represent a view after the
    /// application of styles. As a result, applying a style to a subview might
    /// have no effect.
    ///
    /// - Parameters:
    ///   - view: The view to get the subviews of.
    ///   - transform: A closure that constructs a view from the collection of
    ///     subviews.
    public init<Base, Result>(subviews view: Base, @ViewBuilder transform: @escaping (SubviewsCollection) -> Result) where Content == GroupElementsOfContent<Base, Result>, Base : View, Result : View
}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension View {

    /// Sets the behavior of this view for different layout directions.
    ///
    /// Use `layoutDirectionBehavior(_:)` when you need the system to
    /// horizontally mirror the contents of the view when presented in a
    /// layout direction.
    ///
    /// To override the layout direction for a specific view, use the
    /// ``View/environment(_:_:)`` view modifier to explicitly override
    /// the ``EnvironmentValues/layoutDirection`` environment value for
    /// the view.
    ///
    /// - Parameter behavior: A LayoutDirectionBehavior value that indicates
    ///   whether this view should mirror in a particular layout direction. By
    ///   default, views will adjust their layouts automatically in a
    ///   right-to-left context and do not need to be mirrored.
    ///
    /// - Returns: A view that conditionally mirrors its contents
    ///   horizontally in a given layout direction.
    @inlinable nonisolated public func layoutDirectionBehavior(_ behavior: LayoutDirectionBehavior) -> some View

}

extension View {

    /// Adds an action to be called with information about what views would
    /// be considered visible.
    ///
    /// Use this modifier along with the modifier ``View/scrollTargetLayout()``
    /// to be informed when the views in the targetted scroll view have crossed
    /// the provided threshold to be considered on/off screen.
    ///
    ///     ScrollView {
    ///         LazyVStack {
    ///             ForEach(models) { model in
    ///                 CardView(model: model)
    ///             }
    ///         }
    ///         .scrollTargetLayout()
    ///     }
    ///     .onScrollTargetVisibilityChange(for: Model.ID.self, threshold: 0.2) { onScreenCards in
    ///         // Disable video playback for cards that are offscreen...
    ///     }
    ///
    /// - Parameters:
    ///   - idType: The type of Identity provided by the subviews.
    ///   - threshold: The amount required to be visible within the viewport of the
    ///   the scrollview before the `action` is fired.  By default when the view
    ///   has crossed more than 50% on-screen, the action will be called.
    ///   - action: The action which will be called when the views within the
    ///   scroll view cross the provided threshold. The callback will include
    ///   which views are considered visible.
    @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
    nonisolated public func onScrollTargetVisibilityChange<ID>(idType: ID.Type, threshold: Double = 0.5, _ action: @escaping ([ID]) -> Void) -> some View where ID : Hashable


    /// Adds an action to be called when the view crosses the threshold to be considered on/off screen.
    ///
    /// Use this modifier to be informed when the view has crossed the
    /// provided threshold to be considered on/off screen.
    ///
    ///     struct VideoPlayer: View {
    ///         @State var playing: Bool
    ///
    ///         var body: some View {
    ///             Group {
    ///                 // ...
    ///             }
    ///             .onScrollVisibilityChange(threshold: 0.2) { isVisible in
    ///                 playing = isVisible
    ///             }
    ///         }
    ///     }
    ///
    /// When the view appears on-screen, the action will be called if the threshold
    /// has already been reached.
    ///
    /// - Parameters:
    ///   - threshold: The amount required to be visible within the viewport of the the parent
    ///   view before the `action` is fired. By default when the view has crossed more than 50%
    ///   on-screen, the action will be called.
    ///   - action: The action which will be called when the threshold has been reached.
    @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
    nonisolated public func onScrollVisibilityChange(threshold: Double = 0.5, _ action: @escaping (Bool) -> Void) -> some View

}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension View {

    /// Adds an asynchronous task to perform before this view appears.
    ///
    /// Use this modifier to perform an asynchronous task with a lifetime that
    /// matches that of the modified view. If the task doesn't finish
    /// before SwiftUI removes the view or the view changes identity, SwiftUI
    /// cancels the task.
    ///
    /// Use the `await` keyword inside the task to
    /// wait for an asynchronous call to complete, or to wait on the values of
    /// an <doc://com.apple.documentation/documentation/Swift/AsyncSequence>
    /// instance. For example, you can modify a ``Text`` view to start a task
    /// that loads content from a remote resource:
    ///
    ///     let url = URL(string: "https://example.com")!
    ///     @State private var message = "Loading..."
    ///
    ///     var body: some View {
    ///         Text(message)
    ///             .task {
    ///                 do {
    ///                     var receivedLines = [String]()
    ///                     for try await line in url.lines {
    ///                         receivedLines.append(line)
    ///                         message = "Received \(receivedLines.count) lines"
    ///                     }
    ///                 } catch {
    ///                     message = "Failed to load"
    ///                 }
    ///             }
    ///     }
    ///
    /// This example uses the
    /// <doc://com.apple.documentation/documentation/Foundation/URL/3767315-lines>
    /// method to get the content stored at the specified
    /// <doc://com.apple.documentation/documentation/Foundation/URL> as an
    /// asynchronous sequence of strings. When each new line arrives, the body
    /// of the `for`-`await`-`in` loop stores the line in an array of strings
    /// and updates the content of the text view to report the latest line
    /// count.
    ///
    /// - Parameters:
    ///   - priority: The task priority to use when creating the asynchronous
    ///     task. The default priority is
    ///     <doc://com.apple.documentation/documentation/Swift/TaskPriority/userInitiated>.
    ///   - action: A closure that SwiftUI calls as an asynchronous task
    ///     before the view appears. SwiftUI will automatically cancel the task
    ///     at some point after the view disappears before the action completes.
    ///
    ///
    /// - Returns: A view that runs the specified action asynchronously before
    ///   the view appears.
    @inlinable nonisolated public func task(priority: TaskPriority = .userInitiated, _ action: @escaping @Sendable () async -> Void) -> some View


    /// Adds a task to perform before this view appears or when a specified
    /// value changes.
    ///
    /// This method behaves like ``View/task(priority:_:)``, except that it also
    /// cancels and recreates the task when a specified value changes. To detect
    /// a change, the modifier tests whether a new value for the `id` parameter
    /// equals the previous value. For this to work,
    /// the value's type must conform to the
    /// <doc://com.apple.documentation/documentation/Swift/Equatable> protocol.
    ///
    /// For example, if you define an equatable `Server` type that posts custom
    /// notifications whenever its state changes --- for example, from _signed
    /// out_ to _signed in_ --- you can use the task modifier to update
    /// the contents of a ``Text`` view to reflect the state of the
    /// currently selected server:
    ///
    ///     Text(status ?? "Signed Out")
    ///         .task(id: server) {
    ///             let sequence = NotificationCenter.default.notifications(
    ///                 named: .didUpdateStatus,
    ///                 object: server
    ///             ).compactMap {
    ///                 $0.userInfo?["status"] as? String
    ///             }
    ///             for await value in sequence {
    ///                 status = value
    ///             }
    ///         }
    ///
    /// This example uses the
    /// <doc://com.apple.documentation/documentation/Foundation/NotificationCenter/3813137-notifications>
    /// method to create an asynchronous sequence of notifications, given by an
    /// <doc://com.apple.documentation/documentation/Swift/AsyncSequence>
    /// instance. The example then maps the notification sequence to a sequence
    /// of strings that correspond to values stored with each notification.
    ///
    /// Elsewhere, the server defines a custom `didUpdateStatus` notification:
    ///
    ///     extension NSNotification.Name {
    ///         static var didUpdateStatus: NSNotification.Name {
    ///             NSNotification.Name("didUpdateStatus")
    ///         }
    ///     }
    ///
    /// Whenever the server status changes, like after the user signs in, the
    /// server posts a notification of this custom type:
    ///
    ///     let notification = Notification(
    ///         name: .didUpdateStatus,
    ///         object: self,
    ///         userInfo: ["status": "Signed In"])
    ///     NotificationCenter.default.post(notification)
    ///
    /// The task attached to the ``Text`` view gets and displays the status
    /// value from the notification's user information dictionary. When the user
    /// chooses a different server, SwiftUI cancels the task and creates a new
    /// one, which then waits for notifications from the new server.
    ///
    /// - Parameters:
    ///   - id: The value to observe for changes. The value must conform
    ///     to the <doc://com.apple.documentation/documentation/Swift/Equatable>
    ///     protocol.
    ///   - priority: The task priority to use when creating the asynchronous
    ///     task. The default priority is
    ///     <doc://com.apple.documentation/documentation/Swift/TaskPriority/userInitiated>.
    ///   - action: A closure that SwiftUI calls as an asynchronous task
    ///     before the view appears. SwiftUI can automatically cancel the task
    ///     after the view disappears before the action completes. If the
    ///     `id` value changes, SwiftUI cancels and restarts the task.
    ///
    /// - Returns: A view that runs the specified action asynchronously before
    ///   the view appears, or restarts the task when the `id` value changes.
    @inlinable nonisolated public func task<T>(id value: T, priority: TaskPriority = .userInitiated, _ action: @escaping @Sendable () async -> Void) -> some View where T : Equatable

}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension View {

    /// Sets the spring loading behavior this view.
    ///
    /// Spring loading refers to a view being activated during a drag and drop
    /// interaction. On iOS this can occur when pausing briefly on top of a
    /// view with dragged content. On macOS this can occur with similar brief
    /// pauses or on pressure-sensitive systems by "force clicking" during the
    /// drag. This has no effect on tvOS or watchOS.
    ///
    /// This is commonly used with views that have a navigation or presentation
    /// effect, allowing the destination to be revealed without pausing the
    /// drag interaction. For example, a button that reveals a list of folders
    /// that a dragged item can be dropped onto.
    ///
    ///     Button {
    ///         showFolders = true
    ///     } label: {
    ///         Label("Show Folders", systemImage: "folder")
    ///     }
    ///     .springLoadingBehavior(.enabled)
    ///
    /// Unlike `disabled(_:)`, this modifier overrides the value set by an
    /// ancestor view rather than being unioned with it. For example, the below
    /// button would allow spring loading:
    ///
    ///     HStack {
    ///         Button {
    ///             showFolders = true
    ///         } label: {
    ///             Label("Show Folders", systemImage: "folder")
    ///         }
    ///         .springLoadingBehavior(.enabled)
    ///
    ///         ...
    ///     }
    ///     .springLoadingBehavior(.disabled)
    ///
    /// - Parameter behavior: Whether spring loading is enabled or not. If
    ///   unspecified, the default behavior is `.automatic.`
    nonisolated public func springLoadingBehavior(_ behavior: SpringLoadingBehavior) -> some View

}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension EnvironmentValues {

    /// The behavior of spring loaded interactions for the views associated
    /// with this environment.
    ///
    /// Spring loading refers to a view being activated during a drag and drop
    /// interaction. On iOS this can occur when pausing briefly on top of a
    /// view with dragged content. On macOS this can occur with similar brief
    /// pauses or on pressure-sensitive systems by "force clicking" during the
    /// drag. This has no effect on tvOS or watchOS.
    ///
    /// This is commonly used with views that have a navigation or presentation
    /// effect, allowing the destination to be revealed without pausing the
    /// drag interaction. For example, a button that reveals a list of folders
    /// that a dragged item can be dropped onto.
    ///
    /// A value of `enabled` means that a view should support spring loaded
    /// interactions if it is able, and `disabled` means it should not.
    /// A value of `automatic` means that a view should follow its default
    /// behavior, such as a `TabView` automatically allowing spring loading,
    /// but a `Picker` with `segmented` style would not.
    public var springLoadingBehavior: SpringLoadingBehavior { get }
}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension EnvironmentValues {

    /// A Boolean value that determines whether a tab view shows the
    /// expanded contents of a tab section.
    public var isTabBarShowingSections: Bool { get }

    /// The current placement of the tab bar.
    ///
    /// Note that this value is only set within the
    /// content views of a ``TabView``.
    ///
    /// A `nil` value corresponds to an undefined placement.
    public var tabBarPlacement: TabBarPlacement? { get }
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension EnvironmentValues {

    /// The current phase of the scene.
    ///
    /// The system sets this value to provide an indication of the
    /// operational state of a scene or collection of scenes. The exact
    /// meaning depends on where you access the value. For more information,
    /// see ``ScenePhase``.
    public var scenePhase: ScenePhase
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension EnvironmentValues {

    /// The default minimum height of a row in a `List`.
    /// The default minimum height of a row in a list.
    public var defaultMinListRowHeight: CGFloat

    /// The default minimum height of a header in a list.
    ///
    /// When this value is `nil`, the system chooses the appropriate height. The
    /// default is `nil`.
    public var defaultMinListHeaderHeight: CGFloat?
}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension View {

    /// Marks this view as searchable, which configures the display of a
    /// search field.
    ///
    /// For more information about using searchable modifiers, see
    /// <doc:Adding-a-search-interface-to-your-app>.
    ///
    /// - Parameters:
    ///   - text: The text to display and edit in the search field.
    ///   - placement: The preferred placement of the search field within the
    ///     containing view hierarchy.
    ///   - prompt: A ``Text`` view representing the prompt of the search field
    ///     which provides users with guidance on what to search for.
    nonisolated public func searchable(text: Binding<String>, placement: SearchFieldPlacement = .automatic, prompt: Text? = nil) -> some View


    /// Marks this view as searchable, which configures the display of a
    /// search field.
    ///
    /// For more information about using searchable modifiers, see
    /// <doc:Adding-a-search-interface-to-your-app>.
    ///
    /// - Parameters:
    ///   - text: The text to display and edit in the search field.
    ///   - placement: The preferred placement of the search field within the
    ///     containing view hierarchy.
    ///   - prompt: The key for the localized prompt of the search field
    ///     which provides users with guidance on what to search for.
    nonisolated public func searchable(text: Binding<String>, placement: SearchFieldPlacement = .automatic, prompt: LocalizedStringKey) -> some View


    /// Marks this view as searchable, which configures the display of a
    /// search field.
    ///
    /// For more information about using searchable modifiers, see
    /// <doc:Adding-a-search-interface-to-your-app>.
    ///
    /// - Parameters:
    ///   - text: The text to display and edit in the search field.
    ///   - placement: The preferred placement of the search field within the
    ///     containing view hierarchy.
    ///   - prompt: A string representing the prompt of the search field
    ///     which provides users with guidance on what to search for.
    nonisolated public func searchable<S>(text: Binding<String>, placement: SearchFieldPlacement = .automatic, prompt: S) -> some View where S : StringProtocol

}

extension View {

    /// Marks this view as searchable with programmatic presentation of the
    /// search field.
    ///
    /// For more information about using searchable modifiers, see
    /// <doc:Adding-a-search-interface-to-your-app>.
    /// For information about presenting a search field programmatically, see
    /// <doc:Managing-search-interface-activation>.
    ///
    /// - Parameters:
    ///   - text: The text to display and edit in the search field.
    ///   - isPresenting: A ``Binding`` that controls the presented state
    ///     of search.
    ///   - placement: The preferred placement of the search field within the
    ///     containing view hierarchy.
    ///   - prompt: A ``Text`` view representing the prompt of the search field
    ///     which provides users with guidance on what to search for.
    @available(iOS 17.0, macOS 14.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    nonisolated public func searchable(text: Binding<String>, isPresented: Binding<Bool>, placement: SearchFieldPlacement = .automatic, prompt: Text? = nil) -> some View


    /// Marks this view as searchable with programmatic presentation of the
    /// search field.
    ///
    /// For more information about using searchable modifiers, see
    /// <doc:Adding-a-search-interface-to-your-app>.
    /// For information about presenting a search field programmatically, see
    /// <doc:Managing-search-interface-activation>.
    ///
    /// - Parameters:
    ///   - text: The text to display and edit in the search field.
    ///   - isPresenting: A ``Binding`` that controls the presented state
    ///     of search.
    ///   - placement: The preferred placement of the search field within the
    ///     containing view hierarchy.
    ///   - prompt: The key for the localized prompt of the search field
    ///     which provides users with guidance on what to search for.
    @available(iOS 17.0, macOS 14.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    nonisolated public func searchable(text: Binding<String>, isPresented: Binding<Bool>, placement: SearchFieldPlacement = .automatic, prompt: LocalizedStringKey) -> some View


    /// Marks this view as searchable with programmatic presentation of the
    /// search field.
    ///
    /// For more information about using searchable modifiers, see
    /// <doc:Adding-a-search-interface-to-your-app>.
    /// For information about presenting a search field programmatically, see
    /// <doc:Managing-search-interface-activation>.
    ///
    /// - Parameters:
    ///   - text: The text to display and edit in the search field.
    ///   - isPresenting: A ``Binding`` that controls the presented state
    ///     of search.
    ///   - placement: The preferred placement of the search field within the
    ///     containing view hierarchy.
    ///   - prompt: A string representing the prompt of the search field
    ///     which provides users with guidance on what to search for.
    @available(iOS 17.0, macOS 14.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    nonisolated public func searchable<S>(text: Binding<String>, isPresented: Binding<Bool>, placement: SearchFieldPlacement = .automatic, prompt: S) -> some View where S : StringProtocol

}

@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension ForEach {

    /// Creates an instance that uniquely identifies and creates views across
    /// updates based on the identity of the underlying data.
    ///
    /// It's important that the `id` of a data element doesn't change unless you
    /// replace the data element with a new data element that has a new
    /// identity. If the `id` of a data element changes, the content view
    /// generated from that data element loses any current state and animations.
    ///
    /// When placed inside a `List` the edit actions (like delete or move)
    /// can be automatically synthesized by specifying an appropriate
    /// `EditActions`.
    ///
    /// The following example shows a list of recipes whose elements can be
    /// deleted and reordered:
    ///
    ///     List {
    ///         ForEach($recipes, editActions: [.delete, .move]) { $recipe in
    ///             RecipeCell($recipe)
    ///         }
    ///     }
    ///
    /// Use ``View/deleteDisabled(_:)`` and ``View/moveDisabled(_:)``
    /// to disable respectively delete or move actions on a per-row basis.
    ///
    /// The following example shows a list of recipes whose elements can be
    /// deleted only if they satisfy a condition:
    ///
    ///     List {
    ///         ForEach($recipes, editActions: .delete) { $recipe in
    ///             RecipeCell($recipe)
    ///                 .deleteDisabled(recipe.isFromMom)
    ///         }
    ///     }
    ///
    /// Explicit ``DynamicViewContent.onDelete(perform:)``,
    /// ``DynamicViewContent.onMove(perform:)``, or
    /// ``View.swipeActions(edge:allowsFullSwipe:content:)``
    /// modifiers will override any synthesized actions.
    /// Use this modifier if you need fine-grain control on how mutations are
    /// applied to the data driving the `ForEach`. For example, if you need to
    /// execute side effects or call into your existing model code.
    ///
    /// - Parameters:
    ///   - data: The identified data that the ``ForEach`` instance uses to
    ///     create views dynamically and can be edited by the user.
    ///   - editActions: The edit actions that are synthesized on `data`.
    ///   - content: The view builder that creates views dynamically.
    public init<C, R>(_ data: Binding<C>, editActions: EditActions<C>, @ViewBuilder content: @escaping (Binding<C.Element>) -> R) where Data == IndexedIdentifierCollection<C, ID>, ID == C.Element.ID, Content == EditableCollectionContent<R, C>, C : MutableCollection, C : RandomAccessCollection, R : View, C.Element : Identifiable, C.Index : Hashable

    /// Creates an instance that uniquely identifies and creates views across
    /// updates based on the identity of the underlying data.
    ///
    /// It's important that the `id` of a data element doesn't change unless you
    /// replace the data element with a new data element that has a new
    /// identity. If the `id` of a data element changes, the content view
    /// generated from that data element loses any current state and animations.
    ///
    /// When placed inside a `List` the edit actions (like delete or move)
    /// can be automatically synthesized by specifying an appropriate
    /// `EditActions`.
    ///
    /// The following example shows a list of recipes whose elements can be
    /// deleted and reordered:
    ///
    ///     List {
    ///         ForEach($recipes, editActions: [.delete, .move]) { $recipe in
    ///             RecipeCell($recipe)
    ///         }
    ///     }
    ///
    /// Use ``View/deleteDisabled(_:)`` and ``View/moveDisabled(_:)``
    /// to disable respectively delete or move actions on a per-row basis.
    ///
    /// The following example shows a list of recipes whose elements can be
    /// deleted only if they satisfy a condition:
    ///
    ///     List {
    ///         ForEach($recipes, editActions: .delete) { $recipe in
    ///             RecipeCell($recipe)
    ///                 .deleteDisabled(recipe.isFromMom)
    ///         }
    ///     }
    ///
    /// Explicit ``DynamicViewContent.onDelete(perform:)``,
    /// ``DynamicViewContent.onMove(perform:)``, or
    /// ``View.swipeActions(edge:allowsFullSwipe:content:)``
    /// modifiers will override any synthesized actions.
    /// Use this modifier if you need fine-grain control on how mutations are
    /// applied to the data driving the `ForEach`. For example, if you need to
    /// execute side effects or call into your existing model code.
    ///
    /// - Parameters:
    ///   - data: The identified data that the ``ForEach`` instance uses to
    ///     create views dynamically and can be edited by the user.
    ///   - id: The key path to the provided data's identifier.
    ///   - editActions: The edit actions that are synthesized on `data`.
    ///   - content: The view builder that creates views dynamically.
    public init<C, R>(_ data: Binding<C>, id: KeyPath<C.Element, ID>, editActions: EditActions<C>, @ViewBuilder content: @escaping (Binding<C.Element>) -> R) where Data == IndexedIdentifierCollection<C, ID>, Content == EditableCollectionContent<R, C>, C : MutableCollection, C : RandomAccessCollection, R : View, C.Index : Hashable
}

extension View {

    /// Adds an action to be performed when a value, created from a
    /// geometry proxy, changes.
    ///
    /// The geometry of a view can change frequently, especially if
    /// the view is contained within a ``ScrollView`` and that scroll view
    /// is scrolling.
    ///
    /// You should avoid updating large parts of your app whenever
    /// the scroll geometry changes. To aid in this, you provide two
    /// closures to this modifier:
    ///   * transform: This converts a value of ``GeometryProxy`` to
    ///     your own data type.
    ///   * action: This provides the data type you created in `of`
    ///     and is called whenever the data type changes.
    ///
    /// For example, you can use this modifier to know how much of a view
    /// is visible on screen. In the following example,
    /// the data type you convert to is a ``Bool`` and the action is called
    /// whenever the ``Bool`` changes.
    ///
    ///     ScrollView(.horizontal) {
    ///         LazyHStack {
    ///              ForEach(videos) { video in
    ///                  VideoView(video)
    ///              }
    ///          }
    ///      }
    ///
    ///     struct VideoView: View {
    ///         var video: VideoModel
    ///
    ///         var body: some View {
    ///             VideoPlayer(video)
    ///                 .onGeometryChange(for: Bool.self) { proxy in
    ///                     let frame = proxy.frame(in: .scrollView)
    ///                     let bounds = proxy.bounds(of: .scrollView) ?? .zero
    ///                     let intersection = frame.intersection(
    ///                         CGRect(origin: .zero, size: bounds.size))
    ///                     let visibleHeight = intersection.size.height
    ///                     return (visibleHeight / frame.size.height) > 0.75
    ///                 } action: { isVisible in
    ///                     video.updateAutoplayingState(
    ///                         isVisible: isVisible)
    ///                 }
    ///         }
    ///     }
    ///
    /// For easily responding to geometry changes of a scroll view, see the
    /// ``View/onScrollGeometryChange(for:of:action:)`` modifier.
    ///
    /// - Parameters:
    ///   - type: The type of value transformed from a ``GeometryProxy``.
    ///   - transform: A closure that transforms a ``GeometryProxy``
    ///     to your type.
    ///   - action: A closure to run when the transformed data changes.
    ///   - newValue: The new value that failed the comparison check.
    @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
    nonisolated public func onGeometryChange<T>(for type: T.Type, of transform: @escaping (GeometryProxy) -> T, action: @escaping (_ newValue: T) -> Void) -> some View where T : Equatable

}

extension View {

    /// Adds an action to be performed when a value, created from a
    /// geometry proxy, changes.
    ///
    /// The geometry of a view can change frequently, especially if
    /// the view is contained within a ``ScrollView`` and that scroll view
    /// is scrolling.
    ///
    /// You should avoid updating large parts of your app whenever
    /// the scroll geometry changes. To aid in this, you provide two
    /// closures to this modifier:
    ///   * transform: This converts a value of ``GeometryProxy`` to your
    ///     own data type.
    ///   * action: This provides the data type you created in `of`
    ///     and is called whenever the data type changes.
    ///
    /// For example, you can use this modifier to know how much of a view
    /// is visible on screen. In the following example,
    /// the data type you convert to is a ``Bool`` and the action is called
    /// whenever the ``Bool`` changes.
    ///
    ///     ScrollView(.horizontal) {
    ///         LazyHStack {
    ///              ForEach(videos) { video in
    ///                  VideoView(video)
    ///              }
    ///          }
    ///      }
    ///
    ///     struct VideoView: View {
    ///         var video: VideoModel
    ///
    ///         var body: some View {
    ///             VideoPlayer(video)
    ///                 .onGeometryChange(for: Bool.self) { proxy in
    ///                     let frame = proxy.frame(in: .scrollView)
    ///                     let bounds = proxy.bounds(of: .scrollView) ?? .zero
    ///                     let intersection = frame.intersection(
    ///                         CGRect(origin: .zero, size: bounds.size))
    ///                     let visibleHeight = intersection.size.height
    ///                     return (visibleHeight / frame.size.height) > 0.75
    ///                  } action: { isVisible in
    ///                     video.updateAutoplayingState(
    ///                         isVisible: isVisible)
    ///                 }
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - type: The type of value transformed from a geometry proxy.
    ///   - transform: A closure that transforms a ``GeometryProxy``
    ///     to your type.
    ///   - action: A closure to run when the transformed data changes.
    ///   - oldValue: The old value that failed the comparison check.
    ///   - newValue: The new value that failed the comparison check.
    @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 10.0, *)
    nonisolated public func onGeometryChange<T>(for type: T.Type, of transform: @escaping (GeometryProxy) -> T, action: @escaping (_ oldValue: T, _ newValue: T) -> Void) -> some View where T : Equatable

}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension View {

    /// Adds the provided insets into the safe area of this view.
    ///
    /// Use this modifier when you would like to add a fixed amount
    /// of space to the safe area a view sees.
    ///
    ///     ScrollView(.horizontal) {
    ///         HStack(spacing: 10.0) {
    ///             ForEach(items) { item in
    ///                 ItemView(item)
    ///             }
    ///         }
    ///     }
    ///     .safeAreaPadding(.horizontal, 20.0)
    ///
    /// See the ``View/safeAreaInset(edge:alignment:spacing:content)``
    /// modifier for adding to the safe area based on the size of a
    /// view.
    @available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
    nonisolated public func safeAreaPadding(_ insets: EdgeInsets) -> some View


    /// Adds the provided insets into the safe area of this view.
    ///
    /// Use this modifier when you would like to add a fixed amount
    /// of space to the safe area a view sees.
    ///
    ///     ScrollView(.horizontal) {
    ///         HStack(spacing: 10.0) {
    ///             ForEach(items) { item in
    ///                 ItemView(item)
    ///             }
    ///         }
    ///     }
    ///     .safeAreaPadding(.horizontal, 20.0)
    ///
    /// See the ``View/safeAreaInset(edge:alignment:spacing:content)``
    /// modifier for adding to the safe area based on the size of a
    /// view.
    @available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
    nonisolated public func safeAreaPadding(_ edges: Edge.Set = .all, _ length: CGFloat? = nil) -> some View


    /// Adds the provided insets into the safe area of this view.
    ///
    /// Use this modifier when you would like to add a fixed amount
    /// of space to the safe area a view sees.
    ///
    ///     ScrollView(.horizontal) {
    ///         HStack(spacing: 10.0) {
    ///             ForEach(items) { item in
    ///                 ItemView(item)
    ///             }
    ///         }
    ///     }
    ///     .safeAreaPadding(.horizontal, 20.0)
    ///
    /// See the ``View/safeAreaInset(edge:alignment:spacing:content)``
    /// modifier for adding to the safe area based on the size of a
    /// view.
    @available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
    nonisolated public func safeAreaPadding(_ length: CGFloat) -> some View

}

extension View {

    /// Modifies this view by binding the focus state of the search field
    /// associated with the nearest searchable modifier to the given
    /// Boolean value.
    ///
    /// To control focus by matching a non-boolean value, use the
    /// ``View/searchFocused(_:equals:)`` modifier instead.
    ///
    /// For more information about using searchable modifiers, refer to
    /// <doc:Adding-a-search-interface-to-your-app>.
    ///
    /// - Parameter condition: The focus state to bind. When focus moves
    ///   to the associated search field, the binding sets the bound value to
    ///   `true`. If a caller sets the value to  `true` programmatically, then
    ///   focus moves to the search field. When focus leaves the search field,
    ///   the binding sets the value to `false`. If a caller sets the value to
    ///   `false`, SwiftUI automatically dismisses focus.
    /// - Returns: The modified view.
    @available(iOS 18.0, macOS 15.0, visionOS 2.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    nonisolated public func searchFocused(_ binding: FocusState<Bool>.Binding) -> some View


    /// Modifies this view by binding the focus state of the search field
    /// associated with the nearest searchable modifier to the given value.
    ///
    /// To control focus by matching a simple boolean condition, use the
    /// ``View/searchFocused(_:)`` modifier instead.
    ///
    /// For more information about using searchable modifiers, refer to
    /// <doc:Adding-a-search-interface-to-your-app>.
    ///
    /// - Parameters:
    ///   - binding: The state binding to register. When focus moves to the
    ///     associated search field, the binding sets the bound value to the
    ///     corresponding match value. If a caller sets the state value
    ///     programmatically to the matching value, then focus moves to the
    ///     search field. When focus leaves the search field, the binding sets
    ///     the bound value to `nil`. If a caller sets the value to `nil`,
    ///     SwiftUI automatically dismisses focus.
    ///   - value: The value to match against when determining whether the
    ///     binding should change.
    /// - Returns: The modified view.
    @available(iOS 18.0, macOS 15.0, visionOS 2.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    nonisolated public func searchFocused<V>(_ binding: FocusState<V>.Binding, equals value: V) -> some View where V : Hashable

}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension ForEach {

    /// Creates an instance that uniquely identifies and creates views across
    /// updates based on the sections of a given view.
    ///
    /// - Parameters:
    ///   - view: The view to extract the sections of.
    ///   - content: The view builder that creates views from sections
    public init<V>(sections view: V, @ViewBuilder content: @escaping (SectionConfiguration) -> Content) where Data == ForEachSectionCollection<Content>, ID == SectionConfiguration.ID, Content : View, V : View
}

extension View {

    /// Sets the style for navigation split views within this view.
    ///
    /// - Parameter style: The style to set.
    ///
    /// - Returns: A view that uses the specified navigation split view style.
    @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
    nonisolated public func navigationSplitViewStyle<S>(_ style: S) -> some View where S : NavigationSplitViewStyle

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// Configures whether this view participates in hit test operations.
    @inlinable nonisolated public func allowsHitTesting(_ enabled: Bool) -> some View

}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension ShapeStyle where Self == LinkShapeStyle {

    /// A style appropriate for links.
    ///
    /// For information about how to use shape styles, see ``ShapeStyle``.
    public static var link: LinkShapeStyle { get }
}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension View {

    /// Sets the content shape for this view.
    ///
    /// The content shape has a variety of uses. You can control the kind of the
    /// content shape by specifying one in `kind`. The following example sets
    /// the focus ring shape of the view, without affecting its shape for
    /// hit-testing:
    ///
    ///     MyFocusableView()
    ///         .contentShape(.focusEffect, Circle())
    ///
    /// You can apply multiple kinds of content shapes to the same view. For
    /// example, apply a ``ContentShapeKinds/interaction`` shape and
    /// ``ContentShapeKinds/focusEffect`` shape together to set both the
    /// hit-testing shape and focus ring shape on a view.
    ///
    /// ## Context Menu & Drag Previews
    ///
    /// You can control the preview shown by the system for context menus or
    /// drags using the relevant content shape kind, like
    /// ``ContentShapeKinds/dragPreview`` and
    /// ``ContentShapeKinds/contextMenuPreview``.
    ///
    /// The following example creates a ``VStack`` of an ``Image`` and ``Text``
    /// that has a context menu with a custom content shape:
    ///
    ///     VStack {
    ///         Image("turtlerock")
    ///             .contentShape(.contextMenuPreview,
    ///                           RoundedRectangle(cornerRadius: 10))
    ///         Text("Turtle Rock")
    ///     }
    ///     .contextMenu {
    ///         Button {
    ///             // Add this item to a list of favorites.
    ///         } label: {
    ///             Label("Add to Favorites", systemImage: "heart")
    ///         }
    ///     }
    ///
    /// When someone activates the context menu with an action like touch and
    /// hold in iOS or iPadOS, the system uses the ``Image`` as the preview for
    /// the context menu, applying the requested corner radius.
    ///
    /// The content shape also supports applying modifiers such as
    /// ``InsettableShape/inset(by:)`` to add padding.
    ///
    /// > Note: Similar to ``ContentShapeKinds/focusEffect``,
    /// the ``ContentShapeKinds/contextMenuPreview`` and
    /// ``ContentShapeKinds/dragPreview`` content shapes do not impact the
    /// hit-testing shape. In this example, someone can touch and hold anywhere
    /// on the ``VStack`` to activate the menu. If you only want the ``Image``
    /// to activate the menu, apply ``View/contextMenu(menuItems:)`` to the
    /// ``Image`` instead.
    ///
    /// - Parameters:
    ///   - kind: The kinds to apply to this content shape.
    ///   - shape: The shape to use.
    ///   - eoFill: A Boolean that indicates whether the shape is interpreted
    ///     with the even-odd winding number rule.
    ///
    /// - Returns: A view that uses the given shape for the specified kind.
    @inlinable nonisolated public func contentShape<S>(_ kind: ContentShapeKinds, _ shape: S, eoFill: Bool = false) -> some View where S : Shape

}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension Transaction {

    /// Adds a completion to run when the animations created with this
    /// transaction are all complete.
    ///
    /// The completion callback will always be fired exactly one time. If no
    /// animations are created by the changes in `body`, then the callback will
    /// be called immediately after `body`.
    public mutating func addAnimationCompletion(criteria: AnimationCompletionCriteria = .logicallyComplete, _ completion: @escaping () -> Void)
}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension View {

    /// Applies the given transition, animating between the phases
    /// of the transition as this view appears and disappears within the
    /// visible region of the containing scroll view, or other container
    /// specified using the `coordinateSpace` parameter.
    ///
    /// - Parameters:
    ///   - configuration: The configuration controlling how the
    ///     transition will be applied. The configuration will be applied both
    ///     while the view is coming into view and while it is disappearing (the
    ///     transition is symmetrical).
    ///   - axis: The axis of the containing scroll view over which the
    ///     transition will be applied. The default value of `nil` uses the
    ///     axis of the innermost containing scroll view, or `.vertical` if
    ///     the innermost scroll view is scrollable along both axes.
    ///   - coordinateSpace: The coordinate space of the container that
    ///     visibility is evaluated within. Defaults to `.scrollView`.
    ///   - transition: A closure that applies visual effects as a function of
    ///     the provided phase.
    nonisolated public func scrollTransition(_ configuration: ScrollTransitionConfiguration = .interactive, axis: Axis? = nil, transition: @escaping @Sendable (EmptyVisualEffect, ScrollTransitionPhase) -> some VisualEffect) -> some View


    /// Applies the given transition, animating between the phases
    /// of the transition as this view appears and disappears within the
    /// visible region of the containing scroll view, or other container
    /// specified using the `coordinateSpace` parameter.
    ///
    /// - Parameters:
    ///   - transition: the transition to apply.
    ///   - topLeading: The configuration that drives the transition when
    ///     the view is about to appear at the top edge of a vertical
    ///     scroll view, or the leading edge of a horizont scroll view.
    ///   - bottomTrailing: The configuration that drives the transition when
    ///     the view is about to appear at the bottom edge of a vertical
    ///     scroll view, or the trailing edge of a horizont scroll view.
    ///   - axis: The axis of the containing scroll view over which the
    ///     transition will be applied. The default value of `nil` uses the
    ///     axis of the innermost containing scroll view, or `.vertical` if
    ///     the innermost scroll view is scrollable along both axes.
    ///   - transition: A closure that applies visual effects as a function of
    ///     the provided phase.
    nonisolated public func scrollTransition(topLeading: ScrollTransitionConfiguration, bottomTrailing: ScrollTransitionConfiguration, axis: Axis? = nil, transition: @escaping @Sendable (EmptyVisualEffect, ScrollTransitionPhase) -> some VisualEffect) -> some View

}

extension View {

    @available(iOS, introduced: 13.0, deprecated: 100000.0, message: "Use toolbar(_:) with navigationBarLeading or navigationBarTrailing placement")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, message: "Use toolbar(_:) with navigationBarLeading or navigationBarTrailing placement")
    @available(macOS, unavailable)
    @available(watchOS, unavailable)
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Use toolbar(_:) with navigationBarLeading or navigationBarTrailing placement")
    nonisolated public func navigationBarItems<L, T>(leading: L, trailing: T) -> some View where L : View, T : View


    @available(iOS, introduced: 13.0, deprecated: 100000.0, message: "Use toolbar(_:) with navigationBarLeading or navigationBarTrailing placement")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, message: "Use toolbar(_:) with navigationBarLeading or navigationBarTrailing placement")
    @available(macOS, unavailable)
    @available(watchOS, unavailable)
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Use toolbar(_:) with navigationBarLeading or navigationBarTrailing placement")
    nonisolated public func navigationBarItems<L>(leading: L) -> some View where L : View


    @available(iOS, introduced: 13.0, deprecated: 100000.0, message: "Use toolbar(_:) with navigationBarLeading or navigationBarTrailing placement")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, message: "Use toolbar(_:) with navigationBarLeading or navigationBarTrailing placement")
    @available(macOS, unavailable)
    @available(watchOS, unavailable)
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Use toolbar(_:) with navigationBarLeading or navigationBarTrailing placement")
    nonisolated public func navigationBarItems<T>(trailing: T) -> some View where T : View

}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension LayoutSubview {

    /// The container values associated with the given subview.
    public var containerValues: ContainerValues { get }
}

@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension View {

    /// Sets an explicit type select equivalent text in a collection, such as
    /// a list or table.
    ///
    /// By default, a type select equivalent is automatically derived from any
    /// `Text` or `TextField` content in a list or table. In the below example,
    /// type select can be used to select a person, even though no explicit
    /// value has been set.
    ///
    ///     List(people, selection: $selectedPersonID) { person in
    ///         Label {
    ///             Text(person.name)
    ///         } icon: {
    ///             person.avatar
    ///         }
    ///     }
    ///
    /// An explicit type select value should be set when there is no textual
    /// content or when a different value is desired compared to what's
    /// displayed in the view. Explicit values also provide a more performant
    /// for complex view types. In the below example, type select is explicitly
    /// set to allow selection of views that otherwise only display an image.
    ///
    ///     List(people, selection: $selectedPersonID) { person in
    ///         person.avatar
    ///             .accessibilityLabel(person.name)
    ///             .typeSelectEquivalent(person.name)
    ///     }
    ///
    /// Setting an empty string value disables text selection for the view,
    /// and a value of `nil` results in the view using its default value.
    ///
    /// - Parameter text: The explicit text value to use as a type select
    /// equivalent for a view in a collection.
    @inlinable nonisolated public func typeSelectEquivalent(_ text: Text?) -> some View


    /// Sets an explicit type select equivalent text in a collection, such as
    /// a list or table.
    ///
    /// By default, a type select equivalent is automatically derived from any
    /// `Text` or `TextField` content in a list or table. In the below example,
    /// type select can be used to select a person, even though no explicit
    /// value has been set.
    ///
    ///     List(people, selection: $selectedPersonID) { person in
    ///         Label {
    ///             Text(person.name)
    ///         } icon: {
    ///             person.avatar
    ///         }
    ///     }
    ///
    /// An explicit type select value should be set when there is no textual
    /// content or when a different value is desired compared to what's
    /// displayed in the view. Explicit values also provide a more performant
    /// for complex view types. In the below example, type select is explicitly
    /// set to allow selection of views that otherwise only display an image.
    ///
    ///     List(people, selection: $selectedPersonID) { person in
    ///         person.avatar
    ///             .accessibilityLabel(person.name)
    ///             .typeSelectEquivalent(person.name)
    ///     }
    ///
    /// Setting an empty string value disables text selection for the view,
    /// and a value of `nil` results in the view using its default value.
    ///
    /// - Parameter stringKey: The localized string key to use as a type select
    /// equivalent for a view in a collection.
    nonisolated public func typeSelectEquivalent(_ stringKey: LocalizedStringKey) -> some View


    /// Sets an explicit type select equivalent text in a collection, such as
    /// a list or table.
    ///
    /// By default, a type select equivalent is automatically derived from any
    /// `Text` or `TextField` content in a list or table. In the below example,
    /// type select can be used to select a person, even though no explicit
    /// value has been set.
    ///
    ///     List(people, selection: $selectedPersonID) { person in
    ///         Label {
    ///             Text(person.name)
    ///         } icon: {
    ///             person.avatar
    ///         }
    ///     }
    ///
    /// An explicit type select value should be set when there is no textual
    /// content or when a different value is desired compared to what's
    /// displayed in the view. Explicit values also provide a more performant
    /// for complex view types. In the below example, type select is explicitly
    /// set to allow selection of views that otherwise only display an image.
    ///
    ///     List(people, selection: $selectedPersonID) { person in
    ///         person.avatar
    ///             .accessibilityLabel(person.name)
    ///             .typeSelectEquivalent(person.name)
    ///     }
    ///
    /// Setting an empty string value disables text selection for the view,
    /// and a value of `nil` results in the view using its default value.
    ///
    /// - Parameter string: The string to use as a type select equivalent for a
    /// view in a collection.
    nonisolated public func typeSelectEquivalent<S>(_ string: S) -> some View where S : StringProtocol

}

@available(iOS 13.4, macOS 10.15, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension View {

    /// Adds an action to perform when the user moves the pointer over or away
    /// from the view's frame.
    ///
    /// Calling this method defines a region for detecting pointer movement with
    /// the size and position of this view.
    ///
    /// - Parameter action: The action to perform whenever the pointer enters or
    ///   exits this view's frame. If the pointer is in the view's frame, the
    ///   `action` closure passes `true` as a parameter; otherwise, `false`.
    ///
    /// - Returns: A view that triggers `action` when the pointer enters or
    ///   exits this view's frame.
    @inlinable nonisolated public func onHover(perform action: @escaping (Bool) -> Void) -> some View

}

extension View {

    /// Specifies whether to hide this view from system accessibility features.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityHidden(_:)")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, renamed: "accessibilityHidden(_:)")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityHidden(_:)")
    @available(watchOS, introduced: 6, deprecated: 100000.0, renamed: "accessibilityHidden(_:)")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, renamed: "accessibilityHidden(_:)")
    nonisolated public func accessibility(hidden: Bool) -> ModifiedContent<Self, AccessibilityAttachmentModifier>

    /// Adds a label to the view that describes its contents.
    ///
    /// Use this method to provide an accessibility label for a view that doesn't display text, like an icon.
    /// For example, you could use this method to label a button that plays music with the text "Play".
    /// Don't include text in the label that repeats information that users already have. For example,
    /// don't use the label "Play button" because a button already has a trait that identifies it as a button.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityLabel(_:)")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, renamed: "accessibilityLabel(_:)")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityLabel(_:)")
    @available(watchOS, introduced: 6, deprecated: 100000.0, renamed: "accessibilityLabel(_:)")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, renamed: "accessibilityLabel(_:)")
    nonisolated public func accessibility(label: Text) -> ModifiedContent<Self, AccessibilityAttachmentModifier>

    /// Communicates to the user what happens after performing the view's
    /// action.
    ///
    /// Provide a hint in the form of a brief phrase, like "Purchases the item" or
    /// "Downloads the attachment".
    @available(iOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityHint(_:)")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, renamed: "accessibilityHint(_:)")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityHint(_:)")
    @available(watchOS, introduced: 6, deprecated: 100000.0, renamed: "accessibilityHint(_:)")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, renamed: "accessibilityHint(_:)")
    nonisolated public func accessibility(hint: Text) -> ModifiedContent<Self, AccessibilityAttachmentModifier>

    /// Sets alternate input labels with which users identify a view.
    ///
    /// Provide labels in descending order of importance. Voice Control
    /// and Full Keyboard Access use the input labels.
    ///
    /// > Note: If you don't specify any input labels, the user can still
    ///   refer to the view using the accessibility label that you add with the
    ///   ``accessibility(label:)`` modifier.
    ///
    /// - Parameter inputLabels: An array of Text elements to use as input labels.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityInputLabels(_:)")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, renamed: "accessibilityInputLabels(_:)")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityInputLabels(_:)")
    @available(watchOS, introduced: 6, deprecated: 100000.0, renamed: "accessibilityInputLabels(_:)")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, renamed: "accessibilityInputLabels(_:)")
    nonisolated public func accessibility(inputLabels: [Text]) -> ModifiedContent<Self, AccessibilityAttachmentModifier>

    /// Uses the specified string to identify the view.
    ///
    /// Use this value for testing. It isn't visible to the user.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityIdentifier(_:)")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, renamed: "accessibilityIdentifier(_:)")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityIdentifier(_:)")
    @available(watchOS, introduced: 6, deprecated: 100000.0, renamed: "accessibilityIdentifier(_:)")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, renamed: "accessibilityIdentifier(_:)")
    nonisolated public func accessibility(identifier: String) -> ModifiedContent<Self, AccessibilityAttachmentModifier>

    /// Sets a selection identifier for this view's accessibility element.
    ///
    /// Picker uses the value to determine what node to use for the
    /// accessibility value.
    @available(iOS, deprecated, introduced: 13.0)
    @available(macOS, deprecated, introduced: 10.15)
    @available(tvOS, deprecated, introduced: 13.0)
    @available(watchOS, deprecated, introduced: 6)
    @available(visionOS, introduced: 1.0, deprecated: 1.0)
    nonisolated public func accessibility(selectionIdentifier: AnyHashable) -> ModifiedContent<Self, AccessibilityAttachmentModifier>

    /// Sets the sort priority order for this view's accessibility element,
    /// relative to other elements at the same level.
    ///
    /// Higher numbers are sorted first. The default sort priority is zero.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilitySortPriority(_:)")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, renamed: "accessibilitySortPriority(_:)")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilitySortPriority(_:)")
    @available(watchOS, introduced: 6, deprecated: 100000.0, renamed: "accessibilitySortPriority(_:)")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, renamed: "accessibilitySortPriority(_:)")
    nonisolated public func accessibility(sortPriority: Double) -> ModifiedContent<Self, AccessibilityAttachmentModifier>

    /// Specifies the point where activations occur in the view.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityActivationPoint(_:)")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, renamed: "accessibilityActivationPoint(_:)")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityActivationPoint(_:)")
    @available(watchOS, introduced: 6, deprecated: 100000.0, renamed: "accessibilityActivationPoint(_:)")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, renamed: "accessibilityActivationPoint(_:)")
    nonisolated public func accessibility(activationPoint: CGPoint) -> ModifiedContent<Self, AccessibilityAttachmentModifier>

    /// Specifies the unit point where activations occur in the view.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityActivationPoint(_:)")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, renamed: "accessibilityActivationPoint(_:)")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityActivationPoint(_:)")
    @available(watchOS, introduced: 6, deprecated: 100000.0, renamed: "accessibilityActivationPoint(_:)")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, renamed: "accessibilityActivationPoint(_:)")
    nonisolated public func accessibility(activationPoint: UnitPoint) -> ModifiedContent<Self, AccessibilityAttachmentModifier>
}

extension ModifiedContent where Modifier == AccessibilityAttachmentModifier {

    /// Specifies whether to hide this view from system accessibility features.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityHidden(_:)")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, renamed: "accessibilityHidden(_:)")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityHidden(_:)")
    @available(watchOS, introduced: 6, deprecated: 100000.0, renamed: "accessibilityHidden(_:)")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, renamed: "accessibilityHidden(_:)")
    nonisolated public func accessibility(hidden: Bool) -> ModifiedContent<Content, Modifier>

    /// Adds a label to the view that describes its contents.
    ///
    /// Use this method to provide an accessibility label for a view that doesn't display text, like an icon.
    /// For example, you could use this method to label a button that plays music with the text "Play".
    /// Don't include text in the label that repeats information that users already have. For example,
    /// don't use the label "Play button" because a button already has a trait that identifies it as a button.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityLabel(_:)")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, renamed: "accessibilityLabel(_:)")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityLabel(_:)")
    @available(watchOS, introduced: 6, deprecated: 100000.0, renamed: "accessibilityLabel(_:)")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, renamed: "accessibilityLabel(_:)")
    nonisolated public func accessibility(label: Text) -> ModifiedContent<Content, Modifier>

    /// Communicates to the user what happens after performing the view's
    /// action.
    ///
    /// Provide a hint in the form of a brief phrase, like "Purchases the item" or
    /// "Downloads the attachment".
    @available(iOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityHint(_:)")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, renamed: "accessibilityHint(_:)")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityHint(_:)")
    @available(watchOS, introduced: 6, deprecated: 100000.0, renamed: "accessibilityHint(_:)")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, renamed: "accessibilityHint(_:)")
    nonisolated public func accessibility(hint: Text) -> ModifiedContent<Content, Modifier>

    /// Sets alternate input labels with which users identify a view.
    ///
    /// If you don't specify any input labels, the user can still refer to the view using the accessibility
    /// label that you add with the accessibilityLabel() modifier. Provide labels in descending order
    /// of importance. Voice Control and Full Keyboard Access use the input labels.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityInputLabels(_:)")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, renamed: "accessibilityInputLabels(_:)")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityInputLabels(_:)")
    @available(watchOS, introduced: 6, deprecated: 100000.0, renamed: "accessibilityInputLabels(_:)")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, renamed: "accessibilityInputLabels(_:)")
    nonisolated public func accessibility(inputLabels: [Text]) -> ModifiedContent<Content, Modifier>

    /// Uses the specified string to identify the view.
    ///
    /// Use this value for testing. It isn't visible to the user.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityIdentifier(_:)")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, renamed: "accessibilityIdentifier(_:)")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityIdentifier(_:)")
    @available(watchOS, introduced: 6, deprecated: 100000.0, renamed: "accessibilityIdentifier(_:)")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, renamed: "accessibilityIdentifier(_:)")
    nonisolated public func accessibility(identifier: String) -> ModifiedContent<Content, Modifier>

    @available(iOS, deprecated, introduced: 13.0)
    @available(macOS, deprecated, introduced: 10.15)
    @available(tvOS, deprecated, introduced: 13.0)
    @available(watchOS, deprecated, introduced: 6)
    @available(visionOS, introduced: 1.0, deprecated: 1.0)
    nonisolated public func accessibility(selectionIdentifier: AnyHashable) -> ModifiedContent<Content, Modifier>

    /// Sets the sort priority order for this view's accessibility
    /// element, relative to other elements at the same level.
    ///
    /// Higher numbers are sorted first. The default sort priority is zero.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilitySortPriority(_:)")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, renamed: "accessibilitySortPriority(_:)")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilitySortPriority(_:)")
    @available(watchOS, introduced: 6, deprecated: 100000.0, renamed: "accessibilitySortPriority(_:)")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, renamed: "accessibilitySortPriority(_:)")
    nonisolated public func accessibility(sortPriority: Double) -> ModifiedContent<Content, Modifier>

    /// Specifies the point where activations occur in the view.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityActivationPoint(_:)")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, renamed: "accessibilityActivationPoint(_:)")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityActivationPoint(_:)")
    @available(watchOS, introduced: 6, deprecated: 100000.0, renamed: "accessibilityActivationPoint(_:)")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, renamed: "accessibilityActivationPoint(_:)")
    nonisolated public func accessibility(activationPoint: CGPoint) -> ModifiedContent<Content, Modifier>

    /// Specifies the unit point where activations occur in the view.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityActivationPoint(_:)")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, renamed: "accessibilityActivationPoint(_:)")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityActivationPoint(_:)")
    @available(watchOS, introduced: 6, deprecated: 100000.0, renamed: "accessibilityActivationPoint(_:)")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, renamed: "accessibilityActivationPoint(_:)")
    nonisolated public func accessibility(activationPoint: UnitPoint) -> ModifiedContent<Content, Modifier>
}

@available(iOS 15.0, macOS 13.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension View {

    /// Sets the display mode for the separator associated with this specific row.
    ///
    /// Separators can be presented above and below a row. You can specify to
    /// which edge this preference should apply.
    ///
    /// This modifier expresses a preference to the containing ``List``. The list
    /// style is the final arbiter of the separator visibility.
    ///
    /// The following example shows a simple grouped list whose row separators
    /// are hidden:
    ///
    ///     List {
    ///         ForEach(garage.cars) { car in
    ///             Text(car.model)
    ///                 .listRowSeparator(.hidden)
    ///         }
    ///     }
    ///     .listStyle(.grouped)
    ///
    /// To change the color of a row separators, use
    /// ``View/listRowSeparatorTint(_:edges:)``.
    /// To hide or change the tint color for a section separators, use
    /// ``View/listSectionSeparator(_:edges:)`` and
    /// ``View/listSectionSeparatorTint(_:edges:)``.
    ///
    /// - Parameters:
    ///     - visibility: The visibility of this row's separators.
    ///     - edges: The set of row edges for which this preference applies.
    ///         The list style might already decide to not display separators for
    ///         some edges, typically the top edge. The default is
    ///         ``VerticalEdge/Set/all``.
    ///
    nonisolated public func listRowSeparator(_ visibility: Visibility, edges: VerticalEdge.Set = .all) -> some View


    /// Sets the tint color associated with a row.
    ///
    /// Separators can be presented above and below a row. You can specify to
    /// which edge this preference should apply.
    ///
    /// This modifier expresses a preference to the containing ``List``. The list
    /// style is the final arbiter for the separator tint.
    ///
    /// The following example shows a simple grouped list whose row separators
    /// are tinted based on row-specific data:
    ///
    ///     List {
    ///         ForEach(garage.cars) { car in
    ///             Text(car.model)
    ///                 .listRowSeparatorTint(car.brandColor)
    ///         }
    ///     }
    ///     .listStyle(.grouped)
    ///
    /// To hide a row separators, use
    /// ``View/listRowSeparator(_:edges:)``.
    /// To hide or change the tint color for a section separator, use
    /// ``View/listSectionSeparator(_:edges:)`` and
    /// ``View/listSectionSeparatorTint(_:edges:)``.
    ///
    /// - Parameters:
    ///     - color: The color to use to tint the row separators, or `nil` to
    ///         use the default color for the current list style.
    ///     - edges: The set of row edges for which the tint applies.
    ///         The list style might decide to not display certain separators,
    ///         typically the top edge. The default is ``VerticalEdge/Set/all``.
    ///
    nonisolated public func listRowSeparatorTint(_ color: Color?, edges: VerticalEdge.Set = .all) -> some View

}

@available(iOS 15.0, macOS 13.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension View {

    /// Sets whether to hide the separator associated with a list section.
    ///
    /// Separators can be presented above and below a section. You can specify to
    /// which edge this preference should apply.
    ///
    /// This modifier expresses a preference to the containing ``List``. The list
    /// style is the final arbiter of the separator visibility.
    ///
    /// The following example shows a simple grouped list whose bottom
    /// sections separator are hidden:
    ///
    ///     List {
    ///         ForEach(garage) { garage in
    ///             Section(header: Text(garage.location)) {
    ///                 ForEach(garage.cars) { car in
    ///                     Text(car.model)
    ///                         .listRowSeparatorTint(car.brandColor)
    ///                 }
    ///             }
    ///             .listSectionSeparator(.hidden, edges: .bottom)
    ///         }
    ///     }
    ///     .listStyle(.grouped)
    ///
    /// To change the visibility and tint color for a row separator, use
    /// ``View/listRowSeparator(_:edges:)`` and
    /// ``View/listRowSeparatorTint(_:edges:)``.
    /// To set the tint color for a section separator, use
    /// ``View/listSectionSeparatorTint(_:edges:)``.
    ///
    /// - Parameters:
    ///     - visibility: The visibility of this section's separators.
    ///     - edges: The set of row edges for which the preference applies.
    ///         The list style might already decide to not display separators for
    ///         some edges. The default is ``VerticalEdge/Set/all``.
    ///
    nonisolated public func listSectionSeparator(_ visibility: Visibility, edges: VerticalEdge.Set = .all) -> some View


    /// Sets the tint color associated with a section.
    ///
    /// Separators can be presented above and below a section. You can specify to
    /// which edge this preference should apply.
    ///
    /// This modifier expresses a preference to the containing ``List``. The list
    /// style is the final arbiter for the separator tint.
    ///
    /// The following example shows a simple grouped list whose section separators
    /// are tinted based on section-specific data:
    ///
    ///     List {
    ///         ForEach(garage) { garage in
    ///             Section(header: Text(garage.location)) {
    ///                 ForEach(garage.cars) { car in
    ///                     Text(car.model)
    ///                         .listRowSeparatorTint(car.brandColor)
    ///                 }
    ///             }
    ///             .listSectionSeparatorTint(
    ///                 garage.cars.last?.brandColor, edges: .bottom)
    ///         }
    ///     }
    ///     .listStyle(.grouped)
    ///
    /// To change the visibility and tint color for a row separator, use
    /// ``View/listRowSeparator(_:edges:)`` and
    /// ``View/listRowSeparatorTint(_:edges:)``.
    /// To hide a section separator, use
    /// ``View/listSectionSeparator(_:edges:)``.
    ///
    /// - Parameters:
    ///     - color: The color to use to tint the section separators, or `nil` to
    ///         use the default color for the current list style.
    ///     - edges: The set of row edges for which the tint applies.
    ///         The list style might decide to not display certain separators,
    ///         typically the top edge. The default is ``VerticalEdge/Set/all``.
    ///
    nonisolated public func listSectionSeparatorTint(_ color: Color?, edges: VerticalEdge.Set = .all) -> some View

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// Adds an action to perform when the specified preference key's value
    /// changes.
    ///
    /// - Parameters:
    ///   - key: The key to monitor for value changes.
    ///   - action: The action to perform when the value for `key` changes. The
    ///     `action` closure passes the new value as its parameter.
    ///
    /// - Returns: A view that triggers `action` when the value for `key`
    ///   changes.
    @inlinable nonisolated public func onPreferenceChange<K>(_ key: K.Type = K.self, perform action: @escaping (K.Value) -> Void) -> some View where K : PreferenceKey, K.Value : Equatable

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension View {

    /// Sets the sort priority order for this view's accessibility element,
    /// relative to other elements at the same level.
    ///
    /// Higher numbers are sorted first. The default sort priority is zero.
    nonisolated public func accessibilitySortPriority(_ sortPriority: Double) -> ModifiedContent<Self, AccessibilityAttachmentModifier>
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ModifiedContent where Modifier == AccessibilityAttachmentModifier {

    /// Sets the sort priority order for this view's accessibility
    /// element, relative to other elements at the same level.
    ///
    /// Higher numbers are sorted first. The default sort priority is zero.
    nonisolated public func accessibilitySortPriority(_ sortPriority: Double) -> ModifiedContent<Content, Modifier>
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// Adds an accessibility scroll action to the view. Actions allow
    /// assistive technologies, such as the VoiceOver, to interact with the
    /// view by invoking the action.
    ///
    /// For example, this is how a scroll action to trigger
    /// a refresh could be added to a view.
    ///
    ///     var body: some View {
    ///         ScrollView {
    ///             ContentView()
    ///         }
    ///         .accessibilityScrollAction { edge in
    ///             if edge == .top {
    ///                 // Refresh content
    ///             }
    ///         }
    ///     }
    ///
    nonisolated public func accessibilityScrollAction(_ handler: @escaping (Edge) -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension ModifiedContent where Modifier == AccessibilityAttachmentModifier {

    /// Adds an accessibility scroll action to the view. Actions allow
    /// assistive technologies, such as the VoiceOver, to interact with the
    /// view by invoking the action.
    ///
    /// For example, this is how a scroll action to trigger
    /// a refresh could be added to a view.
    ///
    ///     var body: some View {
    ///         ScrollView {
    ///             ContentView()
    ///         }
    ///         .accessibilityScrollAction { edge in
    ///             if edge == .top {
    ///                 // Refresh content
    ///             }
    ///         }
    ///     }
    ///
    nonisolated public func accessibilityScrollAction(_ handler: @escaping (Edge) -> Void) -> ModifiedContent<Content, Modifier>
}

@available(iOS 17.0, macOS 14.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension View {

    /// Configures the ``fileExporter``, ``fileImporter``, or ``fileMover`` to
    /// open with the specified default directory.
    ///
    /// - Parameter defaultDirectory: The directory to show when
    ///   the system file dialog launches. If the given file dialog has
    ///   a `fileDialogCustomizationID` if stores the user-chosen directory and subsequently
    ///   opens with it, ignoring the default value provided in this modifier.
    nonisolated public func fileDialogDefaultDirectory(_ defaultDirectory: URL?) -> some View


    /// On macOS, configures the `fileExporter`, `fileImporter`,
    /// or `fileMover` to persist and restore the file dialog configuration.
    ///
    /// Among other parameters, it stores the current directory,
    /// view style (e.g., Icons, List, Columns), recent places,
    /// and expanded window size.
    /// It enables a refined user experience; for example,
    /// when importing an image, the user might switch to the Icons view,
    /// but the List view could be more convenient in another context.
    /// The file dialog stores these settings and applies them
    /// every time before presenting the panel.
    /// If not provided, on every launch, the file dialog
    /// uses the default configuration.
    ///
    /// - Parameter id: An identifier of the configuration.
    nonisolated public func fileDialogCustomizationID(_ id: String) -> some View


    /// On macOS, configures the the ``fileExporter``, ``fileImporter``, or ``fileMover``
    /// with a custom text that is presented to the user,
    /// similar to a title.
    ///
    /// - Parameter message: The optional text to use as the file dialog message.
    nonisolated public func fileDialogMessage(_ message: Text?) -> some View


    /// On macOS, configures the the ``fileExporter``, ``fileImporter``,
    /// or ``fileMover`` with a custom message that is presented to the user,
    /// similar to a title.
    ///
    /// - Parameter messageKey: The key to a localized string to display.
    nonisolated public func fileDialogMessage(_ messageKey: LocalizedStringKey) -> some View


    /// On macOS, configures the the ``fileExporter``, ``fileImporter``,
    /// or ``fileMover`` with a custom message that is presented to the user,
    /// similar to a title.
    ///
    /// - Parameter message: The string to use as the file dialog message.
    nonisolated public func fileDialogMessage<S>(_ message: S) -> some View where S : StringProtocol


    /// On macOS, configures the the ``fileExporter``, ``fileImporter``,
    /// or ``fileMover`` with a custom confirmation button label.
    ///
    /// - Parameter label: The string to use as the label for the confirmation button.
    nonisolated public func fileDialogConfirmationLabel<S>(_ label: S) -> some View where S : StringProtocol


    /// On macOS, configures the the ``fileExporter``, ``fileImporter``,
    /// or ``fileMover`` with custom text as a confirmation button label.
    ///
    /// - Parameter label: The optional text to use as the label for the confirmation button.
    nonisolated public func fileDialogConfirmationLabel(_ label: Text?) -> some View


    /// On macOS, configures the the ``fileExporter``, ``fileImporter``,
    /// or ``fileMover`` with a custom confirmation button label.
    ///
    /// - Parameter labelKey: The key to a localized string to display.
    nonisolated public func fileDialogConfirmationLabel(_ labelKey: LocalizedStringKey) -> some View


    /// On macOS, configures the ``fileExporter``
    /// with a text to use as a label for the file name field.
    /// - Parameter label: The optional text to use as the label for the file name field.
    nonisolated public func fileExporterFilenameLabel(_ label: Text?) -> some View


    /// On macOS, configures the ``fileExporter``
    /// with a label for the file name field.
    /// - Parameter labelKey: The key to a localized string to display.
    nonisolated public func fileExporterFilenameLabel(_ labelKey: LocalizedStringKey) -> some View


    /// On macOS, configures the ``fileExporter``
    /// with a label for the file name field.
    /// - Parameter label: The string to use as the label for the file name field.
    nonisolated public func fileExporterFilenameLabel<S>(_ label: S) -> some View where S : StringProtocol


    /// On macOS, configures the the ``fileImporter``
    /// or ``fileMover`` to conditionally disable presented URLs.
    ///
    /// - Parameter predicate: The predicate that evaluates the
    ///    URLs presented to the user to conditionally disable them.
    ///    The implementation is expected to have constant complexity
    ///    and should not access the files contents or metadata. A common use case
    ///    is inspecting the path or the file name.
    nonisolated public func fileDialogURLEnabled(_ predicate: Predicate<URL>) -> some View


    /// On macOS, configures the ``fileExporter``, ``fileImporter``,
    /// or ``fileMover`` behavior when a user chooses an alias.
    ///
    /// By default, file dialogs resolve aliases and
    /// provide the URL of the item referred to by the chosen alias.
    /// This modifier allows control of this behavior: pass `true` if the
    /// application doesn't want file dialog to resolve aliases.
    /// - Parameter imports: A Boolean value that indicates
    ///     if the application receives unresolved or resolved URLs
    ///     when a user chooses aliases.
    nonisolated public func fileDialogImportsUnresolvedAliases(_ imports: Bool) -> some View


    /// On macOS, configures the ``fileExporter``, ``fileImporter``,
    /// or ``fileMover`` to provide a refined URL search experience: include or exclude
    /// hidden files, allow searching by tag, etc.
    ///
    /// - Parameter options: The search options to apply to a given file dialog.
    nonisolated public func fileDialogBrowserOptions(_ options: FileDialogBrowserOptions) -> some View

}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension View {

    /// Enables user suppression of dialogs and alerts presented within `self`,
    /// with a custom suppression message on macOS. Unused on other platforms.
    ///
    /// Applying dialog suppression adds a toggle to dialogs on macOS,
    /// which allows the user to request the alert not be displayed again.
    /// Typically whether a dialog is suppressed is stored in `AppStorage`
    /// and used to decide whether to present the dialog in the future.
    ///
    /// The following example configures a `confirmationDialog` with a
    /// suppression toggle. The toggle's state is stored in `AppStorage` and
    /// used to determine whether or not to show the dialog when the
    /// "Delete Items" button is pressed.
    ///
    ///     struct ConfirmEraseItems: View {
    ///         @State private var isShowingDialog = false
    ///
    ///         @AppStorage("suppressEraseItemAlert")
    ///         private var suppressAlert = false
    ///
    ///         var body: some View {
    ///             Button("Delete Items") {
    ///                 if !suppressAlert {
    ///                     isShowingDialog = true
    ///                 } else {
    ///                     // Handle item deletion.
    ///                 }
    ///             }
    ///             .confirmationDialog(
    ///                 "Are you sure you want to erase these items?",
    ///                 isPresented: $isShowingDialog
    ///             ) {
    ///                 Button("Erase", role: .destructive) {
    ///                     // Handle item deletion.
    ///                 }
    ///                 Button("Cancel", role: .cancel) {
    ///                     isShowingDialog = false
    ///                 }
    ///             }
    ///             .dialogSuppressionToggle(
    ///                 "Do not ask about erasing items again",
    ///                 isSuppressed: $suppressAlert)
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - titleKey: The title of the suppression toggle in the dialog. This
    ///     parameter can be elided to use the default suppression title.
    ///   - isSuppressed: Whether the suppression toggle is on or off in the
    ///     dialog.
    nonisolated public func dialogSuppressionToggle(_ titleKey: LocalizedStringKey, isSuppressed: Binding<Bool>) -> some View


    /// Enables user suppression of dialogs and alerts presented within `self`,
    /// with a custom suppression message on macOS. Unused on other platforms.
    ///
    /// Applying dialog suppression adds a toggle to dialogs on macOS,
    /// which allows the user to request the alert not be displayed again.
    /// Typically whether a dialog is suppressed is stored in `AppStorage`
    /// and used to decide whether to present the dialog in the future.
    ///
    /// The following example configures a `confirmationDialog` with a
    /// suppression toggle. The toggle's state is stored in `AppStorage` and
    /// used to determine whether or not to show the dialog when the
    /// "Delete Items" button is pressed.
    ///
    ///     struct ConfirmEraseItems: View {
    ///         @State private var isShowingDialog = false
    ///
    ///         @AppStorage("suppressEraseItemAlert")
    ///         private var suppressAlert = false
    ///
    ///         var body: some View {
    ///             Button("Delete Items") {
    ///                 if !suppressAlert {
    ///                     isShowingDialog = true
    ///                 } else {
    ///                     // Handle item deletion.
    ///                 }
    ///             }
    ///             .confirmationDialog(
    ///                 "Are you sure you want to erase these items?",
    ///                 isPresented: $isShowingDialog
    ///             ) {
    ///                 Button("Erase", role: .destructive) {
    ///                     // Handle item deletion.
    ///                 }
    ///                 Button("Cancel", role: .cancel) {
    ///                     isShowingDialog = false
    ///                 }
    ///             }
    ///             .dialogSuppressionToggle(
    ///                 "Do not ask about erasing items again",
    ///                 isSuppressed: $suppressAlert)
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - title: The title of the suppression toggle in the dialog. This
    ///     parameter can be elided to use the default suppression title.
    ///   - isSuppressed: Whether the suppression toggle is on or off in the
    ///     dialog.
    nonisolated public func dialogSuppressionToggle<S>(_ title: S, isSuppressed: Binding<Bool>) -> some View where S : StringProtocol


    /// Enables user suppression of dialogs and alerts presented within `self`,
    /// with a custom suppression message on macOS. Unused on other platforms.
    ///
    /// Applying dialog suppression adds a toggle to dialogs on macOS,
    /// which allows the user to request the alert not be displayed again.
    /// Typically whether a dialog is suppressed is stored in `AppStorage`
    /// and used to decide whether to present the dialog in the future.
    ///
    /// The following example configures a `confirmationDialog` with a
    /// suppression toggle. The toggle's state is stored in `AppStorage` and
    /// used to determine whether or not to show the dialog when the
    /// "Delete Items" button is pressed.
    ///
    ///     struct ConfirmEraseItems: View {
    ///         @State private var isShowingDialog = false
    ///
    ///         @AppStorage("suppressEraseItemAlert")
    ///         private var suppressAlert = false
    ///
    ///         var body: some View {
    ///             Button("Delete Items") {
    ///                 if !suppressAlert {
    ///                     isShowingDialog = true
    ///                 } else {
    ///                     // Handle item deletion.
    ///                 }
    ///             }
    ///             .confirmationDialog(
    ///                 "Are you sure you want to erase these items?",
    ///                 isPresented: $isShowingDialog
    ///             ) {
    ///                 Button("Erase", role: .destructive) {
    ///                     // Handle item deletion.
    ///                 }
    ///                 Button("Cancel", role: .cancel) {
    ///                     isShowingDialog = false
    ///                 }
    ///             }
    ///             .dialogSuppressionToggle(
    ///                 Text("Do not ask about erasing items again"),
    ///                 isSuppressed: $suppressAlert)
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - label: The label of the suppression toggle in the dialog. This
    ///     parameter can be elided to use the default suppression title.
    ///   - isSuppressed: Whether the suppression toggle is on or off in the
    ///     dialog.
    nonisolated public func dialogSuppressionToggle(_ label: Text, isSuppressed: Binding<Bool>) -> some View


    /// Enables user suppression of dialogs and alerts presented within `self`,
    /// with a default suppression message on macOS. Unused on other platforms.
    ///
    /// Applying dialog suppression adds a toggle to dialogs on macOS,
    /// which allows the user to request the alert not be displayed again.
    /// Typically whether a dialog is suppressed is stored in `AppStorage`
    /// and used to decide whether to present the dialog in the future.
    ///
    /// The following example configures a `confirmationDialog` with a
    /// suppression toggle. The toggle's state is stored in `AppStorage` and
    /// used to determine whether or not to show the dialog when the
    /// "Delete Items" button is pressed.
    ///
    ///     struct ConfirmEraseItems: View {
    ///         @State private var isShowingDialog = false
    ///
    ///         @AppStorage("suppressEraseItemAlert")
    ///         private var suppressAlert = false
    ///
    ///         var body: some View {
    ///             Button("Delete Items") {
    ///                 if !suppressAlert {
    ///                     isShowingDialog = true
    ///                 } else {
    ///                     // Handle item deletion.
    ///                 }
    ///             }
    ///             .confirmationDialog(
    ///                 "Are you sure you want to erase these items?",
    ///                 isPresented: $isShowingDialog
    ///             ) {
    ///                 Button("Erase", role: .destructive) {
    ///                     // Handle item deletion.
    ///                 }
    ///                 Button("Cancel", role: .cancel) {
    ///                     isShowingDialog = false
    ///                 }
    ///             }
    ///             .dialogSuppressionToggle(isSuppressed: $suppressAlert)
    ///         }
    ///     }
    ///
    /// - Parameter isSuppressed: Whether the suppression toggle is on or off
    ///   in the dialog.
    nonisolated public func dialogSuppressionToggle(isSuppressed: Binding<Bool>) -> some View

}

@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension View {

    /// Presents a system interface for allowing the user to import an existing
    /// file.
    ///
    /// In order for the interface to appear, `isPresented` must be `true`. When
    /// the operation is finished, `isPresented` will be set to `false` before
    /// `onCompletion` is called. If the user cancels the operation,
    /// `isPresented` will be set to `false` and `onCompletion` will not be
    /// called.
    ///
    /// - Note: This dialog provides security-scoped URLs.
    ///   Call the ``startAccessingSecurityScopedResource`` method to access or bookmark
    ///   the URLs, and the ``stopAccessingSecurityScopedResource`` method
    ///   to release the access.
    ///
    /// For example, an application can have a button that allows the user to choose the default directory
    /// with document templates loaded on every launch. Such a button might look like this:
    ///
    ///      struct PickTemplatesDirectoryButton: View {
    ///          @State private var showFileImporter = false
    ///          var onTemplatesDirectoryPicked: (URL) -> Void
    ///
    ///          var body: some View {
    ///              Button {
    ///                  showFileImporter = true
    ///              } label: {
    ///                  Label("Choose templates directory", systemImage: "folder.circle")
    ///              }
    ///              .fileImporter(
    ///                  isPresented: $showFileImporter,
    ///                  allowedContentTypes: [.directory]
    ///              ) { result in
    ///                   switch result {
    ///                   case .success(let directory):
    ///                       // gain access to the directory
    ///                       let gotAccess = directory.startAccessingSecurityScopedResource()
    ///                       if !gotAccess { return }
    ///                       // access the directory URL
    ///                       // (read templates in the directory, make a bookmark, etc.)
    ///                       onTemplatesDirectoryPicked(directory)
    ///                       // release access
    ///                       directory.stopAccessingSecurityScopedResource()
    ///                   case .failure(let error):
    ///                       // handle error
    ///                       print(error)
    ///                   }
    ///              }
    ///          }
    ///      }
    ///
    /// - Note: Changing `allowedContentTypes` while the file importer is
    ///   presented will have no immediate effect, however will apply the next
    ///   time it is presented.
    ///
    /// - Parameters:
    ///   - isPresented: A binding to whether the interface should be shown.
    ///   - allowedContentTypes: The list of supported content types which can
    ///     be imported.
    ///   - onCompletion: A callback that will be invoked when the operation has
    ///     succeeded or failed. To access the received URLs, call `startAccessingSecurityScopedResource`.
    ///     When the access is no longer required, call `stopAccessingSecurityScopedResource`.
    ///   - result: A `Result` indicating whether the operation succeeded or
    ///     failed.
    nonisolated public func fileImporter(isPresented: Binding<Bool>, allowedContentTypes: [UTType], onCompletion: @escaping (_ result: Result<URL, any Error>) -> Void) -> some View


    /// Presents a system interface for allowing the user to import multiple
    /// files.
    ///
    /// In order for the interface to appear, `isPresented` must be `true`. When
    /// the operation is finished, `isPresented` will be set to `false` before
    /// `onCompletion` is called. If the user cancels the operation,
    /// `isPresented` will be set to `false` and `onCompletion` will not be
    /// called.
    ///
    /// - Note: This dialog provides security-scoped URLs.
    ///   Call the ``startAccessingSecurityScopedResource`` method to access or bookmark
    ///   the URLs, and the ``stopAccessingSecurityScopedResource`` method
    ///   to release the access.
    ///
    /// For example, a button that allows the user to choose multiple PDF files for the application
    /// to combine them later, might look like this:
    ///
    ///        struct PickPDFsButton: View {
    ///            @State private var showFileImporter = false
    ///            var handlePickedPDF: (URL) -> Void
    ///
    ///            var body: some View {
    ///                Button {
    ///                    showFileImporter = true
    ///                } label: {
    ///                    Label("Choose PDFs to combine", systemImage: "doc.circle")
    ///                }
    ///                .fileImporter(
    ///                    isPresented: $showFileImporter,
    ///                    allowedContentTypes: [.pdf],
    ///                    allowsMultipleSelection: true
    ///                ) { result in
    ///                    switch result {
    ///                    case .success(let files):
    ///                        files.forEach { file in
    ///                            // gain access to the directory
    ///                            let gotAccess = file.startAccessingSecurityScopedResource()
    ///                            if !gotAccess { return }
    ///                            // access the directory URL
    ///                            // (read templates in the directory, make a bookmark, etc.)
    ///                            handlePickedPDF(file)
    ///                            // release access
    ///                            file.stopAccessingSecurityScopedResource()
    ///                        }
    ///                    case .failure(let error):
    ///                        // handle error
    ///                        print(error)
    ///                    }
    ///                }
    ///            }
    ///        }
    ///
    /// - Note: Changing `allowedContentTypes` or `allowsMultipleSelection`
    ///   while the file importer is presented will have no immediate effect,
    ///   however will apply the next time it is presented.
    ///
    /// - Parameters:
    ///   - isPresented: A binding to whether the interface should be shown.
    ///   - allowedContentTypes: The list of supported content types which can
    ///     be imported.
    ///   - allowsMultipleSelection: Whether the importer allows the user to
    ///     select more than one file to import.
    ///   - onCompletion: A callback that will be invoked when the operation has
    ///     succeeded or failed. To access the received URLs, call `startAccessingSecurityScopedResource`.
    ///     When the access is no longer required, call `stopAccessingSecurityScopedResource`.
    ///   - result: A `Result` indicating whether the operation succeeded or
    ///     failed.
    nonisolated public func fileImporter(isPresented: Binding<Bool>, allowedContentTypes: [UTType], allowsMultipleSelection: Bool, onCompletion: @escaping (_ result: Result<[URL], any Error>) -> Void) -> some View

}

@available(iOS 17.0, macOS 14.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension View {

    /// Presents a system dialog for allowing the user to import multiple
    /// files.
    ///
    /// In order for the dialog to appear, `isPresented` must be `true`. When
    /// the operation is finished, `isPresented` will be set to `false` before
    /// `onCompletion` is called. If the user cancels the operation,
    /// `isPresented` will be set to `false` and `onCompletion` will not be
    /// called.
    ///
    /// - Note: This dialog provides security-scoped URLs.
    ///   Call the ``startAccessingSecurityScopedResource`` method to access or bookmark
    ///   the URLs, and the ``stopAccessingSecurityScopedResource`` method
    ///   to release the access.
    ///
    /// For example, a button that allows the user to choose multiple PDF files for the application
    /// to combine them later, might look like this:
    ///
    ///        struct PickPDFsButton: View {
    ///            @State private var showFileImporter = false
    ///            var handlePickedPDF: (URL) -> Void
    ///
    ///            var body: some View {
    ///                Button {
    ///                    showFileImporter = true
    ///                } label: {
    ///                    Label("Choose PDFs to combine", systemImage: "doc.circle")
    ///                }
    ///                .fileImporter(
    ///                    isPresented: $showFileImporter,
    ///                    allowedContentTypes: [.pdf],
    ///                    allowsMultipleSelection: true
    ///                ) { result in
    ///                    switch result {
    ///                    case .success(let files):
    ///                        files.forEach { file in
    ///                            // gain access to the directory
    ///                            let gotAccess = file.startAccessingSecurityScopedResource()
    ///                            if !gotAccess { return }
    ///                            // access the directory URL
    ///                            // (read templates in the directory, make a bookmark, etc.)
    ///                            handlePickedPDF(file)
    ///                            // release access
    ///                            file.stopAccessingSecurityScopedResource()
    ///                        }
    ///                    case .failure(let error):
    ///                        // handle error
    ///                        print(error)
    ///                    }
    ///                }
    ///            }
    ///        }
    ///
    /// - Note: Changing `allowedContentTypes` or `allowsMultipleSelection`
    ///   while the file importer is presented will have no immediate effect,
    ///   however will apply the next time it is presented.
    ///
    /// - Parameters:
    ///   - isPresented: A binding to whether the dialog should be shown.
    ///   - allowedContentTypes: The list of supported content types which can
    ///     be imported.
    ///   - allowsMultipleSelection: Whether the importer allows the user to
    ///     select more than one file to import.
    ///   - onCompletion: A callback that will be invoked when the operation has
    ///     succeeded or failed. The `result` indicates whether the operation
    ///     succeeded or failed. To access the received URLs, call `startAccessingSecurityScopedResource`.
    ///     When the access is no longer required, call `stopAccessingSecurityScopedResource`.
    ///   - onCancellation: A callback that will be invoked
    ///     if the user cancels the operation.
    nonisolated public func fileImporter(isPresented: Binding<Bool>, allowedContentTypes: [UTType], allowsMultipleSelection: Bool, onCompletion: @escaping (_ result: Result<[URL], any Error>) -> Void, onCancellation: @escaping () -> Void) -> some View

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// Presents a sheet using the given item as a data source
    /// for the sheet's content.
    ///
    /// Use this method when you need to present a modal view with content
    /// from a custom data source. The example below shows a custom data source
    /// `InventoryItem` that the `content` closure uses to populate the display
    /// the action sheet shows to the user:
    ///
    ///     struct ShowPartDetail: View {
    ///         @State private var sheetDetail: InventoryItem?
    ///
    ///         var body: some View {
    ///             Button("Show Part Details") {
    ///                 sheetDetail = InventoryItem(
    ///                     id: "0123456789",
    ///                     partNumber: "Z-1234A",
    ///                     quantity: 100,
    ///                     name: "Widget")
    ///             }
    ///             .sheet(item: $sheetDetail,
    ///                    onDismiss: didDismiss) { detail in
    ///                 VStack(alignment: .leading, spacing: 20) {
    ///                     Text("Part Number: \(detail.partNumber)")
    ///                     Text("Name: \(detail.name)")
    ///                     Text("Quantity On-Hand: \(detail.quantity)")
    ///                 }
    ///                 .onTapGesture {
    ///                     sheetDetail = nil
    ///                 }
    ///             }
    ///         }
    ///
    ///         func didDismiss() {
    ///             // Handle the dismissing action.
    ///         }
    ///     }
    ///
    ///     struct InventoryItem: Identifiable {
    ///         var id: String
    ///         let partNumber: String
    ///         let quantity: Int
    ///         let name: String
    ///     }
    ///
    /// ![A view showing a custom structure acting as a data source, providing
    /// data to a modal sheet.](SwiftUI-View-SheetItemContent.png)
    ///
    /// In vertically compact environments, such as iPhone in landscape
    /// orientation, a sheet presentation automatically adapts to appear as a
    /// full-screen cover. Use the ``View/presentationCompactAdaptation(_:)`` or
    /// ``View/presentationCompactAdaptation(horizontal:vertical:)`` modifier to
    /// override this behavior.
    ///
    /// - Parameters:
    ///   - item: A binding to an optional source of truth for the sheet.
    ///     When `item` is non-`nil`, the system passes the item's content to
    ///     the modifier's closure. You display this content in a sheet that you
    ///     create that the system displays to the user. If `item` changes,
    ///     the system dismisses the sheet and replaces it with a new one
    ///     using the same process.
    ///   - onDismiss: The closure to execute when dismissing the sheet.
    ///   - content: A closure returning the content of the sheet.
    nonisolated public func sheet<Item, Content>(item: Binding<Item?>, onDismiss: (() -> Void)? = nil, @ViewBuilder content: @escaping (Item) -> Content) -> some View where Item : Identifiable, Content : View


    /// Presents a sheet when a binding to a Boolean value that you
    /// provide is true.
    ///
    /// Use this method when you want to present a modal view to the
    /// user when a Boolean value you provide is true. The example
    /// below displays a modal view of the mockup for a software license
    /// agreement when the user toggles the `isShowingSheet` variable by
    /// clicking or tapping on the "Show License Agreement" button:
    ///
    ///     struct ShowLicenseAgreement: View {
    ///         @State private var isShowingSheet = false
    ///         var body: some View {
    ///             Button(action: {
    ///                 isShowingSheet.toggle()
    ///             }) {
    ///                 Text("Show License Agreement")
    ///             }
    ///             .sheet(isPresented: $isShowingSheet,
    ///                    onDismiss: didDismiss) {
    ///                 VStack {
    ///                     Text("License Agreement")
    ///                         .font(.title)
    ///                         .padding(50)
    ///                     Text("""
    ///                             Terms and conditions go here.
    ///                         """)
    ///                         .padding(50)
    ///                     Button("Dismiss",
    ///                            action: { isShowingSheet.toggle() })
    ///                 }
    ///             }
    ///         }
    ///
    ///         func didDismiss() {
    ///             // Handle the dismissing action.
    ///         }
    ///     }
    ///
    /// ![A screenshot of a full-screen modal sheet showing the mockup of a
    /// software license agreement with a Dismiss
    /// button.](SwiftUI-View-SheetIsPresentingContent.png)
    ///
    /// In vertically compact environments, such as iPhone in landscape
    /// orientation, a sheet presentation automatically adapts to appear as a
    /// full-screen cover. Use the ``View/presentationCompactAdaptation(_:)`` or
    /// ``View/presentationCompactAdaptation(horizontal:vertical:)`` modifier to
    /// override this behavior.
    ///
    /// - Parameters:
    ///   - isPresented: A binding to a Boolean value that determines whether
    ///     to present the sheet that you create in the modifier's
    ///     `content` closure.
    ///   - onDismiss: The closure to execute when dismissing the sheet.
    ///   - content: A closure that returns the content of the sheet.
    nonisolated public func sheet<Content>(isPresented: Binding<Bool>, onDismiss: (() -> Void)? = nil, @ViewBuilder content: @escaping () -> Content) -> some View where Content : View

}

@available(iOS 14.0, tvOS 14.0, watchOS 7.0, *)
@available(macOS, unavailable)
extension View {

    /// Presents a modal view that covers as much of the screen as
    /// possible using the binding you provide as a data source for the
    /// sheet's content.
    ///
    /// Use this method to display a modal view that covers as much of the
    /// screen as possible. In the example below a custom structure 
    /// `CoverData`  provides data for the full-screen view to display in the
    /// `content` closure when the user clicks or taps the
    /// "Present Full-Screen Cover With Data" button:
    ///
    ///     struct FullScreenCoverItemOnDismissContent: View {
    ///         @State private var coverData: CoverData?
    ///
    ///         var body: some View {
    ///             Button("Present Full-Screen Cover With Data") {
    ///                 coverData = CoverData(body: "Custom Data")
    ///             }
    ///             .fullScreenCover(item: $coverData,
    ///                              onDismiss: didDismiss) { details in
    ///                 VStack(spacing: 20) {
    ///                     Text("\(details.body)")
    ///                 }
    ///                 .onTapGesture {
    ///                     coverData = nil
    ///                 }
    ///             }
    ///         }
    ///
    ///         func didDismiss() {
    ///             // Handle the dismissing action.
    ///         }
    ///
    ///     }
    ///
    ///     struct CoverData: Identifiable {
    ///         var id: String {
    ///             return body
    ///         }
    ///         let body: String
    ///     }
    ///
    /// ![A full-screen modal view that shows Custom
    /// Content.](SwiftUI-FullScreenCoverItemOnDismissContent.png)
    ///
    /// - Parameters:
    ///   - item: A binding to an optional source of truth for the sheet.
    ///     When `item` is non-`nil`, the system passes the contents to
    ///     the modifier's closure. You display this content in a sheet that you
    ///     create that the system displays to the user. If `item` changes,
    ///     the system dismisses the currently displayed sheet and replaces
    ///     it with a new one using the same process.
    ///   - onDismiss: The closure to execute when dismissing the modal view.
    ///   - content: A closure returning the content of the modal view.
    nonisolated public func fullScreenCover<Item, Content>(item: Binding<Item?>, onDismiss: (() -> Void)? = nil, @ViewBuilder content: @escaping (Item) -> Content) -> some View where Item : Identifiable, Content : View


    /// Presents a modal view that covers as much of the screen as
    /// possible when binding to a Boolean value you provide is true.
    ///
    /// Use this method to show a modal view that covers as much of the screen
    /// as possible. The example below displays a custom view when the user
    /// toggles the value of the `isPresenting` binding:
    ///
    ///     struct FullScreenCoverPresentedOnDismiss: View {
    ///         @State private var isPresenting = false
    ///         var body: some View {
    ///             Button("Present Full-Screen Cover") {
    ///                 isPresenting.toggle()
    ///             }
    ///             .fullScreenCover(isPresented: $isPresenting,
    ///                              onDismiss: didDismiss) {
    ///                 VStack {
    ///                     Text("A full-screen modal view.")
    ///                         .font(.title)
    ///                     Text("Tap to Dismiss")
    ///                 }
    ///                 .onTapGesture {
    ///                     isPresenting.toggle()
    ///                 }
    ///                 .foregroundColor(.white)
    ///                 .frame(maxWidth: .infinity,
    ///                        maxHeight: .infinity)
    ///                 .background(Color.blue)
    ///                 .ignoresSafeArea(edges: .all)
    ///             }
    ///         }
    ///
    ///         func didDismiss() {
    ///             // Handle the dismissing action.
    ///         }
    ///     }
    ///
    /// ![A full-screen modal view with the text A full-screen modal view
    /// and Tap to Dismiss.](SwiftUI-FullScreenCoverIsPresented.png)
    /// - Parameters:
    ///   - isPresented: A binding to a Boolean value that determines whether
    ///     to present the sheet.
    ///   - onDismiss: The closure to execute when dismissing the modal view.
    ///   - content: A closure that returns the content of the modal view.
    nonisolated public func fullScreenCover<Content>(isPresented: Binding<Bool>, onDismiss: (() -> Void)? = nil, @ViewBuilder content: @escaping () -> Content) -> some View where Content : View

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// Constrains this view's dimensions to the specified aspect ratio.
    ///
    /// Use `aspectRatio(_:contentMode:)` to constrain a view's dimensions to an
    /// aspect ratio specified by a
    /// <doc://com.apple.documentation/documentation/CoreFoundation/CGFloat>
    /// using the specified content mode.
    ///
    /// If this view is resizable, the resulting view will have `aspectRatio` as
    /// its aspect ratio. In this example, the purple ellipse has a 3:4
    /// width-to-height ratio, and scales to fit its frame:
    ///
    ///     Ellipse()
    ///         .fill(Color.purple)
    ///         .aspectRatio(0.75, contentMode: .fit)
    ///         .frame(width: 200, height: 200)
    ///         .border(Color(white: 0.75))
    ///
    /// ![A view showing a purple ellipse that has a 3:4 width-to-height ratio,
    /// and scales to fit its frame.](SwiftUI-View-aspectRatio-cgfloat.png)
    ///
    /// - Parameters:
    ///   - aspectRatio: The ratio of width to height to use for the resulting
    ///     view. Use `nil` to maintain the current aspect ratio in the
    ///     resulting view.
    ///   - contentMode: A flag that indicates whether this view fits or fills
    ///     the parent context.
    ///
    /// - Returns: A view that constrains this view's dimensions to the aspect
    ///   ratio of the given size using `contentMode` as its scaling algorithm.
    @inlinable nonisolated public func aspectRatio(_ aspectRatio: CGFloat? = nil, contentMode: ContentMode) -> some View


    /// Constrains this view's dimensions to the aspect ratio of the given size.
    ///
    /// Use `aspectRatio(_:contentMode:)` to constrain a view's dimensions to
    /// an aspect ratio specified by a
    /// <doc://com.apple.documentation/documentation/CoreFoundation/CGSize>.
    ///
    /// If this view is resizable, the resulting view uses `aspectRatio` as its
    /// own aspect ratio. In this example, the purple ellipse has a 3:4
    /// width-to-height ratio, and scales to fill its frame:
    ///
    ///     Ellipse()
    ///         .fill(Color.purple)
    ///         .aspectRatio(CGSize(width: 3, height: 4), contentMode: .fill)
    ///         .frame(width: 200, height: 200)
    ///         .border(Color(white: 0.75))
    ///
    /// ![A view showing a purple ellipse that has a 3:4 width-to-height ratio,
    /// and scales to fill its frame.](SwiftUI-View-aspectRatio.png)
    ///
    /// - Parameters:
    ///   - aspectRatio: A size that specifies the ratio of width to height to
    ///     use for the resulting view.
    ///   - contentMode: A flag indicating whether this view should fit or fill
    ///     the parent context.
    ///
    /// - Returns: A view that constrains this view's dimensions to
    ///   `aspectRatio`, using `contentMode` as its scaling algorithm.
    @inlinable nonisolated public func aspectRatio(_ aspectRatio: CGSize, contentMode: ContentMode) -> some View


    /// Scales this view to fit its parent.
    ///
    /// Use `scaledToFit()` to scale this view to fit its parent, while
    /// maintaining the view's aspect ratio as the view scales.
    ///
    ///     Circle()
    ///         .fill(Color.pink)
    ///         .scaledToFit()
    ///         .frame(width: 300, height: 150)
    ///         .border(Color(white: 0.75))
    ///
    /// ![A screenshot of pink circle scaled to fit its
    /// frame.](SwiftUI-View-scaledToFit-1.png)
    ///
    /// This method is equivalent to calling
    /// ``View/aspectRatio(_:contentMode:)`` with a `nil` aspectRatio and
    /// a content mode of ``ContentMode/fit``.
    ///
    /// - Returns: A view that scales this view to fit its parent, maintaining
    ///   this view's aspect ratio.
    @inlinable nonisolated public func scaledToFit() -> some View


    /// Scales this view to fill its parent.
    ///
    /// Use `scaledToFill()` to scale this view to fill its parent, while
    /// maintaining the view's aspect ratio as the view scales:
    ///
    ///     Circle()
    ///         .fill(Color.pink)
    ///         .scaledToFill()
    ///         .frame(width: 300, height: 150)
    ///         .border(Color(white: 0.75))
    ///
    /// ![A screenshot of pink circle scaled to fill its
    /// frame.](SwiftUI-View-scaledToFill-1.png)
    ///
    /// This method is equivalent to calling
    /// ``View/aspectRatio(_:contentMode:)`` with a `nil` aspectRatio and
    /// a content mode of ``ContentMode/fill``.
    ///
    /// - Returns: A view that scales this view to fill its parent, maintaining
    ///   this view's aspect ratio.
    @inlinable nonisolated public func scaledToFill() -> some View

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension View {

    /// The default store used by `AppStorage` contained within the view.
    ///
    /// If unspecified, the default store for a view hierarchy is
    /// `UserDefaults.standard`, but can be set a to a custom one. For example,
    /// sharing defaults between an app and an extension can override the
    /// default store to one created with `UserDefaults.init(suiteName:_)`.
    ///
    /// - Parameter store: The user defaults to use as the default
    ///   store for `AppStorage`.
    nonisolated public func defaultAppStorage(_ store: UserDefaults) -> some View

}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension View {

    /// Adds an action to perform when the user submits a value to this view.
    ///
    /// Different views may have different triggers for the provided action.
    /// A ``TextField``, or ``SecureField`` will trigger this action when the
    /// user hits the hardware or software return key. This modifier may also
    /// bind this action to a default action keyboard shortcut. You may set this
    /// action on an individual view or an entire view hierarchy.
    ///
    ///     TextField("Username", text: $username)
    ///         .onSubmit {
    ///             guard viewModel.validate() else { return }
    ///             viewModel.login()
    ///         }
    ///
    /// You can use the ``View/submitScope(_:)`` modifier to stop a submit
    /// trigger from a control from propagating higher up in the view hierarchy
    /// to higher `View.onSubmit(of:_:)` modifiers.
    ///
    ///     Form {
    ///         TextField("Username", text: $viewModel.userName)
    ///         SecureField("Password", text: $viewModel.password)
    ///
    ///         TextField("Tags", text: $viewModel.tags)
    ///             .submitScope()
    ///     }
    ///     .onSubmit {
    ///         guard viewModel.validate() else { return }
    ///         viewModel.login()
    ///     }
    ///
    /// You can use different submit triggers to filter the types of triggers
    /// that should invoke the provided submission action. For example, you
    /// may provide a value of ``SubmitTriggers/search`` to only hear
    /// submission triggers that originate from search fields vended by
    /// searchable modifiers.
    ///
    ///     @StateObject private var viewModel = ViewModel()
    ///
    ///     NavigationView {
    ///         SidebarView()
    ///         DetailView()
    ///     }
    ///     .searchable(
    ///         text: $viewModel.searchText,
    ///         placement: .sidebar
    ///     ) {
    ///         SuggestionsView()
    ///     }
    ///     .onSubmit(of: .search) {
    ///         viewModel.submitCurrentSearchQuery()
    ///     }
    ///
    /// - Parameters:
    ///   - triggers: The triggers that should invoke the provided action.
    ///   - action: The action to perform on submission of a value.
    nonisolated public func onSubmit(of triggers: SubmitTriggers = .text, _ action: @escaping (() -> Void)) -> some View


    /// Prevents submission triggers originating from this view to invoke
    /// a submission action configured by a submission modifier higher up
    /// in the view hierarchy.
    ///
    /// Use this modifier when you want to avoid specific views from initiating
    /// a submission action configured by the ``View/onSubmit(of:_:)`` modifier.
    /// In the example below, the tag field doesn't trigger the submission of
    /// the form:
    ///
    ///     Form {
    ///         TextField("Username", text: $viewModel.userName)
    ///         SecureField("Password", text: $viewModel.password)
    ///
    ///         TextField("Tags", text: $viewModel.tags)
    ///             .submitScope()
    ///     }
    ///     .onSubmit {
    ///         guard viewModel.validate() else { return }
    ///         viewModel.login()
    ///     }
    ///
    /// - Parameter isBlocking: A Boolean that indicates whether this scope is
    ///   actively blocking submission triggers from reaching higher submission
    ///   actions.
    nonisolated public func submitScope(_ isBlocking: Bool = true) -> some View

}

@available(iOS 13.0, macOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// Hides the navigation bar for this view.
    ///
    /// Use `navigationBarHidden(_:)` to hide the navigation bar. This modifier
    /// only takes effect when this view is inside of and visible within a
    /// ``NavigationView``.
    ///
    /// - Parameter hidden: A Boolean value that indicates whether to hide the
    ///   navigation bar.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, message: "Use toolbar(.hidden)")
    @available(macOS, unavailable)
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, message: "Use toolbar(.hidden)")
    @available(watchOS, introduced: 6.0, deprecated: 100000.0, message: "Use toolbar(.hidden)")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Use toolbar(.hidden)")
    nonisolated public func navigationBarHidden(_ hidden: Bool) -> some View


    /// Sets the title in the navigation bar for this view.
    ///
    /// Use `navigationBarTitle(_:)` to set the title of the navigation bar.
    /// This modifier only takes effect when this view is inside of and visible
    /// within a ``NavigationView``.
    ///
    /// The example below shows setting the title of the navigation bar using a
    /// ``Text`` view:
    ///
    ///     struct FlavorView: View {
    ///         let items = ["Chocolate", "Vanilla", "Strawberry", "Mint Chip",
    ///                      "Pistachio"]
    ///         var body: some View {
    ///             NavigationView {
    ///                 List(items, id: \.self) {
    ///                     Text($0)
    ///                 }
    ///                 .navigationBarTitle(Text("Today's Flavors"))
    ///             }
    ///         }
    ///     }
    ///
    /// ![A screenshot showing the title of a navigation bar configured using a
    /// text view.](SwiftUI-navigationBarTitle-Text.png)
    ///
    /// - Parameter title: A description of this view to display in the
    ///   navigation bar.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, renamed: "navigationTitle(_:)")
    @available(macOS, unavailable)
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, renamed: "navigationTitle(_:)")
    @available(watchOS, introduced: 6.0, deprecated: 100000.0, renamed: "navigationTitle(_:)")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, renamed: "navigationTitle(_:)")
    nonisolated public func navigationBarTitle(_ title: Text) -> some View


    /// Sets the title of this view's navigation bar with a localized string.
    ///
    /// Use `navigationBarTitle(_:)` to set the title of the navigation bar
    /// using a ``LocalizedStringKey`` that will be used to search for a
    /// matching localized string in the application's localizable strings
    /// assets.
    ///
    /// This modifier only takes effect when this view is inside of and visible
    /// within a ``NavigationView``.
    ///
    /// In the example below, a string constant is used to access a
    /// ``LocalizedStringKey`` that will be resolved at run time to provide a
    /// title for the navigation bar. If the localization key cannot be
    /// resolved, the text of the key name will be used as the title text.
    ///
    ///     struct FlavorView: View {
    ///         let items = ["Chocolate", "Vanilla", "Strawberry", "Mint Chip",
    ///                      "Pistachio"]
    ///         var body: some View {
    ///             NavigationView {
    ///                 List(items, id: \.self) {
    ///                     Text($0)
    ///                 }
    ///                 .navigationBarTitle("Today's Flavors")
    ///             }
    ///         }
    ///     }
    ///
    /// - Parameter titleKey: A key to a localized description of this view to
    ///   display in the navigation bar.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, renamed: "navigationTitle(_:)")
    @available(macOS, unavailable)
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, renamed: "navigationTitle(_:)")
    @available(watchOS, introduced: 6.0, deprecated: 100000.0, renamed: "navigationTitle(_:)")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, renamed: "navigationTitle(_:)")
    nonisolated public func navigationBarTitle(_ titleKey: LocalizedStringKey) -> some View


    /// Sets the title of this view's navigation bar with a string.
    ///
    /// Use `navigationBarTitle(_:)` to set the title of the navigation bar
    /// using a `String`. This modifier only takes effect when this view is
    /// inside of and visible within a ``NavigationView``.
    ///
    /// In the example below, text for the navigation bar title is provided
    /// using a string:
    ///
    ///     struct FlavorView: View {
    ///         let items = ["Chocolate", "Vanilla", "Strawberry", "Mint Chip",
    ///                      "Pistachio"]
    ///         let text = "Today's Flavors"
    ///         var body: some View {
    ///             NavigationView {
    ///                 List(items, id: \.self) {
    ///                     Text($0)
    ///                 }
    ///                 .navigationBarTitle(text)
    ///             }
    ///         }
    ///     }
    ///
    /// - Parameter title: A title for this view to display in the navigation
    ///   bar.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, renamed: "navigationTitle(_:)")
    @available(macOS, unavailable)
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, renamed: "navigationTitle(_:)")
    @available(watchOS, introduced: 6.0, deprecated: 100000.0, renamed: "navigationTitle(_:)")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, renamed: "navigationTitle(_:)")
    nonisolated public func navigationBarTitle<S>(_ title: S) -> some View where S : StringProtocol


    /// Sets the title and display mode in the navigation bar for this view.
    ///
    /// Use `navigationBarTitle(_:displayMode:)` to set the title of the
    /// navigation bar for this view and specify a display mode for the title
    /// from one of the ``NavigationBarItem/TitleDisplayMode`` styles. This
    /// modifier only takes effect when this view is inside of and visible
    /// within a ``NavigationView``.
    ///
    /// In the example below, text for the navigation bar title is provided
    /// using a ``Text`` view. The navigation bar title's
    /// ``NavigationBarItem/TitleDisplayMode`` is set to `.inline` which places
    /// the navigation bar title in the bounds of the navigation bar.
    ///
    ///     struct FlavorView: View {
    ///        let items = ["Chocolate", "Vanilla", "Strawberry", "Mint Chip",
    ///                     "Pistachio"]
    ///        var body: some View {
    ///             NavigationView {
    ///                 List(items, id: \.self) {
    ///                     Text($0)
    ///                 }
    ///                 .navigationBarTitle(Text("Today's Flavors", displayMode: .inline)
    ///             }
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - title: A title for this view to display in the navigation bar.
    ///   - displayMode: The style to use for displaying the navigation bar title.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, message: "Use navigationTitle(_:) with navigationBarTitleDisplayMode(_:)")
    @available(macOS, unavailable)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Use navigationTitle(_:) with navigationBarTitleDisplayMode(_:)")
    nonisolated public func navigationBarTitle(_ title: Text, displayMode: NavigationBarItem.TitleDisplayMode) -> some View


    /// Sets the title and display mode in the navigation bar for this view.
    ///
    /// Use `navigationBarTitle(_:displayMode:)` to set the title of the
    /// navigation bar for this view and specify a display mode for the title
    /// from one of the ``NavigationBarItem/TitleDisplayMode`` styles. This
    /// modifier only takes effect when this view is inside of and visible
    /// within a ``NavigationView``.
    ///
    /// In the example below, text for the navigation bar title is provided
    /// using a string. The navigation bar title's
    /// ``NavigationBarItem/TitleDisplayMode`` is set to `.inline` which places
    /// the navigation bar title in the bounds of the navigation bar.
    ///
    ///     struct FlavorView: View {
    ///         let items = ["Chocolate", "Vanilla", "Strawberry", "Mint Chip",
    ///                      "Pistachio"]
    ///         var body: some View {
    ///             NavigationView {
    ///                 List(items, id: \.self) {
    ///                     Text($0)
    ///                 }
    ///                 .navigationBarTitle("Today's Flavors", displayMode: .inline)
    ///             }
    ///         }
    ///     }
    ///
    /// If the `titleKey` can't be found, the title uses the text of the key
    /// name instead.
    ///
    /// - Parameters:
    ///   - titleKey: A key to a localized description of this view to display
    ///     in the navigation bar.
    ///   - displayMode: The style to use for displaying the navigation bar
    ///     title.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, message: "Use navigationTitle(_:) with navigationBarTitleDisplayMode(_:)")
    @available(macOS, unavailable)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Use navigationTitle(_:) with navigationBarTitleDisplayMode(_:)")
    nonisolated public func navigationBarTitle(_ titleKey: LocalizedStringKey, displayMode: NavigationBarItem.TitleDisplayMode) -> some View


    /// Sets the title and display mode in the navigation bar for this view.
    ///
    /// Use `navigationBarTitle(_:displayMode:)` to set the title of the
    /// navigation bar for this view and specify a display mode for the
    /// title from one of the `NavigationBarItem.Title.DisplayMode`
    /// styles. This modifier only takes effect when this view is inside of and
    /// visible within a `NavigationView`.
    ///
    /// In the example below, `navigationBarTitle(_:displayMode:)` uses a
    /// string to provide a title for the navigation bar. Setting the title's
    /// `displayMode` to `.inline` places the navigation bar title within the
    /// bounds of the navigation bar.
    ///
    /// In the example below, text for the navigation bar title is provided using
    /// a string. The navigation bar title's `displayMode` is set to
    /// `.inline` which places the navigation bar title in the bounds of the
    /// navigation bar.
    ///
    ///     struct FlavorView: View {
    ///         let items = ["Chocolate", "Vanilla", "Strawberry", "Mint Chip",
    ///                      "Pistachio"]
    ///         let title = "Today's Flavors"
    ///         var body: some View {
    ///             NavigationView {
    ///                 List(items, id: \.self) {
    ///                     Text($0)
    ///                 }
    ///                 .navigationBarTitle(title, displayMode: .inline)
    ///             }
    ///         }
    ///     }
    ///
    /// ![A screenshot of a navigation bar, showing the title within the bounds
    ///  of the navigation bar]
    /// (SwiftUI-navigationBarTitle-stringProtocol.png)
    ///
    /// - Parameters:
    ///   - title: A title for this view to display in the navigation bar.
    ///   - displayMode: The way to display the title.
    @available(iOS, introduced: 14.0, deprecated: 100000.0, message: "Use navigationTitle(_:) with navigationBarTitleDisplayMode(_:)")
    @available(macOS, unavailable)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Use navigationTitle(_:) with navigationBarTitleDisplayMode(_:)")
    nonisolated public func navigationBarTitle<S>(_ title: S, displayMode: NavigationBarItem.TitleDisplayMode) -> some View where S : StringProtocol


    /// Hides the navigation bar back button for the view.
    ///
    /// Use `navigationBarBackButtonHidden(_:)` to hide the back button for this
    /// view.
    ///
    /// This modifier only takes effect when this view is inside of and visible
    /// within a ``NavigationView``.
    ///
    /// - Parameter hidesBackButton: A Boolean value that indicates whether to
    ///   hide the back button. The default value is `true`.
    nonisolated public func navigationBarBackButtonHidden(_ hidesBackButton: Bool = true) -> some View

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ModifiedContent : Scene where Content : Scene, Modifier : _SceneModifier {

    /// The content and behavior of the scene.
    ///
    /// For any scene that you create, provide a computed `body` property that
    /// defines the scene as a composition of other scenes. You can assemble a
    /// scene from built-in scenes that SwiftUI provides, as well as other
    /// scenes that you've defined.
    ///
    /// Swift infers the scene's ``SwiftUI/Scene/Body-swift.associatedtype``
    /// associated type based on the contents of the `body` property.
    @MainActor @preconcurrency public var body: ModifiedContent<Content, Modifier>.Body { get }
}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension View {

    /// Adds padding to the specified edges of this view using an amount that's
    /// appropriate for the current scene.
    ///
    /// Use this modifier to add a scene-appropriate amount of padding to a
    /// view. Specify either a single edge value from ``Edge/Set``, or an
    /// <doc://com.apple.documentation/documentation/Swift/OptionSet> that
    /// describes the edges to pad.
    ///
    /// In macOS, use scene padding to produce the recommended spacing around
    /// the root view of a window. In watchOS, use scene padding to align
    /// elements of your user interface with top level elements, like the title
    /// of a navigation view. For example, compare the effects of different
    /// kinds of padding on text views presented inside a ``NavigationView``
    /// in watchOS:
    ///
    ///     VStack(alignment: .leading, spacing: 10) {
    ///         Text("Scene padding")
    ///             .scenePadding(.horizontal)
    ///             .border(.red) // Border added for reference.
    ///         Text("Regular padding")
    ///             .padding(.horizontal)
    ///             .border(.green)
    ///         Text("Text with no padding")
    ///             .border(.blue)
    ///         Button("Button") { }
    ///     }
    ///     .navigationTitle("Hello World")
    ///
    /// The text with scene padding automatically aligns with the title,
    /// unlike the text that uses the default padding or the text without
    /// padding:
    ///
    /// ![A watchOS screenshot with the title Hello World and a back button
    /// in the upper left. The title is indented by a small amount from
    /// the leading edge of the screen. Three bordered strings and a button
    /// appear arranged vertically below the title.
    /// The first string says Scene padding and has a red border that's aligned
    /// with the leading edge of the screen. The leading
    /// edge of the string inside the border aligns with the leading edge of
    /// the screen's title.
    /// The second string says Regular padding and has a green border that's
    /// aligned with the leading edge of the screen. The leading edge of the
    /// string appears offset from the title's leading edge by a small amount.
    /// The third string says Text with no padding and has a blue border that's
    /// aligned with the leading edge of the screen. The string is also aligned
    /// with the leading edge of the screen.](View-scenePadding-1-watchOS)
    ///
    /// Scene padding in watchOS also ensures that your content avoids the
    /// curved edges of a device like Apple Watch Series 7.
    /// In other platforms, scene padding produces the same default padding that
    /// you get from the ``View/padding(_:_:)`` modifier.
    ///
    /// > Important: Scene padding doesn't pad the top and bottom edges of a
    /// view in watchOS, even if you specify those edges as part of the input.
    /// For example, if you specify ``Edge/Set/vertical`` instead of
    /// ``Edge/Set/horizontal`` in the example above, the modifier would have
    /// no effect in watchOS. It does, however, apply to all the edges that you
    /// specify in other platforms.
    ///
    /// - Parameter edges: The set of edges along which to pad this view.
    ///
    /// - Returns: A view that's padded on specified edges by a
    ///   scene-appropriate amount.
    nonisolated public func scenePadding(_ edges: Edge.Set = .all) -> some View


    /// Adds a specified kind of padding to the specified edges of this view
    /// using an amount that's appropriate for the current scene.
    ///
    /// Use this modifier to add a scene-appropriate amount of padding to a
    /// view. Specify either a single edge value from ``Edge/Set``, or an
    /// <doc://com.apple.documentation/documentation/Swift/OptionSet> that
    /// describes the edges to pad.
    ///
    /// In macOS, use scene padding to produce the recommended spacing around
    /// the root view of a window. In watchOS, use scene padding to align
    /// elements of your user interface with top level elements, like the title
    /// of a navigation view. For example, compare the effects of different
    /// kinds of padding on text views presented inside a ``NavigationView``
    /// in watchOS:
    ///
    ///     VStack(alignment: .leading, spacing: 10) {
    ///         Text("Minimum Scene padding")
    ///             .scenePadding(.minimum, edges: .horizontal)
    ///             .border(.red) // Border added for reference.
    ///         Text("Navigation Bar Scene padding")
    ///             .scenePadding(.navigationBar, edges: .horizontal)
    ///             .border(.yellow)
    ///         Text("Regular padding")
    ///             .padding(.horizontal)
    ///             .border(.green)
    ///         Text("Text with no padding")
    ///             .border(.blue)
    ///         Button("Button") { }
    ///     }
    ///     .navigationTitle("Hello World")
    ///
    /// The text with minimum scene padding uses the system minimum padding
    /// and the text with navigation bar scene padding automatically aligns
    /// with the navigation bar content. In contrast, the text that uses the
    /// default padding and the text without padding do not align with scene
    /// elements.
    ///
    /// Scene padding in watchOS also ensures that your content avoids the
    /// curved edges of a device like Apple Watch Series 7.
    /// In other platforms, scene padding produces the same default padding that
    /// you get from the ``View/padding(_:_:)`` modifier.
    ///
    /// > Important: Scene padding doesn't pad the top and bottom edges of a
    /// view in watchOS, even if you specify those edges as part of the input.
    /// For example, if you specify ``Edge/Set/vertical`` instead of
    /// ``Edge/Set/horizontal`` in the example above, the modifier would have
    /// no effect in watchOS. It does, however, apply to all the edges that you
    /// specify in other platforms.
    ///
    /// - Parameter padding: The kind of padding to add.
    /// - Parameter edges: The set of edges along which to pad this view.
    ///
    /// - Returns: A view that's padded on specified edges by a
    ///   scene-appropriate amount.
    @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
    nonisolated public func scenePadding(_ padding: ScenePadding, edges: Edge.Set = .all) -> some View

}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension View {

    /// Explicitly set whether this Accessibility element responds to user
    /// interaction and would thus be interacted with by technologies such as
    /// Switch Control, Voice Control or Full Keyboard Access.
    ///
    /// If this is not set, the value is inferred from the traits of the
    /// Accessibility element, the presence of Accessibility actions on the
    /// element, or the presence of gestures on the element or containing views.
    ///
    /// - Parameters:
    ///   - respondsToUserInteraction: Whether the view responds to user
    ///     interaction.
    ///   - isEnabled: If true the accessibility interaction state is applied;
    ///     otherwise the accessibility interaction state is unchanged.
    nonisolated public func accessibilityRespondsToUserInteraction(_ respondsToUserInteraction: Bool, isEnabled: Bool) -> ModifiedContent<Self, AccessibilityAttachmentModifier>
}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension ModifiedContent where Modifier == AccessibilityAttachmentModifier {

    /// Explicitly set whether this Accessibility element responds to user
    /// interaction and would thus be interacted with by technologies such as
    /// Switch Control, Voice Control or Full Keyboard Access.
    ///
    /// If this is not set, the value is inferred from the traits of the
    /// Accessibility element, the presence of Accessibility actions on the
    /// element, or the presence of gestures on the element or containing views.
    ///
    /// - Parameters:
    ///   - respondsToUserInteraction: Whether the view responds to user
    ///     interaction.
    ///   - isEnabled: If true the accessibility interaction state is applied;
    ///     otherwise the accessibility interaction state is unchanged.
    nonisolated public func accessibilityRespondsToUserInteraction(_ respondsToUserInteraction: Bool, isEnabled: Bool) -> ModifiedContent<Content, Modifier>
}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension View {

    /// Explicitly set whether this Accessibility element responds to user
    /// interaction and would thus be interacted with by technologies such as
    /// Switch Control, Voice Control or Full Keyboard Access.
    ///
    /// If this is not set, the value is inferred from the traits of the
    /// Accessibility element, the presence of Accessibility actions on the
    /// element, or the presence of gestures on the element or containing views.
    nonisolated public func accessibilityRespondsToUserInteraction(_ respondsToUserInteraction: Bool = true) -> ModifiedContent<Self, AccessibilityAttachmentModifier>
}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension ModifiedContent where Modifier == AccessibilityAttachmentModifier {

    /// Explicitly set whether this Accessibility element responds to user
    /// interaction and would thus be interacted with by technologies such as
    /// Switch Control, Voice Control or Full Keyboard Access.
    ///
    /// If this is not set, the value is inferred from the traits of the
    /// Accessibility element, the presence of Accessibility actions on the
    /// element, or the presence of gestures on the element or containing views.
    nonisolated public func accessibilityRespondsToUserInteraction(_ respondsToUserInteraction: Bool = true) -> ModifiedContent<Content, Modifier>
}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension Never : AccessibilityRotorContent {
}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension ForEach : AccessibilityRotorContent where Content : AccessibilityRotorContent {

    /// The internal content of this `AccessibilityRotorContent`.
    @MainActor @preconcurrency public var body: Never { get }

    /// The type for the internal content of this `AccessibilityRotorContent`.
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias Body = Never
}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension ForEach where ID == Data.Element.ID, Content : AccessibilityRotorContent, Data.Element : Identifiable {

    /// Creates an instance that generates Rotor content by combining, in order,
    /// individual Rotor content for each element in the data given to this
    /// `ForEach`.
    ///
    /// It's important that the `id` of a data element doesn't change unless you
    /// replace the data element with a new data element that has a new
    /// identity.
    ///
    /// - Parameters:
    ///   - data: The identified data that the ``ForEach`` instance uses to
    ///     create views dynamically.
    ///   - content: The result builder that generates Rotor content for each
    ///     data element.
    public init(_ data: Data, @AccessibilityRotorContentBuilder content: @escaping (Data.Element) -> Content)
}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension ForEach where Content : AccessibilityRotorContent {

    /// Creates an instance that generates Rotor content by combining, in order,
    /// individual Rotor content for each element in the data given to this
    /// `ForEach`.
    ///
    /// It's important that the `id` of a data element doesn't change, unless
    /// SwiftUI considers the data element to have been replaced with a new data
    /// element that has a new identity.
    ///
    /// - Parameters:
    ///   - data: The data that the ``ForEach`` instance uses to create views
    ///     dynamically.
    ///   - id: The key path to the provided data's identifier.
    ///   - content: The result builder that generates Rotor content for each
    ///     data element.
    public init(_ data: Data, id: KeyPath<Data.Element, ID>, @AccessibilityRotorContentBuilder content: @escaping (Data.Element) -> Content)
}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension Group : AccessibilityRotorContent where Content : AccessibilityRotorContent {

    /// The internal content of this `AccessibilityRotorContent`.
    @MainActor @preconcurrency public var body: Never { get }

    /// Creates an instance that generates Rotor content by combining, in order,
    /// all the Rotor content specified in the passed-in result builder.
    ///
    /// - Parameter content: The result builder that generates Rotor content for
    ///   the group.
    public init(@AccessibilityRotorContentBuilder content: () -> Content)
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension EnvironmentValues {

    /// A binding to the current presentation mode of the view associated with
    /// this environment.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, message: "Use isPresented or dismiss")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, message: "Use isPresented or dismiss")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, message: "Use isPresented or dismiss")
    @available(watchOS, introduced: 6.0, deprecated: 100000.0, message: "Use isPresented or dismiss")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Use isPresented or dismiss")
    public var presentationMode: Binding<PresentationMode> { get }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// Sets the style for buttons within this view to a button style with a
    /// custom appearance and custom interaction behavior.
    ///
    /// Use this modifier to set a specific style for button instances
    /// within a view:
    ///
    ///     HStack {
    ///         Button("Sign In", action: signIn)
    ///         Button("Register", action: register)
    ///     }
    ///     .buttonStyle(.bordered)
    ///
    nonisolated public func buttonStyle<S>(_ style: S) -> some View where S : PrimitiveButtonStyle

}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension View {

    /// Modifies this view by binding its focus state to the given state value.
    ///
    /// Use this modifier to cause the view to receive focus whenever the
    /// the `binding` equals the `value`. Typically, you create an enumeration
    /// of fields that may receive focus, bind an instance of this enumeration,
    /// and assign its cases to focusable views.
    ///
    /// The following example uses the cases of a `LoginForm` enumeration to
    /// bind the focus state of two ``TextField`` views. A sign-in button
    /// validates the fields and sets the bound `focusedField` value to
    /// any field that requires the user to correct a problem.
    ///
    ///     struct LoginForm {
    ///         enum Field: Hashable {
    ///             case usernameField
    ///             case passwordField
    ///         }
    ///
    ///         @State private var username = ""
    ///         @State private var password = ""
    ///         @FocusState private var focusedField: Field?
    ///
    ///         var body: some View {
    ///             Form {
    ///                 TextField("Username", text: $username)
    ///                     .focused($focusedField, equals: .usernameField)
    ///
    ///                 SecureField("Password", text: $password)
    ///                     .focused($focusedField, equals: .passwordField)
    ///
    ///                 Button("Sign In") {
    ///                     if username.isEmpty {
    ///                         focusedField = .usernameField
    ///                     } else if password.isEmpty {
    ///                         focusedField = .passwordField
    ///                     } else {
    ///                         handleLogin(username, password)
    ///                     }
    ///                 }
    ///             }
    ///         }
    ///     }
    ///
    /// To control focus using a Boolean, use the ``View/focused(_:)`` method
    /// instead.
    ///
    /// - Parameters:
    ///   - binding: The state binding to register. When focus moves to the
    ///     modified view, the binding sets the bound value to the corresponding
    ///     match value. If a caller sets the state value programmatically to the
    ///     matching value, then focus moves to the modified view. When focus
    ///     leaves the modified view, the binding sets the bound value to
    ///     `nil`. If a caller sets the value to `nil`, SwiftUI automatically
    ///     dismisses focus.
    ///   - value: The value to match against when determining whether the
    ///     binding should change.
    /// - Returns: The modified view.
    nonisolated public func focused<Value>(_ binding: FocusState<Value>.Binding, equals value: Value) -> some View where Value : Hashable


    /// Modifies this view by binding its focus state to the given Boolean state
    /// value.
    ///
    /// Use this modifier to cause the view to receive focus whenever the
    /// the `condition` value is `true`. You can use this modifier to
    /// observe the focus state of a single view, or programmatically set and
    /// remove focus from the view.
    ///
    /// In the following example, a single ``TextField`` accepts a user's
    /// desired `username`. The text field binds its focus state to the
    /// Boolean value `usernameFieldIsFocused`. A "Submit" button's action
    /// verifies whether the name is available. If the name is unavailable, the
    /// button sets `usernameFieldIsFocused` to `true`, which causes focus to
    /// return to the text field, so the user can enter a different name.
    ///
    ///     @State private var username: String = ""
    ///     @FocusState private var usernameFieldIsFocused: Bool
    ///     @State private var showUsernameTaken = false
    ///
    ///     var body: some View {
    ///         VStack {
    ///             TextField("Choose a username.", text: $username)
    ///                 .focused($usernameFieldIsFocused)
    ///             if showUsernameTaken {
    ///                 Text("That username is taken. Please choose another.")
    ///             }
    ///             Button("Submit") {
    ///                 showUsernameTaken = false
    ///                 if !isUserNameAvailable(username: username) {
    ///                     usernameFieldIsFocused = true
    ///                     showUsernameTaken = true
    ///                 }
    ///             }
    ///         }
    ///     }
    ///
    /// To control focus by matching a value, use the
    /// ``View/focused(_:equals:)`` method instead.
    ///
    /// - Parameter condition: The focus state to bind. When focus moves
    ///   to the view, the binding sets the bound value to `true`. If a caller
    ///   sets the value to  `true` programmatically, then focus moves to the
    ///   modified view. When focus leaves the modified view, the binding
    ///   sets the value to `false`. If a caller sets the value to `false`,
    ///   SwiftUI automatically dismisses focus.
    ///
    /// - Returns: The modified view.
    nonisolated public func focused(_ condition: FocusState<Bool>.Binding) -> some View

}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension VisualEffect {

    /// Offsets the view by the horizontal and vertical amount specified in the
    /// offset parameter.
    ///
    /// - Parameter offset: The distance to offset the view.
    ///
    /// - Returns: An effect that offsets the view by `offset`.
    public func offset(_ offset: CGSize) -> some VisualEffect


    /// Offsets the view by the specified horizontal and vertical distances.
    ///
    /// - Parameters:
    ///   - x: The horizontal distance to offset the view.
    ///   - y: The vertical distance to offset the view.
    ///
    /// - Returns: An effect that offsets the view by `x` and `y`.
    public func offset(x: CGFloat = 0, y: CGFloat = 0) -> some VisualEffect

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// Positions the center of this view at the specified point in its parent's
    /// coordinate space.
    ///
    /// Use the `position(_:)` modifier to place the center of a view at a
    /// specific coordinate in the parent view using a
    /// <doc://com.apple.documentation/documentation/CoreFoundation/CGPoint> to specify the `x`
    /// and `y` offset.
    ///
    ///     Text("Position by passing a CGPoint()")
    ///         .position(CGPoint(x: 175, y: 100))
    ///         .border(Color.gray)
    ///
    /// - Parameter position: The point at which to place the center of this
    ///   view.
    ///
    /// - Returns: A view that fixes the center of this view at `position`.
    @inlinable nonisolated public func position(_ position: CGPoint) -> some View


    /// Positions the center of this view at the specified coordinates in its
    /// parent's coordinate space.
    ///
    /// Use the `position(x:y:)` modifier to place the center of a view at a
    /// specific coordinate in the parent view using an `x` and `y` offset.
    ///
    ///     Text("Position by passing the x and y coordinates")
    ///         .position(x: 175, y: 100)
    ///         .border(Color.gray)
    ///
    /// - Parameters:
    ///   - x: The x-coordinate at which to place the center of this view.
    ///   - y: The y-coordinate at which to place the center of this view.
    ///
    /// - Returns: A view that fixes the center of this view at `x` and `y`.
    @inlinable nonisolated public func position(x: CGFloat = 0, y: CGFloat = 0) -> some View

}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension TimelineSchedule where Self == AnimationTimelineSchedule {

    /// A pausable schedule of dates updating at a frequency no more quickly
    /// than the provided interval.
    public static var animation: AnimationTimelineSchedule { get }

    /// A pausable schedule of dates updating at a frequency no more quickly
    /// than the provided interval.
    ///
    /// - Parameters:
    ///     - minimumInterval: The minimum interval to update the schedule at.
    ///     Pass nil to let the system pick an appropriate update interval.
    ///     - paused: If the schedule should stop generating updates.
    public static func animation(minimumInterval: Double? = nil, paused: Bool = false) -> AnimationTimelineSchedule
}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension View {

    /// Sets the submit label for this view.
    ///
    ///     Form {
    ///         TextField("Username", $viewModel.username)
    ///             .submitLabel(.continue)
    ///         SecureField("Password", $viewModel.password)
    ///             .submitLabel(.done)
    ///     }
    ///
    /// - Parameter submitLabel: One of the cases specified in ``SubmitLabel``.
    nonisolated public func submitLabel(_ submitLabel: SubmitLabel) -> some View

}

extension View {

    /// Sets the navigation transition style for this view.
    ///
    /// Add this modifier to a view that appears within a
    /// ``NavigationStack`` or a sheet, outside of any containers such as
    /// ``VStack``.
    ///
    ///     struct ContentView: View {
    ///         @Namespace private var namespace
    ///         var body: some View {
    ///             NavigationStack {
    ///                 NavigationLink {
    ///                     DetailView()
    ///                         .navigationTransition(.zoom(sourceID: "world", in: namespace))
    ///                 } label: {
    ///                     Image(systemName: "globe")
    ///                         .matchedTransitionSource(id: "world", in: namespace)
    ///                 }
    ///             }
    ///         }
    ///     }
    ///
    @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
    nonisolated public func navigationTransition(_ style: some NavigationTransition) -> some View

}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension View {

    /// Marks this view as refreshable.
    ///
    /// Apply this modifier to a view to set the ``EnvironmentValues/refresh``
    /// value in the view's environment to a ``RefreshAction`` instance that
    /// uses the specified `action` as its handler. Views that detect the
    /// presence of the instance can change their appearance to provide a
    /// way for the user to execute the handler.
    ///
    /// For example, when you apply this modifier on iOS and iPadOS to a
    /// ``List``, the list enables a standard pull-to-refresh gesture that
    /// refreshes the list contents. When the user drags the top of the
    /// scrollable area downward, the view reveals a progress indicator
    /// and executes the specified handler. The indicator remains visible
    /// for the duration of the refresh, which runs asynchronously:
    ///
    ///     List(mailbox.conversations) { conversation in
    ///         ConversationCell(conversation)
    ///     }
    ///     .refreshable {
    ///         await mailbox.fetch()
    ///     }
    ///
    /// You can add refresh capability to your own views as well. For
    /// information on how to do that, see ``RefreshAction``.
    ///
    /// - Parameters:
    ///   - action: An asynchronous handler that SwiftUI executes when the
    ///   user requests a refresh. Use this handler to initiate
    ///   an update of model data displayed in the modified view. Use
    ///   `await` in front of any asynchronous calls inside the handler.
    /// - Returns: A view with a new refresh action in its environment.
    nonisolated public func refreshable(action: @escaping @Sendable () async -> Void) -> some View

}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension EnvironmentValues {

    /// A refresh action stored in a view's environment.
    ///
    /// When this environment value contains an instance of the
    /// ``RefreshAction`` structure, certain built-in views in the corresponding
    /// ``Environment`` begin offering a refresh capability. They apply the
    /// instance's handler to any refresh operation that the user initiates.
    /// By default, the environment value is `nil`, but you can use the
    /// ``View/refreshable(action:)`` modifier to create and store a new
    /// refresh action that uses the handler that you specify:
    ///
    ///     List(mailbox.conversations) { conversation in
    ///         ConversationCell(conversation)
    ///     }
    ///     .refreshable {
    ///         await mailbox.fetch()
    ///     }
    ///
    /// On iOS and iPadOS, the ``List`` in the example above offers a
    /// pull to refresh gesture because it detects the refresh action. When
    /// the user drags the list down and releases, the list calls the action's
    /// handler. Because SwiftUI declares the handler as asynchronous, it can
    /// safely make long-running asynchronous calls, like fetching network data.
    ///
    /// ### Refreshing custom views
    ///
    /// You can also offer refresh capability in your custom views.
    /// Read the `refresh` environment value to get the ``RefreshAction``
    /// instance for a given ``Environment``. If you find
    /// a non-`nil` value, change your view's appearance or behavior to offer
    /// the refresh to the user, and call the instance to conduct the
    /// refresh. You can call the refresh instance directly because it defines
    /// a ``RefreshAction/callAsFunction()`` method that Swift calls
    /// when you call the instance:
    ///
    ///     struct RefreshableView: View {
    ///         @Environment(\.refresh) private var refresh
    ///
    ///         var body: some View {
    ///             Button("Refresh") {
    ///                 Task {
    ///                     await refresh?()
    ///                 }
    ///             }
    ///             .disabled(refresh == nil)
    ///         }
    ///     }
    ///
    /// Be sure to call the handler asynchronously by preceding it
    /// with `await`. Because the call is asynchronous, you can use
    /// its lifetime to indicate progress to the user. For example,
    /// you can reveal an indeterminate ``ProgressView`` before
    /// calling the handler, and hide it when the handler completes.
    ///
    /// If your code isn't already in an asynchronous context, create a
    /// <doc://com.apple.documentation/documentation/Swift/Task> for the
    /// method to run in. If you do this, consider adding a way for the
    /// user to cancel the task. For more information, see
    /// [Concurrency](https://docs.swift.org/swift-book/LanguageGuide/Concurrency.html)
    /// in *The Swift Programming Language*.
    public var refresh: RefreshAction? { get }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// Applies a projection transformation to this view's rendered output.
    ///
    /// Use `projectionEffect(_:)` to apply a 3D transformation to the view.
    ///
    /// The example below rotates the text 30 around the `z` axis, which is the
    /// axis pointing out of the screen:
    ///
    ///     // This transform represents a 30 rotation around the z axis.
    ///     let transform = CATransform3DMakeRotation(
    ///         -30 * (.pi / 180), 0.0, 0.0, 1.0)
    ///
    ///     Text("Projection effects using transforms")
    ///         .projectionEffect(.init(transform))
    ///         .border(Color.gray)
    ///
    /// ![A screenshot showing text rotated 30 degrees around the axis pointing
    /// out of the screen.](SwiftUI-View-projectionEffect.png)
    ///
    /// - Parameter transform: A ``ProjectionTransform`` to apply to the view.
    @inlinable nonisolated public func projectionEffect(_ transform: ProjectionTransform) -> some View

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// Applies an affine transformation to this view's rendered output.
    ///
    /// Use `transformEffect(_:)` to rotate, scale, translate, or skew the
    /// output of the view according to the provided
    /// <doc://com.apple.documentation/documentation/CoreFoundation/CGAffineTransform>.
    ///
    /// In the example below, the text is rotated at -30 on the `y` axis.
    ///
    ///     let transform = CGAffineTransform(rotationAngle: -30 * (.pi / 180))
    ///
    ///     Text("Projection effect using transforms")
    ///         .transformEffect(transform)
    ///         .border(Color.gray)
    ///
    /// ![A screenshot of a view showing text that is rotated at -30 degrees on
    /// the y axis.](SwiftUI-View-transformEffect.png)
    ///
    /// - Parameter transform: A
    /// <doc://com.apple.documentation/documentation/CoreFoundation/CGAffineTransform> to
    /// apply to the view.
    @inlinable nonisolated public func transformEffect(_ transform: CGAffineTransform) -> some View

}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension VisualEffect {

    /// Applies a projection transformation to the view's rendered output.
    ///
    /// Use `transformEffect(_:)` to rotate, scale, translate, or skew the
    /// output of the view according to the provided
    /// <doc://com.apple.documentation/documentation/SwiftUI/ProjectionTransform>.
    ///
    /// - Parameter transform: A
    /// <doc://com.apple.documentation/documentation/SwiftUI/ProjectionTransform> to
    /// apply to the view.
    ///
    /// - Returns: An effect that applies a projection transformation to the
    ///   view's rendered output.
    public func transformEffect(_ transform: ProjectionTransform) -> some VisualEffect


    /// Applies an affine transformation to the view's rendered output.
    ///
    /// Use `transformEffect(_:)` to rotate, scale, translate, or skew the
    /// output of the view according to the provided
    /// <doc://com.apple.documentation/documentation/CoreFoundation/CGAffineTransform>.
    ///
    /// - Parameter transform: A
    /// <doc://com.apple.documentation/documentation/CoreFoundation/CGAffineTransform> to
    /// apply to the view.
    ///
    /// - Returns: An effect that applies an affine transformation to the
    ///   view's rendered output.
    ///
    public func transformEffect(_ transform: CGAffineTransform) -> some VisualEffect

}

@available(iOS 18.0, tvOS 18.0, visionOS 2.0, *)
@available(macOS, unavailable)
extension UIView {

    /// Animate changes to one or more views using the specified SwiftUI
    /// animation.
    ///
    /// Animations performed using this method can be smoothly retargeted while
    /// preserving velocity, just like animations in SwiftUI views.
    ///
    /// ```
    /// Task {
    ///     // Begin animation
    ///     UIView.animate(.spring(duration: 1.0)) {
    ///         myView.center = CGPoint(x: 200, y: 200)
    ///     }
    ///
    ///     try await Task.sleep(for: .seconds(0.5))
    ///
    ///     // Retarget running animations
    ///     UIView.animate(.spring) {
    ///         myView.center = CGPoint(x: 100, y: 400)
    ///     }
    /// }
    /// ```
    ///
    /// - Note: When a SwiftUI animation is used for UIView animations, the
    ///   animations are run in-process, and are not backed by `CAAnimation`s.
    ///
    /// - Parameters:
    ///   - animation: The animation to use for the changes.
    ///   - changes: A closure containing the changes to animate.
    ///   - completion: A closure to execute after the animation completes.
    @MainActor @preconcurrency public static func animate(_ animation: Animation, changes: () -> Void, completion: (() -> Void)? = nil)

    @available(iOS, introduced: 18.0, deprecated: 18.0, renamed: "animate(_:changes:completion:)")
    @available(macOS, unavailable)
    @available(tvOS, introduced: 18.0, deprecated: 18.0, renamed: "animate(_:changes:completion:)")
    @available(visionOS, introduced: 2.0, deprecated: 2.0, renamed: "animate(_:changes:completion:)")
    @MainActor @preconcurrency public static func animate(with animation: Animation = Animation.default, changes: () -> Void, completion: (() -> Void)? = nil)
}

@available(iOS 18.0, tvOS 18.0, visionOS 2.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension View {

    /// Applies a hover effect to this view, while providing a way to
    /// conditionally enable or disable it.
    ///
    /// By default, ``CustomHoverEffect/automatic`` is used. You can control
    /// the behavior of the automatic effect with the
    /// ``View/defaultHoverEffect(_:)`` modifier.
    ///
    /// - Parameters:
    ///   - effect: The hover effect to apply to this view.
    ///   - isEnabled: Whether the hover effect is enabled or not.
    /// - Returns: A view with the hover effect applied.
    nonisolated public func hoverEffect(_ effect: some CustomHoverEffect = .automatic, isEnabled: Bool = true) -> some View

}

@available(iOS 13.4, tvOS 16.0, visionOS 1.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension View {

    /// Applies a hover effect to this view.
    ///
    /// By default, ``HoverEffect/automatic`` is used. You can control the
    /// behavior of the automatic effect with the
    /// ``View/defaultHoverEffect(_:)`` modifier.
    ///
    /// - Parameters:
    ///   - effect: The effect to apply to this view.
    ///   - isEnabled: Whether the effect is enabled or not.
    /// - Returns: A new view that applies a hover effect to `self`.
    @available(iOS 13.4, tvOS 16.0, visionOS 1.0, *)
    @available(macOS, unavailable)
    @available(watchOS, unavailable)
    nonisolated public func hoverEffect(_ effect: HoverEffect = .automatic) -> some View

}

@available(iOS 17.0, tvOS 17.0, visionOS 1.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension View {

    /// Applies a hover effect to this view.
    ///
    /// By default, ``HoverEffect/automatic`` is used. You can control the
    /// behavior of the automatic effect with the
    /// ``View/defaultHoverEffect(_:)`` modifier.
    ///
    /// - Parameters:
    ///   - effect: The effect to apply to this view.
    ///   - isEnabled: Whether the effect is enabled or not.
    /// - Returns: A new view that applies a hover effect to `self`.
    nonisolated public func hoverEffect(_ effect: HoverEffect = .automatic, isEnabled: Bool = true) -> some View


    /// Sets the default hover effect to use for views within this view.
    ///
    /// Use this modifier to set a specific hover effect for all views with the
    /// ``View/hoverEffect(_:)`` modifier applied within a view. The default
    /// effect is typically used when no ``HoverEffect`` was provided or if
    /// ``HoverEffect/automatic`` is specified.
    ///
    /// For example, this view uses ``HoverEffect/highlight`` for both the red
    /// and green Color views:
    ///
    ///     HStack {
    ///         Color.red.hoverEffect()
    ///         Color.green.hoverEffect()
    ///     }
    ///     .defaultHoverEffect(.highlight)
    ///
    /// This also works for customizing the default hover effect in views like
    /// ``Button``s when using a SwiftUI-defined style like
    /// ``ButtonStyle/bordered``, which can provide a hover effect by default.
    /// For example, this view replaces the hover effect for a ``Button`` with
    /// ``HoverEffect/highlight``:
    ///
    ///     Button("Next") {}
    ///         // perform action
    ///     }
    ///     .buttonStyle(.bordered)
    ///     .defaultHoverEffect(.highlight)
    ///
    /// Use a `nil` effect to indicate that the default hover effect should not
    /// be modified.
    ///
    /// - Parameter effect: The default hover effect to use for views within
    ///   this view.
    /// - Returns: A view that uses this effect as the default hover effect.
    nonisolated public func defaultHoverEffect(_ effect: HoverEffect?) -> some View


    /// Sets the default hover effect to use within this view hierarchy.
    ///
    /// Use this modifier to set a specific hover effect for all views with the
    /// ``View/hoverEffect(_:)`` modifier applied to them within a view
    /// hierarchy. The default effect is typically used when no
    /// ``CustomHoverEffect`` was provided or if ``CustomHoverEffect/automatic``
    /// is specified.
    ///
    /// For example, this view applies a custom effect named `FadeInHoverEffect`
    /// for both the red and green Color views:
    ///
    ///
    ///     HStack {
    ///         Color.red.hoverEffect()
    ///         Color.green.hoverEffect()
    ///     }
    ///     .defaultHoverEffect(FadeInHoverEffect())
    ///
    ///
    /// This also works for customizing the default hover effect in views like
    /// ``Button``s when using a SwiftUI-defined style like
    /// ``ButtonStyle/bordered``, which can provide a hover effect by default.
    /// For example, this view replaces the hover effect for a ``Button`` with
    /// a `FadeInHoverEffect` effect:
    ///
    ///
    ///     Button("Next") {
    ///         // perform action
    ///     }
    ///     .buttonStyle(.bordered)
    ///     .defaultHoverEffect(FadeInHoverEffect())
    ///
    ///
    /// - Parameter effect: The default hover effect to use within this view
    ///   hierarchy.
    /// - Returns: A view that uses `effect` as the default hover effect.
    @available(iOS 18.0, tvOS 18.0, visionOS 2.0, *)
    @available(macOS, unavailable)
    @available(watchOS, unavailable)
    nonisolated public func defaultHoverEffect(_ effect: some CustomHoverEffect) -> some View


    /// Adds a condition that controls whether this view can display hover
    /// effects.
    ///
    /// The higher views in a view hierarchy can override the value you set on
    /// this view. In the following example, the button does not display a hover
    /// effect because the outer `hoverEffectDisabled(_:)` modifier overrides
    /// the inner one:
    ///
    ///     HStack {
    ///         Button("Press") {}
    ///             .hoverEffectDisabled(false)
    ///     }
    ///     .hoverEffectDisabled(true)
    ///
    /// - Parameter disabled: A Boolean value that determines whether this view
    ///   can display hover effects.
    ///
    /// - Returns: A view that controls whether hover effects can be displayed
    ///   in this view.
    nonisolated public func hoverEffectDisabled(_ disabled: Bool = true) -> some View

}

@available(iOS 17.0, tvOS 17.0, visionOS 1.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension EnvironmentValues {

    /// A Boolean value that indicates whether the view associated with this
    /// environment allows hover effects to be displayed.
    ///
    /// The default value is `true`.
    public var isHoverEffectEnabled: Bool
}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension VisualEffect {

    /// Rotates content in two dimensions around the specified point.
    ///
    /// This effect rotates the content around the axis that points
    /// out of the xy-plane. It has no effect on the content's frame.
    /// The following code rotates text by 22 and then draws a border around
    /// the modified view to show that the frame remains unchanged by the
    /// rotation:
    ///
    ///     Text("Rotation by passing an angle in degrees")
    ///         .visualEffect { content, geometryProxy in
    ///             content
    ///                 .rotationEffect(.degrees(22))
    ///         }
    ///         .border(Color.gray)
    ///
    /// ![A screenshot of text and a wide grey box. The text says Rotation by passing an angle in degrees. The baseline of the text is rotated clockwise by 22 degrees relative to the box. The center of the box and the center of the text are aligned.](SwiftUI-View-rotationEffect)
    ///
    /// - Parameters:
    ///   - angle: The angle by which to rotate the content.
    ///   - anchor: A unit point within the content about which to
    ///     perform the rotation. The default value is ``UnitPoint/center``.
    /// - Returns: A rotation effect.
    public func rotationEffect(_ angle: Angle, anchor: UnitPoint = .center) -> some VisualEffect

}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension VisualEffect {

    /// Scales the view's rendered output by the given vertical and horizontal
    /// size amounts, relative to an anchor point.
    ///
    /// - Parameters:
    ///   - scale: A <doc://com.apple.documentation/documentation/CoreFoundation/CGSize> that
    ///     represents the horizontal and vertical amount to scale the view.
    ///   - anchor: The point with a default of ``UnitPoint/center`` that
    ///     defines the location within the view from which to apply the
    ///     transformation.
    ///
    /// - Returns: An effect that scales the view's rendered output.
    public func scaleEffect(_ scale: CGSize, anchor: UnitPoint = .center) -> some VisualEffect


    /// Scales the view's rendered output by the given amount in both the
    /// horizontal and vertical directions, relative to an anchor point.
    ///
    /// - Parameters:
    ///   - s: The amount to scale the view in the view in both the horizontal
    ///     and vertical directions.
    ///   - anchor: The point with a default of ``UnitPoint/center`` that
    ///     defines the location within the view from which to apply the
    ///     transformation.
    ///
    /// - Returns: An effect that scales the view's rendered output.
    public func scaleEffect(_ scale: CGFloat, anchor: UnitPoint = .center) -> some VisualEffect


    /// Scales the view's rendered output by the given horizontal and vertical
    /// amounts, relative to an anchor point.
    ///
    /// - Parameters:
    ///   - x: An amount that represents the horizontal amount to scale the
    ///     view. The default value is `1.0`.
    ///   - y: An amount that represents the vertical amount to scale the view.
    ///     The default value is `1.0`.
    ///   - anchor: The point with a default of ``UnitPoint/center`` that
    ///     defines the location within the view from which to apply the
    ///     transformation.
    ///
    /// - Returns: An effect that scales the view's rendered output.
    public func scaleEffect(x: CGFloat = 1.0, y: CGFloat = 1.0, anchor: UnitPoint = .center) -> some VisualEffect

}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension VisualEffect {

    /// Applies a Gaussian blur to the view.
    ///
    /// Use `blur(radius:opaque:)` to apply a gaussian blur effect to the
    /// rendering of the view.
    ///
    /// - Parameters:
    ///   - radius: The radial size of the blur. A blur is more diffuse when its
    ///     radius is large.
    ///   - opaque: A Boolean value that indicates whether the blur renderer
    ///     permits transparency in the blur output. Set to `true` to create an
    ///     opaque blur, or set to `false` to permit transparency.
    ///
    /// - Returns: An effect that blurs the view.
    public func blur(radius: CGFloat, opaque: Bool = false) -> some VisualEffect

}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension VisualEffect {

    /// Brightens the view by the specified amount.
    ///
    /// - Parameter amount: A value between 0 (no effect) and 1 (full white
    ///   brightening) that represents the intensity of the brightness effect.
    ///
    /// - Returns: An effect that brightens the view by the specified amount.
    public func brightness(_ amount: Double) -> some VisualEffect

}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension Animation {

    /// Creates a new animation with speed controlled by the given curve.
    ///
    /// - Parameters:
    ///   - timingCurve: A curve that describes the speed of the
    ///     animation over its duration.
    ///   - duration: The duration of the animation, in seconds.
    public static func timingCurve(_ curve: UnitCurve, duration: TimeInterval) -> Animation
}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension VisualEffect {

    /// Sets the contrast and separation between similar colors in the view.
    ///
    /// Apply contrast to a view to increase or decrease the separation between
    /// similar colors in the view.
    ///
    /// - Parameter amount: The intensity of color contrast to apply. negative
    ///   values invert colors in addition to applying contrast.
    ///
    /// - Returns: An effect that applies color contrast to the view.
    public func contrast(_ amount: Double) -> some VisualEffect

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension Never : ToolbarContent, CustomizableToolbarContent {
}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension VisualEffect {

    /// Adds a grayscale effect to the view.
    ///
    /// A grayscale effect reduces the intensity of colors in the view.
    ///
    /// - Parameter amount: The intensity of grayscale to apply from 0.0 to less
    ///   than 1.0. Values closer to 0.0 are more colorful, and values closer to
    ///   1.0 are less colorful.
    ///
    /// - Returns: An effect that reduces the intensity of colors in the view.
    public func grayscale(_ amount: Double) -> some VisualEffect

}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension VisualEffect {

    /// Applies a hue rotation effect to the view.
    ///
    /// Use hue rotation effect to shift all of the colors in a view according
    /// to the angle you specify.
    ///
    /// - Parameter angle: The hue rotation angle to apply to the colors in the
    ///   view.
    ///
    /// - Returns: An effect that shifts all of the colors in the view.
    public func hueRotation(_ angle: Angle) -> some VisualEffect

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 7.0, *)
extension View {

    /// Sets the style for navigation views within this view.
    ///
    /// Use this modifier to change the appearance and behavior of navigation
    /// views. For example, by default, navigation views appear with multiple
    /// columns in wider environments, like iPad in landscape orientation:
    ///
    /// ![A screenshot of an iPad in landscape orientation mode showing a
    /// multicolumn navigation view. The left column lists the colors Purple,
    /// Pink, and Orange, with Purple selected. The right column presents a
    /// detail view that shows a purple square.](View-navigationViewStyle-1)
    ///
    /// You can apply the ``NavigationViewStyle/stack`` style to force
    /// single-column stack navigation in these environments:
    ///
    ///     NavigationView {
    ///         List {
    ///             NavigationLink("Purple", destination: ColorDetail(color: .purple))
    ///             NavigationLink("Pink", destination: ColorDetail(color: .pink))
    ///             NavigationLink("Orange", destination: ColorDetail(color: .orange))
    ///         }
    ///         .navigationTitle("Colors")
    ///
    ///         Text("Select a Color") // A placeholder to show before selection.
    ///     }
    ///     .navigationViewStyle(.stack)
    ///
    /// ![A screenshot of an iPad in landscape orientation mode showing a
    /// single column containing the list Purple, Pink, and
    /// Orange.](View-navigationViewStyle-2)
    @available(iOS, introduced: 13.0, deprecated: 100000.0, message: "replace styled NavigationView with NavigationStack or NavigationSplitView instead")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, message: "replace styled NavigationView with NavigationStack or NavigationSplitView instead")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, message: "replace styled NavigationView with NavigationStack or NavigationSplitView instead")
    @available(watchOS, introduced: 7.0, deprecated: 100000.0, message: "replace styled NavigationView with NavigationStack or NavigationSplitView instead")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "replace styled NavigationView with NavigationStack or NavigationSplitView instead")
    nonisolated public func navigationViewStyle<S>(_ style: S) -> some View where S : NavigationViewStyle

}

extension View {

    /// Sets the preferred visibility of the non-transient system views
    /// overlaying the app.
    ///
    /// Use this modifier to influence the appearance of system overlays
    /// in your app. The behavior varies by platform.
    ///
    /// In iOS, the following example hides every persistent system overlay.
    /// In visionOS 2 and later, the SharePlay Indicator hides if the
    /// scene is shared through SharePlay, or not shared at all.
    /// During screen sharing, the indicator always remains visible.
    /// The Home indicator doesn't appear without specific user intent
    /// when you set visibility to ``hidden``. For a ``WindowGroup``,
    /// the modifier affects the visibility of the window chrome. For an
    /// ``ImmersiveSpace``, it affects the Home indicator.
    ///
    ///     struct ImmersiveView: View {
    ///         var body: some View {
    ///             Text("Maximum immersion")
    ///                 .persistentSystemOverlays(.hidden)
    ///         }
    ///     }
    ///
    /// > Note: You can indicate a preference with this modifier, but the system
    /// might or might not be able to honor that preference.
    ///
    /// Affected non-transient system views can include, but are not limited to:
    /// - The Home indicator.
    /// - The SharePlay indicator.
    /// - The Multitasking Controls button and Picture in Picture on iPad.
    ///
    /// - Parameter visibility: A value that indicates the visibility of the
    /// non-transient system views overlaying the app.
    @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
    nonisolated public func persistentSystemOverlays(_ visibility: Visibility) -> some View

}

@available(iOS 13.0, macOS 10.15, tvOS 14.0, *)
@available(watchOS, introduced: 6.0, deprecated: 7.0)
extension View {

    /// Adds a context menu to a view.
    ///
    /// Use this modifier to add a context menu to a view in your app's
    /// user interface. Compose the menu by returning controls like ``Button``,
    /// ``Toggle``, and ``Picker`` from the `menuItems` closure. You can also
    /// use ``Menu`` to define submenus or ``Section`` to group items.
    ///
    /// The following example creates a ``Text`` view that has a context menu
    /// with two buttons:
    ///
    ///     Text("Turtle Rock")
    ///         .padding()
    ///         .contextMenu {
    ///             Button {
    ///                 // Add this item to a list of favorites.
    ///             } label: {
    ///                 Label("Add to Favorites", systemImage: "heart")
    ///             }
    ///             Button {
    ///                 // Open Maps and center it on this item.
    ///             } label: {
    ///                 Label("Show in Maps", systemImage: "mappin")
    ///             }
    ///         }
    ///
    /// When someone activates the context menu with an action like touch and
    /// hold in iOS or iPadOS, the system displays the menu next to the content:
    ///
    /// ![A screenshot of a context menu showing two menu items: Add to
    /// Favorites, and Show in Maps.](View-contextMenu-1-iOS)
    ///
    /// The system dismisses the menu if someone makes a selection, or taps
    /// or clicks outside the menu.
    ///
    /// To customize the default preview, apply a
    /// ``View/contentShape(_:_:eoFill:)`` with a
    /// ``ContentShapeKinds/contextMenuPreview`` kind. For example, you can
    /// change the preview's corner radius or use a nested view as the preview.
    ///
    /// > Note: This view modifier produces a context menu on macOS, but that
    /// platform doesn't display a preview.
    ///
    /// If you want to show a different preview, you can use
    /// ``View/contextMenu(menuItems:preview:)``. To add a context menu to a
    /// container that supports selection, like a ``List`` or a ``Table``, and
    /// to distinguish between menu activation on a selection and
    /// activation in an empty area of the container, use
    /// ``View/contextMenu(forSelectionType:menu:primaryAction:)``.
    ///
    /// - Parameter menuItems: A closure that produces the menu's contents. You
    ///   can deactivate the context menu by returning nothing from the closure.
    ///
    /// - Returns: A view that can display a context menu.
    nonisolated public func contextMenu<MenuItems>(@ViewBuilder menuItems: () -> MenuItems) -> some View where MenuItems : View

}

@available(iOS 16.0, macOS 13.0, tvOS 16.0, *)
@available(watchOS, unavailable)
extension View {

    /// Adds a context menu with a custom preview to a view.
    ///
    /// When you use this modifer to add a context menu to a view in your
    /// app's user interface, the system displays the custom preview beside the
    /// menu.
    /// Compose the menu by returning controls like ``Button``, ``Toggle``, and
    /// ``Picker`` from the `menuItems` closure. You can also use ``Menu`` to
    /// define submenus or ``Section`` to group items.
    ///
    /// Define the custom preview by returning a view from the `preview`
    /// closure. The system sizes the preview to match the size of its content.
    /// For example, you can add a two button context menu to a ``Text`` view,
    /// and use an ``Image`` as the preview:
    ///
    ///     Text("Turtle Rock")
    ///         .padding()
    ///         .contextMenu {
    ///             Button {
    ///                 // Add this item to a list of favorites.
    ///             } label: {
    ///                 Label("Add to Favorites", systemImage: "heart")
    ///             }
    ///             Button {
    ///                 // Open Maps and center it on this item.
    ///             } label: {
    ///                 Label("Show in Maps", systemImage: "mappin")
    ///             }
    ///         } preview: {
    ///             Image("turtlerock") // Loads the image from an asset catalog.
    ///         }
    ///
    /// When someone activates the context menu with an action like touch and
    /// hold in iOS or iPadOS, the system displays the image and the menu:
    ///
    /// ![A screenshot of a context menu with two buttons that are labeled
    /// Add to Favorites, and Show in Maps. An image of a Joshua Tree appears
    /// above the menu.](View-contextMenu-2-iOS)
    ///
    /// To customize the lift preview, shown while the system transitions
    /// to show your custom `preview`, apply a ``View/contentShape(_:_:eoFill:)``
    /// with a ``ContentShapeKinds/contextMenuPreview`` kind. For example, you
    /// can change the lift preview's corner radius or use a nested view as the
    /// lift preview.
    ///
    /// > Note: This view modifier produces a context menu on macOS, but that
    /// platform doesn't display the preview.
    ///
    /// If you don't need a preview, use ``View/contextMenu(menuItems:)``
    /// instead. If you want to add a context menu to a container that supports
    /// selection, like a ``List`` or a ``Table``, and you want to distinguish
    /// between menu activation on a selection and activation in an empty area
    /// of the container, use
    /// ``View/contextMenu(forSelectionType:menu:primaryAction:)``.
    ///
    /// - Parameters:
    ///   - menuItems: A closure that produces the menu's contents. You can
    ///     deactivate the context menu by returning nothing from the closure.
    ///   - preview: A view that the system displays along with the menu.
    ///
    /// - Returns: A view that can display a context menu with a preview.
    nonisolated public func contextMenu<M, P>(@ViewBuilder menuItems: () -> M, @ViewBuilder preview: () -> P) -> some View where M : View, P : View

}

@available(iOS, introduced: 13.0, deprecated: 100000.0, message: "Use `contextMenu(menuItems:)` instead.")
@available(macOS, introduced: 10.15, deprecated: 100000.0, message: "Use `contextMenu(menuItems:)` instead.")
@available(tvOS, unavailable)
@available(watchOS, introduced: 6.0, deprecated: 7.0)
@available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Use `contextMenu(menuItems:)` instead.")
extension View {

    /// Adds a context menu to the view.
    ///
    /// Use this method to attach a specified context menu to a view.
    /// You can make the context menu unavailable by conditionally passing `nil`
    /// as the value for the `contextMenu`.
    ///
    /// The example below creates a ``ContextMenu`` that contains two items and
    /// passes them into the modifier. The Boolean value `shouldShowMenu`,
    /// which defaults to `true`, controls the context menu availability:
    ///
    ///     private let menuItems = ContextMenu {
    ///         Button {
    ///             // Add this item to a list of favorites.
    ///         } label: {
    ///             Label("Add to Favorites", systemImage: "heart")
    ///         }
    ///         Button {
    ///             // Open Maps and center it on this item.
    ///         } label: {
    ///             Label("Show in Maps", systemImage: "mappin")
    ///         }
    ///     }
    ///
    ///     private struct ContextMenuMenuItems: View {
    ///         @State private var shouldShowMenu = true
    ///
    ///         var body: some View {
    ///             Text("Turtle Rock")
    ///                 .contextMenu(shouldShowMenu ? menuItems : nil)
    ///         }
    ///     }
    ///
    /// ![A screenshot of a context menu showing two menu items: Add to
    /// Favorites, and Show in Maps.](View-contextMenu-1-iOS)
    ///
    /// To customize the default preview, apply a
    /// ``View/contentShape(_:_:eoFill:)`` with a
    /// ``ContentShapeKinds/contextMenuPreview`` kind. For example, you can
    /// change the preview's corner radius or use a nested view as the preview.
    ///
    /// - Parameter contextMenu: A context menu container for views that you
    ///   present as menu items in a context menu.
    ///
    /// - Returns: A view that can show a context menu.
    nonisolated public func contextMenu<MenuItems>(_ contextMenu: ContextMenu<MenuItems>?) -> some View where MenuItems : View

}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension View {

    /// Configures the visibility of the window toolbar when the window enters
    /// full screen mode.
    ///
    /// By default, the window toolbar will show at the top of the display,
    /// above the window's contents.
    ///
    /// You can use this modifier to override the default behavior.
    ///
    /// For example, you can specify that the window toolbar should be hidden
    /// by default, and only show once the mouse moves into the area occupied
    /// by the menu bar:
    ///
    ///     struct RootView: View {
    ///         var body: some View {
    ///             ContentView()
    ///                 .toolbar {
    ///                     ...
    ///                 }
    ///                 .windowToolbarFullScreenVisibility(.onHover)
    ///         }
    ///     }
    ///
    /// - Parameter visibility: The visibility to use for the window toolbar in
    ///   full screen mode.
    nonisolated public func windowToolbarFullScreenVisibility(_ visibility: WindowToolbarFullScreenVisibility) -> some View

}

extension DynamicViewContent {

    /// Sets the insert action for the dynamic view.
    ///
    ///     struct Profile: Identifiable {
    ///         let givenName: String
    ///         let familyName: String
    ///         let id = UUID()
    ///     }
    ///
    ///     @State private var profiles: [Profile] = [
    ///         Person(givenName: "Juan", familyName: "Chavez"),
    ///         Person(givenName: "Mei", familyName: "Chen"),
    ///         Person(givenName: "Tom", familyName: "Clark"),
    ///         Person(givenName: "Gita", familyName: "Kumar")
    ///     ]
    ///
    ///     var body: some View {
    ///         List {
    ///             ForEach(profiles) { profile in
    ///                 Text(profile.givenName)
    ///             }
    ///             .dropDestination(for: Profile.self) { receivedProfiles, offset in
    ///                 profiles.insert(contentsOf: receivedProfiles, at: offset)
    ///             }
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - payloadType: Type of the models that are dropped.
    ///   - action: A closure that SwiftUI invokes when elements are added to
    ///     the view. The closure takes two arguments: The first argument is the
    ///     offset relative to the dynamic view's underlying collection of data.
    ///     The second argument is an array of `Transferable` items that
    ///     represents the data that you want to insert.
    ///
    /// - Returns: A view that calls `action` when elements are inserted into
    ///   the original view.
    @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
    nonisolated public func dropDestination<T>(for payloadType: T.Type = T.self, action: @escaping ([T], Int) -> Void) -> some DynamicViewContent where T : Transferable

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension DynamicViewContent {

    /// Sets the insert action for the dynamic view.
    ///
    /// - Parameters:
    ///   - supportedContentTypes: An array of UTI types that the dynamic
    ///     view supports.
    ///   - action: A closure that SwiftUI invokes when elements are added to
    ///     the view. The closure takes two arguments: The first argument is the
    ///     offset relative to the dynamic view's underlying collection of data.
    ///     The second argument is an array of
    ///     <doc://com.apple.documentation/documentation/Foundation/NSItemProvider> items that
    ///     represents the data that you want to insert.
    ///
    /// - Returns: A view that calls `action` when elements are inserted into
    ///   the original view.
    @available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
    nonisolated public func onInsert(of supportedContentTypes: [UTType], perform action: @escaping (Int, [NSItemProvider]) -> Void) -> some DynamicViewContent


    /// Sets the insert action for the dynamic view.
    ///
    /// - Parameters:
    ///   - acceptedTypeIdentifiers: An array of UTI types that the dynamic
    ///     view supports.
    ///   - action: A closure that SwiftUI invokes when elements are added to
    ///     the view. The closure takes two arguments: The first argument is the
    ///     offset relative to the dynamic view's underlying collection of data.
    ///     The second argument is an array of `NSItemProvider` that represents
    ///     the data that you want to insert.
    ///
    /// - Returns: A view that calls `action` when elements are inserted into
    ///   the original view.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, message: "Provide `UTType`s as the `supportedContentTypes` instead.")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, message: "Provide `UTType`s as the `supportedContentTypes` instead.")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, message: "Provide `UTType`s as the `supportedContentTypes` instead.")
    @available(watchOS, introduced: 6.0, deprecated: 100000.0, message: "Provide `UTType`s as the `supportedContentTypes` instead.")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Provide `UTType`s as the `supportedContentTypes` instead.")
    public func onInsert(of acceptedTypeIdentifiers: [String], perform action: @escaping (Int, [NSItemProvider]) -> Void) -> some DynamicViewContent

}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension VisualEffect {

    /// Adjusts the color saturation of the view.
    ///
    /// Use color saturation to increase or decrease the intensity of colors in
    /// a view.
    ///
    /// - SeeAlso: `contrast(_:)`
    /// - Parameter amount: The amount of saturation to apply to the view.
    ///
    /// - Returns: An effect that adjusts the saturation of the view.
    public func saturation(_ amount: Double) -> some VisualEffect

}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension VisualEffect {

    /// Sets the transparency of the view.
    ///
    /// When applying the `opacity(_:)` effect to a view that has already had
    /// its opacity transformed, the effect of the underlying opacity
    /// transformation is multiplied.
    ///
    /// - Parameter opacity: A value between 0 (fully transparent) and 1 (fully
    ///   opaque).
    ///
    /// - Returns: An effect that sets the transparency of the view.
    public func opacity(_ opacity: Double) -> some VisualEffect

}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension ShapeStyle {

    /// Returns a new style based on `self` that multiplies by the
    /// specified opacity when drawing.
    @inlinable public func opacity(_ opacity: Double) -> some ShapeStyle

}

extension View {

    /// Specifies the preferred shape style of the background of a bar managed
    /// by SwiftUI.
    ///
    /// The preferred style flows up to the nearest container that
    /// renders a bar. This could be a ``NavigationView`` or ``TabView``
    /// in iOS, or the root view of a ``WindowGroup`` in macOS. This example
    /// shows a view that renders the navigation bar with a blue background
    /// and dark color scheme.
    ///
    ///     NavigationView {
    ///         ContentView()
    ///             .toolbarBackground(.white)
    ///             .toolbarColorScheme(.dark)
    ///     }
    ///
    /// You can provide multiple ``ToolbarPlacement`` instances to customize
    /// multiple bars at once.
    ///
    ///     TabView {
    ///         NavigationView {
    ///             ContentView()
    ///                 .toolbarBackground(
    ///                     .blue, for: .navigationBar, .tabBar)
    ///                 .toolbarColorScheme(
    ///                     .dark, for: .navigationBar, .tabBar)
    ///         }
    ///     }
    ///
    /// When used within a ``TabView``, the specified style will be
    /// preferred while the tab is currently active. You can use a ``Group``
    /// to specify the same preferred background for every tab.
    ///
    ///     TabView {
    ///         Group {
    ///             MainView()
    ///             SettingsView()
    ///         }
    ///         .toolbarBackground(.blue, for: .tabBar)
    ///     }
    ///
    /// Depending on the specified bars, the requested style may not be able to
    /// be fullfilled.
    ///
    /// - Parameters:
    ///   - style: The style to display as the background of the bar.
    ///   - bars: The bars to use the style for or
    ///     ``ToolbarPlacement/automatic`` if empty.
    @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
    nonisolated public func toolbarBackground<S>(_ style: S, for bars: ToolbarPlacement...) -> some View where S : ShapeStyle


    /// Specifies the preferred visibility of backgrounds on a bar managed by
    /// SwiftUI.
    ///
    /// The preferred visibility flows up to the nearest container that
    /// renders a bar. This could be a ``NavigationView`` or ``TabView``
    /// in iOS, or the root view of a ``WindowGroup`` in macOS.
    ///
    /// In iOS, a value of ``ToolbarPlacement/automatic`` makes the visibility
    /// of a tab bar or navigation bar background depend on where a ``List`` or
    /// ``ScrollView`` settles. For example, when aligned to the bottom edge of
    /// of a scroll view's content, the background of a tab bar becomes
    /// transparent.
    ///
    /// Specify a value of ``Visibility/visible`` to ensure that the
    /// background of a bar remains visible regardless of where any scroll
    /// view or list stops scrolling.
    ///
    /// This example shows a view that prefers to always have the tab bar
    /// visible when the middle tab is selected:
    ///
    ///     TabView {
    ///         FirstTab()
    ///         MiddleTab()
    ///             .toolbarBackground(.visible, for: .tabBar)
    ///         LastTab()
    ///     }
    ///
    /// You can provide multiple placements to customize multiple bars
    /// at once, as in the following example:
    ///
    ///     TabView {
    ///         NavigationView {
    ///             ContentView()
    ///                 .toolbarBackground(
    ///                     .visible, for: .navigationBar, .tabBar)
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - visibility: The preferred visibility of the background of the bar.
    ///   - bars: The bars to update the color scheme of or
    ///     ``ToolbarPlacement/automatic`` if empty.
    @available(iOS, introduced: 16.0, deprecated: 100000.0, renamed: "toolbarBackgroundVisibility(_:for:)")
    @available(macOS, introduced: 13.0, deprecated: 100000.0, renamed: "toolbarBackgroundVisibility(_:for:)")
    @available(tvOS, introduced: 16.0, deprecated: 100000.0, renamed: "toolbarBackgroundVisibility(_:for:)")
    @available(watchOS, introduced: 9.0, deprecated: 100000.0, renamed: "toolbarBackgroundVisibility(_:for:)")
    nonisolated public func toolbarBackground(_ visibility: Visibility, for bars: ToolbarPlacement...) -> some View


    /// Specifies the preferred visibility of backgrounds on a bar managed by
    /// SwiftUI.
    ///
    /// The preferred visibility flows up to the nearest container that
    /// renders a bar. This could be a ``NavigationView`` or ``TabView``
    /// in iOS, or the root view of a ``WindowGroup`` in macOS.
    ///
    /// In iOS, a value of ``ToolbarPlacement/automatic`` makes the visibility
    /// of a tab bar or navigation bar background depend on where a ``List`` or
    /// ``ScrollView`` settles. For example, when aligned to the bottom edge of
    /// of a scroll view's content, the background of a tab bar becomes
    /// transparent.
    ///
    /// Specify a value of ``Visibility/visible`` to ensure that the
    /// background of a bar remains visible regardless of where any scroll
    /// view or list stops scrolling.
    ///
    /// This example shows a view that prefers to always have the tab bar
    /// visible when the middle tab is selected:
    ///
    ///     TabView {
    ///         FirstTab()
    ///         MiddleTab()
    ///             .toolbarBackgroundVisibility(.visible, for: .tabBar)
    ///         LastTab()
    ///     }
    ///
    /// You can provide multiple placements to customize multiple bars
    /// at once, as in the following example:
    ///
    ///     TabView {
    ///         NavigationView {
    ///             ContentView()
    ///                 .toolbarBackgroundVisibility(
    ///                     .visible, for: .navigationBar, .tabBar)
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - visibility: The preferred visibility of the background of the bar.
    ///   - bars: The bars to update the color scheme of or
    ///     ``ToolbarPlacement/automatic`` if empty.
    @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
    nonisolated public func toolbarBackgroundVisibility(_ visibility: Visibility, for bars: ToolbarPlacement...) -> some View


    /// Specifies the preferred color scheme of a bar managed by SwiftUI.
    ///
    /// The preferred color scheme flows up to the nearest container
    /// that renders a bar. This could be a ``NavigationView`` or ``TabView``
    /// in iOS, or the root view of a ``WindowGroup`` in macOS. Pass in a value
    /// of nil to match the current system's color scheme.
    ///
    /// This examples shows a view that renders the navigation bar with a blue
    /// background and dark color scheme:
    ///
    ///     TabView {
    ///         NavigationView {
    ///             ContentView()
    ///                 .toolbarBackground(.blue)
    ///                 .toolbarColorScheme(.dark)
    ///         }
    ///         // other tabs...
    ///     }
    ///
    /// You can provide multiple ``ToolbarPlacement`` instances to customize
    /// multiple bars at once.
    ///
    ///     TabView {
    ///         NavigationView {
    ///             ContentView()
    ///                 .toolbarBackground(
    ///                     .blue, for: .navigationBar, .tabBar)
    ///                 .toolbarColorScheme(
    ///                     .dark, for: .navigationBar, .tabBar)
    ///         }
    ///     }
    ///
    /// Note that the provided color scheme is only respected while a
    /// background is visible in the requested bar. As the background becomes
    /// visible, the bar transitions from the color scheme of the app to the
    /// requested color scheme. You can ensure that the color scheme is always
    /// respected by specifying that the background of the bar always be
    /// visible.
    ///
    ///     NavigationView {
    ///         ContentView()
    ///             .toolbarBackground(.visible)
    ///             .toolbarColorScheme(.dark)
    ///     }
    ///
    /// Depending on the specified bars, the requested color scheme may not be
    /// able to be fullfilled.
    ///
    /// - Parameters:
    ///   - colorScheme: The preferred color scheme of the background
    ///     of the bar.
    ///   - bars: The bars to update the color scheme of or
    ///     ``ToolbarPlacement/automatic`` if empty.
    @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
    nonisolated public func toolbarColorScheme(_ colorScheme: ColorScheme?, for bars: ToolbarPlacement...) -> some View


    /// Specifies the visibility of a bar managed by SwiftUI.
    ///
    /// The preferred visibility flows up to the nearest container
    /// that renders a bar. This could be a ``NavigationView`` or ``TabView``
    /// in iOS, or the root view of a ``WindowGroup`` in macOS.
    ///
    /// This examples shows a view that hides the navigation bar on iOS, or the
    /// window toolbar items on macOS.
    ///
    ///     NavigationView {
    ///         ContentView()
    ///             .toolbar(.hidden)
    ///     }
    ///
    /// To hide the entire titlebar on macOS, use this modifier with
    /// ``ToolbarPlacement/windowToolbar`` placement.
    ///
    ///     NavigationView {
    ///         ContentView()
    ///             .toolbar(.hidden, for: .windowToolbar)
    ///     }
    ///
    /// You can provide multiple ``ToolbarPlacement`` instances to hide
    /// multiple bars at once.
    ///
    ///     TabView {
    ///         NavigationView {
    ///             ContentView()
    ///                 .toolbar(
    ///                     .hidden, for: .navigationBar, .tabBar)
    ///         }
    ///     }
    ///
    /// > Note: In macOS, if you provide ``ToolbarCommands`` to the scene
    ///   of your app, this modifier disables the toolbar visibility command
    ///   while the value of the modifier is not ``ToolbarPlacement/automatic``.
    ///
    /// Depending on the specified bars, the requested visibility may not be
    /// able to be fulfilled.
    ///
    /// - Parameters:
    ///   - visibility: The preferred visibility of the bar.
    ///   - bars: The bars to update the visibility of or
    ///     ``ToolbarPlacement/automatic`` if empty.
    @available(iOS, introduced: 16.0, deprecated: 100000.0, renamed: "toolbarVisibility(_:for:)")
    @available(macOS, introduced: 13.0, deprecated: 100000.0, renamed: "toolbarVisibility(_:for:)")
    @available(tvOS, introduced: 16.0, deprecated: 100000.0, renamed: "toolbarVisibility(_:for:)")
    @available(watchOS, introduced: 9.0, deprecated: 100000.0, renamed: "toolbarVisibility(_:for:)")
    nonisolated public func toolbar(_ visibility: Visibility, for bars: ToolbarPlacement...) -> some View


    /// Specifies the visibility of a bar managed by SwiftUI.
    ///
    /// The preferred visibility flows up to the nearest container
    /// that renders a bar. This could be a ``NavigationView`` or ``TabView``
    /// in iOS, or the root view of a ``WindowGroup`` in macOS.
    ///
    /// This examples shows a view that hides the navigation bar on iOS, or the
    /// window toolbar items on macOS.
    ///
    ///     NavigationView {
    ///         ContentView()
    ///             .toolbarVisibility(.hidden)
    ///     }
    ///
    /// To hide the entire titlebar on macOS, use this modifier with
    /// ``ToolbarPlacement/windowToolbar`` placement.
    ///
    ///     NavigationView {
    ///         ContentView()
    ///             .toolbarVisibility(.hidden, for: .windowToolbar)
    ///     }
    ///
    /// You can provide multiple ``ToolbarPlacement`` instances to hide
    /// multiple bars at once.
    ///
    ///     TabView {
    ///         NavigationView {
    ///             ContentView()
    ///                 .toolbarVisibility(
    ///                     .hidden, for: .navigationBar, .tabBar)
    ///         }
    ///     }
    ///
    /// > Note: In macOS, if you provide ``ToolbarCommands`` to the scene
    ///   of your app, this modifier disables the toolbar visibility command
    ///   while the value of the modifier is not ``ToolbarPlacement/automatic``.
    ///
    /// Depending on the specified bars, the requested visibility may not be
    /// able to be fulfilled.
    ///
    /// - Parameters:
    ///   - visibility: The preferred visibility of the bar.
    ///   - bars: The bars to update the visibility of or
    ///     ``ToolbarPlacement/automatic`` if empty.
    @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
    nonisolated public func toolbarVisibility(_ visibility: Visibility, for bars: ToolbarPlacement...) -> some View

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// Provides a closure that vends the drag representation to be used for a
    /// particular data element.
    @inlinable nonisolated public func itemProvider(_ action: (() -> NSItemProvider?)?) -> some View

}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Optional : TabContent where Wrapped : TabContent {

    /// The type used to drive selection for the containing tab view.
    public typealias TabValue = Wrapped.TabValue

    /// The type of content representing the body of this content type.
    public typealias Body = Wrapped?

    /// The value of this type's nested content.
    @MainActor @preconcurrency public var body: Wrapped? { get }
}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension ForEach : TabContent where Content : TabContent {

    /// The type used to drive selection for the containing tab view.
    public typealias TabValue = Content.TabValue

    /// Creates an instance that uniquely identifies and creates tabs across
    /// updates based on the provided key path to the underlying data's
    /// identifier.
    ///
    /// It's important that the `id` of a data element doesn't change, unless
    /// SwiftUI considers the data element to have been replaced with a new data
    /// element that has a new identity. If the `id` of a data element changes,
    /// then the tabs generated from that data element will lose any
    /// current state and animations.
    ///
    /// - Parameters:
    ///   - data: The data that the ``ForEach`` instance uses to create views
    ///     dynamically.
    ///   - id: The key path to the provided data's identifier.
    ///   - content: The builder that creates tabs dynamically.
    nonisolated public init<V>(_ data: Data, id: KeyPath<Data.Element, ID>, @TabContentBuilder<V> content: @escaping (Data.Element) -> Content) where V == Content.TabValue

    /// Creates an instance that uniquely identifies and creates tabs across
    /// updates based on the provided key path to the underlying data's
    /// identifier.
    ///
    /// It's important that the `id` of a data element doesn't change, unless
    /// SwiftUI considers the data element to have been replaced with a new data
    /// element that has a new identity. If the `id` of a data element changes,
    /// then the tabs generated from that data element will lose any
    /// current state and animations.
    ///
    /// This initializer overload allows for non optional tab content to be
    /// passed into `content`, even if the selection value of the tab
    /// view is optional.
    ///
    /// - Parameters:
    ///   - data: The data that the ``ForEach`` instance uses to create views
    ///     dynamically.
    ///   - id: The key path to the provided data's identifier.
    ///   - content: The builder that creates tabs dynamically.
    nonisolated public init<V>(_ data: Data, id: KeyPath<Data.Element, ID>, @TabContentBuilder<V?> content: @escaping (Data.Element) -> Content) where V : Hashable, Content.TabValue == V?

    /// The type of content representing the body of this content type.
    public typealias Body = ForEach<Data, ID, Content>

    /// The value of this type's nested content.
    @MainActor @preconcurrency public var body: ForEach<Data, ID, Content> { get }
}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension ForEach where ID == Data.Element.ID, Content : TabContent, Data.Element : Identifiable {

    /// Creates an instance that uniquely identifies and creates tabs across
    /// updates based on the identity of the underlying data.
    ///
    /// It's important that the `id` of a data element doesn't change unless you
    /// replace the data element with a new data element that has a new
    /// identity. If the `id` of a data element changes, the tabs
    /// generated from that data element lose any current state and animations.
    ///
    /// - Parameters:
    ///   - data: The identified data that the ``ForEach`` instance uses to
    ///     create views dynamically.
    ///   - content: The builder that creates tabs dynamically.
    public init<V>(_ data: Data, @TabContentBuilder<V> content: @escaping (Data.Element) -> Content) where V == Content.TabValue

    /// Creates an instance that uniquely identifies and creates tabs across
    /// updates based on the identity of the underlying data.
    ///
    /// It's important that the `id` of a data element doesn't change unless you
    /// replace the data element with a new data element that has a new
    /// identity. If the `id` of a data element changes, the tabs
    /// generated from that data element lose any current state and animations.
    ///
    /// This initializer overload allows for non optional tab content to be
    /// passed into `content`, even if the selection value of the tab
    /// view is optional.
    ///
    /// - Parameters:
    ///   - data: The identified data that the ``ForEach`` instance uses to
    ///     create views dynamically.
    ///   - content: The builder that creates tabs dynamically.
    public init<V>(_ data: Data, @TabContentBuilder<V?> content: @escaping (Data.Element) -> Content) where V : Hashable, Content.TabValue == V?
}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension ForEach where Data == Range<Int>, ID == Int, Content : TabContent {

    /// Creates an instance that computes tabs on demand over a given constant
    /// range.
    ///
    /// The instance only reads the initial value of the provided `data` and
    /// doesn't need to identify tabs across updates. To compute tabs on
    /// demand over a dynamic range, use ``ForEach/init(_:id:content:)``.
    ///
    /// - Parameters:
    ///   - data: A constant range.
    ///   - content: The builder that creates tabs dynamically.
    public init<V>(_ data: Range<Int>, @TabContentBuilder<V> content: @escaping (Int) -> Content) where V == Content.TabValue

    /// Creates an instance that computes tabs on demand over a given constant
    /// range.
    ///
    /// The instance only reads the initial value of the provided `data` and
    /// doesn't need to identify tabs across updates. To compute tabs on
    /// demand over a dynamic range, use ``ForEach/init(_:id:content:)``.
    ///
    /// This initializer overload allows for non optional tab content to be
    /// passed into `content`, even if the selection value of the tab
    /// view is optional.
    ///
    /// - Parameters:
    ///   - data: A constant range.
    ///   - content: The builder that creates tabs dynamically.
    public init<V>(_ data: Range<Int>, @TabContentBuilder<V?> content: @escaping (Int) -> Content) where V : Hashable, Content.TabValue == V?
}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Group : TabContent where Content : TabContent {

    /// The type used to drive selection for the containing tab view.
    public typealias TabValue = Content.TabValue

    /// Creates a group of tab content.
    /// - Parameter content: A ``TabContentBuilder`` that produces the content
    ///   to group.
    public init<V>(@TabContentBuilder<V> content: () -> Content) where V == Content.TabValue

    /// Creates a group of tab content.
    /// - Parameter content: A ``TabContentBuilder`` that produces the content
    ///   to group.
    public init<V>(@TabContentBuilder<V?> content: () -> Content) where V : Hashable, Content.TabValue == V?

    /// The type of content representing the body of this content type.
    public typealias Body = Group<Content>

    /// The value of this type's nested content.
    @MainActor @preconcurrency public var body: Group<Content> { get }
}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Transaction {

    /// The behavior a scroll view will have regarding content offset
    /// adjustments for the current transaction.
    ///
    /// A scroll view may automatically adjust its content offset
    /// based on the current context. The absolute offset may be adjusted
    /// to keep content in relatively the same place. For example,
    /// when scrolled to the bottom, a scroll view may keep the bottom
    /// edge scrolled to the bottom when the overall size of its content
    /// changes.
    ///
    /// Use this property to disable these kinds of adjustments when needed.
    @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
    public var scrollContentOffsetAdjustmentBehavior: ScrollContentOffsetAdjustmentBehavior
}

@available(iOS 17.0, macOS 14.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension View {

    /// Specifies the selection effect to apply to a palette item.
    ///
    /// ``PaletteSelectionEffect/automatic`` applies the system's default
    /// appearance when selected. When using un-tinted SF Symbols or template
    /// images, the current tint color is applied to the selected items' image.
    /// If the provided SF Symbols have custom tints, a stroke is drawn around selected items.
    ///
    /// If you wish to provide a specific image (or SF Symbol) to indicate
    /// selection, use ``PaletteSelectionEffect/custom`` to forgo the system's
    /// default selection appearance allowing the provided image to solely
    /// indicate selection instead.
    ///
    /// The following example creates a palette picker that disables the
    /// system selection behavior:
    ///
    ///     Menu {
    ///         Picker("Palettes", selection: $selection) {
    ///             ForEach(palettes) { palette in
    ///                 Label(palette.title, image: selection == palette ?
    ///                       "selected-palette" : "palette")
    ///                 .tint(palette.tint)
    ///                 .tag(palette)
    ///             }
    ///         }
    ///         .pickerStyle(.palette)
    ///         .paletteSelectionEffect(.custom)
    ///     } label: {
    ///         ...
    ///     }
    ///
    /// If a specific SF Symbol variant is preferable instead, use
    /// ``PaletteSelectionEffect/symbolVariant(_:)``.
    ///
    ///     Menu {
    ///         ControlGroup {
    ///             ForEach(ColorTags.allCases) { colorTag in
    ///                 Toggle(isOn: $selectedColorTags[colorTag]) {
    ///                     Label(colorTag.name, systemImage: "circle")
    ///                 }
    ///                 .tint(colorTag.color)
    ///             }
    ///         }
    ///         .controlGroupStyle(.palette)
    ///         .paletteSelectionEffect(.symbolVariant(.fill))
    ///     }
    ///
    /// - Parameter effect: The type of effect to apply when a palette item is selected.
    nonisolated public func paletteSelectionEffect(_ effect: PaletteSelectionEffect) -> some View

}

@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension EnvironmentValues {

    /// The current size of sidebar rows.
    ///
    /// On macOS, reflects the value of the "Sidebar icon size" in
    /// System Settings' Appearance settings.
    ///
    /// This can be used to update the content shown in the sidebar in
    /// response to this size. And it can be overridden to force a sidebar to a
    /// particularly size, regardless of the user preference.
    ///
    /// On other platforms, the value is always `.medium` and setting a
    /// different value has no effect.
    ///
    /// SwiftUI views like `Label` automatically adapt to the sidebar row size.
    public var sidebarRowSize: SidebarRowSize
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// Sets the style for buttons within this view to a button style with a
    /// custom appearance and standard interaction behavior.
    ///
    /// Use this modifier to set a specific style for all button instances
    /// within a view:
    ///
    ///     HStack {
    ///         Button("Sign In", action: signIn)
    ///         Button("Register", action: register)
    ///     }
    ///     .buttonStyle(.bordered)
    ///
    /// You can also use this modifier to set the style for controls that
    /// acquire a button style through composition, like the ``Menu`` and
    /// ``Toggle`` views in the following example:
    ///
    ///     VStack {
    ///         Menu("Terms and Conditions") {
    ///             Button("Open in Preview", action: openInPreview)
    ///             Button("Save as PDF", action: saveAsPDF)
    ///         }
    ///         Toggle("Remember Password", isOn: $isToggleOn)
    ///         Toggle("Flag", isOn: $flagged)
    ///         Button("Sign In", action: signIn)
    ///     }
    ///     .menuStyle(.button)
    ///     .toggleStyle(.button)
    ///     .buttonStyle(.bordered)
    ///
    /// The ``View/menuStyle(_:)`` modifier causes the Terms
    /// and Conditions menu to render as a button. Similarly, the
    /// ``View/toggleStyle(_:)`` modifier causes the two toggles to
    /// render as buttons. The button style modifier then causes not only
    /// the explicit Sign In ``Button``, but also the menu and toggles with
    /// button styling, to render with the bordered button style.
    nonisolated public func buttonStyle<S>(_ style: S) -> some View where S : ButtonStyle

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// Sets the style for text fields within this view.
    nonisolated public func textFieldStyle<S>(_ style: S) -> some View where S : TextFieldStyle

}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension View {

    /// Presents an alert when a given condition is true, using a localized
    /// string key for the title.
    ///
    /// In the example below, a login form conditionally presents an alert by
    /// setting the `didFail` state variable. When the form sets the value to
    /// to `true`, the system displays an alert with an "OK" action.
    ///
    ///     struct Login: View {
    ///         @State private var didFail = false
    ///
    ///         var body: some View {
    ///             LoginForm(didFail: $didFail)
    ///                 .alert(
    ///                     "Login failed.",
    ///                     isPresented: $didFail
    ///                 ) {
    ///                     Button("OK") {
    ///                         // Handle the acknowledgement.
    ///                     }
    ///                 }
    ///         }
    ///     }
    ///
    /// All actions in an alert dismiss the alert after the action runs.
    /// The default button is shown with greater prominence.  You can
    /// influence the default button by assigning it the
    /// ``KeyboardShortcut/defaultAction`` keyboard shortcut.
    ///
    /// The system may reorder the buttons based on their role and prominence.
    ///
    /// If no actions are present, the system includes a standard "OK"
    /// action. No default cancel action is provided. If you want to show a
    /// cancel action, use a button with a role of ``ButtonRole/cancel``.
    ///
    /// On iOS, tvOS, and watchOS, alerts only support controls with labels that
    /// are ``Text``. Passing any other type of view results in the content
    /// being omitted.
    ///
    /// This modifier creates a ``Text`` view for the title on your behalf, and
    /// treats the localized key similar to
    /// ``Text/init(_:tableName:bundle:comment:)``. See ``Text`` for more
    /// information about localizing strings.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the localized string that describes the title
    ///     of the alert.
    ///   - isPresented: A binding to a Boolean value that determines whether to
    ///     present the alert. When the user presses or taps one of the alert's
    ///     actions, the system sets this value to `false` and dismisses.
    ///   - actions: A ``ViewBuilder`` returning the alert's actions.
    nonisolated public func alert<A>(_ titleKey: LocalizedStringKey, isPresented: Binding<Bool>, @ViewBuilder actions: () -> A) -> some View where A : View


    /// Presents an alert when a given condition is true, using a string
    /// variable as a title.
    ///
    /// In the example below, a login form conditionally presents an alert by
    /// setting the `didFail` state variable. When the form sets the value to
    /// to `true`, the system displays an alert with an "OK" action.
    ///
    ///     struct Login: View {
    ///         @State private var didFail = false
    ///         let alertTitle: String = "Login failed."
    ///
    ///         var body: some View {
    ///             LoginForm(didFail: $didFail)
    ///                 .alert(
    ///                     alertTitle,
    ///                     isPresented: $didFail
    ///                 ) {
    ///                     Button("OK") {
    ///                         // Handle the acknowledgement.
    ///                     }
    ///                 }
    ///         }
    ///     }
    ///
    /// All actions in an alert dismiss the alert after the action runs.
    /// The default button is shown with greater prominence.  You can
    /// influence the default button by assigning it the
    /// ``KeyboardShortcut/defaultAction`` keyboard shortcut.
    ///
    /// The system may reorder the buttons based on their role and prominence.
    ///
    /// If no actions are present, the system includes a standard "OK"
    /// action. No default cancel action is provided. If you want to show a
    /// cancel action, use a button with a role of ``ButtonRole/cancel``.
    ///
    /// On iOS, tvOS, and watchOS, alerts only support controls with labels that
    /// are ``Text``. Passing any other type of view results in the content
    /// being omitted.
    ///
    /// - Parameters:
    ///   - title: A text string used as the title of the alert.
    ///   - isPresented: A binding to a Boolean value that determines whether to
    ///     present the alert. When the user presses or taps one of the alert's
    ///     actions, the system sets this value to `false` and dismisses.
    ///   - actions: A ``ViewBuilder`` returning the alert's actions.
    nonisolated public func alert<S, A>(_ title: S, isPresented: Binding<Bool>, @ViewBuilder actions: () -> A) -> some View where S : StringProtocol, A : View


    /// Presents an alert when a given condition is true, using a text view for
    /// the title.
    ///
    /// In the example below, a login form conditionally presents an alert by
    /// setting the `didFail` state variable. When the form sets the value to
    /// to `true`, the system displays an alert with an "OK" action.
    ///
    ///     struct Login: View {
    ///         @State private var didFail = false
    ///         let alertTitle: String = "Login failed."
    ///
    ///         var body: some View {
    ///             LoginForm(didFail: $didFail)
    ///                 .alert(
    ///                     Text(alertTitle),
    ///                     isPresented: $didFail
    ///                 ) {
    ///                     Button("OK") {
    ///                         // Handle the acknowledgement.
    ///                     }
    ///                 }
    ///         }
    ///     }
    ///
    /// All actions in an alert dismiss the alert after the action runs.
    /// The default button is shown with greater prominence.  You can
    /// influence the default button by assigning it the
    /// ``KeyboardShortcut/defaultAction`` keyboard shortcut.
    ///
    /// The system may reorder the buttons based on their role and prominence.
    ///
    /// If no actions are present, the system includes a standard "OK"
    /// action. No default cancel action is provided. If you want to show a
    /// cancel action, use a button with a role of ``ButtonRole/cancel``.
    ///
    /// On iOS, tvOS, and watchOS, alerts only support controls with labels that
    /// are ``Text``. Passing any other type of view results in the content
    /// being omitted.
    ///
    /// - Parameters:
    ///   - title: The title of the alert.
    ///   - isPresented: A binding to a Boolean value that determines whether to
    ///     present the alert. When the user presses or taps one of the alert's
    ///     actions, the system sets this value to `false` and dismisses.
    ///   - actions: A ``ViewBuilder`` returning the alert's actions.
    nonisolated public func alert<A>(_ title: Text, isPresented: Binding<Bool>, @ViewBuilder actions: () -> A) -> some View where A : View

}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension View {

    /// Presents an alert with a message when a given condition is true, using
    /// a localized string key for a title.
    ///
    /// In the example below, a login form conditionally presents an alert by
    /// setting the `didFail` state variable. When the form sets the value to
    /// to `true`, the system displays an alert with an "OK" action.
    ///
    ///     struct Login: View {
    ///         @State private var didFail = false
    ///
    ///         var body: some View {
    ///             LoginForm(didFail: $didFail)
    ///                 .alert(
    ///                     "Login failed.",
    ///                     isPresented: $didFail
    ///                 ) {
    ///                     Button("OK") {
    ///                         // Handle the acknowledgement.
    ///                     }
    ///                 } message: {
    ///                     Text("Please check your credentials and try again.")
    ///                 }
    ///         }
    ///     }
    ///
    /// All actions in an alert dismiss the alert after the action runs.
    /// The default button is shown with greater prominence.  You can
    /// influence the default button by assigning it the
    /// ``KeyboardShortcut/defaultAction`` keyboard shortcut.
    ///
    /// The system may reorder the buttons based on their role and prominence.
    ///
    /// If no actions are present, the system includes a standard "OK"
    /// action. No default cancel action is provided. If you want to show a
    /// cancel action, use a button with a role of ``ButtonRole/cancel``.
    ///
    /// On iOS, tvOS, and watchOS, alerts only support controls with labels that
    /// are ``Text``. Passing any other type of view results in the content
    /// being omitted.
    ///
    /// Only unstyled text is supported for the message.
    ///
    /// This modifier creates a ``Text`` view for the title on your behalf, and
    /// treats the localized key similar to
    /// ``Text/init(_:tableName:bundle:comment:)``. See ``Text`` for more
    /// information about localizing strings.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the localized string that describes the title
    ///     of the alert.
    ///   - isPresented: A binding to a Boolean value that determines whether to
    ///     present the alert. When the user presses or taps one of the alert's
    ///     actions, the system sets this value to `false` and dismisses.
    ///   - actions: A ``ViewBuilder`` returning the alert's actions.
    ///   - message: A ``ViewBuilder`` returning the message for the alert.
    nonisolated public func alert<A, M>(_ titleKey: LocalizedStringKey, isPresented: Binding<Bool>, @ViewBuilder actions: () -> A, @ViewBuilder message: () -> M) -> some View where A : View, M : View


    /// Presents an alert with a message when a given condition is true using
    /// a string variable as a title.
    ///
    /// In the example below, a login form conditionally presents an alert by
    /// setting the `didFail` state variable. When the form sets the value to
    /// to `true`, the system displays an alert with an "OK" action.
    ///
    ///     struct Login: View {
    ///         @State private var didFail = false
    ///         let alertTitle: String = "Login failed."
    ///
    ///         var body: some View {
    ///             LoginForm(didFail: $didFail)
    ///                 .alert(
    ///                     alertTitle,
    ///                     isPresented: $didFail
    ///                 ) {
    ///                     Button("OK") {
    ///                         // Handle the acknowledgement.
    ///                     }
    ///                 } message: {
    ///                     Text("Please check your credentials and try again.")
    ///                 }
    ///         }
    ///     }
    ///
    /// All actions in an alert dismiss the alert after the action runs.
    /// The default button is shown with greater prominence.  You can
    /// influence the default button by assigning it the
    /// ``KeyboardShortcut/defaultAction`` keyboard shortcut.
    ///
    /// The system may reorder the buttons based on their role and prominence.
    ///
    /// If no actions are present, the system includes a standard "OK"
    /// action. No default cancel action is provided. If you want to show a
    /// cancel action, use a button with a role of ``ButtonRole/cancel``.
    ///
    /// On iOS, tvOS, and watchOS, alerts only support controls with labels that
    /// are ``Text``. Passing any other type of view results in the content
    /// being omitted.
    ///
    /// Only unstyled text is supported for the message.
    ///
    /// - Parameters:
    ///   - title: A text string used as the title of the alert.
    ///   - isPresented: A binding to a Boolean value that determines whether to
    ///     present the alert. When the user presses or taps one of the alert's
    ///     actions, the system sets this value to `false` and dismisses.
    ///   - actions: A ``ViewBuilder`` returning the alert's actions.
    ///   - message: A ``ViewBuilder`` returning the message for the alert.
    nonisolated public func alert<S, A, M>(_ title: S, isPresented: Binding<Bool>, @ViewBuilder actions: () -> A, @ViewBuilder message: () -> M) -> some View where S : StringProtocol, A : View, M : View


    /// Presents an alert with a message when a given condition is true using
    /// a text view as a title.
    ///
    /// In the example below, a login form conditionally presents an alert by
    /// setting the `didFail` state variable. When the form sets the value to
    /// to `true`, the system displays an alert with an "OK" action.
    ///
    ///     struct Login: View {
    ///         @State private var didFail = false
    ///         let alertTitle: String = "Login failed."
    ///
    ///         var body: some View {
    ///             LoginForm(didFail: $didFail)
    ///                 .alert(
    ///                     Text(alertTitle),
    ///                     isPresented: $didFail
    ///                 ) {
    ///                     Button("OK") {
    ///                         // Handle the acknowledgement.
    ///                     }
    ///                 } message: {
    ///                    Text("Please check your credentials and try again.")
    ///                 }
    ///         }
    ///     }
    ///
    /// All actions in an alert dismiss the alert after the action runs.
    /// The default button is shown with greater prominence.  You can
    /// influence the default button by assigning it the
    /// ``KeyboardShortcut/defaultAction`` keyboard shortcut.
    ///
    /// The system may reorder the buttons based on their role and prominence.
    ///
    /// If no actions are present, the system includes a standard "OK"
    /// action. No default cancel action is provided. If you want to show a
    /// cancel action, use a button with a role of ``ButtonRole/cancel``.
    ///
    /// On iOS, tvOS, and watchOS, alerts only support controls with labels that
    /// are ``Text``. Passing any other type of view results in the content
    /// being omitted.
    ///
    /// Only unstyled text is supported for the message.
    ///
    /// - Parameters:
    ///   - title: The title of the alert.
    ///   - isPresented: A binding to a Boolean value that determines whether to
    ///     present the alert. When the user presses or taps one of the alert's
    ///     actions, the system sets this value to `false` and dismisses.
    ///   - actions: A ``ViewBuilder`` returning the alert's actions.
    ///   - message: A ``ViewBuilder`` returning the message for the alert.
    nonisolated public func alert<A, M>(_ title: Text, isPresented: Binding<Bool>, @ViewBuilder actions: () -> A, @ViewBuilder message: () -> M) -> some View where A : View, M : View

}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension View {

    /// Presents an alert using the given data to produce the alert's content
    /// and a localized string key for a title.
    ///
    /// For the alert to appear, both `isPresented` must be `true` and
    /// `data` must not be `nil`. The data should not change after the
    /// presentation occurs. Any changes that you make after the presentation
    /// occurs are ignored.
    ///
    /// Use this method when you need to populate the fields of an alert with
    /// content from a data source. The example below shows a custom data
    /// source, `SaveDetails`, that provides data to populate the alert:
    ///
    ///     struct SaveDetails: Identifiable {
    ///         let name: String
    ///         let error: String
    ///         let id = UUID()
    ///     }
    ///
    ///     struct SaveButton: View {
    ///         @State private var didError = false
    ///         @State private var details: SaveDetails?
    ///
    ///         var body: some View {
    ///             Button("Save") {
    ///                 details = model.save(didError: $didError)
    ///             }
    ///             .alert(
    ///                 "Save failed.",
    ///                 isPresented: $didError,
    ///                 presenting: details
    ///             ) { details in
    ///                 Button(role: .destructive) {
    ///                     // Handle the deletion.
    ///                 } label: {
    ///                     Text("Delete \(details.name)")
    ///                 }
    ///                 Button("Retry") {
    ///                     // Handle the retry action.
    ///                 }
    ///             }
    ///         }
    ///     }
    ///
    /// This modifier creates a ``Text`` view for the title on your behalf, and
    /// treats the localized key similar to
    /// ``Text/init(_:tableName:bundle:comment:)``. See ``Text`` for more
    /// information about localizing strings.
    ///
    /// All actions in an alert dismiss the alert after the action runs.
    /// The default button is shown with greater prominence.  You can
    /// influence the default button by assigning it the
    /// ``KeyboardShortcut/defaultAction`` keyboard shortcut.
    ///
    /// The system may reorder the buttons based on their role and prominence.
    ///
    /// If no actions are present, the system includes a standard "OK"
    /// action. No default cancel action is provided. If you want to show a
    /// cancel action, use a button with a role of ``ButtonRole/cancel``.
    ///
    /// On iOS, tvOS, and watchOS, alerts only support controls with labels that
    /// are ``Text``. Passing any other type of view results in the content
    /// being omitted.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the localized string that describes the title
    ///     of the alert.
    ///   - isPresented: A binding to a Boolean value that determines whether to
    ///     present the alert. When the user presses or taps one of the alert's
    ///     actions, the system sets this value to `false` and dismisses.
    ///   - data: An optional source of truth for the alert. The system passes
    ///     the contents to the modifier's closures. You use this data to
    ///     populate the fields of an alert that you create that the system
    ///     displays to the user.
    ///   - actions: A ``ViewBuilder`` returning the alert's actions given the
    ///     currently available data.
    nonisolated public func alert<A, T>(_ titleKey: LocalizedStringKey, isPresented: Binding<Bool>, presenting data: T?, @ViewBuilder actions: (T) -> A) -> some View where A : View


    /// Presents an alert using the given data to produce the alert's content
    /// and a string variable as a title.
    ///
    /// For the alert to appear, both `isPresented` must be `true` and
    /// `data` must not be `nil`. The data should not change after the
    /// presentation occurs. Any changes that you make after the presentation
    /// occurs are ignored.
    ///
    /// Use this method when you need to populate the fields of an alert with
    /// content from a data source. The example below shows a custom data
    /// source, `SaveDetails`, that provides data to populate the alert:
    ///
    ///     struct SaveDetails: Identifiable {
    ///         let name: String
    ///         let error: String
    ///         let id = UUID()
    ///     }
    ///
    ///     struct SaveButton: View {
    ///         @State private var didError = false
    ///         @State private var details: SaveDetails?
    ///         let alertTitle: String = "Save failed."
    ///
    ///         var body: some View {
    ///             Button("Save") {
    ///                 details = model.save(didError: $didError)
    ///             }
    ///             .alert(
    ///                 alertTitle,
    ///                 isPresented: $didError,
    ///                 presenting: details
    ///             ) { details in
    ///                 Button(role: .destructive) {
    ///                     // Handle the deletion.
    ///                 } label: {
    ///                     Text("Delete \(details.name)")
    ///                 }
    ///                 Button("Retry") {
    ///                     // Handle the retry action.
    ///                 }
    ///             }
    ///         }
    ///     }
    ///
    /// All actions in an alert dismiss the alert after the action runs.
    /// The default button is shown with greater prominence.  You can
    /// influence the default button by assigning it the
    /// ``KeyboardShortcut/defaultAction`` keyboard shortcut.
    ///
    /// The system may reorder the buttons based on their role and prominence.
    ///
    /// If no actions are present, the system includes a standard "OK"
    /// action. No default cancel action is provided. If you want to show a
    /// cancel action, use a button with a role of ``ButtonRole/cancel``.
    ///
    /// On iOS, tvOS, and watchOS, alerts only support controls with labels that
    /// are ``Text``. Passing any other type of view results in the content
    /// being omitted.
    ///
    /// - Parameters:
    ///   - title: A text string used as the title of the alert.
    ///   - isPresented: A binding to a Boolean value that determines whether to
    ///     present the alert. When the user presses or taps one of the alert's
    ///     actions, the system sets this value to `false` and dismisses.
    ///   - data: An optional source of truth for the alert. The system passes
    ///     the contents to the modifier's closures. You use this data to
    ///     populate the fields of an alert that you create that the system
    ///     displays to the user.
    ///   - actions: A ``ViewBuilder`` returning the alert's actions given the
    ///     currently available data.
    nonisolated public func alert<S, A, T>(_ title: S, isPresented: Binding<Bool>, presenting data: T?, @ViewBuilder actions: (T) -> A) -> some View where S : StringProtocol, A : View


    /// Presents an alert using the given data to produce the alert's content
    /// and a text view as a title.
    ///
    /// For the alert to appear, both `isPresented` must be `true` and
    /// `data` must not be `nil`. The data should not change after the
    /// presentation occurs. Any changes that you make after the presentation
    /// occurs are ignored.
    ///
    /// Use this method when you need to populate the fields of an alert with
    /// content from a data source. The example below shows a custom data
    /// source, `SaveDetails`, that provides data to populate the alert:
    ///
    ///     struct SaveDetails: Identifiable {
    ///         let name: String
    ///         let error: String
    ///         let id = UUID()
    ///     }
    ///
    ///     struct SaveButton: View {
    ///         @State private var didError = false
    ///         @State private var details: SaveDetails?
    ///         let alertTitle: String = "Save failed."
    ///
    ///             var body: some View {
    ///             Button("Save") {
    ///                 details = model.save(didError: $didError)
    ///             }
    ///             .alert(
    ///                 Text(alertTitle),
    ///                 isPresented: $didError,
    ///                 presenting: details
    ///             ) { details in
    ///                 Button(role: .destructive) {
    ///                     // Handle the deletion.
    ///                 } label: {
    ///                     Text("Delete \(details.name)")
    ///                 }
    ///                 Button("Retry") {
    ///                     // Handle the retry action.
    ///                 }
    ///             }
    ///         }
    ///     }
    ///
    /// All actions in an alert dismiss the alert after the action runs.
    /// The default button is shown with greater prominence.  You can
    /// influence the default button by assigning it the
    /// ``KeyboardShortcut/defaultAction`` keyboard shortcut.
    ///
    /// The system may reorder the buttons based on their role and prominence.
    ///
    /// If no actions are present, the system includes a standard "OK"
    /// action. No default cancel action is provided. If you want to show a
    /// cancel action, use a button with a role of ``ButtonRole/cancel``.
    ///
    /// On iOS, tvOS, and watchOS, alerts only support controls with labels that
    /// are ``Text``. Passing any other type of view results in the content
    /// being omitted.
    ///
    /// - Parameters:
    ///   - title: the title of the alert.
    ///   - isPresented: A binding to a Boolean value that determines whether to
    ///     present the alert. When the user presses or taps one of the alert's
    ///     actions, the system sets this value to `false` and dismisses.
    ///   - data: An optional source of truth for the alert. The system passes
    ///     the contents to the modifier's closures. You use this data to
    ///     populate the fields of an alert that you create that the system
    ///     displays to the user.
    ///   - actions: A ``ViewBuilder`` returning the alert's actions given the
    ///     currently available data.
    nonisolated public func alert<A, T>(_ title: Text, isPresented: Binding<Bool>, presenting data: T?, @ViewBuilder actions: (T) -> A) -> some View where A : View

}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension View {

    /// Presents an alert with a message using the given data to produce the
    /// alert's content and a localized string key for a title.
    ///
    /// For the alert to appear, both `isPresented` must be `true` and
    /// `data` must not be `nil`. The data should not change after the
    /// presentation occurs. Any changes that you make after the presentation
    /// occurs are ignored.
    ///
    /// Use this method when you need to populate the fields of an alert with
    /// content from a data source. The example below shows a custom data
    /// source, `SaveDetails`, that provides data to populate the alert:
    ///
    ///     struct SaveDetails: Identifiable {
    ///         let name: String
    ///         let error: String
    ///         let id = UUID()
    ///     }
    ///
    ///     struct SaveButton: View {
    ///         @State private var didError = false
    ///         @State private var details: SaveDetails?
    ///
    ///         var body: some View {
    ///             Button("Save") {
    ///                 details = model.save(didError: $didError)
    ///             }
    ///             .alert(
    ///                 "Save failed.",
    ///                 isPresented: $didError,
    ///                 presenting: details
    ///             ) { details in
    ///                 Button(role: .destructive) {
    ///                     // Handle the deletion.
    ///                 } label: {
    ///                     Text("Delete \(details.name)")
    ///                 }
    ///                 Button("Retry") {
    ///                     // Handle the retry action.
    ///                 }
    ///             } message: { details in
    ///                 Text(details.error)
    ///             }
    ///         }
    ///     }
    ///
    /// This modifier creates a ``Text`` view for the title on your behalf, and
    /// treats the localized key similar to
    /// ``Text/init(_:tableName:bundle:comment:)``. See ``Text`` for more
    /// information about localizing strings.
    ///
    /// All actions in an alert dismiss the alert after the action runs.
    /// The default button is shown with greater prominence.  You can
    /// influence the default button by assigning it the
    /// ``KeyboardShortcut/defaultAction`` keyboard shortcut.
    ///
    /// The system may reorder the buttons based on their role and prominence.
    ///
    /// If no actions are present, the system includes a standard "OK"
    /// action. No default cancel action is provided. If you want to show a
    /// cancel action, use a button with a role of ``ButtonRole/cancel``.
    ///
    /// On iOS, tvOS, and watchOS, alerts only support controls with labels that
    /// are ``Text``. Passing any other type of view results in the content
    /// being omitted.
    ///
    /// Only unstyled text is supported for the message.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the localized string that describes the title
    ///     of the alert.
    ///   - isPresented: A binding to a Boolean value that determines whether to
    ///     present the alert. When the user presses or taps one of the alert's
    ///     actions, the system sets this value to `false` and dismisses.
    ///   - data: An optional source of truth for the alert. The system passes
    ///     the contents to the modifier's closures. You use this data to
    ///     populate the fields of an alert that you create that the system
    ///     displays to the user.
    ///   - actions: A ``ViewBuilder`` returning the alert's actions given the
    ///     currently available data.
    ///   - message: A ``ViewBuilder`` returning the message for the alert given
    ///     the currently available data.
    nonisolated public func alert<A, M, T>(_ titleKey: LocalizedStringKey, isPresented: Binding<Bool>, presenting data: T?, @ViewBuilder actions: (T) -> A, @ViewBuilder message: (T) -> M) -> some View where A : View, M : View


    /// Presents an alert with a message using the given data to produce the
    /// alert's content and a string variable as a title.
    ///
    /// For the alert to appear, both `isPresented` must be `true` and
    /// `data` must not be `nil`. The data should not change after the
    /// presentation occurs. Any changes that you make after the presentation
    /// occurs are ignored.
    ///
    /// Use this method when you need to populate the fields of an alert with
    /// content from a data source. The example below shows a custom data
    /// source, `SaveDetails`, that provides data to populate the alert:
    ///
    ///     struct SaveDetails: Identifiable {
    ///         let name: String
    ///         let error: String
    ///         let id = UUID()
    ///     }
    ///
    ///     struct SaveButton: View {
    ///         @State private var didError = false
    ///         @State private var details: SaveDetails?
    ///         let alertTitle: String = "Save failed."
    ///
    ///         var body: some View {
    ///             Button("Save") {
    ///                 details = model.save(didError: $didError)
    ///             }
    ///             .alert(
    ///                 alertTitle,
    ///                 isPresented: $didError,
    ///                 presenting: details
    ///             ) { details in
    ///                 Button(role: .destructive) {
    ///                     // Handle the deletion.
    ///                 } label: {
    ///                     Text("Delete \(details.name)")
    ///                 }
    ///                 Button("Retry") {
    ///                     // Handle the retry action.
    ///                 }
    ///             } message: { details in
    ///                 Text(details.error)
    ///             }
    ///         }
    ///     }
    ///
    /// All actions in an alert dismiss the alert after the action runs.
    /// The default button is shown with greater prominence.  You can
    /// influence the default button by assigning it the
    /// ``KeyboardShortcut/defaultAction`` keyboard shortcut.
    ///
    /// The system may reorder the buttons based on their role and prominence.
    ///
    /// If no actions are present, the system includes a standard "OK"
    /// action. No default cancel action is provided. If you want to show a
    /// cancel action, use a button with a role of ``ButtonRole/cancel``.
    ///
    /// On iOS, tvOS, and watchOS, alerts only support controls with labels that
    /// are ``Text``. Passing any other type of view results in the content
    /// being omitted.
    ///
    /// Only unstyled text is supported for the message.
    ///
    /// - Parameters:
    ///   - title: A text string used as the title of the alert.
    ///   - isPresented: A binding to a Boolean value that determines whether to
    ///     present the alert. When the user presses or taps one of the alert's
    ///     actions, the system sets this value to `false` and dismisses.
    ///   - data: An optional source of truth for the alert. The system passes
    ///     the contents to the modifier's closures. You use this data to
    ///     populate the fields of an alert that you create that the system
    ///     displays to the user.
    ///   - actions: A ``ViewBuilder`` returning the alert's actions given the
    ///     currently available data.
    ///   - message: A ``ViewBuilder`` returning the message for the alert given
    ///     the currently available data.
    nonisolated public func alert<S, A, M, T>(_ title: S, isPresented: Binding<Bool>, presenting data: T?, @ViewBuilder actions: (T) -> A, @ViewBuilder message: (T) -> M) -> some View where S : StringProtocol, A : View, M : View


    /// Presents an alert with a message using the given data to produce the
    /// alert's content and a text view for a title.
    ///
    /// For the alert to appear, both `isPresented` must be `true` and
    /// `data` must not be `nil`. The data should not change after the
    /// presentation occurs. Any changes that you make after the presentation
    /// occurs are ignored.
    ///
    /// Use this method when you need to populate the fields of an alert with
    /// content from a data source. The example below shows a custom data
    /// source, `SaveDetails`, that provides data to populate the alert:
    ///
    ///     struct SaveDetails: Identifiable {
    ///         let name: String
    ///         let error: String
    ///         let id = UUID()
    ///     }
    ///
    ///     struct SaveButton: View {
    ///         @State private var didError = false
    ///         @State private var details: SaveDetails?
    ///         let alertTitle: String = "Save failed."
    ///
    ///         var body: some View {
    ///             Button("Save") {
    ///                 details = model.save(didError: $didError)
    ///             }
    ///             .alert(
    ///                 Text(alertTitle),
    ///                 isPresented: $didError,
    ///                 presenting: details
    ///             ) { details in
    ///                 Button(role: .destructive) {
    ///                     // Handle the deletion.
    ///                 } label: {
    ///                     Text("Delete \(details.name)")
    ///                 }
    ///                 Button("Retry") {
    ///                     // Handle the retry action.
    ///                 }
    ///             } message: { details in
    ///                 Text(details.error)
    ///             }
    ///         }
    ///     }
    ///
    /// All actions in an alert dismiss the alert after the action runs.
    /// The default button is shown with greater prominence.  You can
    /// influence the default button by assigning it the
    /// ``KeyboardShortcut/defaultAction`` keyboard shortcut.
    ///
    /// The system may reorder the buttons based on their role and prominence.
    ///
    /// If no actions are present, the system includes a standard "OK"
    /// action. No default cancel action is provided. If you want to show a
    /// cancel action, use a button with a role of ``ButtonRole/cancel``.
    ///
    /// On iOS, tvOS, and watchOS, alerts only support controls with labels that
    /// are ``Text``. Passing any other type of view results in the content
    /// being omitted.
    ///
    /// Only unstyled text is supported for the message.
    ///
    /// - Parameters:
    ///   - title: the title of the alert.
    ///   - isPresented: A binding to a Boolean value that determines whether to
    ///     present the alert. When the user presses or taps one of the alert's
    ///     actions, the system sets this value to `false` and dismisses.
    ///   - data: An optional source of truth for the alert. The system passes
    ///     the contents to the modifier's closures. You use this data to
    ///     populate the fields of an alert that you create that the system
    ///     displays to the user.
    ///   - actions: A ``ViewBuilder`` returning the alert's actions given the
    ///     currently available data.
    ///   - message: A ``ViewBuilder`` returning the message for the alert given
    ///     the currently available data.
    nonisolated public func alert<A, M, T>(_ title: Text, isPresented: Binding<Bool>, presenting data: T?, @ViewBuilder actions: (T) -> A, @ViewBuilder message: (T) -> M) -> some View where A : View, M : View

}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension View {

    /// Presents an alert when an error is present.
    ///
    /// In the example below, a form conditionally presents an alert depending
    /// upon the value of an error. When the error value isn't `nil`, the system
    /// presents an alert with an "OK" action.
    ///
    /// The title of the alert is inferred from the error's `errorDescription`.
    ///
    ///     struct TicketPurchase: View {
    ///         @State private var error: TicketPurchaseError? = nil
    ///         @State private var showAlert = false
    ///
    ///         var body: some View {
    ///             TicketForm(showAlert: $showAlert, error: $error)
    ///                 .alert(isPresented: $showAlert, error: error) {
    ///                     Button("OK") {
    ///                         // Handle acknowledgement.
    ///                     }
    ///                 }
    ///         }
    ///     }
    ///
    /// All actions in an alert dismiss the alert after the action runs.
    /// The default button is shown with greater prominence.  You can
    /// influence the default button by assigning it the
    /// ``KeyboardShortcut/defaultAction`` keyboard shortcut.
    ///
    /// The system may reorder the buttons based on their role and prominence.
    ///
    /// If no actions are present, the system includes a standard "OK"
    /// action. No default cancel action is provided. If you want to show a
    /// cancel action, use a button with a role of ``ButtonRole/cancel``.
    ///
    /// On iOS, tvOS, and watchOS, alerts only support controls with labels that
    /// are ``Text``. Passing any other type of view results in the content
    /// being omitted.
    ///
    /// This modifier creates a ``Text`` view for the title on your behalf, and
    /// treats the localized key similar to
    /// ``Text/init(_:tableName:bundle:comment:)``. See ``Text`` for more
    /// information about localizing strings.
    ///
    /// - Parameters:
    ///   - isPresented: A binding to a Boolean value that determines whether to
    ///     present the alert. When the user presses or taps one of the alert's
    ///     actions, the system sets this value to `false` and dismisses.
    ///   - error: An optional localized Error that is used to generate the
    ///     alert's title.  The system passes the contents to the modifier's
    ///     closures. You use this data to populate the fields of an alert that
    ///     you create that the system displays to the user.
    ///   - actions: A ``ViewBuilder`` returning the alert's actions.
    nonisolated public func alert<E, A>(isPresented: Binding<Bool>, error: E?, @ViewBuilder actions: () -> A) -> some View where E : LocalizedError, A : View


    /// Presents an alert with a message when an error is present.
    ///
    /// In the example below, a form conditionally presents an alert depending
    /// upon the value of an error. When the error value isn't `nil`, the system
    /// presents an alert with an "OK" action.
    ///
    /// The title of the alert is inferred from the error's `errorDescription`.
    ///
    ///     struct TicketPurchase: View {
    ///         @State private var error: TicketPurchaseError? = nil
    ///         @State private var showAlert = false
    ///
    ///         var body: some View {
    ///             TicketForm(showAlert: $showAlert, error: $error)
    ///                 .alert(isPresented: $showAlert, error: error) { _ in
    ///                     Button("OK") {
    ///                         // Handle acknowledgement.
    ///                     }
    ///                 } message: { error in
    ///                     Text(error.recoverySuggestion ?? "Try again later.")
    ///                 }
    ///         }
    ///     }
    ///
    /// All actions in an alert dismiss the alert after the action runs.
    /// The default button is shown with greater prominence.  You can
    /// influence the default button by assigning it the
    /// ``KeyboardShortcut/defaultAction`` keyboard shortcut.
    ///
    /// The system may reorder the buttons based on their role and prominence.
    ///
    /// If no actions are present, the system includes a standard "OK"
    /// action. No default cancel action is provided. If you want to show a
    /// cancel action, use a button with a role of ``ButtonRole/cancel``.
    ///
    /// On iOS, tvOS, and watchOS, alerts only support controls with labels that
    /// are ``Text``. Passing any other type of view results in the content
    /// being omitted.
    ///
    /// This modifier creates a ``Text`` view for the title on your behalf, and
    /// treats the localized key similar to
    /// ``Text/init(_:tableName:bundle:comment:)``. See ``Text`` for more
    /// information about localizing strings.
    ///
    /// - Parameters:
    ///   - isPresented: A binding to a Boolean value that determines whether to
    ///     present the alert. When the user presses or taps one of the alert's
    ///     actions, the system sets this value to `false` and dismisses.
    ///   - error: An optional localized Error that is used to generate the
    ///     alert's title.  The system passes the contents to the modifier's
    ///     closures. You use this data to populate the fields of an alert that
    ///     you create that the system displays to the user.
    ///   - actions: A ``ViewBuilder`` returning the alert's actions.
    ///   - message: A view builder returning the message for the alert given
    ///     the current error.
    nonisolated public func alert<E, A, M>(isPresented: Binding<Bool>, error: E?, @ViewBuilder actions: (E) -> A, @ViewBuilder message: (E) -> M) -> some View where E : LocalizedError, A : View, M : View

}

extension View {

    /// Configures the search suggestions for this view.
    ///
    /// You can suggest search terms during a search operation by providing a
    /// collection of view to this modifier. The interface presents the
    /// suggestion views as a list of choices when someone activates the
    /// search interface. Associate a string with each suggestion
    /// view by adding the ``View/searchCompletion(_:)`` modifier to
    /// the view. For example, you can suggest fruit types by displaying their
    /// emoji, and provide the corresponding search string as a search
    /// completion in each case:
    ///
    ///     ProductList()
    ///         .searchable(text: $text)
    ///         .searchSuggestions {
    ///             Text("").searchCompletion("apple")
    ///             Text("").searchCompletion("pear")
    ///             Text("").searchCompletion("banana")
    ///         }
    ///
    /// When someone chooses a suggestion, SwiftUI replaces the text in the
    /// search field with the search completion string. If you omit the search
    /// completion modifier for a particular suggestion view, SwiftUI displays
    /// the suggestion, but the suggestion view doesn't react to taps or clicks.
    ///
    /// > Important: In tvOS, searchable modifiers only support suggestion views
    /// of type ``Text``, like in the above example. Other platforms can use any
    /// view for the suggestions, including custom views.
    ///
    /// You can update the suggestions that you provide as conditions change.
    ///
    /// For example, you can specify an array of suggestions that you store
    /// in a model:
    ///
    ///     ProductList()
    ///         .searchable(text: $text)
    ///         .searchSuggestions {
    ///             ForEach(model.suggestedSearches) { suggestion in
    ///                 Label(suggestion.title, image: suggestion.image)
    ///                     .searchCompletion(suggestion.text)
    ///             }
    ///         }
    ///
    /// If the model's `suggestedSearches` begins as an empty array, the
    /// interface doesn't display any suggestions to start. You can then provide
    /// logic that updates the array based on some condition. For example, you
    /// might update the completions based on the current search text. Note that
    /// certain events or actions, like when someone moves a macOS window, might
    /// dismiss the suggestion view.
    ///
    /// For more information about using search modifiers, see
    /// <doc:Adding-a-search-interface-to-your-app>.
    ///
    /// - Parameters:
    ///   - suggestions: A view builder that produces content that
    ///     populates a list of suggestions.
    @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
    nonisolated public func searchSuggestions<S>(@ViewBuilder _ suggestions: () -> S) -> some View where S : View

}

extension View {

    /// Marks this view as searchable, which configures the display of a
    /// search field.
    ///
    /// For more information about using searchable modifiers, see
    /// <doc:Adding-a-search-interface-to-your-app>.
    ///
    /// - Parameters:
    ///   - text: The text to display and edit in the search field.
    ///   - placement: Where the search field should attempt to be
    ///     placed based on the containing view hierarchy.
    ///   - prompt: A ``Text`` view representing the prompt of the search field
    ///     which provides users with guidance on what to search for.
    ///   - suggestions: A view builder that produces content that
    ///     populates a list of suggestions.
    @available(iOS, introduced: 15.0, deprecated: 100000.0, message: "Use the searchable modifier with the searchSuggestions modifier")
    @available(macOS, introduced: 12.0, deprecated: 100000.0, message: "Use the searchable modifier with the searchSuggestions modifier")
    @available(tvOS, introduced: 15.0, deprecated: 100000.0, message: "Use the searchable modifier with the searchSuggestions modifier")
    @available(watchOS, introduced: 8.0, deprecated: 100000.0, message: "Use the searchable modifier with the searchSuggestions modifier")
    nonisolated public func searchable<S>(text: Binding<String>, placement: SearchFieldPlacement = .automatic, prompt: Text? = nil, @ViewBuilder suggestions: () -> S) -> some View where S : View


    /// Marks this view as searchable, which configures the display of a
    /// search field.
    ///
    /// For more information about using searchable modifiers, see
    /// <doc:Adding-a-search-interface-to-your-app>.
    ///
    /// - Parameters:
    ///   - text: The text to display and edit in the search field.
    ///   - placement: Where the search field should attempt to be
    ///     placed based on the containing view hierarchy.
    ///   - prompt: A key for the localized prompt of the search field
    ///     which provides users with guidance on what to search for.
    ///   - suggestions: A view builder that produces content that
    ///     populates a list of suggestions.
    @available(iOS, introduced: 15.0, deprecated: 100000.0, message: "Use the searchable modifier with the searchSuggestions modifier")
    @available(macOS, introduced: 12.0, deprecated: 100000.0, message: "Use the searchable modifier with the searchSuggestions modifier")
    @available(tvOS, introduced: 15.0, deprecated: 100000.0, message: "Use the searchable modifier with the searchSuggestions modifier")
    @available(watchOS, introduced: 8.0, deprecated: 100000.0, message: "Use the searchable modifier with the searchSuggestions modifier")
    nonisolated public func searchable<S>(text: Binding<String>, placement: SearchFieldPlacement = .automatic, prompt: LocalizedStringKey, @ViewBuilder suggestions: () -> S) -> some View where S : View


    /// Marks this view as searchable, which configures the display of a
    /// search field.
    ///
    /// For more information about using searchable modifiers, see
    /// <doc:Adding-a-search-interface-to-your-app>.
    ///
    /// - Parameters:
    ///   - text: The text to display and edit in the search field.
    ///   - placement: Where the search field should attempt to be
    ///     placed based on the containing view hierarchy.
    ///   - prompt: A string representing the prompt of the search field
    ///     which provides users with guidance on what to search for.
    ///   - suggestions: A view builder that produces content that
    ///     populates a list of suggestions.
    @available(iOS, introduced: 15.0, deprecated: 100000.0, message: "Use the searchable modifier with the searchSuggestions modifier")
    @available(macOS, introduced: 12.0, deprecated: 100000.0, message: "Use the searchable modifier with the searchSuggestions modifier")
    @available(tvOS, introduced: 15.0, deprecated: 100000.0, message: "Use the searchable modifier with the searchSuggestions modifier")
    @available(watchOS, introduced: 8.0, deprecated: 100000.0, message: "Use the searchable modifier with the searchSuggestions modifier")
    nonisolated public func searchable<V, S>(text: Binding<String>, placement: SearchFieldPlacement = .automatic, prompt: S, @ViewBuilder suggestions: () -> V) -> some View where V : View, S : StringProtocol

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 7.0, *)
extension View {

    /// Sets the tab bar item associated with this view.
    ///
    /// Use `tabItem(_:)` to configure a view as a tab bar item in a
    /// ``TabView``. The example below adds two views as tabs in a ``TabView``:
    ///
    ///     struct View1: View {
    ///         var body: some View {
    ///             Text("View 1")
    ///         }
    ///     }
    ///
    ///     struct View2: View {
    ///         var body: some View {
    ///             Text("View 2")
    ///         }
    ///     }
    ///
    ///     struct TabItem: View {
    ///         var body: some View {
    ///             TabView {
    ///                 View1()
    ///                     .tabItem {
    ///                         Label("Menu", systemImage: "list.dash")
    ///                     }
    ///
    ///                 View2()
    ///                     .tabItem {
    ///                         Label("Order", systemImage: "square.and.pencil")
    ///                     }
    ///             }
    ///         }
    ///     }
    ///
    /// ![A screenshot of a two views configured as tab items in a tab
    /// view.](SwiftUI-View-tabItem.png)
    ///
    /// - Parameter label: The tab bar item to associate with this view.
    @available(iOS, deprecated: 100000.0, message: "Use `Tab(title:image:value:content:)` and related initializers instead")
    @available(macOS, deprecated: 100000.0, message: "Use `Tab(title:image:value:content:)` and related initializers instead")
    @available(tvOS, deprecated: 100000.0, message: "Use `Tab(title:image:value:content:)` and related initializers instead")
    @available(watchOS, deprecated: 100000.0, message: "Use `Tab(title:image:value:content:)` and related initializers instead")
    nonisolated public func tabItem<V>(@ViewBuilder _ label: () -> V) -> some View where V : View

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// Sets a value for the specified preference key, the value is a
    /// function of a geometry value tied to the current coordinate
    /// space, allowing readers of the value to convert the geometry to
    /// their local coordinates.
    ///
    /// - Parameters:
    ///   - key: the preference key type.
    ///   - value: the geometry value in the current coordinate space.
    ///   - transform: the function to produce the preference value.
    ///
    /// - Returns: a new version of the view that writes the preference.
    @inlinable nonisolated public func anchorPreference<A, K>(key _: K.Type = K.self, value: Anchor<A>.Source, transform: @escaping (Anchor<A>) -> K.Value) -> some View where K : PreferenceKey

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension DynamicViewContent {

    /// Sets the move action for the dynamic view.
    ///
    /// - Parameters:
    ///   - action: A closure that SwiftUI invokes when elements in the dynamic
    ///     view are moved. The closure takes two arguments that represent the
    ///     offset relative to the dynamic view's underlying collection of data.
    ///     Pass `nil` to disable the ability to move items.
    ///
    /// - Returns: A view that calls `action` when elements are moved within the
    ///   original view.
    @inlinable nonisolated public func onMove(perform action: ((IndexSet, Int) -> Void)?) -> some DynamicViewContent

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// Adds a condition for whether the view's view hierarchy is movable.
    @inlinable nonisolated public func moveDisabled(_ isDisabled: Bool) -> some View

}

@available(iOS 16.0, macOS 13.0, watchOS 9.0, *)
@available(tvOS, unavailable)
extension View {

    /// Specifies the visibility of the background for scrollable views within
    /// this view.
    ///
    /// The following example hides the standard system background of the List.
    ///
    ///     List {
    ///         Text("One")
    ///         Text("Two")
    ///         Text("Three")
    ///     }
    ///     .scrollContentBackground(.hidden)
    ///
    /// On macOS 15.0 and later, the visibility of the scroll background helps
    /// achieve the seamless window/titlebar appearance for scroll views that
    /// fill the window's content view, or a pane's full width and height.
    /// `List` and `Form` have the seamless appearance by default, configurable
    /// by hiding the scroll background. `ScrollView` can become seamless by
    /// making the background visible.
    ///
    /// - Parameters:
    ///    - visibility: the visibility to use for the background.
    nonisolated public func scrollContentBackground(_ visibility: Visibility) -> some View

}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, visionOS 2.0, watchOS 11.0, *)
extension View {

    /// Sets the sizing of the containing presentation.
    ///
    /// Use this modifier to apply a ``PresentationSizing`` to a
    /// presentation like ``View/sheet(isPresented:onDismiss:content:)``.
    /// The `sizing` parameter defines the size proposed to the content, and the
    /// presentation adopts the returned size. The default value is `automatic`.
    ///
    /// Sizings can be modified to fix their dimensions based on the content,
    /// and optionally be sticky.
    /// - Seealso: ``PresentationSizing/fitted(horizontal:vertical:)`` and
    /// ``PresentationSizing/sticky(horizontal:vertical:)``.
    ///
    /// - Note: If the presentation's root container is a `NavigationSplitView`,
    /// the proposed width only applies to the `detail` column. The `sidebar`
    /// and `content` column widths use system-provided values, or those from
    /// ``View/navigationSplitViewColumnWidth(_:)`` or
    /// ``View/navigationSplitViewColumnWidth(min:ideal:max:)`` modifiers.
    ///
    /// For example, a presentation with facts about flowers could
    /// prefer `.page` sizing because its content is primarily
    /// informational. Since the user can choose different flowers from the
    /// picker, each with different lengths of information, the size is fitted
    /// vertically to size the sheet to the textual content, and vertically
    /// sticky is specified to prevent the presentation from changing size too
    /// frequently as the user changes selection.
    ///
    ///     struct ContentView: View {
    ///         @State private var presentInfo = true
    ///
    ///         var body: some View {
    ///             ContentView.sheet(isPresented: $presentInfo) {
    ///                 VStack {
    ///                     Picker("Flower Species", selection: $flower) {
    ///                         ForEach(Flower.allCases) {
    ///                             Text($0.rawValue.uppercased()).tag($0)
    ///                         }
    ///                     }
    ///                     Text(flower.emoji).font(.largeTitle)
    ///                     Text(flower.informationalText)
    ///                 }
    ///                 .frame(maxHeight: .infinity, alignment: .top)
    ///                 .padding()
    ///                 .presentationSizing(
    ///                     .page
    ///                         .fitted(horizontal: false, vertical: true)
    ///                         .sticky(horizontal: false, vertical: true))
    ///             }
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///    - sizing: A value dictating size to propose to presentation content
    ///      and how the presentation responds to changes in content size.
    nonisolated public func presentationSizing(_ sizing: some PresentationSizing) -> some View

}

@available(iOS 16.0, macOS 12.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension ModifiedContent : TableRowContent where Content : TableRowContent, Modifier : _TableRowContentModifier {

    /// The type of value represented by this table row content.
    public typealias TableRowValue = Content.TableRowValue

    /// The type of content representing the body of this table row content.
    public typealias TableRowBody = Never

    /// The composition of content that comprise the table row content.
    @MainActor @preconcurrency public var tableRowBody: Never { get }
}

@available(iOS 16.0, macOS 12.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension ModifiedContent : DynamicTableRowContent where Content : DynamicTableRowContent, Modifier : _TableRowContentModifier {

    /// The collection of underlying data.
    public var data: Content.Data { get }

    /// The type of the underlying collection of data.
    @available(iOS 16.0, macOS 12.0, *)
    @available(tvOS, unavailable, introduced: 13.0)
    @available(watchOS, unavailable, introduced: 6.0)
    public typealias Data = Content.Data
}

@available(iOS 18.0, tvOS 18.0, visionOS 2.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension CustomHoverEffect where Self == AutomaticHoverEffect {

    /// The default hover effect based on the surrounding context.
    ///
    /// The automatic effect will resolve to any ``View/defaultHoverEffect(_:)``
    /// applied to the current View hierarchy, or a system-defined effect if
    /// no default effect has been defined.
    public static var automatic: AutomaticHoverEffect { get }
}

@available(iOS 18.0, tvOS 18.0, visionOS 2.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension CustomHoverEffect where Self == HighlightHoverEffect {

    /// A hover effect that highlights views using a light source to indicate
    /// position.
    ///
    /// For pointer input this effect morphs the pointer into a platter behind
    /// the view and shows a light source indicating position.
    ///
    /// On tvOS it applies a projection effect accompanied with a specular
    /// highlight on the view when contained within a focused view. It also
    /// incorporates motion effects to produce a parallax effect by adjusting
    /// the projection matrix and specular offset.
    ///
    /// On visionOS this effect applies a glow effect based on where the user
    /// is looking or touching the view.
    public static var highlight: HighlightHoverEffect { get }
}

@available(iOS 18.0, tvOS 18.0, visionOS 2.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension CustomHoverEffect where Self == LiftHoverEffect {

    /// A hover effect that slides the pointer under the view and disappears as
    /// the view scales up and gains a shadow.
    public static var lift: LiftHoverEffect { get }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// Renders a view's content as if it's rotated in three dimensions around
    /// the specified axis.
    ///
    /// Use this method to create the effect of rotating a view in three
    /// dimensions around a specified axis of rotation. The modifier projects
    /// the rotated content onto the original view's plane. Use the
    /// `perspective` value to control the renderer's vanishing point. The
    /// following example creates the appearance of rotating text 45 about
    /// the y-axis:
    ///
    ///     Text("Rotation by passing an angle in degrees")
    ///         .rotation3DEffect(
    ///             .degrees(45),
    ///             axis: (x: 0.0, y: 1.0, z: 0.0),
    ///             anchor: .center,
    ///             anchorZ: 0,
    ///             perspective: 1)
    ///         .border(Color.gray)
    ///
    /// ![A screenshot of text in a grey box. The text says Rotation by passing an angle in degrees. The text is rendered in a way that makes it appear farther from the viewer on the right side and closer on the left, as if the text is angled to face someone sitting on the viewer's right.](SwiftUI-View-rotation3DEffect)
    ///
    /// > Important: In visionOS, create this effect with
    ///   ``perspectiveRotationEffect(_:axis:anchor:anchorZ:perspective:)``
    ///   instead. To truly rotate a view in three dimensions,
    ///   use a 3D rotation modifier without a perspective input like
    ///   ``rotation3DEffect(_:axis:anchor:)``.
    ///
    /// - Parameters:
    ///   - angle: The angle by which to rotate the view's content.
    ///   - axis: The axis of rotation, specified as a tuple with named
    ///     elements for each of the three spatial dimensions.
    ///   - anchor: A two dimensional unit point within the view about which to
    ///     perform the rotation. The default value is ``UnitPoint/center``.
    ///   - anchorZ: The location on the z-axis around which to rotate the
    ///     content. The default is `0`.
    ///   - perspective: The relative vanishing point for the rotation. The
    ///     default is `1`.
    /// - Returns: A view with rotated content.
    @inlinable nonisolated public func rotation3DEffect(_ angle: Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint = .center, anchorZ: CGFloat = 0, perspective: CGFloat = 1) -> some View

}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension VisualEffect {

    /// Renders content as if it's rotated in three dimensions around
    /// the specified axis.
    ///
    /// Use this method to create the effect of rotating a two dimensional view
    /// in three dimensions around a specified axis of rotation. The effect
    /// projects the rotated content onto the original content's plane. Use the
    /// `perspective` input to control the renderer's vanishing point.
    /// The following example creates the appearance of rotating
    /// text 45 about the y-axis:
    ///
    ///     Text("Rotation by passing an angle in degrees")
    ///         .visualEffect { content, geometryProxy in
    ///             content
    ///                 .rotation3DEffect(
    ///                     .degrees(45),
    ///                     axis: (x: 0.0, y: 1.0, z: 0.0),
    ///                     anchor: .center,
    ///                     anchorZ: 0,
    ///                     perspective: 1)
    ///             }
    ///         .border(Color.gray)
    ///
    /// ![A screenshot of text in a grey box. The text says Rotation by passing an angle in degrees. The text is rendered in a way that makes it appear farther from the viewer on the right side and closer on the left, as if the text is angled to face someone sitting on the viewer's right.](SwiftUI-View-rotation3DEffect)
    ///
    /// > Important: In visionOS, create this effect with
    ///   ``perspectiveRotationEffect(_:axis:anchor:perspective:)``
    ///   instead. To truly rotate a view in three dimensions,
    ///   use a 3D rotation effect without a perspective input like
    ///   ``rotation3DEffect(_:axis:anchor:)``.
    ///
    /// - Parameters:
    ///   - angle: The angle by which to rotate the content.
    ///   - axis: The axis of rotation, specified as a tuple with named
    ///     elements for each of the three spatial dimensions.
    ///   - anchor: A two dimensional unit point within the content about which
    ///     to perform the rotation. The default value is ``UnitPoint/center``.
    ///   - anchorZ: The location on the z-axis around which to rotate the
    ///     content. The default is `0`.
    ///   - perspective: The relative vanishing point for the rotation. The
    ///     default is `1`.
    /// - Returns: A rotation effect.
    public func rotation3DEffect(_ angle: Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint = .center, anchorZ: CGFloat = 0, perspective: CGFloat = 1) -> some VisualEffect

}

@available(iOS 17.0, macOS 14.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@available(visionOS, unavailable)
extension View {

    /// Inserts an inspector at the applied position in the view hierarchy.
    ///
    /// Apply this modifier to declare an inspector with a context-dependent
    /// presentation. For example, an inspector can present as a trailing
    /// column in a horizontally regular size class, but adapt to a sheet in a
    /// horizontally compact size class.
    ///
    ///     struct ShapeEditor: View {
    ///         @State var presented: Bool = false
    ///         var body: some View {
    ///             MyEditorView()
    ///                 .inspector(isPresented: $presented) {
    ///                     TextTraitsInspectorView()
    ///                 }
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - isPresented: A binding to `Bool` controlling the presented state.
    ///   - content: The inspector content.
    ///
    /// - Note: Trailing column inspectors have their presentation state
    /// restored by the framework.
    /// - Seealso: ``InspectorCommands`` for including the default inspector
    /// commands and keyboard shortcuts.
    nonisolated public func inspector<V>(isPresented: Binding<Bool>, @ViewBuilder content: () -> V) -> some View where V : View


    /// Sets a flexible, preferred width for the inspector in a trailing-column
    /// presentation.
    ///
    /// Apply this modifier on the content of a
    /// ``View/inspector(isPresented:content:)`` to specify a preferred flexible
    /// width for the column. Use ``View/inspectorColumnWidth(_:)`` if you need
    /// to specify a fixed width.
    ///
    /// The following example shows an editor interface with an inspector, which
    /// when presented as a trailing-column, has a preferred width of 225
    /// points, maximum of 400, and a minimum of 150 at which point it will
    /// collapse, if allowed.
    ///
    ///     MyEditorView()
    ///         .inspector {
    ///             TextTraitsInspectorView()
    ///                 .inspectorColumnWidth(min: 150, ideal: 225, max: 400)
    ///         }
    ///
    /// Only some platforms enable flexible inspector columns. If
    /// you specify a width that the current presentation environment doesn't
    /// support, SwiftUI may use a different width for your column.
    /// - Parameters:
    ///   - min: The minimum allowed width for the trailing column inspector
    ///   - ideal: The initial width of the inspector in the absence of state
    ///   restoration. `ideal` influences the resulting width on macOS when a
    ///   user double-clicks the divider on the leading edge of the inspector.
    ///   clicks a divider to readjust
    ///   - max: The maximum allowed width for the trailing column inspector
    nonisolated public func inspectorColumnWidth(min: CGFloat? = nil, ideal: CGFloat, max: CGFloat? = nil) -> some View


    /// Sets a fixed, preferred width for the inspector containing this view
    /// when presented as a trailing column.
    ///
    /// Apply this modifier on the content of a
    /// ``View/inspector(isPresented:content:)`` to specify a fixed preferred
    /// width for the trailing column. Use
    /// ``View/inspectorColumnWidth(min:ideal:max:)`` if you need to specify a
    /// flexible width.
    ///
    /// The following example shows an editor interface with an inspector, which
    /// when presented as a trailing-column, has a fixed width of 225
    /// points. The example also uses ``View/interactiveDismissDisabled(_:)`` to
    /// prevent the inspector from being collapsed by user action like dragging
    /// a divider.
    ///
    ///     MyEditorView()
    ///         .inspector {
    ///             TextTraitsInspectorView()
    ///                 .inspectorColumnWidth(225)
    ///                 .interactiveDismissDisabled()
    ///         }
    ///
    /// - Parameter width: The preferred fixed width for the inspector if
    /// presented as a trailing column.
    /// - Note: A fixed width does not prevent the user collapsing the
    /// inspector on macOS. See ``View/interactiveDismissDisabled(_:)``.
    nonisolated public func inspectorColumnWidth(_ width: CGFloat) -> some View

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension View {

    /// Sets the style for progress views in this view.
    ///
    /// For example, the following code creates a progress view that uses the
    /// "circular" style:
    ///
    ///     ProgressView()
    ///         .progressViewStyle(.circular)
    ///
    /// - Parameter style: The progress view style to use for this view.
    nonisolated public func progressViewStyle<S>(_ style: S) -> some View where S : ProgressViewStyle

}

extension View {

    /// Marks this view as searchable with text and tokens.
    ///
    /// For more information about using searchable modifiers, see
    /// <doc:Adding-a-search-interface-to-your-app>.
    ///
    /// - Parameters:
    ///   - text: The text to display and edit in the search field.
    ///   - tokens: A collection of tokens to display and edit in the
    ///     search field.
    ///   - placement: The preferred placement of the search field within the
    ///     containing view hierarchy.
    ///   - prompt: A ``Text`` view representing the prompt of the search field
    ///     which provides users with guidance on what to search for.
    ///   - token: A view builder that creates a view given an element in
    ///     tokens.
    @available(iOS 16.0, macOS 13.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    nonisolated public func searchable<C, T>(text: Binding<String>, tokens: Binding<C>, placement: SearchFieldPlacement = .automatic, prompt: Text? = nil, @ViewBuilder token: @escaping (C.Element) -> T) -> some View where C : RandomAccessCollection, C : RangeReplaceableCollection, T : View, C.Element : Identifiable


    /// Marks this view as searchable, which configures the display of a
    /// search field.
    ///
    /// For more information about using searchable modifiers, see
    /// <doc:Adding-a-search-interface-to-your-app>.
    ///
    /// - Parameters:
    ///   - text: The text to display and edit in the search field.
    ///   - editableTokens: A collection of tokens to display and edit in the
    ///     search field.
    ///   - placement: The preferred placement of the search field within the
    ///     containing view hierarchy.
    ///   - prompt: A ``Text`` view representing the prompt of the search field
    ///     which provides users with guidance on what to search for.
    ///   - token: A view builder that creates a view given an element in
    ///     tokens.
    @available(iOS 17.0, macOS 14.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    nonisolated public func searchable<C>(text: Binding<String>, editableTokens: Binding<C>, placement: SearchFieldPlacement = .automatic, prompt: Text? = nil, @ViewBuilder token: @escaping (Binding<C.Element>) -> some View) -> some View where C : RandomAccessCollection, C : RangeReplaceableCollection, C.Element : Identifiable


    /// Marks this view as searchable with text and tokens.
    ///
    /// For more information about using searchable modifiers, see
    /// <doc:Adding-a-search-interface-to-your-app>.
    ///
    /// - Parameters:
    ///   - text: The text to display and edit in the search field.
    ///   - tokens: A collection of tokens to display and edit in the
    ///     search field.
    ///   - placement: The preferred placement of the search field within the
    ///     containing view hierarchy.
    ///   - prompt: The key for the localized prompt of the search field
    ///     which provides users with guidance on what to search for.
    ///   - token: A view builder that creates a view given an element in
    ///     tokens.
    @available(iOS 16.0, macOS 13.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    nonisolated public func searchable<C, T>(text: Binding<String>, tokens: Binding<C>, placement: SearchFieldPlacement = .automatic, prompt: LocalizedStringKey, @ViewBuilder token: @escaping (C.Element) -> T) -> some View where C : RandomAccessCollection, C : RangeReplaceableCollection, T : View, C.Element : Identifiable


    /// Marks this view as searchable, which configures the display of a
    /// search field.
    ///
    /// For more information about using searchable modifiers, see
    /// <doc:Adding-a-search-interface-to-your-app>.
    ///
    /// - Parameters:
    ///   - text: The text to display and edit in the search field.
    ///   - editableTokens: A collection of tokens to display and edit in the
    ///     search field.
    ///   - placement: The preferred placement of the search field within the
    ///     containing view hierarchy.
    ///   - prompt: The key for the localized prompt of the search field
    ///     which provides users with guidance on what to search for.
    ///   - token: A view builder that creates a view given an element in
    ///     tokens.
    @available(iOS 17.0, macOS 14.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    nonisolated public func searchable<C>(text: Binding<String>, editableTokens: Binding<C>, placement: SearchFieldPlacement = .automatic, prompt: LocalizedStringKey, @ViewBuilder token: @escaping (Binding<C.Element>) -> some View) -> some View where C : RandomAccessCollection, C : RangeReplaceableCollection, C.Element : Identifiable


    /// Marks this view as searchable with text and tokens.
    ///
    /// For more information about using searchable modifiers, see
    /// <doc:Adding-a-search-interface-to-your-app>.
    ///
    /// - Parameters:
    ///   - text: The text to display and edit in the search field.
    ///   - tokens: A collection of tokens to display and edit in the
    ///     search field.
    ///   - placement: The preferred placement of the search field within the
    ///     containing view hierarchy.
    ///   - prompt: A string representing the prompt of the search field
    ///     which provides users with guidance on what to search for.
    ///   - token: A view builder that creates a view given an element in
    ///     tokens.
    @available(iOS 16.0, macOS 13.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    nonisolated public func searchable<C, T, S>(text: Binding<String>, tokens: Binding<C>, placement: SearchFieldPlacement = .automatic, prompt: S, @ViewBuilder token: @escaping (C.Element) -> T) -> some View where C : RandomAccessCollection, C : RangeReplaceableCollection, T : View, S : StringProtocol, C.Element : Identifiable


    /// Marks this view as searchable, which configures the display of a
    /// search field.
    ///
    /// For more information about using searchable modifiers, see
    /// <doc:Adding-a-search-interface-to-your-app>.
    ///
    /// - Parameters:
    ///   - text: The text to display and edit in the search field.
    ///   - editableTokens: A collection of tokens to display and edit in the
    ///     search field.
    ///   - placement: The preferred placement of the search field within the
    ///     containing view hierarchy.
    ///   - prompt: A string representing the prompt of the search field
    ///     which provides users with guidance on what to search for.
    ///   - token: A view builder that creates a view given an element in
    ///     tokens.
    @available(iOS 17.0, macOS 14.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    nonisolated public func searchable<C>(text: Binding<String>, editableTokens: Binding<C>, placement: SearchFieldPlacement = .automatic, prompt: some StringProtocol, @ViewBuilder token: @escaping (Binding<C.Element>) -> some View) -> some View where C : RandomAccessCollection, C : RangeReplaceableCollection, C.Element : Identifiable

}

extension View {

    /// Marks this view as searchable with text and tokens, as well as
    /// programmatic presentation.
    ///
    /// For more information about using searchable modifiers, see
    /// <doc:Adding-a-search-interface-to-your-app>.
    /// For information about presenting a search field programmatically, see
    /// <doc:Managing-search-interface-activation>.
    ///
    /// - Parameters:
    ///   - text: The text to display and edit in the search field.
    ///   - tokens: A collection of tokens to display and edit in the
    ///     search field.
    ///   - isPresenting: A ``Binding`` that controls the presented state
    ///     of search.
    ///   - placement: The preferred placement of the search field within the
    ///     containing view hierarchy.
    ///   - prompt: A ``Text`` view representing the prompt of the search field
    ///     which provides users with guidance on what to search for.
    ///   - token: A view builder that creates a view given an element in
    ///     tokens.
    @available(iOS 17.0, macOS 14.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    nonisolated public func searchable<C, T>(text: Binding<String>, tokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement = .automatic, prompt: Text? = nil, @ViewBuilder token: @escaping (C.Element) -> T) -> some View where C : RandomAccessCollection, C : RangeReplaceableCollection, T : View, C.Element : Identifiable


    /// Marks this view as searchable, which configures the display of a
    /// search field.
    ///
    /// For more information about using searchable modifiers, see
    /// <doc:Adding-a-search-interface-to-your-app>.
    ///
    /// - Parameters:
    ///   - text: The text to display and edit in the search field.
    ///   - editableTokens: A collection of tokens to display and edit in the
    ///     search field.
    ///   - isPresenting: A ``Binding`` which controls the presented state
    ///     of search.
    ///   - placement: The preferred placement of the search field within the
    ///     containing view hierarchy.
    ///   - prompt: A ``Text`` view representing the prompt of the search field
    ///     which provides users with guidance on what to search for.
    ///   - token: A view builder that creates a view given an element in
    ///     tokens.
    @available(iOS 17.0, macOS 14.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    nonisolated public func searchable<C>(text: Binding<String>, editableTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement = .automatic, prompt: Text? = nil, @ViewBuilder token: @escaping (Binding<C.Element>) -> some View) -> some View where C : RandomAccessCollection, C : RangeReplaceableCollection, C.Element : Identifiable


    /// Marks this view as searchable with text and tokens, as well as
    /// programmatic presentation.
    ///
    /// For more information about using searchable modifiers, see
    /// <doc:Adding-a-search-interface-to-your-app>.
    /// For information about presenting a search field programmatically, see
    /// <doc:Managing-search-interface-activation>.
    ///
    /// - Parameters:
    ///   - text: The text to display and edit in the search field.
    ///   - tokens: A collection of tokens to display and edit in the
    ///     search field.
    ///   - isPresenting: A ``Binding`` that controls the presented state
    ///     of search.
    ///   - placement: The preferred placement of the search field within the
    ///     containing view hierarchy.
    ///   - prompt: The key for the localized prompt of the search field
    ///     which provides users with guidance on what to search for.
    ///   - token: A view builder that creates a view given an element in
    ///     tokens.
    @available(iOS 17.0, macOS 14.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    nonisolated public func searchable<C, T>(text: Binding<String>, tokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement = .automatic, prompt: LocalizedStringKey, @ViewBuilder token: @escaping (C.Element) -> T) -> some View where C : RandomAccessCollection, C : RangeReplaceableCollection, T : View, C.Element : Identifiable


    /// Marks this view as searchable, which configures the display of a
    /// search field.
    ///
    /// For more information about using searchable modifiers, see
    /// <doc:Adding-a-search-interface-to-your-app>.
    ///
    /// - Parameters:
    ///   - text: The text to display and edit in the search field.
    ///   - editableTokens: A collection of tokens to display and edit in the
    ///     search field.
    ///   - isPresenting: A ``Binding`` which controls the presented state
    ///     of search.
    ///   - placement: The preferred placement of the search field within the
    ///     containing view hierarchy.
    ///   - prompt: The key for the localized prompt of the search field
    ///     which provides users with guidance on what to search for.
    ///   - token: A view builder that creates a view given an element in
    ///     tokens.
    @available(iOS 17.0, macOS 14.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    nonisolated public func searchable<C>(text: Binding<String>, editableTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement = .automatic, prompt: LocalizedStringKey, @ViewBuilder token: @escaping (Binding<C.Element>) -> some View) -> some View where C : RandomAccessCollection, C : RangeReplaceableCollection, C.Element : Identifiable


    /// Marks this view as searchable with text and tokens, as well as
    /// programmatic presentation.
    ///
    /// For more information about using searchable modifiers, see
    /// <doc:Adding-a-search-interface-to-your-app>.
    /// For information about presenting a search field programmatically, see
    /// <doc:Managing-search-interface-activation>.
    ///
    /// - Parameters:
    ///   - text: The text to display and edit in the search field.
    ///   - tokens: A collection of tokens to display and edit in the
    ///     search field.
    ///   - isPresenting: A ``Binding`` that controls the presented state
    ///     of search.
    ///   - placement: The preferred placement of the search field within the
    ///     containing view hierarchy.
    ///   - prompt: A string representing the prompt of the search field
    ///     which provides users with guidance on what to search for.
    ///   - token: A view builder that creates a view given an element in
    ///     tokens.
    @available(iOS 17.0, macOS 14.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    nonisolated public func searchable<C, T, S>(text: Binding<String>, tokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement = .automatic, prompt: S, @ViewBuilder token: @escaping (C.Element) -> T) -> some View where C : RandomAccessCollection, C : RangeReplaceableCollection, T : View, S : StringProtocol, C.Element : Identifiable


    /// Marks this view as searchable, which configures the display of a
    /// search field.
    ///
    /// For more information about using searchable modifiers, see
    /// <doc:Adding-a-search-interface-to-your-app>.
    ///
    /// - Parameters:
    ///   - text: The text to display and edit in the search field.
    ///   - editableTokens: A collection of tokens to display and edit in the
    ///     search field.
    ///   - isPresenting: A ``Binding`` which controls the presented state
    ///     of search.
    ///   - placement: The preferred placement of the search field within the
    ///     containing view hierarchy.
    ///   - prompt: A string representing the prompt of the search field
    ///     which provides users with guidance on what to search for.
    ///   - token: A view builder that creates a view given an element in
    ///     tokens.
    @available(iOS 17.0, macOS 14.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    nonisolated public func searchable<C>(text: Binding<String>, editableTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement = .automatic, prompt: some StringProtocol, @ViewBuilder token: @escaping (Binding<C.Element>) -> some View) -> some View where C : RandomAccessCollection, C : RangeReplaceableCollection, C.Element : Identifiable

}

extension View {

    /// Marks this view as searchable with text, tokens, and suggestions.
    ///
    /// For more information about using searchable modifiers, see
    /// <doc:Adding-a-search-interface-to-your-app>.
    ///
    /// - Parameters:
    ///   - text: The text to display and edit in the search field.
    ///   - tokens: A collection of tokens to display and edit in the
    ///     search field.
    ///   - suggestedTokens: A collection of tokens to display as suggestions.
    ///   - placement: The preferred placement of the search field within the
    ///     containing view hierarchy.
    ///   - prompt: A ``Text`` view representing the prompt of the search field
    ///     which provides users with guidance on what to search for.
    ///   - token: A view builder that creates a view given an element in
    ///     tokens.
    @available(iOS 16.0, macOS 13.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    nonisolated public func searchable<C, T>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, placement: SearchFieldPlacement = .automatic, prompt: Text? = nil, @ViewBuilder token: @escaping (C.Element) -> T) -> some View where C : MutableCollection, C : RandomAccessCollection, C : RangeReplaceableCollection, T : View, C.Element : Identifiable


    /// Marks this view as searchable with text, tokens, and suggestions.
    ///
    /// For more information about using searchable modifiers, see
    /// <doc:Adding-a-search-interface-to-your-app>.
    ///
    /// - Parameters:
    ///   - text: The text to display and edit in the search field.
    ///   - tokens: A collection of tokens to display and edit in the
    ///     search field.
    ///   - suggestedTokens: A collection of tokens to display as suggestions.
    ///   - placement: The preferred placement of the search field within the
    ///     containing view hierarchy.
    ///   - prompt: The key for the localized prompt of the search field
    ///     which provides users with guidance on what to search for.
    ///   - token: A view builder that creates a view given an element in
    ///     tokens.
    @available(iOS 16.0, macOS 13.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    nonisolated public func searchable<C, T>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, placement: SearchFieldPlacement = .automatic, prompt: LocalizedStringKey, @ViewBuilder token: @escaping (C.Element) -> T) -> some View where C : MutableCollection, C : RandomAccessCollection, C : RangeReplaceableCollection, T : View, C.Element : Identifiable


    /// Marks this view as searchable with text, tokens, and suggestions.
    ///
    /// For more information about using searchable modifiers, see
    /// <doc:Adding-a-search-interface-to-your-app>.
    ///
    /// - Parameters:
    ///   - text: The text to display and edit in the search field.
    ///   - tokens: A collection of tokens to display and edit in the
    ///     search field.
    ///   - suggestedTokens: A collection of tokens to display as suggestions.
    ///   - placement: The preferred placement of the search field within the
    ///     containing view hierarchy.
    ///   - prompt: A string representing the prompt of the search field
    ///     which provides users with guidance on what to search for.
    ///   - token: A view builder that creates a view given an element in
    ///     tokens.
    @available(iOS 16.0, macOS 13.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    nonisolated public func searchable<C, T, S>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, placement: SearchFieldPlacement = .automatic, prompt: S, @ViewBuilder token: @escaping (C.Element) -> T) -> some View where C : MutableCollection, C : RandomAccessCollection, C : RangeReplaceableCollection, T : View, S : StringProtocol, C.Element : Identifiable


    /// Marks this view as searchable with text, tokens, and suggestions, as
    /// well as programmatic presentation.
    ///
    /// For more information about using searchable modifiers, see
    /// <doc:Adding-a-search-interface-to-your-app>.
    /// For information about presenting a search field programmatically, see
    /// <doc:Managing-search-interface-activation>.
    ///
    /// - Parameters:
    ///   - text: The text to display and edit in the search field.
    ///   - tokens: A collection of tokens to display and edit in the
    ///     search field.
    ///   - suggestedTokens: A collection of tokens to display as suggestions.
    ///   - isPresenting: A ``Binding`` that controls the presented state
    ///     of search.
    ///   - placement: The preferred placement of the search field within the
    ///     containing view hierarchy.
    ///   - prompt: A ``Text`` view representing the prompt of the search field
    ///     which provides users with guidance on what to search for.
    ///   - token: A view builder that creates a view given an element in
    ///     tokens.
    @available(iOS 17.0, macOS 14.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    nonisolated public func searchable<C, T>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement = .automatic, prompt: Text? = nil, @ViewBuilder token: @escaping (C.Element) -> T) -> some View where C : RandomAccessCollection, C : RangeReplaceableCollection, T : View, C.Element : Identifiable


    /// Marks this view as searchable with text, tokens, and suggestions, as
    /// well as programmatic presentation.
    ///
    /// For more information about using searchable modifiers, see
    /// <doc:Adding-a-search-interface-to-your-app>.
    /// For information about presenting a search field programmatically, see
    /// <doc:Managing-search-interface-activation>.
    ///
    /// - Parameters:
    ///   - text: The text to display and edit in the search field.
    ///   - tokens: A collection of tokens to display and edit in the
    ///     search field.
    ///   - suggestedTokens: A collection of tokens to display as suggestions.
    ///   - isPresenting: A ``Binding`` that controls the presented state
    ///     of search.
    ///   - placement: The preferred placement of the search field within the
    ///     containing view hierarchy.
    ///   - prompt: The key for the localized prompt of the search field
    ///     which provides users with guidance on what to search for.
    ///   - token: A view builder that creates a view given an element in
    ///     tokens.
    @available(iOS 17.0, macOS 14.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    nonisolated public func searchable<C, T>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement = .automatic, prompt: LocalizedStringKey, @ViewBuilder token: @escaping (C.Element) -> T) -> some View where C : RandomAccessCollection, C : RangeReplaceableCollection, T : View, C.Element : Identifiable


    /// Marks this view as searchable with text, tokens, and suggestions, as
    /// well as programmatic presentation.
    ///
    /// For more information about using searchable modifiers, see
    /// <doc:Adding-a-search-interface-to-your-app>.
    /// For information about presenting a search field programmatically, see
    /// <doc:Managing-search-interface-activation>.
    ///
    /// - Parameters:
    ///   - text: The text to display and edit in the search field.
    ///   - tokens: A collection of tokens to display and edit in the
    ///     search field.
    ///   - suggestedTokens: A collection of tokens to display as suggestions.
    ///   - isPresenting: A ``Binding`` that controls the presented state
    ///     of search.
    ///   - placement: The preferred placement of the search field within the
    ///     containing view hierarchy.
    ///   - prompt: A string representing the prompt of the search field
    ///     which provides users with guidance on what to search for.
    ///   - token: A view builder that creates a view given an element in
    ///     tokens.
    @available(iOS 17.0, macOS 14.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    nonisolated public func searchable<C, T, S>(text: Binding<String>, tokens: Binding<C>, suggestedTokens: Binding<C>, isPresented: Binding<Bool>, placement: SearchFieldPlacement = .automatic, prompt: S, @ViewBuilder token: @escaping (C.Element) -> T) -> some View where C : MutableCollection, C : RandomAccessCollection, C : RangeReplaceableCollection, T : View, S : StringProtocol, C.Element : Identifiable

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// Overrides the device for a preview.
    ///
    /// By default, Xcode automatically chooses a preview device based
    /// on your currently selected run destination. If you want to
    /// choose a device that doesn't change based on Xcode settings,
    /// provide a ``PreviewDevice`` instance that you initialize with
    /// the name or model of a specific device:
    ///
    ///     struct CircleImage_Previews: PreviewProvider {
    ///         static var previews: some View {
    ///             CircleImage()
    ///                 .previewDevice(PreviewDevice(rawValue: "iPad Pro (11-inch)"))
    ///         }
    ///     }
    ///
    /// You can get a list of supported preview device names, like "iPhone 11",
    /// "iPad Pro (11-inch)", and "Apple Watch Series 5 - 44mm", by using the
    /// `xcrun` command in the Terminal app:
    ///
    ///     % xcrun simctl list devicetypes
    ///
    /// Additionally, you can use the following values for macOS platform
    /// development:
    /// - "Mac"
    /// - "Mac Catalyst"
    ///
    /// - Parameter value: A device to use for preview, or `nil` to let Xcode
    ///   automatically choose a device based on the run destination.
    /// - Returns: A preview that uses the given device.
    @inlinable nonisolated public func previewDevice(_ value: PreviewDevice?) -> some View


    /// Overrides the size of the container for the preview.
    ///
    /// By default, previews use the ``PreviewLayout/device`` layout,
    /// which places the view inside a visual representation of the chosen
    /// device. You can instead tell a preview to use a different layout
    /// by choosing one of the ``PreviewLayout`` values, like
    /// ``PreviewLayout/sizeThatFits``:
    ///
    ///     struct CircleImage_Previews: PreviewProvider {
    ///         static var previews: some View {
    ///             CircleImage()
    ///                 .previewLayout(.sizeThatFits)
    ///         }
    ///     }
    ///
    /// - Parameter value: A layout to use for preview.
    /// - Returns: A preview that uses the given layout.
    @inlinable nonisolated public func previewLayout(_ value: PreviewLayout) -> some View


    /// Sets a user visible name to show in the canvas for a preview.
    ///
    /// Apply this modifier to a view inside your ``PreviewProvider``
    /// implementation to associate a display name with that view's preview:
    ///
    ///     struct CircleImage_Previews: PreviewProvider {
    ///         static var previews: some View {
    ///             CircleImage()
    ///                 .previewDisplayName("Circle")
    ///         }
    ///     }
    ///
    /// ![A screenshot of the Xcode preview canvas cropped to just the top of a
    /// preview, highlighting the name in the preview's title bar, which is set
    /// to the word circle.](View-previewDisplayName-1)
    ///
    /// Add a name when you have multiple previews together in the canvas that
    /// you need to tell apart. The default value is `nil`, in which case
    /// Xcode displays a default string.
    ///
    /// - Parameter value: A name for the preview.
    /// - Returns: A preview that uses the given name.
    @inlinable nonisolated public func previewDisplayName(_ value: String?) -> some View


    /// Declares a context for the preview.
    ///
    /// - Parameter value: The context for the preview; the default is `nil`.
    @available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
    @inlinable nonisolated public func previewContext<C>(_ value: C) -> some View where C : PreviewContext


    /// Overrides the orientation of the preview.
    ///
    /// By default, device previews appear right side up, using orientation
    /// ``InterfaceOrientation/portrait``. You can
    /// change the orientation of a preview using one of the values in
    /// the ``InterfaceOrientation`` structure:
    ///
    ///     struct CircleImage_Previews: PreviewProvider {
    ///         static var previews: some View {
    ///             CircleImage()
    ///                 .previewInterfaceOrientation(.landscapeRight)
    ///         }
    ///     }
    ///
    /// - Parameter value: An orientation to use for preview.
    /// - Returns: A preview that uses the given orientation.
    @available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
    nonisolated public func previewInterfaceOrientation(_ value: InterfaceOrientation) -> some View

}

extension View {

    /// Associates an anchor to control which part of the scroll view's
    /// content should be rendered by default.
    ///
    /// Use this modifier to specify an anchor to control both which part of
    /// the scroll view's content should be visible initially and how
    /// the scroll view handles content size changes.
    ///
    /// Provide a value of `UnitPoint/center`` to have the scroll
    /// view start in the center of its content when a scroll view
    /// is scrollable in both axes.
    ///
    ///     ScrollView([.horizontal, .vertical]) {
    ///         // initially centered content
    ///     }
    ///     .defaultScrollAnchor(.center)
    ///
    /// Provide a value of `UnitPoint/bottom` to have the scroll view
    /// start at the bottom of its content when scrollable in the
    /// vertical axis.
    ///
    ///     @Binding var items: [Item]
    ///     @Binding var scrolledID: Item.ID?
    ///
    ///     ScrollView {
    ///         LazyVStack {
    ///             ForEach(items) { item in
    ///                 ItemView(item)
    ///             }
    ///         }
    ///     }
    ///     .defaultScrollAnchor(.bottom)
    ///
    /// The user may scroll away from the initial defined scroll position.
    /// When the content size of the scroll view changes, it may consult
    /// the anchor to know how to reposition the content.
    ///
    @available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
    nonisolated public func defaultScrollAnchor(_ anchor: UnitPoint?) -> some View

}

extension View {

    /// Associates an anchor to control the position of a scroll view in a
    /// particular circumstance.
    ///
    /// You can associate a ``UnitPoint`` to a ``ScrollView`` using the
    /// ``View/defaultScrollAnchor(_:)`` modifier. By default, the system
    /// uses this point for different kinds of behaviors including:
    ///   - Where the scroll view should initially be scrolled
    ///   - How the scroll view should handle content size or
    ///     container size changes
    ///   - How the scroll view should align content smaller than
    ///     its container size
    ///
    /// You can further customize this behavior by assigning different unit
    /// points for these different cases.
    ///
    /// For example, you can use the ``View/defaultScrollAnchor(_:)`` modifier
    /// to provide a value of ``UnitPoint/bottom`` as the anchor for all cases
    /// and then opt out of certain cases by providing a different value
    /// for them.
    ///
    ///     @Binding var items: [Item]
    ///     @Binding var scrolledID: Item.ID?
    ///
    ///     ScrollView {
    ///         LazyVStack {
    ///             ForEach(items) { item in
    ///                 ItemView(item)
    ///             }
    ///         }
    ///     }
    ///     .defaultScrollAnchor(.bottom)
    ///     .defaultScrollAnchor(.topLeading, for: .alignment)
    ///
    @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
    nonisolated public func defaultScrollAnchor(_ anchor: UnitPoint?, for role: ScrollAnchorRole) -> some View

}

@available(iOS 13.0, macOS 10.15, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension View {

    /// Presents a popover using the given item as a data source for the
    /// popover's content.
    ///
    /// Use this method when you need to present a popover with content
    /// from a custom data source. The example below uses data in
    /// the `PopoverModel` structure to populate the view in the `content`
    /// closure that the popover displays to the user:
    ///
    ///     struct PopoverExample: View {
    ///         @State private var popover: PopoverModel?
    ///
    ///         var body: some View {
    ///             Button("Show Popover") {
    ///                 popover = PopoverModel(message: "Custom Message")
    ///             }
    ///             .popover(item: $popover, arrowEdge: .bottom) { detail in
    ///                 Text("\(detail.message)")
    ///                     .padding()
    ///             }
    ///         }
    ///     }
    ///
    ///     struct PopoverModel: Identifiable {
    ///         var id: String { message }
    ///         let message: String
    ///     }
    ///
    /// ![A screenshot showing a popover that says Custom Message hovering
    /// over a Show Popover button.](View-popover-2)
    ///
    /// - Important: Prior to iOS 18, the popover arrow edge was not respected.
    /// Apps that are re-compiled with the iOS 18 or later SDK or visionOS 2 or
    /// later SDK and run on iOS 18 or later or visionOS 2 or later have the
    /// arrow edge respected. On macOS, arrow edge has always been respected.
    /// Alternatively, to allow the system to choose the
    /// best orientation of the popover's arrow, use the
    /// ```View/popover(item:attachmentAnchor:content:)``` variant.
    ///
    /// - Parameters:
    ///   - item: A binding to an optional source of truth for the popover.
    ///     When `item` is non-`nil`, the system passes the contents to
    ///     the modifier's closure. You use this content to populate the fields
    ///     of a popover that you create that the system displays to the user.
    ///     If `item` changes, the system dismisses the currently presented
    ///     popover and replaces it with a new popover using the same process.
    ///   - attachmentAnchor: The positioning anchor that defines the
    ///     attachment point of the popover. The default is
    ///     ``Anchor/Source/bounds``.
    ///   - arrowEdge: The edge of the `attachmentAnchor` that defines the
    ///     location of the popover's arrow. The default is
    ///     ``Edge/top``.
    ///   - content: A closure returning the content of the popover.
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    nonisolated public func popover<Item, Content>(item: Binding<Item?>, attachmentAnchor: PopoverAttachmentAnchor = .rect(.bounds), arrowEdge: Edge = .top, @ViewBuilder content: @escaping (Item) -> Content) -> some View where Item : Identifiable, Content : View


    /// Presents a popover using the given item as a data source for the
    /// popover's content.
    ///
    /// Use this method when you need to present a popover with content
    /// from a custom data source. The example below uses data in
    /// the `PopoverModel` structure to populate the view in the `content`
    /// closure that the popover displays to the user:
    ///
    ///     struct PopoverExample: View {
    ///         @State private var popover: PopoverModel?
    ///
    ///         var body: some View {
    ///             Button("Show Popover") {
    ///                 popover = PopoverModel(message: "Custom Message")
    ///             }
    ///             .popover(item: $popover) { detail in
    ///                 Text("\(detail.message)")
    ///                     .padding()
    ///             }
    ///         }
    ///     }
    ///
    ///     struct PopoverModel: Identifiable {
    ///         var id: String { message }
    ///         let message: String
    ///     }
    ///
    /// ![A screenshot showing a popover that says Custom Message hovering
    /// over a Show Popover button.](View-popover-2)
    ///
    /// Use this modifier if you want the system to choose the best orientation
    /// of the popover's arrow. If you want to specify a particular edge for the
    /// arrow, use
    /// ``View/popover(item:attachmentAnchor:arrowEdge:content:)``.
    ///
    /// - Parameters:
    ///   - item: A binding to an optional source of truth for the popover.
    ///     When `item` is non-`nil`, the system passes the contents to
    ///     the modifier's closure. You use this content to populate the fields
    ///     of a popover that you create that the system displays to the user.
    ///     If `item` changes, the system dismisses the currently presented
    ///     popover and replaces it with a new popover using the same process.
    ///   - attachmentAnchor: The positioning anchor that defines the
    ///     attachment point of the popover. The default is
    ///     ``Anchor/Source/bounds``.
    ///   - content: A closure returning the content of the popover.
    @available(iOS 18.0, macOS 15.0, visionOS 2.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    nonisolated public func popover<Item, Content>(item: Binding<Item?>, attachmentAnchor: PopoverAttachmentAnchor = .rect(.bounds), @ViewBuilder content: @escaping (Item) -> Content) -> some View where Item : Identifiable, Content : View


    /// Presents a popover when a given condition is true.
    ///
    /// Use this method to show a popover whose contents are a SwiftUI view
    /// that you provide when a bound Boolean variable is `true`. In the
    /// example below, a popover displays whenever the user toggles
    /// the `isShowingPopover` state variable by pressing the
    /// "Show Popover" button:
    ///
    ///     struct PopoverExample: View {
    ///         @State private var isShowingPopover = false
    ///
    ///         var body: some View {
    ///             Button("Show Popover") {
    ///                 self.isShowingPopover = true
    ///             }
    ///             .popover(
    ///                 isPresented: $isShowingPopover, arrowEdge: .bottom
    ///             ) {
    ///                 Text("Popover Content")
    ///                     .padding()
    ///             }
    ///         }
    ///     }
    ///
    /// ![A screenshot showing a popover that says Popover Content hovering
    /// over a Show Popover button.](View-popover-1)
    ///
    /// - Important: Prior to iOS 18, the popover arrow edge was not respected.
    /// Apps that are re-compiled with the iOS 18 or later SDK or visionOS 2 or
    /// later SDK and run on iOS 18 or later or visionOS 2 or later have the
    /// arrow edge respected. On macOS, arrow edge has always been respected.
    /// Alternatively, to allow the system to choose the
    /// best orientation of the popover's arrow, use the
    /// ```View/popover(isPresented:attachmentAnchor:content:)``` variant.
    ///
    /// - Parameters:
    ///   - isPresented: A binding to a Boolean value that determines whether
    ///     to present the popover content that you return from the modifier's
    ///     `content` closure.
    ///   - attachmentAnchor: The positioning anchor that defines the
    ///     attachment point of the popover. The default is
    ///     ``Anchor/Source/bounds``.
    ///   - arrowEdge: The edge of the `attachmentAnchor` that defines the
    ///     location of the popover's arrow. The default is
    ///     ``Edge/top``.
    ///   - content: A closure returning the content of the popover.
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    nonisolated public func popover<Content>(isPresented: Binding<Bool>, attachmentAnchor: PopoverAttachmentAnchor = .rect(.bounds), arrowEdge: Edge = .top, @ViewBuilder content: @escaping () -> Content) -> some View where Content : View


    /// Presents a popover when a given condition is true.
    ///
    /// Use this method to show a popover whose contents are a SwiftUI view
    /// that you provide when a bound Boolean variable is `true`. In the
    /// example below, a popover displays whenever the user toggles
    /// the `isShowingPopover` state variable by pressing the
    /// "Show Popover" button:
    ///
    ///     struct PopoverExample: View {
    ///         @State private var isShowingPopover = false
    ///
    ///         var body: some View {
    ///             Button("Show Popover") {
    ///                 self.isShowingPopover = true
    ///             }
    ///             .popover(
    ///                 isPresented: $isShowingPopover
    ///             ) {
    ///                 Text("Popover Content")
    ///                     .padding()
    ///             }
    ///         }
    ///     }
    ///
    /// ![A screenshot showing a popover that says Popover Content hovering
    /// over a Show Popover button.](View-popover-1)
    ///
    /// Use this modifier if you want the system to choose the best orientation
    /// of the popover's arrow. If you want to specify a particular edge for the
    /// arrow, use
    /// ``View/popover(isPresented:attachmentAnchor:arrowEdge:content:)``.
    ///
    /// - Parameters:
    ///   - isPresented: A binding to a Boolean value that determines whether
    ///     to present the popover content that you return from the modifier's
    ///     `content` closure.
    ///   - attachmentAnchor: The positioning anchor that defines the
    ///     attachment point of the popover. The default is
    ///     ``Anchor/Source/bounds``.
    ///   - content: A closure returning the content of the popover.
    @available(iOS 18.0, macOS 15.0, visionOS 2.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    nonisolated public func popover<Content>(isPresented: Binding<Bool>, attachmentAnchor: PopoverAttachmentAnchor = .rect(.bounds), @ViewBuilder content: @escaping () -> Content) -> some View where Content : View

}

extension View {

    /// Sets the visibility of scroll indicators within this view.
    ///
    /// Use this modifier to hide or show scroll indicators on scrollable
    /// content in views like a ``ScrollView``, ``List``, or ``TextEditor``.
    /// This modifier applies the prefered visibility to any
    /// scrollable content within a view hierarchy.
    ///
    ///     ScrollView {
    ///         VStack(alignment: .leading) {
    ///             ForEach(0..<100) {
    ///                 Text("Row \($0)")
    ///             }
    ///         }
    ///     }
    ///     .scrollIndicators(.hidden)
    ///
    /// Use the ``ScrollIndicatorVisibility/hidden`` value to indicate that you
    /// prefer that views never show scroll indicators along a given axis.
    /// Use ``ScrollIndicatorVisibility/visible`` when you prefer that
    /// views show scroll indicators. Depending on platform conventions,
    /// visible scroll indicators might only appear while scrolling. Pass
    /// ``ScrollIndicatorVisibility/automatic`` to allow views to
    /// decide whether or not to show their indicators.
    ///
    /// - Parameters:
    ///   - visibility: The visibility to apply to scrollable views.
    ///   - axes: The axes of scrollable views that the visibility applies to.
    ///
    /// - Returns: A view with the specified scroll indicator visibility.
    @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
    nonisolated public func scrollIndicators(_ visibility: ScrollIndicatorVisibility, axes: Axis.Set = [.vertical, .horizontal]) -> some View

}

extension View {

    /// Enables or disables scrolling in scrollable views when using particular
    /// inputs.
    ///
    /// In contrast to ``View/scrollDisabled(_:)``, this modifier will enable
    /// or disable scrolling only for particular inputs. The following, for
    /// instance, disables double-tap-to-scroll on watchOS while preserving
    /// the ability to scroll via touch and the Digital Crown:
    ///
    ///     ScrollView(...)
    ///         .scrollInputBehavior(.disabled, for: .handGestureShortcut)
    ///
    /// If `scrollDisabled(true)` has been applied to this view, scrolling will
    /// be disabled for all inputs and this modifier cannot be used to re-enable
    /// scrolling.
    ///
    /// - Parameters:
    ///     - behavior: Whether scrolling should be enabled or disabled for this
    ///     input.
    ///     - input: The input for which to enable or disable scrolling.
    @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
    @MainActor @preconcurrency public func scrollInputBehavior(_ behavior: ScrollInputBehavior, for input: ScrollInputKind) -> some View

}

extension EnvironmentValues {

    /// The visiblity to apply to scroll indicators of any
    /// vertically scrollable content.
    @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
    public var verticalScrollIndicatorVisibility: ScrollIndicatorVisibility

    /// The visibility to apply to scroll indicators of any
    /// horizontally scrollable content.
    @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
    public var horizontalScrollIndicatorVisibility: ScrollIndicatorVisibility
}

extension View {

    /// Flashes the scroll indicators of scrollable views when a value changes.
    ///
    /// When the value that you provide to this modifier changes, the scroll
    /// indicators of any scrollable views within the modified view hierarchy
    /// briefly flash. The following example configures the scroll indicators
    /// to flash any time `flashCount` changes:
    ///
    ///     @State private var isPresented = false
    ///     @State private var flashCount = 0
    ///
    ///     ScrollView {
    ///         // ...
    ///     }
    ///     .scrollIndicatorsFlash(trigger: flashCount)
    ///     .sheet(isPresented: $isPresented) {
    ///         // ...
    ///     }
    ///     .onChange(of: isPresented) { newValue in
    ///         if newValue {
    ///             flashCount += 1
    ///         }
    ///     }
    ///
    /// Only scroll indicators that you configure to be visible flash.
    /// To flash scroll indicators when a scroll view initially appears,
    /// use ``View/scrollIndicatorsFlash(onAppear:)`` instead.
    ///
    /// - Parameter value: The value that causes scroll indicators to flash.
    ///   The value must conform to the
    ///   <doc://com.apple.documentation/documentation/Swift/Equatable>
    ///   protocol.
    ///
    /// - Returns: A view that flashes any visible scroll indicators when a
    ///   value changes.
    @available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
    nonisolated public func scrollIndicatorsFlash(trigger value: some Equatable) -> some View


    /// Flashes the scroll indicators of a scrollable view when it appears.
    ///
    /// Use this modifier to control whether the scroll indicators of a scroll
    /// view briefly flash when the view first appears. For example, you can
    /// make the indicators flash by setting the `onAppear` parameter to `true`:
    ///
    ///     ScrollView {
    ///         // ...
    ///     }
    ///     .scrollIndicatorsFlash(onAppear: true)
    ///
    /// Only scroll indicators that you configure to be visible flash.
    /// To flash scroll indicators when a value changes, use
    /// ``View/scrollIndicatorsFlash(trigger:)`` instead.
    ///
    /// - Parameter onAppear: A Boolean value that indicates whether the scroll
    ///   indicators flash when the scroll view appears.
    ///
    /// - Returns: A view that flashes any visible scroll indicators when it
    ///   first appears.
    @available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
    nonisolated public func scrollIndicatorsFlash(onAppear: Bool) -> some View

}

extension View {

    /// Disables or enables scrolling in scrollable views.
    ///
    /// Use this modifier to control whether a ``ScrollView`` can scroll:
    ///
    ///     @State private var isScrollDisabled = false
    ///
    ///     var body: some View {
    ///         ScrollView {
    ///             VStack {
    ///                 Toggle("Disable", isOn: $isScrollDisabled)
    ///                 MyContent()
    ///             }
    ///         }
    ///         .scrollDisabled(isScrollDisabled)
    ///     }
    ///
    /// SwiftUI passes the disabled property through the environment, which
    /// means you can use this modifier to disable scrolling for all scroll
    /// views within a view hierarchy. In the following example, the modifier
    /// affects both scroll views:
    ///
    ///      ScrollView {
    ///          ForEach(rows) { row in
    ///              ScrollView(.horizontal) {
    ///                  RowContent(row)
    ///              }
    ///          }
    ///      }
    ///      .scrollDisabled(true)
    ///
    /// You can also use this modifier to disable scrolling for other kinds
    /// of scrollable views, like a ``List`` or a ``TextEditor``.
    ///
    /// - Parameter disabled: A Boolean that indicates whether scrolling is
    ///   disabled.
    @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
    nonisolated public func scrollDisabled(_ disabled: Bool) -> some View

}

extension EnvironmentValues {

    /// A Boolean value that indicates whether any scroll views associated
    /// with this environment allow scrolling to occur.
    ///
    /// The default value is `true`. Use the ``View/scrollDisabled(_:)``
    /// modifier to configure this property.
    @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
    public var isScrollEnabled: Bool
}

extension View {

    /// Sets whether a scroll view clips its content to its bounds.
    ///
    /// By default, a scroll view clips its content to its bounds, but you can
    /// disable that behavior by using this modifier. For example, if the views
    /// inside the scroll view have shadows that extend beyond the bounds of the
    /// scroll view, you can use this modifier to avoid clipping the shadows:
    ///
    ///     struct ContentView: View {
    ///         var disabled: Bool
    ///         let colors: [Color] = [.red, .green, .blue, .mint, .teal]
    ///
    ///         var body: some View {
    ///             ScrollView(.horizontal) {
    ///                 HStack(spacing: 20) {
    ///                     ForEach(colors, id: \.self) { color in
    ///                         Rectangle()
    ///                             .frame(width: 100, height: 100)
    ///                             .foregroundStyle(color)
    ///                             .shadow(color: .primary, radius: 20)
    ///                     }
    ///                 }
    ///             }
    ///             .scrollClipDisabled(disabled)
    ///         }
    ///     }
    ///
    /// The scroll view in the above example clips when the
    /// content view's `disabled` input is `false`, as it does
    /// if you omit the modifier, but not when the input is `true`:
    ///
    /// @TabNavigator {
    ///     @Tab("True") {
    ///         ![A horizontal row of uniformly sized, evenly spaced, vertically aligned squares inside a bounding box that's about twice the height of the squares, and almost four times the width. From left to right, three squares appear in full, while only the first quarter of a fourth square appears at the far right. All the squares have shadows that fade away before reaching the top or the bottom of the bounding box.](View-scrollClipDisabled-1-iOS)
    ///     }
    ///     @Tab("False") {
    ///         ![A horizontal row of uniformly sized, evenly spaced, vertically aligned squares inside a bounding box that's about twice the height of the squares, and almost four times the width. From left to right, three squares appear in full, while only the first quarter of a fourth square appears at the far right. All the squares have shadows that are visible in between squares, but clipped at the top and bottom of the squares.](View-scrollClipDisabled-2-iOS)
    ///     }
    /// }
    ///
    /// While you might want to avoid clipping parts of views that exceed the
    /// bounds of the scroll view, like the shadows in the above example, you
    /// typically still want the scroll view to clip at some point.
    /// Create custom clipping by using the ``View/clipShape(_:style:)``
    /// modifier to add a different clip shape. The following code disables
    /// the default clipping and then adds rectangular clipping that exceeds
    /// the bounds of the scroll view by the default padding amount:
    ///
    ///     ScrollView(.horizontal) {
    ///         // ...
    ///     }
    ///     .scrollClipDisabled()
    ///     .padding()
    ///     .clipShape(Rectangle())
    ///
    /// - Parameter disabled: A Boolean value that specifies whether to disable
    ///   scroll view clipping.
    ///
    /// - Returns: A view that disables or enables scroll view clipping.
    @available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
    nonisolated public func scrollClipDisabled(_ disabled: Bool = true) -> some View

}

extension View {

    /// Configures the behavior in which scrollable content interacts with
    /// the software keyboard.
    ///
    /// You use this modifier to customize how scrollable content interacts
    /// with the software keyboard. For example, you can specify a value of
    /// ``ScrollDismissesKeyboardMode/immediately`` to indicate that you
    /// would like scrollable content to immediately dismiss the keyboard if
    /// present when a scroll drag gesture begins.
    ///
    ///     @State private var text = ""
    ///
    ///     ScrollView {
    ///         TextField("Prompt", text: $text)
    ///         ForEach(0 ..< 50) { index in
    ///             Text("\(index)")
    ///                 .padding()
    ///         }
    ///     }
    ///     .scrollDismissesKeyboard(.immediately)
    ///
    /// You can also use this modifier to customize the keyboard dismissal
    /// behavior for other kinds of scrollable views, like a ``List`` or a
    /// ``TextEditor``.
    ///
    /// By default, a ``TextEditor`` is interactive while other kinds
    /// of scrollable content always dismiss the keyboard on a scroll
    /// when linked against iOS 16 or later. Pass a value of
    /// ``ScrollDismissesKeyboardMode/never`` to indicate that scrollable
    /// content should never automatically dismiss the keyboard.
    ///
    /// - Parameter mode: The keyboard dismissal mode that scrollable content
    ///   uses.
    ///
    /// - Returns: A view that uses the specified keyboard dismissal mode.
    @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
    @available(visionOS, unavailable)
    nonisolated public func scrollDismissesKeyboard(_ mode: ScrollDismissesKeyboardMode) -> some View

}

extension EnvironmentValues {

    /// The way that scrollable content interacts with the software keyboard.
    ///
    /// The default value is ``ScrollDismissesKeyboardMode/automatic``. Use the
    /// ``View/scrollDismissesKeyboard(_:)`` modifier to configure this
    /// property.
    @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
    @available(visionOS, unavailable)
    public var scrollDismissesKeyboardMode: ScrollDismissesKeyboardMode
}

extension View {

    /// Configures the bounce behavior of scrollable views along the specified
    /// axis.
    ///
    /// Use this modifier to indicate whether scrollable views bounce when
    /// people scroll to the end of the view's content, taking into account the
    /// relative sizes of the view and its content. For example, the following
    /// ``ScrollView`` only enables bounce behavior if its content is large
    /// enough to require scrolling:
    ///
    ///     ScrollView {
    ///         Text("Small")
    ///         Text("Content")
    ///     }
    ///     .scrollBounceBehavior(.basedOnSize)
    ///
    /// The modifier passes the scroll bounce mode through the ``Environment``,
    /// which means that the mode affects any scrollable views in the modified
    /// view hierarchy. Provide an axis to the modifier to constrain the kinds
    /// of scrollable views that the mode affects. For example, all the scroll
    /// views in the following example can access the mode value, but
    /// only the two nested scroll views are affected, because only they use
    /// horizontal scrolling:
    ///
    ///     ScrollView { // Defaults to vertical scrolling.
    ///         ScrollView(.horizontal) {
    ///             ShelfContent()
    ///         }
    ///         ScrollView(.horizontal) {
    ///             ShelfContent()
    ///         }
    ///     }
    ///     .scrollBounceBehavior(.basedOnSize, axes: .horizontal)
    ///
    /// You can use this modifier to configure any kind of scrollable view,
    /// including ``ScrollView``, ``List``, ``Table``, and ``TextEditor``:
    ///
    ///     List {
    ///         Text("Hello")
    ///         Text("World")
    ///     }
    ///     .scrollBounceBehavior(.basedOnSize)
    ///
    /// - Parameters:
    ///   - behavior: The bounce behavior to apply to any scrollable views
    ///     within the configured view. Use one of the ``ScrollBounceBehavior``
    ///     values.
    ///   - axes: The set of axes to apply `behavior` to. The default is
    ///     ``Axis/vertical``.
    ///
    /// - Returns: A view that's configured with the specified scroll bounce
    ///   behavior.
    @available(iOS 16.4, macOS 13.3, tvOS 16.4, watchOS 9.4, *)
    nonisolated public func scrollBounceBehavior(_ behavior: ScrollBounceBehavior, axes: Axis.Set = [.vertical]) -> some View

}

extension EnvironmentValues {

    /// The scroll bounce mode for the vertical axis of scrollable views.
    ///
    /// Use the ``View/scrollBounceBehavior(_:axes:)`` view modifier to set this
    /// value in the ``Environment``.
    @available(iOS 16.4, macOS 13.3, tvOS 16.4, watchOS 9.4, *)
    public var verticalScrollBounceBehavior: ScrollBounceBehavior

    /// The scroll bounce mode for the horizontal axis of scrollable views.
    ///
    /// Use the ``View/scrollBounceBehavior(_:axes:)`` view modifier to set this
    /// value in the ``Environment``.
    @available(iOS 16.4, macOS 13.3, tvOS 16.4, watchOS 9.4, *)
    public var horizontalScrollBounceBehavior: ScrollBounceBehavior
}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension View {

    /// Explicitly set whether this accessibility element is a direct touch
    /// area. Direct touch areas passthrough touch events to the app rather
    /// than being handled through an assistive technology, such as VoiceOver.
    /// The modifier accepts an optional `AccessibilityDirectTouchOptions`
    /// option set to customize the functionality of the direct touch area.
    ///
    /// For example, this is how a direct touch area would allow a VoiceOver
    /// user to interact with a view with a `rotationEffect` controlled by a
    /// `RotationGesture`. The direct touch area would require a user to
    /// activate the area before using the direct touch area.
    ///
    ///     var body: some View {
    ///         Rectangle()
    ///             .frame(width: 200, height: 200, alignment: .center)
    ///             .rotationEffect(angle)
    ///             .gesture(rotation)
    ///             .accessibilityDirectTouch(options: .requiresActivation)
    ///     }
    ///
    nonisolated public func accessibilityDirectTouch(_ isDirectTouchArea: Bool = true, options: AccessibilityDirectTouchOptions = []) -> ModifiedContent<Self, AccessibilityAttachmentModifier>
}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension ModifiedContent where Modifier == AccessibilityAttachmentModifier {

    /// Explicitly set whether this accessibility element is a direct touch
    /// area. Direct touch areas passthrough touch events to the app rather
    /// than being handled through an assistive technology, such as VoiceOver.
    /// The modifier accepts an optional `AccessibilityDirectTouchOptions`
    /// option set to customize the functionality of the direct touch area.
    ///
    /// For example, this is how a direct touch area would allow a VoiceOver
    /// user to interact with a view with a `rotationEffect` controlled by a
    /// `RotationGesture`. The direct touch area would require a user to
    /// activate the area before using the direct touch area.
    ///
    ///     var body: some View {
    ///         Rectangle()
    ///             .frame(width: 200, height: 200, alignment: .center)
    ///             .rotationEffect(angle)
    ///             .gesture(rotation)
    ///             .accessibilityDirectTouch(options: .requiresActivation)
    ///     }
    ///
    nonisolated public func accessibilityDirectTouch(_ isDirectTouchArea: Bool = true, options: AccessibilityDirectTouchOptions = []) -> ModifiedContent<Content, Modifier>
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension View {

    /// Sets the tint effect for content in a list.
    ///
    /// The containing list's style applies the tint as appropriate. For
    /// example, watchOS uses the tint color for its background platter
    /// appearance. Sidebars on iOS and macOS apply the tint color to their
    /// ``Label`` icons, which otherwise use the accent color by default.
    ///
    /// - Parameter tint: The tint effect to use. Use `nil` to avoid  overriding
    ///   the inherited tint.
    @inlinable nonisolated public func listItemTint(_ tint: ListItemTint?) -> some View


    /// Sets a fixed tint color for content in a list.
    ///
    /// The containing list's style applies the tint as appropriate. For
    /// example, watchOS uses the tint color for its background platter
    /// appearance. Sidebars on iOS and macOS apply the tint color to their
    /// ``Label`` icons, which otherwise use the accent color by default.
    ///
    /// > Note: This modifier is equivalent to using the version of the modifier
    ///   that takes a ``ListItemTint`` value and specifying the `tint` color in
    ///   the corresponding ``ListItemTint/fixed(_:)`` input.
    ///
    /// - Parameter tint: The color to use to tint the content. Use `nil` to
    ///   avoid overriding the inherited tint.
    @inlinable nonisolated public func listItemTint(_ tint: Color?) -> some View

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// Hides the labels of any controls contained within this view.
    ///
    /// Use this modifier when you want to omit a label from one or more
    /// controls in your user interface. For example, the first ``Toggle`` in
    /// the following example hides its label:
    ///
    ///     VStack {
    ///         Toggle(isOn: $toggle1) {
    ///             Text("Toggle 1")
    ///         }
    ///         .labelsHidden()
    ///
    ///         Toggle(isOn: $toggle2) {
    ///             Text("Toggle 2")
    ///         }
    ///     }
    ///
    /// The ``VStack`` in the example above centers the first toggle's control
    /// element in the available space, while it centers the second toggle's
    /// combined label and control element:
    ///
    /// ![A screenshot showing a view with two toggle controls where one label
    ///   is visible and the other label is hidden.](View-labelsHidden-1.png)
    ///
    /// Always provide a label for controls, even when you hide the label,
    /// because SwiftUI uses labels for other purposes, including accessibility.
    ///
    /// > Note: This modifier doesn't work for all labels. It applies to
    ///   labels that are separate from the rest of the control's interface,
    ///   like they are for ``Toggle``, but not to controls like a bordered
    ///   button where the label is inside the button's border.
    nonisolated public func labelsHidden() -> some View

}

extension View {

    /// Sets the container background of the enclosing container using a view.
    ///
    /// The following example uses a ``LinearGradient`` as a background:
    ///
    ///     struct ContentView: View {
    ///         var body: some View {
    ///             NavigationStack {
    ///                 List {
    ///                     NavigationLink("Blue") {
    ///                         Text("Blue")
    ///                         .containerBackground(.blue.gradient, for: .navigation)
    ///                     }
    ///                     NavigationLink("Red") {
    ///                         Text("Red")
    ///                         .containerBackground(.red.gradient, for: .navigation)
    ///                     }
    ///                 }
    ///             }
    ///         }
    ///     }
    ///
    /// The `.containerBackground(_:for:)` modifier differs from the
    /// ``View/background(_:ignoresSafeAreaEdges:)`` modifier by automatically
    /// filling an entire parent container. ``ContainerBackgroundPlacement``
    /// describes the available containers.
    ///
    /// - Parameters
    ///   - style: The shape style to use as the container background.
    ///   - container: The container that will use the background.
    @available(iOS 17.0, tvOS 17.0, macOS 14.0, watchOS 10.0, *)
    nonisolated public func containerBackground<S>(_ style: S, for container: ContainerBackgroundPlacement) -> some View where S : ShapeStyle


    /// Sets the container background of the enclosing container using a view.
    ///
    /// The following example uses a custom ``View`` as a background:
    ///
    ///     struct ContentView: View {
    ///         var body: some View {
    ///             NavigationStack {
    ///                 List {
    ///                     NavigationLink("Image") {
    ///                         Text("Image")
    ///                         .containerBackground(for: .navigation) {
    ///                             Image(name: "ImageAsset")
    ///                         }
    ///                     }
    ///                 }
    ///             }
    ///         }
    ///     }
    ///
    /// The `.containerBackground(for:alignment:content:)` modifier differs from
    /// the ``View/background(_:ignoresSafeAreaEdges:)`` modifier by
    /// automatically filling an entire parent container.
    /// ``ContainerBackgroundPlacement`` describes the available containers.
    ///
    /// - Parameters:
    ///   - alignment: The alignment that the modifier uses to position the
    ///     implicit ``ZStack`` that groups the background views. The default is
    ///     ``Alignment/center``.
    ///   - container: The container that will use the background.
    ///   - content: The view to use as the background of the container.
    @available(iOS 17.0, tvOS 17.0, macOS 14.0, watchOS 10.0, *)
    nonisolated public func containerBackground<V>(for container: ContainerBackgroundPlacement, alignment: Alignment = .center, @ViewBuilder content: () -> V) -> some View where V : View

}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension ForEach {

    /// Creates an instance that uniquely identifies and creates views across
    /// updates based on the subviews of a given view.
    ///
    /// Subviews are proxies to the resolved view they represent, meaning
    /// that modifiers applied to the original view will be applied before
    /// modifiers applied to the subview, and the view is resolved
    /// using the environment of its container, *not* the environment of the
    /// its subview proxy. Additionally, because subviews must represent a
    /// single leaf view, or container, a subview may represent a view after the
    /// application of styles. As such, attempting to apply a style to it may
    /// have no affect.
    ///
    /// - Parameters:
    ///   - view: The view to extract the subviews of.
    ///   - content: The view builder that creates views from subviews.
    public init<V>(subviews view: V, @ViewBuilder content: @escaping (Subview) -> Content) where Data == ForEachSubviewCollection<Content>, ID == Subview.ID, Content : View, V : View
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// Sets the style for pickers within this view.
    nonisolated public func pickerStyle<S>(_ style: S) -> some View where S : PickerStyle

}

@available(iOS 17.0, watchOS 10.0, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
extension View {

    /// Sets the spacing between adjacent sections in a ``List``.
    ///
    /// Pass `.default` for the default spacing, or use `.compact` for
    /// a compact appearance between sections.
    ///
    /// The following example creates a ``List`` with compact spacing between
    /// sections:
    ///
    ///     List {
    ///         Section("Colors") {
    ///             Text("Blue")
    ///             Text("Red")
    ///         }
    ///
    ///         Section("Shapes") {
    ///             Text("Square")
    ///             Text("Circle")
    ///         }
    ///     }
    ///     .listSectionSpacing(.compact)
    ///
    /// Spacing can also be specified on an individual ``Section``, as in this
    /// example:
    ///
    ///     Section("Borders") {
    ///         Text("Dashed")
    ///         Text("Solid")
    ///     }
    ///     .listSectionSpacing(.compact)
    ///
    /// Spacing applied on sections in the ``List`` overrides spacing applied on
    /// the ``List`` as a whole.
    ///
    /// - Parameter spacing: the ``ListSectionSpacing`` to apply.
    @inlinable nonisolated public func listSectionSpacing(_ spacing: ListSectionSpacing) -> some View


    /// Sets the spacing between adjacent sections in a ``List`` to a custom
    /// value.
    ///
    /// The following example creates a ``List`` with 5 pts of spacing between
    /// sections:
    ///
    ///     List {
    ///         Section("Colors") {
    ///             Text("Blue")
    ///             Text("Red")
    ///         }
    ///
    ///         Section("Shapes") {
    ///             Text("Square")
    ///             Text("Circle")
    ///         }
    ///     }
    ///     .listSectionSpacing(5.0)
    ///
    /// Spacing can also be specified on an individual ``Section``, as in this
    /// example:
    ///
    ///     Section("Borders") {
    ///         Text("Dashed")
    ///         Text("Solid")
    ///     }
    ///     .listSectionSpacing(10.0)
    ///
    /// If adjacent sections have different spacing applied, each section
    /// applies half its spacing above and below. Sections without
    /// explicit spacing apply the spacing of their adjacent sections.
    ///
    ///     List {
    ///         Section("Colors") {
    ///             Text("Blue")
    ///             Text("Red")
    ///         }
    ///
    ///         Section("Borders") {
    ///             Text("Dashed")
    ///             Text("Solid")
    ///         }
    ///         .listSectionSpacing(10.0)
    ///
    ///         Section("Shapes") {
    ///             Text("Square")
    ///             Text("Circle")
    ///         }
    ///         .listSectionSpacing(100.0)
    ///     }
    ///
    /// In the above example, the "Colors" and "Borders" section are separated
    /// by 10 pts of spacing, and the "Borders" and "Shapes" section are
    /// separated by 55 pts of spacing.
    ///
    /// Spacing applied on sections in the ``List`` overrides spacing applied on
    /// the ``List`` as a whole.
    ///
    /// - Parameter spacing: the amount of spacing to apply.
    @inlinable nonisolated public func listSectionSpacing(_ spacing: CGFloat) -> some View

}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension View {

    /// Specifies whether to hide this view from system accessibility features.
    ///
    /// - Parameters:
    ///   - hidden: Whether to hide this view from accessibility features.
    ///   - isEnabled: If true the accessibility hidden state is applied;
    ///     otherwise the accessibility hidden state is unchanged.
    nonisolated public func accessibilityHidden(_ hidden: Bool, isEnabled: Bool) -> ModifiedContent<Self, AccessibilityAttachmentModifier>
}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension ModifiedContent where Modifier == AccessibilityAttachmentModifier {

    /// Specifies whether to hide this view from system accessibility features.
    ///
    /// - Parameters:
    ///   - hidden: Whether to hide this view from accessibility features.
    ///   - isEnabled: If true the accessibility hidden state is applied;
    ///     otherwise the accessibility hidden state is unchanged.
    nonisolated public func accessibilityHidden(_ hidden: Bool, isEnabled: Bool) -> ModifiedContent<Content, Modifier>
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension View {

    /// Specifies whether to hide this view from system accessibility features.
    nonisolated public func accessibilityHidden(_ hidden: Bool) -> ModifiedContent<Self, AccessibilityAttachmentModifier>
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ModifiedContent where Modifier == AccessibilityAttachmentModifier {

    /// Specifies whether to hide this view from system accessibility features.
    nonisolated public func accessibilityHidden(_ hidden: Bool) -> ModifiedContent<Content, Modifier>
}

@available(iOS 18.0, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@available(visionOS, unavailable)
extension Never : ControlWidgetConfiguration {
}

extension View {

    /// Adds to a `DocumentLaunchView` actions that accept
    /// a list of selected files as their parameter.
    ///
    /// Add `documentBrowserContextMenu` modifier to ``DocumentLaunchView``
    /// to provide additional actions to the document browser items' context menu.
    /// For example, a book editor application could have a "Favorite" button
    /// that marks user-chosen books as their favorite. The button enables when the user
    /// switches the browser into "Selection" mode.
    ///
    ///     import UniformTypeIdentifiers
    ///
    ///     struct BookEditor: View {
    ///
    ///         var body: some View {
    ///             DocumentLaunchView(for: [.book]) {
    ///                 NewDocumentButton("Start New Book")
    ///             } onDocumentOpen: { url in
    ///                 BookEditor(url)
    ///             }
    ///             .documentBrowserContextMenu { selectedURLs in
    ///                 FavoriteBookButton(urls: selectedURLs)
    ///             }
    ///         }
    ///     }
    ///
    ///     struct FavoriteBookButton: View {
    ///         var urls: [URL]?
    ///         var body: some View {
    ///             Button {
    ///                 updateFavorite(urls)
    ///             } label: {
    ///                 Image(systemName: allFavorite(urls) ? "heart.fill" : "heart")
    ///             }
    ///         }
    ///
    ///         func allFavorite(_ urls: [URL]?) -> Bool { ... }
    ///         func updateFavorite(_ urls: [URL]?) { ... }
    ///     }
    ///
    ///     struct BookEditor: View {
    ///         init(_ url: URL) { ... }
    ///     }
    ///
    ///     extension UTType {
    ///         static var book = UTType(exportedAs: "com.example.bookEditor")
    ///     }
    ///
    /// In the example above, the application stores a list of URLs to favorite books,
    /// and does not need to access the file on disk. In cases when an application wants to read
    /// the contents of the URL from the disk or associated metadata, it should call
    /// ``URL.startAccessingSecurityScopedResource()`` to gain access to the resource,
    /// and ``URL.stopAccessingSecurityScopedResource()`` to relinquish access when it is not needed.
    ///
    /// The actions are displayed in the document browser navigation bar
    /// when a document browser is in Select mode, and also added to
    /// context menu for the file items.
    ///
    /// - Parameters:
    ///   - menu: Items representing the content of the menu.
    @available(iOS 18.1, *)
    @available(macOS, unavailable)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    @MainActor @preconcurrency public func documentBrowserContextMenu(@ViewBuilder _ menu: @escaping ([URL]?) -> some View) -> some View

}

@available(iOS 17.5, macOS 14.5, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
@available(visionOS, unavailable)
extension View {

    /// Adds an action to perform after the user double-taps their Apple Pencil.
    ///
    /// You should respect peoples setting for the double-tap gesture by
    /// reading the ``EnvironmentValues/preferredPencilDoubleTapAction``
    /// environment value, if the setting makes sense in your app. If it
    /// doesnt, consider giving people a way to specify custom behavior in your
    /// app instead.
    ///
    /// In the example below, double-tapping an Apple Pencil will
    ///
    /// - do nothing if this is what the user selected in the Settings app,
    /// - switch the tool to Lasso if this is the action they have configured
    ///   in the app,
    /// - switch the tool to Eraser if they havent configured a custom action
    ///   in the app and this is what they selected in the Settings app,
    /// - switch the tool to the last used one otherwise.
    ///
    /// ```
    /// enum MyDrawingTool: Equatable {
    ///     case brush
    ///     case lasso
    ///     case eraser
    ///     ...
    /// }
    ///
    /// enum MyPencilAction: String {
    ///     case switchLasso
    ///     ...
    /// }
    ///
    /// @State private var currentTool = MyDrawingTool.brush
    /// @State private var lastTool: MyDrawingTool?
    ///
    /// @Environment(\.preferredPencilDoubleTapAction) private var globalAction
    /// @AppStorage("customPencilDoubleTapAction") private var customAction: MyPencilAction?
    ///
    /// var body: some View {
    ///     MyDrawingCanvas()
    ///         .onPencilDoubleTap { _ in
    ///             guard globalAction != .ignore else {
    ///                 // Respect the users preference to ignore the double-tap gesture.
    ///                 return
    ///             }
    ///             if let customAction {
    ///                 // If a custom action is configured, respect it.
    ///                 if customAction == .switchLasso, currentTool != .lasso {
    ///                      (currentTool, lastTool) = (.lasso, currentTool)
    ///                 }
    ///             } else if globalAction == .switchEraser, currentTool != .eraser {
    ///                 // Switch to eraser if the user prefers it otherwise.
    ///                 (currentTool, lastTool) = (.eraser, currentTool)
    ///             } else if let lastTool {
    ///                 // Switch to the last used tool by default.
    ///                 (currentTool, lastTool) = (lastTool, currentTool)
    ///             }
    ///         }
    /// }
    /// ```
    ///
    /// For more information about Apple Pencil double-tap gestures, see
    /// [Human Interface Guidelines](https://developer.apple.com/design/human-interface-guidelines/apple-pencil-and-scribble#Double-tap).
    ///
    /// > Note: If multiple views with the `onPencilDoubleTap` view modifier
    /// > are visible, all their action closures will be performed after the
    /// > user double-taps their Apple Pencil.
    ///
    /// - Parameters:
    ///     - action: The action to perform after the user double-taps their
    ///       Apple Pencil.
    ///
    /// - Returns: A view that performs `action` after the user double-taps
    ///   their Apple Pencil.
    nonisolated public func onPencilDoubleTap(perform action: @escaping (_ value: PencilDoubleTapGestureValue) -> Void) -> some View

}

@available(iOS 17.5, macOS 14.5, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
@available(visionOS, unavailable)
extension View {

    /// Adds an action to perform when the user squeezes their Apple Pencil.
    ///
    /// You should respect peoples setting for the squeeze gesture by reading
    /// the ``EnvironmentValues/preferredPencilSqueezeAction`` environment
    /// value, if the setting makes sense in your app. If it doesnt, consider
    /// giving people a way to specify custom behavior in your app instead.
    ///
    /// In the example below, completing an Apple Pencil squeeze gesture will
    ///
    /// - do nothing if this is what the user selected in the Settings app,
    /// - switch the tool to Lasso if this is the action they have configured
    ///   in the app,
    /// - spill the ink if this is the action they have configured in the app,
    /// - present a custom contextual palette if they havent configured a
    ///   custom action in the app and this is what they selected in the
    ///   Settings app.
    ///
    /// ```
    /// enum MyPencilAction: String {
    ///     case spillInk
    ///     ...
    /// }
    ///
    /// @Environment(\.preferredPencilSqueezeAction) private var preferredAction
    /// @AppStorage("customPencilSqueezeAction") private var customAction: MyPencilAction?
    ///
    /// @State private var contextualPaletteAnchor: PopoverAttachmentAnchor?
    /// @State private var contextualPalettePresented = false
    ///
    /// var body: some View {
    ///     MyDrawingCanvas()
    ///         .onPencilSqueeze { phase in
    ///             guard preferredAction != .ignore else {
    ///                 // Skip if this is what the user prefers.
    ///                 return
    ///             }
    ///             if let customAction {
    ///                 // If a custom action is configured, respect it.
    ///                 if customAction == .spillInk {
    ///                     switch phase {
    ///                         // Spill the ink while the user is squeezing their Apple Pencil.
    ///                     }
    ///                 }
    ///             } else if preferredAction == .showContextualPalette, case let .ended(value) = phase {
    ///                 // Present a custom contextual palette if the user prefers it.
    ///                 contextualPaletteAnchor = value.hoverPose?.anchor.map { .point($0) }
    ///                 contextualPalettePresented = true
    ///             }
    ///         }
    ///         .popover(
    ///             isPresented: $contextualPalettePresented,
    ///             attachmentAnchor: contextualPaletteAnchor ?? .point(.center)
    ///         ) {
    ///             MyContextualPalette()
    ///         }
    /// ```
    ///
    /// > Note: If multiple views with the `onPencilSqueeze` view modifier
    /// > are visible, all their action closures will be performed when the
    /// > user squeezes their Apple Pencil.
    ///
    /// - Parameters:
    ///     - action: The action to perform when the user squeezes their
    ///       Apple Pencil.
    ///
    /// - Returns: A view that performs `action` when the user squeezes
    ///   their Apple Pencil.
    nonisolated public func onPencilSqueeze(perform action: @escaping (_ phase: PencilSqueezeGesturePhase) -> Void) -> some View

}

extension View {

    /// Adds an action to perform when the scroll phase of the first scroll
    /// view in the hierarchy changes.
    ///
    /// Use this modifier to be informed of changes to a scroll view's
    /// phase. A scroll view may be in a variety of different phases like
    /// panning or decelerating. See ``ScrollPhase`` for more information
    /// on the phases of a scroll view.
    ///
    /// When the phase of a scroll view changes, the system invokes the action
    /// you provide. In the following example, a selection binding is updated
    /// when the scroll view transitions to the ``ScrollPhase/decelerating``
    /// or ``ScrollPhase/idle`` phase.
    ///
    ///     @Binding var selection: SelectionValue?
    ///
    ///     ScrollView {
    ///         // ...
    ///     }
    ///     .onScrollPhaseChange { _, newPhase in
    ///         if newPhase == .decelerating || newPhase == .idle {
    ///             selection = updateSelection()
    ///         }
    ///     }
    ///
    /// The system can also provide you with the geometry of the scroll view
    /// at the time of the phase change. You can use the geometry to
    /// understand where the scroll view has come or gone between the
    /// phase changes and update dependent state on that information.
    /// In the following example, whether toolbar content is hidden is
    /// determined based on the direction of the last user initiated
    /// scroll.
    ///
    ///     @Binding var hidesToolbarContent: Bool
    ///     @State private var lastOffset: CGFloat = 0.0
    ///
    ///     ScrollView {
    ///         // ...
    ///     }
    ///     .onScrollPhaseChange { oldPhase, newPhase, context in
    ///         if newPhase == .panning {
    ///             lastOffset = context.geometry.contentOffset.y
    ///         }
    ///         if oldPhase == .panning, newPhase != .animating,
    ///             context.geometry.contentOffset.y - lastOffset < 0.0
    ///         {
    ///             hidesToolbarContent = true
    ///         } else {
    ///             hidesToolbarContent = false
    ///         }
    ///     }
    ///
    /// If multiple scroll views are found within the view hierarchy,
    /// only the first one will invoke the closure you provide and a runtime
    /// issue will be logged. For example, in the following view, only the
    /// vertical scroll view will have its phase changes invoke the provided
    /// closure.
    ///
    ///     VStack {
    ///         ScrollView(.vertical) { ... }
    ///         ScrollView(.horizontal) { ... }
    ///     }
    ///     .onScrollPhaseChange { ... }
    ///
    /// - Parameters:
    ///   - action: A closure to run when the scroll phase changes.
    ///   - oldPhase: The old scroll phase.
    ///   - newPhase: The new scroll phase.
    ///   - geometry: The scroll geometry at the time of the scroll
    ///     phase change.
    @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
    nonisolated public func onScrollPhaseChange(_ action: @escaping (_ oldPhase: ScrollPhase, _ newPhase: ScrollPhase) -> Void) -> some View


    /// Adds an action to perform when the scroll phase of the first scroll
    /// view in the hierarchy changes.
    ///
    /// Use this modifier to be informed of changes to a scroll view's
    /// phase. A scroll view may be in a variety of different phases like
    /// interacting or decelerating. See ``ScrollPhase`` for more information
    /// on the phases of a scroll view.
    ///
    /// When the phase of a scroll view changes, the system invokes the action
    /// you provide. In the following example, a selection binding is updated
    /// when the scroll view transitions to the ``ScrollPhase/decelerating``
    /// or ``ScrollPhase/idle`` phase.
    ///
    ///     @Binding var selection: SelectionValue?
    ///
    ///     ScrollView {
    ///         // ...
    ///     }
    ///     .onScrollPhaseChange { _, newPhase in
    ///         if newPhase == .decelerating || newPhase == .idle {
    ///             selection = updateSelection()
    ///         }
    ///     }
    ///
    /// The system can also provide you with a context containing
    /// the geometry of the scroll view at the time of the phase change.
    /// You can use the geometry to understand where the scroll view
    /// has come or gone between the phase changes and update
    /// dependent state on that information. In the following example,
    /// whether toolbar content is hidden is determined based on
    /// the direction of the last user initiated scroll.
    ///
    ///     @Binding var hidesToolbarContent: Bool
    ///     @State private var lastOffset: CGFloat = 0.0
    ///
    ///     ScrollView {
    ///         // ...
    ///     }
    ///     .onScrollPhaseChange { oldPhase, newPhase, context in
    ///         if newPhase == .interacting {
    ///             lastOffset = context.geometry.contentOffset.y
    ///         }
    ///         if oldPhase == .interacting, newPhase != .animating,
    ///             context.geometry.contentOffset.y - lastOffset < 0.0
    ///         {
    ///             hidesToolbarContent = true
    ///         } else {
    ///             hidesToolbarContent = false
    ///         }
    ///     }
    ///
    /// If multiple scroll views are found within the view hierarchy,
    /// only the first one will invoke the closure you provide and a runtime
    /// issue will be logged. For example, in the following view, only the
    /// vertical scroll view will have its phase changes invoke the provided
    /// closure.
    ///
    ///     VStack {
    ///         ScrollView(.vertical) { ... }
    ///         ScrollView(.horizontal) { ... }
    ///     }
    ///     .onScrollPhaseChange { ... }
    ///
    /// - Parameters:
    ///   - action: A closure to run when the scroll phase changes.
    ///   - oldPhase: The old scroll phase.
    ///   - newPhase: The new scroll phase.
    ///   - context: The phase context at the time of the scroll
    ///     phase change.
    @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
    nonisolated public func onScrollPhaseChange(_ action: @escaping (_ oldPhase: ScrollPhase, _ newPhase: ScrollPhase, _ context: ScrollPhaseChangeContext) -> Void) -> some View


    /// Adds an action to be performed when a value, created from a
    /// scroll geometry, changes.
    ///
    /// The geometry of a scroll view changes frequently while scrolling.
    /// You should avoid updating large parts of your app whenever
    /// the scroll geometry changes. To aid in this, you provide two
    /// closures to this modifier:
    ///   * transform: This converts a value of ``ScrollGeometry`` to a
    ///     your own data type.
    ///   * action: This provides the data type you created in `of`
    ///     and is called whenever the data type changes.
    ///
    /// For example, you can use this modifier to know when the user scrolls
    /// a scroll view beyond the top of its content. In the following example,
    /// the data type you convert to is a ``Bool`` and the action is called
    /// whenever the ``Bool`` changes.
    ///
    ///     @Binding var isBeyondZero: Bool
    ///
    ///     ScrollView {
    ///         // ...
    ///     }
    ///     .onScrollGeometryChange(for: Bool.self) { geometry in
    ///         geometry.contentOffset.y < geometry.contentInsets.top
    ///     } action: { wasBeyondZero, isBeyondZero in
    ///         self.isBeyondZero = isBeyondZero
    ///     }
    ///
    /// If multiple scroll views are found within the view hierarchy,
    /// only the first one will invoke the closure you provide and a runtime
    /// issue will be logged. For example, in the following view, only the
    /// vertical scroll view will have its geometry changes invoke the provided
    /// closure.
    ///
    ///     VStack {
    ///         ScrollView(.vertical) { ... }
    ///         ScrollView(.horizontal) { ... }
    ///     }
    ///     .onScrollGeometryChange(for: Bool.self) { geometry in
    ///          ...
    ///     } action: { oldValue, newValue in
    ///         ...
    ///     }
    ///
    /// For responding to non-scroll geometry changes, see the
    /// ``View/onGeometryChange(for:of:action:)`` modifier.
    ///
    /// - Parameters:
    ///   - type: The type of value transformed from a ``ScrollGeometry``.
    ///   - transform: A closure that transforms a ``ScrollGeometry``
    ///     to your type.
    ///   - action: A closure to run when the transformed data changes.
    ///   - oldValue: The old value that failed the comparison check.
    ///   - newValue: The new value that failed the comparison check.
    @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
    nonisolated public func onScrollGeometryChange<T>(for type: T.Type, of transform: @escaping (ScrollGeometry) -> T, action: @escaping (_ oldValue: T, _ newValue: T) -> Void) -> some View where T : Equatable

}

extension View {

    /// Tells a menu whether to dismiss after performing an action.
    ///
    /// Use this modifier to control the dismissal behavior of a menu.
    /// In the example below, the menu doesn't dismiss after someone
    /// chooses either the increase or decrease action:
    ///
    ///     Menu("Font size") {
    ///         Button(action: increase) {
    ///             Label("Increase", systemImage: "plus.magnifyingglass")
    ///         }
    ///         .menuActionDismissBehavior(.disabled)
    ///
    ///         Button("Reset", action: reset)
    ///
    ///         Button(action: decrease) {
    ///             Label("Decrease", systemImage: "minus.magnifyingglass")
    ///         }
    ///         .menuActionDismissBehavior(.disabled)
    ///     }
    ///
    /// You can use this modifier on any controls that present a menu, like a
    /// ``Picker`` that uses the ``PickerStyle/menu`` style or a
    /// ``ControlGroup``. For example, the code below creates a picker that
    /// disables dismissal when someone selects one of the options:
    ///
    ///     Picker("Flavor", selection: $selectedFlavor) {
    ///         ForEach(Flavor.allCases) { flavor in
    ///             Text(flavor.rawValue.capitalized)
    ///                 .tag(flavor)
    ///         }
    ///     }
    ///     .pickerStyle(.menu)
    ///     .menuActionDismissBehavior(.disabled)
    ///
    /// You can also use this modifier on context menus. The example below
    /// creates a context menu that stays presented after someone selects an
    /// action to run:
    ///
    ///     Text("Favorite Card Suit")
    ///         .padding()
    ///         .contextMenu {
    ///             Button(" - Hearts", action: increaseHeartsCount)
    ///             Button(" - Clubs", action: increaseClubsCount)
    ///             Button(" - Spades", action: increaseSpadesCount)
    ///             Button(" - Diamonds", action: increaseDiamondsCount)
    ///         }
    ///         .menuActionDismissBehavior(.disabled)
    ///
    /// - Parameter dismissal: The menu action dismissal behavior to apply.
    ///
    /// - Returns: A view that has the specified menu dismissal behavior.
    @available(iOS 16.4, macOS 13.3, tvOS 16.4, watchOS 9.4, *)
    nonisolated public func menuActionDismissBehavior(_ behavior: MenuActionDismissBehavior) -> some View

}

@available(iOS 18.0, macOS 15.0, visionOS 2.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension View {

    /// Adds a custom header to the sidebar of a tab view.
    ///
    /// The header appears at the top of the sidebar before
    /// any tab labels and can scroll with the content. The header is
    /// only visible when the ``TabView`` is displaying the sidebar.
    ///
    /// The following example adds a welcome message to
    /// the top of the sidebar:
    ///
    ///     TabView {
    ///         Tab("Home", systemImage: "house") {
    ///             HomeView()
    ///         }
    ///
    ///         Tab("Alerts", systemImage: "bell") {
    ///             AlertsView()
    ///         }
    ///
    ///         Tab("Browse", systemImage: "list.bullet") {
    ///             MyBrowseView()
    ///         }
    ///     }
    ///     .tabViewStyle(.sidebarAdaptable)
    ///     .tabViewSidebarHeader {
    ///         WelcomeHeaderView()
    ///     }
    ///
    /// > Note: To have a sidebar, a``TabView`` needs the
    ///   ``TabViewStyle/sidebarAdaptable`` style.
    nonisolated public func tabViewSidebarHeader<Content>(@ViewBuilder content: () -> Content) -> some View where Content : View


    /// Adds a custom footer to the sidebar of a tab view.
    ///
    /// The footer appears at the bottom of the sidebar after
    /// any tab labels and can scroll with the content. The footer is
    /// only visible when the ``TabView`` is displaying the sidebar.
    ///
    /// The following example adds a link to contact support to
    /// the bottom of the sidebar content:
    ///
    ///     TabView {
    ///         Tab("Home", systemImage: "house") {
    ///             HomeView()
    ///         }
    ///
    ///         Tab("Alerts", systemImage: "bell") {
    ///             AlertsView()
    ///         }
    ///
    ///         Tab("Browse", systemImage: "list.bullet") {
    ///             MyBrowseView()
    ///         }
    ///     }
    ///     .tabViewStyle(.sidebarAdaptable)
    ///     .tabViewSidebarFooter {
    ///         ContactSupportLink()
    ///     }
    ///
    nonisolated public func tabViewSidebarFooter<Content>(@ViewBuilder content: () -> Content) -> some View where Content : View


    /// Adds a custom bottom bar to the sidebar of a tab view.
    ///
    /// The content is pinned at the bottom of the sidebar, so it's
    /// always visible when the sidebar is visible and doesn't
    /// scroll with the content.
    ///
    /// The following example adds an account button to
    /// the bottom of the sidebar:
    ///
    ///     TabView {
    ///         Tab("Home", systemImage: "house") {
    ///             HomeView()
    ///         }
    ///
    ///         Tab("Alerts", systemImage: "bell") {
    ///             AlertsView()
    ///         }
    ///
    ///         Tab("Browse", systemImage: "list.bullet") {
    ///             MyBrowseView()
    ///         }
    ///     }
    ///     .tabViewStyle(.sidebarAdaptable)
    ///     .tabViewSidebarBottomBar {
    ///         AccountButton()
    ///     }
    ///
    nonisolated public func tabViewSidebarBottomBar<Content>(@ViewBuilder content: () -> Content) -> some View where Content : View

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension Group : Scene where Content : Scene {

    /// Creates a group of scenes.
    ///
    /// - Parameter content: A ``SwiftUI/SceneBuilder`` that produces the scenes
    /// to group.
    @inlinable nonisolated public init(@SceneBuilder content: () -> Content)
}

@available(iOS 16.0, macOS 13.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension Optional : TableRowContent where Wrapped : TableRowContent {

    /// The type of value represented by this table row content.
    public typealias TableRowValue = Wrapped.TableRowValue

    public typealias TableRowBody = Never
}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension View {

    /// Sets alternate input labels with which users identify a view.
    ///
    /// Provide labels in descending order of importance. Voice Control
    /// and Full Keyboard Access use the input labels.
    ///
    /// > Note: If you don't specify any input labels, the user can still
    ///   refer to the view using the accessibility label that you add with the
    ///   `accessibilityLabel()` modifier.
    ///
    /// - Parameters:
    ///   - inputLabels: The accessibility input labels to apply.
    ///   - isEnabled: If true the accessibility input labels are applied;
    ///     otherwise the accessibility input labels are unchanged.
    nonisolated public func accessibilityInputLabels(_ inputLabels: [Text], isEnabled: Bool) -> ModifiedContent<Self, AccessibilityAttachmentModifier>

    /// Sets alternate input labels with which users identify a view.
    ///
    /// Provide labels in descending order of importance. Voice Control
    /// and Full Keyboard Access use the input labels.
    ///
    /// > Note: If you don't specify any input labels, the user can still
    ///   refer to the view using the accessibility label that you add with the
    ///   `accessibilityLabel()` modifier.
    ///
    /// - Parameters:
    ///   - inputLabelKeys: The accessibility input labels to apply.
    ///   - isEnabled: If true the accessibility input labels are applied;
    ///     otherwise the accessibility input labels are unchanged.
    nonisolated public func accessibilityInputLabels(_ inputLabelKeys: [LocalizedStringKey], isEnabled: Bool) -> ModifiedContent<Self, AccessibilityAttachmentModifier>

    /// Sets alternate input labels with which users identify a view.
    ///
    /// Provide labels in descending order of importance. Voice Control
    /// and Full Keyboard Access use the input labels.
    ///
    /// > Note: If you don't specify any input labels, the user can still
    ///   refer to the view using the accessibility label that you add with the
    ///   `accessibilityLabel()` modifier.
    ///
    /// - Parameters:
    ///   - inputLabels: The accessibility input labels to apply.
    ///   - isEnabled: If true the accessibility input labels are applied;
    ///     otherwise the accessibility input labels are unchanged.
    nonisolated public func accessibilityInputLabels<S>(_ inputLabels: [S], isEnabled: Bool) -> ModifiedContent<Self, AccessibilityAttachmentModifier> where S : StringProtocol
}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension ModifiedContent where Modifier == AccessibilityAttachmentModifier {

    /// Sets alternate input labels with which users identify a view.
    ///
    /// Provide labels in descending order of importance. Voice Control
    /// and Full Keyboard Access use the input labels.
    ///
    /// > Note: If you don't specify any input labels, the user can still
    ///   refer to the view using the accessibility label that you add with the
    ///   `accessibilityLabel()` modifier.
    ///
    /// - Parameters:
    ///   - inputLabels: The accessibility input labels to apply.
    ///   - isEnabled: If true the accessibility input labels are applied;
    ///     otherwise the accessibility input labels are unchanged.
    nonisolated public func accessibilityInputLabels(_ inputLabels: [Text], isEnabled: Bool) -> ModifiedContent<Content, Modifier>

    /// Sets alternate input labels with which users identify a view.
    ///
    /// Provide labels in descending order of importance. Voice Control
    /// and Full Keyboard Access use the input labels.
    ///
    /// > Note: If you don't specify any input labels, the user can still
    ///   refer to the view using the accessibility label that you add with the
    ///   `accessibilityLabel()` modifier.
    ///
    /// - Parameters:
    ///   - inputLabelKeys: The accessibility input labels to apply.
    ///   - isEnabled: If true the accessibility input labels are applied;
    ///     otherwise the accessibility input labels are unchanged.
    nonisolated public func accessibilityInputLabels(_ inputLabelKeys: [LocalizedStringKey], isEnabled: Bool) -> ModifiedContent<Content, Modifier>

    /// Sets alternate input labels with which users identify a view.
    ///
    /// Provide labels in descending order of importance. Voice Control
    /// and Full Keyboard Access use the input labels.
    ///
    /// > Note: If you don't specify any input labels, the user can still
    ///   refer to the view using the accessibility label that you add with the
    ///   `accessibilityLabel()` modifier.
    ///
    /// - Parameters:
    ///   - inputLabels: The accessibility input labels to apply.
    ///   - isEnabled: If true the accessibility input labels are applied;
    ///     otherwise the accessibility input labels are unchanged.
    nonisolated public func accessibilityInputLabels<S>(_ inputLabels: [S], isEnabled: Bool) -> ModifiedContent<Content, Modifier> where S : StringProtocol
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension View {

    /// Sets alternate input labels with which users identify a view.
    ///
    /// Provide labels in descending order of importance. Voice Control
    /// and Full Keyboard Access use the input labels.
    ///
    /// > Note: If you don't specify any input labels, the user can still
    ///   refer to the view using the accessibility label that you add with the
    ///   `accessibilityLabel()` modifier.
    ///
    /// - Parameter inputLabels: An array of Text elements to use as input labels.
    nonisolated public func accessibilityInputLabels(_ inputLabels: [Text]) -> ModifiedContent<Self, AccessibilityAttachmentModifier>

    /// Sets alternate input labels with which users identify a view.
    ///
    /// Provide labels in descending order of importance. Voice Control
    /// and Full Keyboard Access use the input labels.
    ///
    /// > Note: If you don't specify any input labels, the user can still
    ///   refer to the view using the accessibility label that you add with the
    ///   `accessibilityLabel()` modifier.
    nonisolated public func accessibilityInputLabels(_ inputLabelKeys: [LocalizedStringKey]) -> ModifiedContent<Self, AccessibilityAttachmentModifier>

    /// Sets alternate input labels with which users identify a view.
    ///
    /// Provide labels in descending order of importance. Voice Control
    /// and Full Keyboard Access use the input labels.
    ///
    /// > Note: If you don't specify any input labels, the user can still
    ///   refer to the view using the accessibility label that you add with the
    ///   `accessibilityLabel()` modifier.
    nonisolated public func accessibilityInputLabels<S>(_ inputLabels: [S]) -> ModifiedContent<Self, AccessibilityAttachmentModifier> where S : StringProtocol
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ModifiedContent where Modifier == AccessibilityAttachmentModifier {

    /// Sets alternate input labels with which users identify a view.
    ///
    /// If you don't specify any input labels, the user can still refer to the
    /// view using the accessibility label that you add with the
    /// accessibilityLabel() modifier. Provide labels in descending order
    /// of importance. Voice Control and Full Keyboard Access use the input
    /// labels.
    nonisolated public func accessibilityInputLabels(_ inputLabels: [Text]) -> ModifiedContent<Content, Modifier>

    /// Sets alternate input labels with which users identify a view.
    ///
    /// Provide labels in descending order of importance. Voice Control
    /// and Full Keyboard Access use the input labels.
    ///
    /// > Note: If you don't specify any input labels, the user can still
    ///   refer to the view using the accessibility label that you add with the
    ///   `accessibilityLabel()` modifier.
    nonisolated public func accessibilityInputLabels(_ inputLabelKeys: [LocalizedStringKey]) -> ModifiedContent<Content, Modifier>

    /// Sets alternate input labels with which users identify a view.
    ///
    /// Provide labels in descending order of importance. Voice Control
    /// and Full Keyboard Access use the input labels.
    ///
    /// > Note: If you don't specify any input labels, the user can still
    ///   refer to the view using the accessibility label that you add with the
    ///   `accessibilityLabel()` modifier.
    nonisolated public func accessibilityInputLabels<S>(_ inputLabels: [S]) -> ModifiedContent<Content, Modifier> where S : StringProtocol
}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension View {

    /// Associates a fully formed string with the value of this view when used
    /// as a search suggestion.
    ///
    /// Use this method to associate a fully formed string with a
    /// view that is within a search suggestion list context. The system
    /// uses this value when the view is selected to replace the
    /// partial text being currently edited of the associated search field.
    ///
    /// On tvOS, the string that you provide to the this modifier is
    /// used when displaying the associated suggestion and when
    /// replacing the partial text of the search field.
    ///
    ///     SearchPlaceholderView()
    ///         .searchable(text: $text) {
    ///             Text("").searchCompletion("apple")
    ///             Text("").searchCompletion("pear")
    ///             Text("").searchCompletion("banana")
    ///         }
    ///
    /// - Parameters:
    ///   - text: A string to use as the views completion.
    nonisolated public func searchCompletion(_ completion: String) -> some View

}

extension View {

    /// Associates a search token with the value of this view when used
    /// as a search suggestion.
    ///
    /// Use this method to associate a search token with a view that is
    /// within a search suggestion list context. The system uses this value
    /// when the view is selected to replace the partial text being currently
    /// edited of the associated search field.
    ///
    ///     enum FruitToken: Hashable, Identifiable, CaseIterable {
    ///         case apple
    ///         case pear
    ///         case banana
    ///
    ///         var id: Self { self }
    ///     }
    ///
    ///     @State private var text = ""
    ///     @State private var tokens: [FruitToken] = []
    ///
    ///     SearchPlaceholderView()
    ///         .searchable(text: $text, tokens: $tokens) { token in
    ///             switch token {
    ///             case .apple: Text("Apple")
    ///             case .pear: Text("Pear")
    ///             case .banana: Text("Banana")
    ///             }
    ///         }
    ///         .searchSuggestions {
    ///             Text("").searchCompletion(FruitToken.apple)
    ///             Text("").searchCompletion(FruitToken.pear)
    ///             Text("").searchCompletion(FruitToken.banana)
    ///         }
    ///
    /// - Parameters:
    ///   - token: Data to use as the views completion.
    @available(iOS 16.0, macOS 13.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    nonisolated public func searchCompletion<T>(_ token: T) -> some View where T : Identifiable


    /// Configures how to display search suggestions within this view.
    ///
    /// SwiftUI presents search suggestions differently depending on several
    /// factors, like the platform, the position of the search field, and the
    /// size class. Use this modifier when you want to only display suggestions
    /// in certain ways under certain conditions. For example, you might choose
    /// to display suggestions in a menu when possible, but directly filter
    /// your data source otherwise.
    ///
    ///     enum FruitSuggestion: String, Identifiable {
    ///         case apple, banana, orange
    ///         var id: Self { self }
    ///     }
    ///
    ///     @State private var text = ""
    ///     @State private var suggestions: [FruitSuggestion] = []
    ///
    ///     var body: some View {
    ///         MainContent()
    ///             .searchable(text: $text) {
    ///                 ForEach(suggestions) { suggestion
    ///                     Text(suggestion.rawValue)
    ///                         .searchCompletion(suggestion.rawValue)
    ///                 }
    ///                 .searchSuggestions(.hidden, for: .content)
    ///             }
    ///     }
    ///
    /// - Parameters:
    ///   - visibility: The visibility of the search suggestions
    ///     for the specified locations.
    ///   - placements: The set of locations in which to set the visibility of
    ///     search suggestions.
    @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
    nonisolated public func searchSuggestions(_ visibility: Visibility, for placements: SearchSuggestionsPlacement.Set) -> some View

}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension EnvironmentValues {

    /// A Boolean value that indicates when the user is searching.
    ///
    /// You can read this value like any of the other ``EnvironmentValues``,
    /// by creating a property with the ``Environment`` property wrapper:
    ///
    ///     @Environment(\.isSearching) private var isSearching
    ///
    /// Get the value to find out when the user interacts with a search
    /// field that's produced by one of the searchable modifiers, like
    /// ``View/searchable(text:placement:prompt:)``:
    ///
    ///     struct SearchingExample: View {
    ///         @State private var searchText = ""
    ///
    ///         var body: some View {
    ///             NavigationStack {
    ///                 SearchedView()
    ///                     .searchable(text: $searchText)
    ///             }
    ///         }
    ///     }
    ///
    ///     struct SearchedView: View {
    ///         @Environment(\.isSearching) private var isSearching
    ///
    ///         var body: some View {
    ///             Text(isSearching ? "Searching!" : "Not searching.")
    ///         }
    ///     }
    ///
    /// When the user first taps or clicks in a search field, the
    /// `isSearching` property becomes `true`. When the user cancels the
    /// search operation, the property becomes `false`. To programmatically
    /// set the value to `false` and dismiss the search operation, use
    /// ``EnvironmentValues/dismissSearch``.
    ///
    /// > Important: Access the value from inside the searched view, as the
    ///   example above demonstrates, rather than from the searched views
    ///   parent. SwiftUI sets the value in the environment of the view that
    ///   you apply the searchable modifier to, and doesnt propagate the
    ///   value up the view hierarchy.
    public var isSearching: Bool { get }

    /// An action that ends the current search interaction.
    ///
    /// Use this environment value to get the ``DismissSearchAction`` instance
    /// for the current ``Environment``. Then call the instance to dismiss
    /// the current search interaction. You call the instance directly because
    /// it defines a ``DismissSearchAction/callAsFunction()`` method that Swift
    /// calls when you call the instance.
    ///
    /// When you dismiss search, SwiftUI:
    ///
    /// * Sets ``EnvironmentValues/isSearching`` to `false`.
    /// * Clears any text from the search field.
    /// * Removes focus from the search field.
    ///
    /// > Note: Calling this instance has no effect if the user isn't
    /// interacting with a search field.
    ///
    /// Use this action to dismiss a search operation based on
    /// another user interaction. For example, consider a searchable
    /// view with a ``Button`` that presents more information about the first
    /// matching item from a collection:
    ///
    ///     struct ContentView: View {
    ///         @State private var searchText = ""
    ///
    ///         var body: some View {
    ///             NavigationStack {
    ///                 SearchedView(searchText: searchText)
    ///                     .searchable(text: $searchText)
    ///             }
    ///         }
    ///     }
    ///
    ///     private struct SearchedView: View {
    ///         let searchText: String
    ///
    ///         let items = ["a", "b", "c"]
    ///         var filteredItems: [String] { items.filter { $0 == searchText.lowercased() } }
    ///
    ///         @State private var isPresented = false
    ///         @Environment(\.dismissSearch) private var dismissSearch
    ///
    ///         var body: some View {
    ///             if let item = filteredItems.first {
    ///                 Button("Details about \(item)") {
    ///                     isPresented = true
    ///                 }
    ///                 .sheet(isPresented: $isPresented) {
    ///                     NavigationStack {
    ///                         DetailView(item: item, dismissSearch: dismissSearch)
    ///                     }
    ///                 }
    ///             }
    ///         }
    ///     }
    ///
    /// The button becomes visible only after the user enters search text
    /// that produces a match. When the user taps the button, SwiftUI shows
    /// a sheet that provides more information about the item, including
    /// an Add button for adding the item to a stored list of items:
    ///
    ///     private struct DetailView: View {
    ///         var item: String
    ///         var dismissSearch: DismissSearchAction
    ///
    ///         @Environment(\.dismiss) private var dismiss
    ///
    ///         var body: some View {
    ///             Text("Information about \(item).")
    ///                 .toolbar {
    ///                     Button("Add") {
    ///                         // Store the item here...
    ///
    ///                         dismiss()
    ///                         dismissSearch()
    ///                     }
    ///                 }
    ///         }
    ///     }
    ///
    /// People can dismiss the sheet by dragging it down, effectively
    /// canceling the operation, leaving the in-progress search interaction
    /// intact. Alternatively, people can tap the Add button to store the item.
    /// Because the person using your app is likely to be done with both the
    /// detail view and the search interaction at this point, the button's
    /// closure also uses the ``EnvironmentValues/dismiss`` property to dismiss
    /// the sheet, and the ``EnvironmentValues/dismissSearch`` property to
    /// reset the search field.
    ///
    /// > Important: Access the action from inside the searched view, as the
    ///   example above demonstrates, rather than from the searched views
    ///   parent, or another hierarchy, like that of a sheet. SwiftUI sets the
    ///   value in the environment of the view that you apply the searchable
    ///   modifier to, and doesnt propagate the value up the view hierarchy.
    public var dismissSearch: DismissSearchAction { get }

    /// The current placement of search suggestions.
    ///
    /// Search suggestions render based on the platform and surrounding context
    /// in which you place the searchable modifier containing suggestions.
    /// You can render search suggestions in two ways:
    ///
    /// * In a menu attached to the search field.
    /// * Inline with the main content of the app.
    ///
    /// You find the current search suggestion placement by querying the
    /// ``EnvironmentValues/searchSuggestionsPlacement`` in your
    /// search suggestions.
    ///
    ///     enum FruitSuggestion: String, Identifiable {
    ///         case apple, banana, orange
    ///         var id: Self { self }
    ///     }
    ///
    ///     @State private var text: String = ""
    ///     @State private var suggestions: [FruitSuggestion] = []
    ///
    ///     var body: some View {
    ///         MainContent()
    ///             .searchable(text: $text) {
    ///                 FruitSuggestions(suggestions: suggestions)
    ///             }
    ///     }
    ///
    ///     struct FruitSuggestions: View {
    ///         var suggestions: [FruitSuggestion]
    ///
    ///         @Environment(\.searchSuggestionsPlacement)
    ///         private var placement
    ///
    ///         var body: some View {
    ///             if shouldRender {
    ///                 ForEach(suggestions) { suggestion in
    ///                     Text(suggestion.rawValue.capitalized)
    ///                         .searchCompletion(suggestion.rawValue)
    ///                 }
    ///             }
    ///         }
    ///
    ///         var shouldRender: Bool {
    ///             #if os(iOS)
    ///             placement == .menu
    ///             #else
    ///             true
    ///             #endif
    ///         }
    ///     }
    ///
    /// In the above example, search suggestions only render in iOS
    /// if the searchable modifier displays them in a menu. You might want
    /// to do this to render suggestions in your own list alongside
    /// your own search results when they would render in a list.
    @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
    public var searchSuggestionsPlacement: SearchSuggestionsPlacement { get }
}

@available(iOS 15.0, macOS 12.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension ShapeStyle where Self == SelectionShapeStyle {

    /// A style used to visually indicate selection following platform conventional
    /// colors and behaviors.
    ///
    /// For example:
    ///
    ///     ForEach(items) {
    ///        ItemView(value: item, isSelected: item.id == selectedID)
    ///     }
    ///
    ///     struct ItemView {
    ///         var value: item
    ///         var isSelected: Bool
    ///
    ///         var body: some View {
    ///             // construct the actual cell content
    ///                 .background(isSelected
    ///                     ? AnyShapeStyle(.selection)
    ///                         : AnyShapeStyle(.fill.quaternary),
    ///                     in: .rect(cornerRadius: 6))
    ///         }
    ///     }
    ///
    /// On macOS and iPadOS this automatically reflects window key state and focus
    /// state, where the emphasized appearance will be used only when the window is
    /// key and the nearest focusable element is actually focused. On iPhone, this
    /// will always fill with the environment's accent color.
    ///
    /// When applied as a background of another view, it will automatically
    /// set the `EnvironmentValues.backgroundProminence` for the environment
    /// of that view to match the current prominence of the selection.
    ///
    /// For information about how to use shape styles, see ``ShapeStyle``.
    public static var selection: SelectionShapeStyle { get }
}

@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Image : Transferable {

    /// The representation used to import and export the item.
    ///
    /// A ``transferRepresentation`` can contain multiple representations
    /// for different content types.
    public static var transferRepresentation: some TransferRepresentation { get }

    /// The type of the representation used to import and export the item.
    ///
    /// Swift infers this type from the return value of the
    /// ``transferRepresentation`` property.
    @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
    public typealias Representation = some TransferRepresentation
}

extension View {

    /// Identifies this view as the source of a navigation transition, such
    /// as a zoom transition.
    ///
    /// - Parameters:
    ///   - id: The identifier, often derived from the identifier of
    ///     the data being displayed by the view.
    ///   - namespace: The namespace in which defines the `id`. New
    ///     namespaces are created by adding an ``Namespace`` variable
    ///     to a ``View`` type and reading its value in the view's body
    ///     method.
    @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
    nonisolated public func matchedTransitionSource(id: some Hashable, in namespace: Namespace.ID) -> some View


    /// Identifies this view as the source of a navigation transition, such
    /// as a zoom transition.
    ///
    /// The appearance of the source can be configured using the
    /// `configuration` trailing closure. Any modifiers applied will
    /// be smoothly interpolated when a zoom transition originates from
    /// this matched transition source.
    ///
    /// ```
    /// MyView()
    ///     .matchedTransitionSource(id: someID, in: someNamespace) { source in
    ///         source
    ///             .cornerRadius(8.0)
    ///     }
    /// ```
    ///
    /// - Parameters:
    ///   - id: The identifier, often derived from the identifier of
    ///     the data being displayed by the view.
    ///   - namespace: The namespace in which defines the `id`. New
    ///     namespaces are created by adding an ``Namespace`` variable
    ///     to a ``View`` type and reading its value in the view's body
    ///     method.
    ///   - configuration: A closure that you can use to apply styling to the source.
    @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
    nonisolated public func matchedTransitionSource(id: some Hashable, in namespace: Namespace.ID, configuration: (EmptyMatchedTransitionSourceConfiguration) -> some MatchedTransitionSourceConfiguration) -> some View

}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension View {

    /// Defines an explicit identifier tying an Accessibility element for this
    /// view to an entry in an Accessibility Rotor.
    ///
    /// Use this when creating an AccessibilityRotorEntry without a namespace
    /// does not allow SwiftUI to automatically find and reveal the element,
    /// or when the Rotor entry should be associated with a sub-element of
    /// a complex view generated in a ForEach, for example.
    ///
    /// - Parameter id: An arbitrary hashable identifier. Pass this same value
    /// when initializing an AccessibilityRotorEntry.
    /// - Parameter namespace: A namespace created with `@Namespace()`. Pass this
    /// same namespace when initializing an `AccessibilityRotorEntry`.
    nonisolated public func accessibilityRotorEntry<ID>(id: ID, in namespace: Namespace.ID) -> some View where ID : Hashable

}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension View {

    /// Sets the border shape for buttons in this view.
    ///
    /// The border shape is used to draw the platter for a bordered button.
    /// In macOS, some border shapes are only applicable to bordered
    /// buttons in widgets.
    ///
    /// The border shape affects buttons of the
    /// ``PrimitiveButtonStyle/bordered`` and
    /// ``PrimitiveButtonStyle/borderedProminent`` styles.
    ///
    /// - Parameter shape: The shape to use.
    @inlinable nonisolated public func buttonBorderShape(_ shape: ButtonBorderShape) -> some View

}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension Shape where Self == ButtonBorderShape {

    /// A shape that defers to the environment to determine the resolved button border shape.
    ///
    /// You can override the resolved shape in a given view hierarchy by using
    /// the ``View/buttonBorderShape(_:)`` modifier. If no button border shape
    /// is specified, it is resolved automatically for the given context and platform.
    public static var buttonBorder: ButtonBorderShape { get }
}

extension View {

    /// Assigns a name to the view's coordinate space, so other code can operate
    /// on dimensions like points and sizes relative to the named space.
    ///
    /// Use `coordinateSpace(name:)` to allow another function to find and
    /// operate on a view and operate on dimensions relative to that view.
    ///
    /// The example below demonstrates how a nested view can find and operate on
    /// its enclosing view's coordinate space:
    ///
    ///     struct ContentView: View {
    ///         @State private var location = CGPoint.zero
    ///
    ///         var body: some View {
    ///             VStack {
    ///                 Color.red.frame(width: 100, height: 100)
    ///                     .overlay(circle)
    ///                 Text("Location: \(Int(location.x)), \(Int(location.y))")
    ///             }
    ///             .coordinateSpace(name: "stack")
    ///         }
    ///
    ///         var circle: some View {
    ///             Circle()
    ///                 .frame(width: 25, height: 25)
    ///                 .gesture(drag)
    ///                 .padding(5)
    ///         }
    ///
    ///         var drag: some Gesture {
    ///             DragGesture(coordinateSpace: .named("stack"))
    ///                 .onChanged { info in location = info.location }
    ///         }
    ///     }
    ///
    /// Here, the ``VStack`` in the `ContentView` named stack is composed of a
    /// red frame with a custom ``Circle`` view ``View/overlay(_:alignment:)``
    /// at its center.
    ///
    /// The `circle` view has an attached ``DragGesture`` that targets the
    /// enclosing VStack's coordinate space. As the gesture recognizer's closure
    /// registers events inside `circle` it stores them in the shared `location`
    /// state variable and the ``VStack`` displays the coordinates in a ``Text``
    /// view.
    ///
    /// ![A screenshot showing an example of finding a named view and tracking
    /// relative locations in that view.](SwiftUI-View-coordinateSpace.png)
    ///
    /// - Parameter name: A name used to identify this coordinate space.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, message: "use coordinateSpace(_:) instead")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, message: "use coordinateSpace(_:) instead")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, message: "use coordinateSpace(_:) instead")
    @available(watchOS, introduced: 6.0, deprecated: 100000.0, message: "use coordinateSpace(_:) instead")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "use coordinateSpace(_:) instead")
    @inlinable nonisolated public func coordinateSpace<T>(name: T) -> some View where T : Hashable

}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension View {

    /// Assigns a name to the view's coordinate space, so other code can operate
    /// on dimensions like points and sizes relative to the named space.
    ///
    /// Use `coordinateSpace(_:)` to allow another function to find and
    /// operate on a view and operate on dimensions relative to that view.
    ///
    /// The example below demonstrates how a nested view can find and operate on
    /// its enclosing view's coordinate space:
    ///
    ///     struct ContentView: View {
    ///         @State private var location = CGPoint.zero
    ///
    ///         var body: some View {
    ///             VStack {
    ///                 Color.red.frame(width: 100, height: 100)
    ///                     .overlay(circle)
    ///                 Text("Location: \(Int(location.x)), \(Int(location.y))")
    ///             }
    ///             .coordinateSpace(.named("stack"))
    ///         }
    ///
    ///         var circle: some View {
    ///             Circle()
    ///                 .frame(width: 25, height: 25)
    ///                 .gesture(drag)
    ///                 .padding(5)
    ///         }
    ///
    ///         var drag: some Gesture {
    ///             DragGesture(coordinateSpace: .named("stack"))
    ///                 .onChanged { info in location = info.location }
    ///         }
    ///     }
    ///
    /// Here, the ``VStack`` in the `ContentView` named stack is composed of a
    /// red frame with a custom ``Circle`` view ``View/overlay(_:alignment:)``
    /// at its center.
    ///
    /// The `circle` view has an attached ``DragGesture`` that targets the
    /// enclosing VStack's coordinate space. As the gesture recognizer's closure
    /// registers events inside `circle` it stores them in the shared `location`
    /// state variable and the ``VStack`` displays the coordinates in a ``Text``
    /// view.
    ///
    /// ![A screenshot showing an example of finding a named view and tracking
    /// relative locations in that view.](SwiftUI-View-coordinateSpace.png)
    ///
    /// - Parameter name: A name used to identify this coordinate space.
    nonisolated public func coordinateSpace(_ name: NamedCoordinateSpace) -> some View

}

@available(iOS 18.0, tvOS 18.0, visionOS 2.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension CustomHoverEffect {

    /// Disables this hover effect.
    ///
    /// Use `hoverEffectDisabled(_:)` to prevent a hover effect from becoming
    /// active. When an effect is disabled, all contained effects are also
    /// disabled and cannot be re-enabled.
    ///
    /// In the following example, the scale effect is disabled if the
    /// `accessibilityReduceMotion` setting is enabled:
    ///
    ///
    ///     struct ScaleAndFadeEffect: CustomHoverEffect {
    ///         @Environment(\.accessibilityReduceMotion) var accessibilityReduceMotion
    ///         func body(content: Content) -> some CustomHoverEffect {
    ///             content.hoverEffect { effect, isActive, _ in
    ///                 effect.scaleEffect(!isActive ? 0.95 : 1.05)
    ///             }
    ///             .hoverEffectDisabled(accessibilityReduceMotion)
    ///             .hoverEffect { effect, isActive, _ in
    ///                 effect.opacity(!isActive ? 0.9 : 1)
    ///             }
    ///         }
    ///     }
    ///
    ///
    /// - Parameters:
    ///   - isDisabled: A Boolean value that determines whether the hover effect
    ///     is disabled or not. Specifying `true` takes precedence over `false`.
    ///     Default: `true`.
    /// - Returns: A conditionally disabled hover effect.
    public func hoverEffectDisabled(_ isDisabled: Bool = true) -> some CustomHoverEffect

}

extension EnvironmentValues {

    /// The configuration of a document in a ``DocumentGroup``.
    ///
    /// The value is `nil` for views that are not enclosed in a ``DocumentGroup``.
    ///
    /// For example, if the app shows the document path in the footer
    /// of each document, it can get the URL from the environment:
    ///
    ///     struct ContentView: View {
    ///         @Binding var document: TextDocument
    ///         @Environment(\.documentConfiguration) private var configuration: DocumentConfiguration?
    ///
    ///         var body: some View {
    ///             
    ///             Label(
    ///                 configuration?.fileURL?.path ??
    ///                     "", systemImage: "folder.circle"
    ///             )
    ///         }
    ///     }
    ///
    @available(iOS 17.0, macOS 14.0, visionOS 1.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public var documentConfiguration: DocumentConfiguration? { get }
}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension View {

    /// Create an Accessibility Rotor with the specified user-visible label,
    /// and entries generated from the content closure.
    ///
    /// An Accessibility Rotor is a shortcut for Accessibility users to
    /// quickly navigate to specific elements of the user interface,
    /// and optionally specific ranges of text within those elements.
    ///
    /// In the following example, a Message application creates a Rotor
    /// allowing users to navigate to specifically the messages originating from
    /// VIPs.
    ///
    ///     // `messages` is a list of `Identifiable` `Message`s.
    ///
    ///     ScrollView {
    ///         LazyVStack {
    ///             ForEach(messages) { message in
    ///                 MessageView(message)
    ///             }
    ///         }
    ///     }
    ///     .accessibilityElement(children: .contain)
    ///     .accessibilityRotor("VIPs") {
    ///         // Not all the MessageViews are generated at once, the model knows
    ///         // about all the messages.
    ///         ForEach(messages) { message in
    ///             // If the Message is from a VIP, make a Rotor entry for it.
    ///             if message.isVIP {
    ///                 AccessibilityRotorEntry(message.subject, id: message.id)
    ///             }
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - label: Localized label identifying this Rotor to the user.
    ///   - entries: Content used to generate Rotor entries. This can
    ///     include AccessibilityRotorEntry structs, as well as constructs such
    ///     as if and ForEach.
    nonisolated public func accessibilityRotor<Content>(_ label: Text, @AccessibilityRotorContentBuilder entries: @escaping () -> Content) -> some View where Content : AccessibilityRotorContent


    /// Create an Accessibility Rotor replacing the specified system-provided
    /// Rotor.
    ///
    /// An Accessibility Rotor is a shortcut for Accessibility users to
    /// quickly navigate to specific elements of the user interface,
    /// and optionally specific ranges of text within those elements.
    /// Replacing system Rotors this way is useful when the System Rotor
    /// does not automatically pick up elements that aren't on-screen,
    /// such as elements far down in a `LazyVStack` or `List`.
    ///
    /// In the following example, a Message application adds a Rotor allowing
    /// the user to navigate through all the ranges of text containing
    /// headings.
    ///
    ///     extension Message {
    ///         // Ranges of special areas in the `content` text. Calculated
    ///         // when `content` is set and then cached so that we don't have
    ///         // to re-compute them.
    ///         var contentHeadingRanges: [Range<String.Index>]
    ///     }
    ///
    ///     struct MessageContentView: View {
    ///         TextEditor(.constant(message.content))
    ///             .accessibilityRotor(.heading) {
    ///                 ForEach(range in message.contentHeadingRanges) {
    ///                     AccessibilityRotorEntry(textRange: range)
    ///                 }
    ///             }
    ///     }
    ///
    /// - Parameters:
    ///   - systemRotor: The system-provided Rotor that will be overridden
    ///     by this custom Rotor.
    ///   - entries: Content used to generate Rotor entries. This can
    ///     include AccessibilityRotorEntry structs, as well as constructs such
    ///     as if and ForEach.
    nonisolated public func accessibilityRotor<Content>(_ systemRotor: AccessibilitySystemRotor, @AccessibilityRotorContentBuilder entries: @escaping () -> Content) -> some View where Content : AccessibilityRotorContent


    /// Create an Accessibility Rotor with the specified user-visible label
    /// and entries.
    ///
    /// An Accessibility Rotor is a shortcut for Accessibility users to
    /// quickly navigate to specific elements of the user interface,
    /// and optionally specific ranges of text within those elements.
    ///
    /// Using this modifier requires
    /// that the Rotor be attached to a `ScrollView`, or an Accessibility
    /// Element directly within a `ScrollView`, such as a `ForEach`.
    ///
    /// In the following example, a Message application creates a Rotor
    /// allowing users to navigate to specifically the messages originating from
    /// VIPs.
    ///
    ///     // `messages` is a list of `Identifiable` `Message`s that have a
    ///     // `subject`.
    ///     // `vipMessages` is a filtered version of that list containing only
    ///     // messages from VIPs.
    ///
    ///     ScrollView {
    ///         LazyVStack {
    ///             ForEach(messages) { message in
    ///                 MessageView(message)
    ///             }
    ///         }
    ///     }
    ///     .accessibilityElement(children: .contain)
    ///     .accessibilityRotor("VIPs", entries: vipMessages, label: \.subject)
    ///
    /// - Parameters:
    ///   - rotorLabel: Localized label identifying this Rotor to the user.
    ///   - entries: An array of identifiable values that will be
    ///     used to generate the entries of the Rotor. The identifiers
    ///     of the `Identifiable` values must match up with identifiers in a
    ///     `ForEach` or explicit `id` calls within the `ScrollView`.
    ///     When the user navigates to entries from this Rotor, SwiftUI will
    ///     automatically scroll them into place as needed.
    ///   - entryLabel: Key path on the `Identifiable` type that can be
    ///     used to get a user-visible label for every Rotor entry. This is used
    ///     on macOS when the user opens the list of entries for the Rotor.
    nonisolated public func accessibilityRotor<EntryModel>(_ rotorLabel: Text, entries: [EntryModel], entryLabel: KeyPath<EntryModel, String>) -> some View where EntryModel : Identifiable


    /// Create an Accessibility Rotor with the specified user-visible label
    /// and entries.
    ///
    /// An Accessibility Rotor is a shortcut for Accessibility users to
    /// quickly navigate to specific elements of the user interface,
    /// and optionally specific ranges of text within those elements.
    ///
    /// Using this modifier requires
    /// that the Rotor be attached to a `ScrollView`, or an Accessibility
    /// Element directly within a `ScrollView`, such as a `ForEach`.
    /// When the user navigates to entries from this Rotor, SwiftUI will
    /// automatically scroll them into place as needed.
    ///
    /// In the following example, a Message application creates a Rotor
    /// allowing users to navigate to specifically the messages originating from
    /// VIPs.
    ///
    ///     // `messages` is a list of `Message`s that have a `subject` and a
    ///     // `uuid`. `vipMessages` is a filtered version of that list
    ///     // containing only messages from VIPs.
    ///     ScrollView {
    ///         LazyVStack {
    ///             ForEach(messages) { message in
    ///                 MessageView(message)
    ///             }
    ///         }
    ///     }
    ///     .accessibilityElement(children: .contain)
    ///     .accessibilityRotor("VIPs", entries: vipMessages,
    ///         id: \.uuid, label: \.subject)
    ///
    /// - Parameters:
    ///   - rotorLabel: Localized label identifying this Rotor to the user.
    ///   - entries: An array of values that will be used to generate
    ///     the entries of the Rotor.
    ///   - entryID: Key path on the entry type that can be used
    ///     to generate an identifier for the Entry. The identifiers
    ///     must match up with identifiers in `ForEach` or explicit `id` calls
    ///     within the `ScrollView`.
    ///   - entryLabel: Key path on the entry type that can be
    ///     used to get a user-visible label for every Rotor entry. This is used
    ///     on macOS when the user opens the list of entries for the Rotor.
    nonisolated public func accessibilityRotor<EntryModel, ID>(_ rotorLabel: Text, entries: [EntryModel], entryID: KeyPath<EntryModel, ID>, entryLabel: KeyPath<EntryModel, String>) -> some View where ID : Hashable


    /// Create an Accessibility Rotor replacing the specified system-provided
    /// Rotor.
    ///
    /// An Accessibility Rotor is a shortcut for Accessibility users to
    /// quickly navigate to specific elements of the user interface,
    /// and optionally specific ranges of text within those elements.
    ///
    /// Using this modifier requires
    /// that the Rotor be attached to a `ScrollView`, or an Accessibility
    /// Element directly within a `ScrollView`, such as a `ForEach`.
    ///
    /// In the following example, a Message application creates a Rotor
    /// allowing users to navigate to the headings in its vertical stack of
    /// messages.
    ///
    ///     // `messageListItems` is a list of `Identifiable` `MessageListItem`s
    ///     // that are either a `Message` or a heading, containing a `subject`.
    ///     // `headingMessageListItems` is a filtered list of
    ///     // `messageListItems` containing just the headings.
    ///     ScrollView {
    ///         LazyVStack {
    ///             ForEach(messageListItems) { messageListItem in
    ///                 switch messageListItem {
    ///                     case .heading(let subject):
    ///                         Text(subject)
    ///                     case .message(let message):
    ///                         MessageView(message)
    ///                 }
    ///             }
    ///         }
    ///     }
    ///     .accessibilityElement(children: .contain)
    ///     .accessibilityRotor(
    ///         .heading, entries: headingMessageListItems, label: \.subject)
    ///
    /// - Parameters:
    ///   - systemRotor: The system-provided Rotor that will be overridden
    ///     by this custom Rotor.
    ///   - entries: An array of identifiable values that will be
    ///     used to generate the entries of the Rotor. The identifiers
    ///     of the `Identifiable` values must match up with identifiers in a
    ///     `ForEach` or explicit `id` calls within the `ScrollView`.
    ///     When the user navigates to entries from this Rotor, SwiftUI will
    ///     automatically scroll them into place as needed.
    ///   - entryLabel: Key path on the `Identifiable` type that can be
    ///     used to get a user-visible label for every Rotor entry. This is used
    ///     on macOS when the user opens the list of entries for the Rotor.
    nonisolated public func accessibilityRotor<EntryModel>(_ systemRotor: AccessibilitySystemRotor, entries: [EntryModel], entryLabel: KeyPath<EntryModel, String>) -> some View where EntryModel : Identifiable


    /// Create an Accessibility Rotor replacing the specified system-provided
    /// Rotor.
    ///
    /// An Accessibility Rotor is a shortcut for Accessibility users to
    /// quickly navigate to specific elements of the user interface,
    /// and optionally specific ranges of text within those elements.
    ///
    /// Using this modifier requires
    /// that the Rotor be attached to a `ScrollView`, or an Accessibility
    /// Element directly within a `ScrollView`, such as a `ForEach`.
    /// When the user navigates to entries from this Rotor, SwiftUI will
    /// automatically scroll them into place as needed.
    ///
    /// In the following example, a Message application creates a Rotor
    /// allowing users to navigate to the headings in its vertical stack of
    /// messages.
    ///
    ///     // `messageListItems` is a list of `MessageListItem`s
    ///     // that are either a `Message` or a heading, containing a `subject`
    ///     // and a `uuid`.
    ///     // `headingMessageListItems` is a filtered list of
    ///     // `messageListItems` containing just the headings.
    ///     ScrollView {
    ///         LazyVStack {
    ///             ForEach(messageListItems) { messageListItem in
    ///                 switch messageListItem {
    ///                     case .heading(let subject):
    ///                         Text(subject)
    ///                     case .message(let message):
    ///                         MessageView(message)
    ///                 }
    ///             }
    ///         }
    ///     }
    ///     .accessibilityElement(children: .contain)
    ///     .accessibilityRotor(
    ///         .heading, entries: headingMessageListItems,
    ///         entryID: \.uuid, label: \.subject
    ///     )
    ///
    /// - Parameters:
    ///   - systemRotor: The system-provided Rotor that will be overridden
    ///     by this custom Rotor.
    ///   - entries: An array of values that will be used to generate
    ///     the entries of the Rotor.
    ///   - entryID: Key path on the entry type that can be used
    ///     to generate an identifier for the Entry. The identifiers
    ///     must match up with identifiers in `ForEach` or explicit `id` calls
    ///     within the `ScrollView`.
    ///   - entryLabel: Key path on the entry type that can be
    ///     used to get a user-visible label for every Rotor entry. This is used
    ///     on macOS when the user opens the list of entries for the Rotor.
    nonisolated public func accessibilityRotor<EntryModel, ID>(_ systemRotor: AccessibilitySystemRotor, entries: [EntryModel], entryID: KeyPath<EntryModel, ID>, entryLabel: KeyPath<EntryModel, String>) -> some View where ID : Hashable


    /// Create an Accessibility Rotor with the specified user-visible label
    /// and entries for each of the specified ranges. The Rotor will be attached
    /// to the current Accessibility element, and each entry will go the
    /// specified range of that element.
    ///
    /// An Accessibility Rotor is a shortcut for Accessibility users to
    /// quickly navigate to specific elements of the user interface,
    /// and optionally specific ranges of text within those elements.
    ///
    /// In the following example, a Message application adds a Rotor allowing
    /// the user to navigate through all the ranges of text containing
    /// email addresses.
    ///
    ///     extension Message {
    ///         // Ranges of special areas in the `content` text. Calculated
    ///         // when `content` is set and then cached so that we don't have
    ///         // to re-compute them.
    ///         var emailAddressRanges: [Range<String.Index>]
    ///     }
    ///
    ///     struct MessageContentView: View {
    ///         TextEditor(.constant(message.content))
    ///             .accessibilityRotor("Email Addresses",
    ///                 textRanges: message.emailAddressRanges)
    ///     }
    ///
    /// - Parameters:
    ///   - label: Localized label identifying this Rotor to the user.
    ///   - textRanges: An array of ranges that will be used to generate
    ///     the entries of the Rotor.
    nonisolated public func accessibilityRotor(_ label: Text, textRanges: [Range<String.Index>]) -> some View


    /// Create an Accessibility Rotor replacing the specified system-provided
    /// Rotor. The Rotor will be attached to the current Accessibility element,
    /// and each entry will go the specified range of that element.
    ///
    /// An Accessibility Rotor is a shortcut for Accessibility users to
    /// quickly navigate to specific elements of the user interface,
    /// and optionally specific ranges of text within those elements.
    ///
    /// In the following example, a Message application adds a Rotor allowing
    /// the user to navigate through all the ranges of text containing headings.
    ///
    ///     extension Message {
    ///         // Ranges of special areas in the `content` text. Calculated when
    ///         // `content` is set and then cached so that we don't have to
    ///         // re-compute them.
    ///         var headingRanges: [Range<String.Index>]
    ///     }
    ///
    ///     struct MessageContentView: View {
    ///         TextEditor(.constant(message.content))
    ///             .accessibilityRotor(
    ///                 .heading,
    ///                 textRanges: message.headingRanges
    ///             )
    ///     }
    ///
    /// - Parameters:
    ///   - systemRotor: The system-provided Rotor that will be overridden
    ///     by this custom Rotor.
    ///   - textRanges: An array of ranges that will be used to generate
    ///     the entries of the Rotor.
    nonisolated public func accessibilityRotor(_ systemRotor: AccessibilitySystemRotor, textRanges: [Range<String.Index>]) -> some View

}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension View {

    /// Create an Accessibility Rotor with the specified user-visible label,
    /// and entries generated from the content closure.
    ///
    /// An Accessibility Rotor is a shortcut for Accessibility users to
    /// quickly navigate to specific elements of the user interface,
    /// and optionally specific ranges of text within those elements.
    ///
    /// In the following example, a Message application creates a Rotor
    /// allowing users to navigate to specifically the messages originating from
    /// VIPs.
    ///
    ///     // `messages` is a list of `Identifiable` `Message`s.
    ///
    ///     ScrollView {
    ///         LazyVStack {
    ///             ForEach(messages) { message in
    ///                 MessageView(message)
    ///             }
    ///         }
    ///     }
    ///     .accessibilityElement(children: .contain)
    ///     .accessibilityRotor("VIPs") {
    ///         // Not all the MessageViews are generated at once, the model
    ///         // knows about all the messages.
    ///         ForEach(messages) { message in
    ///             // If the Message is from a VIP, make a Rotor entry for it.
    ///             if message.isVIP {
    ///                 AccessibilityRotorEntry(message.subject, id: message.id)
    ///             }
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - labelKey: Localized label identifying this Rotor to the user.
    ///   - entries: Content used to generate Rotor entries. This can
    ///     include AccessibilityRotorEntry structs, as well as constructs such
    ///     as if and ForEach.
    nonisolated public func accessibilityRotor<Content>(_ labelKey: LocalizedStringKey, @AccessibilityRotorContentBuilder entries: @escaping () -> Content) -> some View where Content : AccessibilityRotorContent


    /// Create an Accessibility Rotor with the specified user-visible label,
    /// and entries generated from the content closure.
    ///
    /// An Accessibility Rotor is a shortcut for Accessibility users to
    /// quickly navigate to specific elements of the user interface,
    /// and optionally specific ranges of text within those elements.
    ///
    /// In the following example, a Message application creates a Rotor
    /// allowing users to navigate to specifically the messages originating from
    /// VIPs.
    ///
    ///     // `messages` is a list of `Identifiable` `Message`s.
    ///
    ///     ScrollView {
    ///         LazyVStack {
    ///             ForEach(messages) { message in
    ///                 MessageView(message)
    ///             }
    ///         }
    ///     }
    ///     .accessibilityElement(children: .contain)
    ///     .accessibilityRotor("VIPs") {
    ///         // Not all the MessageViews are generated at once, the model
    ///         // knows about all the messages.
    ///         ForEach(messages) { message in
    ///             // If the Message is from a VIP, make a Rotor entry for it.
    ///             if message.isVIP {
    ///                 AccessibilityRotorEntry(message.subject, id: message.id)
    ///             }
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - label: Localized label identifying this Rotor to the user.
    ///   - entries: Content used to generate Rotor entries. This can
    ///     include AccessibilityRotorEntry structs, as well as constructs such
    ///     as if and ForEach.
    nonisolated public func accessibilityRotor<L, Content>(_ label: L, @AccessibilityRotorContentBuilder entries: @escaping () -> Content) -> some View where L : StringProtocol, Content : AccessibilityRotorContent


    /// Create an Accessibility Rotor with the specified user-visible label
    /// and entries.
    ///
    /// An Accessibility Rotor is a shortcut for Accessibility users to
    /// quickly navigate to specific elements of the user interface,
    /// and optionally specific ranges of text within those elements.
    ///
    /// Using this modifier requires
    /// that the Rotor be attached to a `ScrollView`, or an Accessibility
    /// Element directly within a `ScrollView`, such as a `ForEach`.
    ///
    /// In the following example, a Message application creates a Rotor
    /// allowing users to navigate to specifically the messages originating from
    /// VIPs.
    ///
    ///     // `messages` is a list of `Identifiable` `Message`s that have a
    ///     // `subject`.
    ///     // `vipMessages` is a filtered version of that list containing only
    ///     // messages from VIPs.
    ///
    ///     ScrollView {
    ///         LazyVStack {
    ///             ForEach(messages) { message in
    ///                 MessageView(message)
    ///             }
    ///         }
    ///     }
    ///     .accessibilityElement(children: .contain)
    ///     .accessibilityRotor("VIPs", entries: vipMessages,
    ///         entryLabel: \.subject)
    ///
    /// - Parameters:
    ///   - rotorLabelKey: Localized label identifying this Rotor to the user.
    ///   - entries: An array of identifiable values that will be
    ///     used to generate the entries of the Rotor. The identifiers
    ///     of the `Identifiable` values must match up with identifiers in a
    ///     `ForEach` or explicit `id` calls within the `ScrollView`.
    ///     When the user navigates to entries from this Rotor, SwiftUI will
    ///     automatically scroll them into place as needed.
    ///   - entryLabel: Key path on the `Identifiable` type that can be
    ///     used to get a user-visible label for every Rotor entry. This is used
    ///     on macOS when the user opens the list of entries for the Rotor.
    nonisolated public func accessibilityRotor<EntryModel>(_ rotorLabelKey: LocalizedStringKey, entries: [EntryModel], entryLabel: KeyPath<EntryModel, String>) -> some View where EntryModel : Identifiable


    /// Create an Accessibility Rotor with the specified user-visible label
    /// and entries.
    ///
    /// An Accessibility Rotor is a shortcut for Accessibility users to
    /// quickly navigate to specific elements of the user interface,
    /// and optionally specific ranges of text within those elements.
    ///
    /// Using this modifier requires
    /// that the Rotor be attached to a `ScrollView`, or an Accessibility
    /// Element directly within a `ScrollView`, such as a `ForEach`.
    ///
    /// In the following example, a Message application creates a Rotor
    /// allowing users to navigate to specifically the messages originating from
    /// VIPs.
    ///
    ///     // `messages` is a list of `Identifiable` `Message`s that have a
    ///     // `subject`.
    ///     // `vipMesages` is a filtered version of that list containing only
    ///     // messages from VIPs.
    ///
    ///     ScrollView {
    ///         LazyVStack {
    ///             ForEach(messages) { message in
    ///                 MessageView(message)
    ///             }
    ///         }
    ///     }
    ///     .accessibilityElement(children: .contain)
    ///     .accessibilityRotor("VIPs", entries: vipMessages, label: \.subject)
    ///
    /// - Parameters:
    ///   - rotorLabel: Localized label identifying this Rotor to the user.
    ///   - entries: An array of identifiable values that will be
    ///     used to generate the entries of the Rotor. The identifiers
    ///     of the `Identifiable` values must match up with identifiers in a
    ///     `ForEach` or explicit `id` calls within the `ScrollView`.
    ///     When the user navigates to entries from this Rotor, SwiftUI will
    ///     automatically scroll them into place as needed.
    ///   - entry: Key path on the `Identifiable` type that can be
    ///     used to get a user-visible label for every Rotor entry. This is used
    ///     on macOS when the user opens the list of entries for the Rotor.
    nonisolated public func accessibilityRotor<L, EntryModel>(_ rotorLabel: L, entries: [EntryModel], entryLabel: KeyPath<EntryModel, String>) -> some View where L : StringProtocol, EntryModel : Identifiable


    /// Create an Accessibility Rotor with the specified user-visible label
    /// and entries.
    ///
    /// An Accessibility Rotor is a shortcut for Accessibility users to
    /// quickly navigate to specific elements of the user interface,
    /// and optionally specific ranges of text within those elements.
    ///
    /// Using this modifier requires that the Rotor be attached to a
    /// `ScrollView`, or an Accessibility Element directly within a
    /// `ScrollView`, such as a `ForEach`. When the user navigates to entries
    /// from this Rotor, SwiftUI will automatically scroll them into place as
    /// needed.
    ///
    /// In the following example, a Message application creates a Rotor
    /// allowing users to navigate to specifically the messages originating from
    /// VIPs.
    ///
    ///     // `messages` is a list of `Message`s that have a `subject` and a
    ///     // `uuid`. `vipMesages` is a filtered version of that list
    ///     // containing only messages from VIPs.
    ///     ScrollView {
    ///         LazyVStack {
    ///             ForEach(messages) { message in
    ///                 MessageView(message)
    ///             }
    ///         }
    ///     }
    ///     .accessibilityElement(children: .contain)
    ///     .accessibilityRotor("VIPs", entries: vipMessages,
    ///         entryID: \.uuid, entryLabel: \.subject)
    ///
    /// - Parameters:
    ///   - labelKey: Localized label identifying this Rotor to the user.
    ///   - entries: An array of values that will be used to generate
    ///     the entries of the Rotor.
    ///   - entryID: Key path on the entry type that can be used
    ///     to generate an identifier for the Entry. The identifiers
    ///     must match up with identifiers in `ForEach` or explicit `id` calls
    ///     within the `ScrollView`.
    ///   - entryLabel: Key path on the entry type that can be
    ///     used to get a user-visible label for every Rotor entry. This is used
    ///     on macOS when the user opens the list of entries for the Rotor.
    nonisolated public func accessibilityRotor<EntryModel, ID>(_ rotorLabelKey: LocalizedStringKey, entries: [EntryModel], entryID: KeyPath<EntryModel, ID>, entryLabel: KeyPath<EntryModel, String>) -> some View where ID : Hashable


    /// Create an Accessibility Rotor with the specified user-visible label
    /// and entries.
    ///
    /// An Accessibility Rotor is a shortcut for Accessibility users to
    /// quickly navigate to specific elements of the user interface,
    /// and optionally specific ranges of text within those elements.
    ///
    /// Using this modifier requires
    /// that the Rotor be attached to a `ScrollView`, or an Accessibility
    /// Element directly within a `ScrollView`, such as a `ForEach`.
    /// When the user navigates to entries from this Rotor, SwiftUI will
    /// automatically scroll them into place as needed.
    ///
    /// In the following example, a Message application creates a Rotor
    /// allowing users to navigate to specifically the messages originating from
    /// VIPs.
    ///     // `messages` is a list of `Message`s that have a `subject` and a
    ///     // `uuid`. `vipMessages` is a filtered version of that list
    ///     // containing only messages from VIPs.
    ///     ScrollView {
    ///         LazyVStack {
    ///             ForEach(messages) { message in
    ///                 MessageView(message)
    ///             }
    ///         }
    ///     }
    ///     .accessibilityElement(children: .contain)
    ///     .accessibilityRotor("VIPs", entries: vipMessages,
    ///         id: \.uuid, label: \.subject)
    ///
    /// - Parameters:
    ///   - rotorLabel: Localized label identifying this Rotor to the user.
    ///   - entries: An array of values that will be used to generate
    ///     the entries of the Rotor.
    ///   - entryID: Key path on the entry type that can be used
    ///     to generate an identifier for the Entry. The identifiers
    ///     must match up with identifiers in `ForEach` or explicit `id` calls
    ///     within the `ScrollView`.
    ///   - entryLabel: Key path on the entry type that can be
    ///     used to get a user-visible label for every Rotor entry. This is used
    ///     on macOS when the user opens the list of entries for the Rotor.
    nonisolated public func accessibilityRotor<L, EntryModel, ID>(_ rotorLabel: L, entries: [EntryModel], entryID: KeyPath<EntryModel, ID>, entryLabel: KeyPath<EntryModel, String>) -> some View where L : StringProtocol, ID : Hashable


    /// Create an Accessibility Rotor with the specified user-visible label
    /// and entries for each of the specified ranges. The Rotor will be attached
    /// to the current Accessibility element, and each entry will go the
    /// specified range of that element.
    ///
    /// An Accessibility Rotor is a shortcut for Accessibility users to
    /// quickly navigate to specific elements of the user interface,
    /// and optionally specific ranges of text within those elements.
    ///
    /// In the following example, a Message application adds a Rotor allowing
    /// the user to navigate through all the ranges of text containing
    /// email addresses.
    ///
    ///     extension Message {
    ///         // Ranges of special areas in the `content` text. Calculated
    ///         // when `content` is set and then cached so that we don't have
    ///         // to re-compute them.
    ///         var emailAddressRanges: [Range<String.Index>]
    ///     }
    ///
    ///     struct MessageContentView: View {
    ///         TextEditor(.constant(message.content))
    ///             .accessibilityRotor("Email Addresses",
    ///                 textRanges: message.emailAddressRanges)
    ///     }
    ///
    /// - Parameters:
    ///   - labelKey: Localized label identifying this Rotor to the user.
    ///   - textRanges: An array of ranges that will be used to generate
    ///     the entries of the Rotor.
    nonisolated public func accessibilityRotor(_ labelKey: LocalizedStringKey, textRanges: [Range<String.Index>]) -> some View


    /// Create an Accessibility Rotor with the specified user-visible label
    /// and entries for each of the specified ranges. The Rotor will be attached
    /// to the current Accessibility element, and each entry will go the
    /// specified range of that element.
    ///
    /// An Accessibility Rotor is a shortcut for Accessibility users to
    /// quickly navigate to specific elements of the user interface,
    /// and optionally specific ranges of text within those elements.
    ///
    /// In the following example, a Message application adds a Rotor allowing
    /// the user to navigate through all the ranges of text containing
    /// email addresses.
    ///
    ///     extension Message {
    ///         // Ranges of special areas in the `content` text. Calculated
    ///         // when `content` is set and then cached so that we don't have
    ///         // to re-compute them.
    ///         var emailAddressRanges: [Range<String.Index>]
    ///     }
    ///
    ///     struct MessageContentView: View {
    ///         TextEditor(.constant(message.content))
    ///             .accessibilityRotor("Email Addresses",
    ///                 textRanges: message.emailAddressRanges)
    ///     }
    ///
    /// - Parameters:
    ///   - label: Localized label identifying this Rotor to the user.
    ///   - textRanges: An array of ranges that will be used to generate
    ///     the entries of the Rotor.
    nonisolated public func accessibilityRotor<L>(_ label: L, textRanges: [Range<String.Index>]) -> some View where L : StringProtocol

}

@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension View {

    /// Sets the style for forms in a view hierarchy.
    ///
    /// - Parameter style: The form style to set.
    /// - Returns: A view that uses the specified form style for itself
    ///   and its child views.
    nonisolated public func formStyle<S>(_ style: S) -> some View where S : FormStyle

}

@available(iOS 16.0, macOS 12.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension Never : TableColumnContent {

    /// The type of sort comparator associated with this table column content.
    public typealias TableColumnSortComparator = Never

    /// The type of content representing the body of this table column content.
    public typealias TableColumnBody = Never

    /// The composition of content that comprise the table column content.
    nonisolated public var tableColumnBody: Never { get }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View where Self : Equatable {

    /// Prevents the view from updating its child view when its new value is the
    /// same as its old value.
    @inlinable nonisolated public func equatable() -> EquatableView<Self>
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension Never : Scene {
}

@available(iOS 15.0, macOS 12.0, watchOS 8.0, *)
@available(tvOS, unavailable)
extension View {

    /// Adds custom swipe actions to a row in a list.
    ///
    /// Use this method to add swipe actions to a view that acts as a row in a
    /// list. Indicate the ``HorizontalEdge`` where the swipe action
    /// originates, and define individual actions with ``Button`` instances.
    /// For example, if you have a list of messages,
    /// you can add an action to toggle a message as unread
    /// on a swipe from the leading edge,
    /// and actions to delete or flag messages on a trailing edge swipe:
    ///
    ///     List {
    ///         ForEach(store.messages) { message in
    ///             MessageCell(message: message)
    ///                 .swipeActions(edge: .leading) {
    ///                     Button { store.toggleUnread(message) } label: {
    ///                         if message.isUnread {
    ///                             Label("Read", systemImage: "envelope.open")
    ///                         } else {
    ///                             Label("Unread", systemImage: "envelope.badge")
    ///                         }
    ///                     }
    ///                 }
    ///                 .swipeActions(edge: .trailing) {
    ///                     Button(role: .destructive) {
    ///                         store.delete(message)
    ///                     } label: {
    ///                         Label("Delete", systemImage: "trash")
    ///                     }
    ///                     Button { store.flag(message) } label: {
    ///                         Label("Flag", systemImage: "flag")
    ///                     }
    ///                 }
    ///             }
    ///         }
    ///     }
    ///
    /// Actions appear in the order you list them, starting from the swipe's
    /// originating edge. In the example above, the Delete action appears
    /// closest to the screen's trailing edge:
    ///
    /// ![A screenshot of a list of messages, where one of the messages has been
    ///   swiped from the trailing edge, revealing a Flag and Delete button.
    ///   The Flag button is grey, while the Delete button is
    ///   red.](View-swipeActions-1)
    ///
    /// For labels or images that appear in swipe actions, SwiftUI automatically
    /// applies the ``SymbolVariants/fill-swift.type.property`` symbol variant,
    /// as shown above.
    ///
    /// By default, the user can perform the first action for a given swipe
    /// direction with a full swipe. For the example above, the user can perform
    /// both the toggle unread and delete actions with full swipes.
    /// You can opt out of this behavior for an edge by setting
    /// the `allowsFullSwipe` parameter to `false`. For example, you can
    /// disable the full swipe on the leading edge:
    ///
    ///     .swipeActions(edge: .leading, allowsFullSwipe: false) {
    ///         Button { store.toggleUnread(message) } label: {
    ///             if message.isUnread {
    ///                 Label("Read", systemImage: "envelope.open")
    ///             } else {
    ///                 Label("Unread", systemImage: "envelope.badge")
    ///             }
    ///         }
    ///     }
    ///
    /// When you set a role for a button using one of the values from the
    /// ``ButtonRole`` enumeration, SwiftUI styles the button according to
    /// its role. In the example above, the delete action appears in
    /// ``ShapeStyle/red`` because it has the ``ButtonRole/destructive`` role.
    /// If you want to set a different color  for example, to match the
    /// overall theme of your app's UI  add the ``View/tint(_:)``
    /// modifier to the button:
    ///
    ///     MessageCell(message: message)
    ///         .swipeActions(edge: .leading) {
    ///             Button { store.toggleUnread(message) } label: {
    ///                 if message.isUnread {
    ///                     Label("Read", systemImage: "envelope.open")
    ///                 } else {
    ///                     Label("Unread", systemImage: "envelope.badge")
    ///                 }
    ///             }
    ///             .tint(.blue)
    ///         }
    ///         .swipeActions(edge: .trailing) {
    ///             Button(role: .destructive) { store.delete(message) } label: {
    ///                 Label("Delete", systemImage: "trash")
    ///             }
    ///             Button { store.flag(message) } label: {
    ///                 Label("Flag", systemImage: "flag")
    ///             }
    ///             .tint(.orange)
    ///         }
    ///
    /// The modifications in the code above make the toggle unread action
    /// ``ShapeStyle/blue`` and the flag action ``ShapeStyle/orange``:
    ///
    /// ![A screenshot of a row that the user swiped from the leading edge
    ///   to reveal a blue Unread button, and another screenshot of the same
    ///   row after the user swiped from the trailing edge to reveal an
    ///   orange Flag button and a red Delete button.](View-swipeActions-2)
    ///
    /// When you add swipe actions, SwiftUI no longer synthesizes the Delete
    /// actions that otherwise appear when using the
    /// ``ForEach/onDelete(perform:)`` method on a ``ForEach`` instance.
    /// You become responsible for creating a Delete
    /// action, if appropriate, among your swipe actions.
    ///
    /// Actions accumulate for a given edge if you call the modifier multiple
    /// times on the same list row view.
    ///
    /// - Parameters:
    ///     - edge: The edge of the view to associate the swipe actions with.
    ///         The default is ``HorizontalEdge/trailing``.
    ///     - allowsFullSwipe: A Boolean value that indicates whether a full swipe
    ///         automatically performs the first action. The default is `true`.
    ///     - content: The content of the swipe actions.
    nonisolated public func swipeActions<T>(edge: HorizontalEdge = .trailing, allowsFullSwipe: Bool = true, @ViewBuilder content: () -> T) -> some View where T : View

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension DynamicViewContent {

    /// Sets the deletion action for the dynamic view. You must delete the
    /// corresponding item within `action`, as it will be called after the
    /// row has already been removed from the ``List``.
    ///
    /// - Parameter action: The action that you want SwiftUI to perform when
    ///   elements in the view are deleted. SwiftUI passes a set of indices to the
    ///   closure that's relative to the dynamic view's underlying collection of
    ///   data.
    ///
    /// - Returns: A view that calls `action` when elements are deleted from the
    ///   original view.
    @inlinable nonisolated public func onDelete(perform action: ((IndexSet) -> Void)?) -> some DynamicViewContent

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// Adds a condition for whether the view's view hierarchy is deletable.
    @inlinable nonisolated public func deleteDisabled(_ isDisabled: Bool) -> some View

}

@available(iOS 14.0, macOS 11.0, watchOS 9.0, *)
@available(tvOS, unavailable)
extension Never : WidgetConfiguration {
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension View {

    /// Sets whether this view should ignore the system Smart Invert setting.
    ///
    /// Use this modifier to suppress Smart Invert in a view that shouldn't
    /// be inverted. Or pass an `active` argument of `false` to begin following
    /// the Smart Invert setting again when it was previously disabled.
    ///
    /// - Parameter active: A true value ignores the system Smart Invert
    ///   setting. A false value follows the system setting.
    @inlinable nonisolated public func accessibilityIgnoresInvertColors(_ active: Bool = true) -> some View

}

@available(iOS 18.0, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@available(visionOS, unavailable)
extension Never : ControlWidgetTemplate {
}

extension EnvironmentValues {

    /// The undo manager used to register a view's undo operations.
    ///
    /// This value is `nil` when the environment represents a context that
    /// doesn't support undo and redo operations. You can skip registration of
    /// an undo operation when this value is `nil`.
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    public var undoManager: UndoManager? { get }
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension Group : ToolbarContent where Content : ToolbarContent {

    /// Creates a group of toolbar content instances.
    ///
    /// - Parameter content: A ``SwiftUI/ToolbarContentBuilder`` that produces
    /// the toolbar content instances to group.
    nonisolated public init(@ToolbarContentBuilder content: () -> Content)
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension Group : CustomizableToolbarContent where Content : CustomizableToolbarContent {

    /// Creates a group of customizable toolbar content instances.
    ///
    /// - Parameter content: A ``SwiftUI/ToolbarContentBuilder`` that produces
    /// the customizable toolbar content instances to group.
    public init(@ToolbarContentBuilder content: () -> Content)
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension NSUserActivity {

    /// Error types when getting/setting typed payload
    @available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
    public enum TypedPayloadError : Error {

        /// UserInfo is empty or invalid
        case invalidContent

        /// Content failed to encode into a valid Dictionary
        case encodingError

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: NSUserActivity.TypedPayloadError, b: NSUserActivity.TypedPayloadError) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Given a Codable Swift type, return an instance decoded from the
    /// NSUserActivity's userInfo dictionary
    ///
    /// - Parameter type: the instance type to be decoded from userInfo
    /// - Returns: the type safe instance or raises if it can't be decoded
    public func typedPayload<T>(_ type: T.Type) throws -> T where T : Decodable, T : Encodable

    /// Given an instance of a Codable Swift type, encode it into the
    /// NSUserActivity's userInfo dictionary
    ///
    /// - Parameter payload: the instance to be converted to userInfo
    public func setTypedPayload<T>(_ payload: T) throws where T : Decodable, T : Encodable
}

@available(iOS 13.0, tvOS 13.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension EnvironmentValues {

    /// An indication of whether the user can edit the contents of a view
    /// associated with this environment.
    ///
    /// Read this environment value to receive a optional binding to the
    /// edit mode state. The binding contains an ``EditMode`` value
    /// that indicates whether edit mode is active, and that you can use to
    /// change the mode. To learn how to read an environment
    /// value, see ``EnvironmentValues``.
    ///
    /// Certain built-in views automatically alter their appearance and behavior
    /// in edit mode. For example, a ``List`` with a ``ForEach`` that's
    /// configured with the ``DynamicViewContent/onDelete(perform:)`` or
    /// ``DynamicViewContent/onMove(perform:)`` modifier provides controls to
    /// delete or move list items while in edit mode. On devices without an
    /// attached keyboard and mouse or trackpad, people can make multiple
    /// selections in lists only when edit mode is active.
    ///
    /// You can also customize your own views to react to edit mode.
    /// The following example replaces a read-only ``Text`` view with
    /// an editable ``TextField``, checking for edit mode by
    /// testing the wrapped value's ``EditMode/isEditing`` property:
    ///
    ///     @Environment(\.editMode) private var editMode
    ///     @State private var name = "Maria Ruiz"
    ///
    ///     var body: some View {
    ///         Form {
    ///             if editMode?.wrappedValue.isEditing == true {
    ///                 TextField("Name", text: $name)
    ///             } else {
    ///                 Text(name)
    ///             }
    ///         }
    ///         .animation(nil, value: editMode?.wrappedValue)
    ///         .toolbar { // Assumes embedding this view in a NavigationView.
    ///             EditButton()
    ///         }
    ///     }
    ///
    /// You can set the edit mode through the binding, or you can
    /// rely on an ``EditButton`` to do that for you, as the example above
    /// demonstrates. The button activates edit mode when the user
    /// taps the Edit button, and disables editing mode when the user taps Done.
    @available(macOS, unavailable)
    @available(watchOS, unavailable)
    public var editMode: Binding<EditMode>?
}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension Text.LineStyle {

    /// Creates a ``Text.LineStyle`` from ``NSUnderlineStyle``.
    ///
    /// > Note: Use this initializer only if you need to convert an existing
    /// ``NSUnderlineStyle`` to a SwiftUI ``Text.LineStyle``.
    /// Otherwise, create a ``Text.LineStyle`` using an
    /// initializer like ``init(pattern:color:)``.
    ///
    /// - Parameter nsUnderlineStyle: A value of ``NSUnderlineStyle``
    /// to wrap with ``Text.LineStyle``.
    ///
    /// - Returns: A new ``Text.LineStyle`` or `nil` when
    /// `nsUnderlineStyle` contains styles not supported by ``Text.LineStyle``.
    public init?(nsUnderlineStyle: NSUnderlineStyle)
}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension NSUnderlineStyle {

    /// Creates a ``NSUnderlineStyle`` from ``Text.LineStyle``.
    ///
    /// - Parameter lineStyle: A value of ``Text.LineStyle``
    /// to wrap with ``NSUnderlineStyle``.
    ///
    /// - Returns: A new ``NSUnderlineStyle``.
    public init(_ lineStyle: Text.LineStyle)
}

extension View {

    /// Configures the view's document for purposes of navigation.
    ///
    /// In iOS, iPadOS, this populates the title menu with a header
    /// previewing the document. In macOS, this populates a proxy icon.
    ///
    /// Refer to the <doc:Configure-Your-Apps-Navigation-Titles> article
    /// for more information on navigation document modifiers.
    ///
    /// - Parameters:
    ///   - document: The transferable content associated to the
    ///     navigation title.
    @available(iOS 16.0, macOS 13.0, watchOS 9.0, tvOS 16.0, *)
    nonisolated public func navigationDocument<D>(_ document: D) -> some View where D : Transferable


    /// Configures the view's document for purposes of navigation.
    ///
    /// In iOS, iPadOS, this populates the title menu with a header
    /// previewing the document. In macOS, this populates a proxy icon.
    ///
    /// Refer to the <doc:Configure-Your-Apps-Navigation-Titles> article
    /// for more information on navigation document modifiers.
    ///
    /// - Parameters:
    ///   - document: The transferable content associated to the
    ///     navigation title.
    ///   - preview: The preview of the document to use when sharing.
    @available(iOS 16.0, macOS 13.0, watchOS 9.0, *)
    @available(tvOS, unavailable)
    nonisolated public func navigationDocument<D>(_ document: D, preview: SharePreview<Never, Never>) -> some View where D : Transferable


    /// Configures the view's document for purposes of navigation.
    ///
    /// In iOS, iPadOS, this populates the title menu with a header
    /// previewing the document. In macOS, this populates a proxy icon.
    ///
    /// Refer to the <doc:Configure-Your-Apps-Navigation-Titles> article
    /// for more information on navigation document modifiers.
    ///
    /// - Parameters:
    ///   - document: The transferable content associated to the
    ///     navigation title.
    ///   - preview: The preview of the document to use when sharing.
    @available(iOS 16.0, macOS 13.0, watchOS 9.0, *)
    @available(tvOS, unavailable)
    nonisolated public func navigationDocument<D, I>(_ document: D, preview: SharePreview<Never, I>) -> some View where D : Transferable, I : Transferable


    /// Configures the view's document for purposes of navigation.
    ///
    /// In iOS, iPadOS, this populates the title menu with a header
    /// previewing the document. In macOS, this populates a proxy icon.
    ///
    /// Refer to the <doc:Configure-Your-Apps-Navigation-Titles> article
    /// for more information on navigation document modifiers.
    ///
    /// - Parameters:
    ///   - document: The transferable content associated to the
    ///     navigation title.
    ///   - preview: The preview of the document to use when sharing.
    @available(iOS 16.0, macOS 13.0, watchOS 9.0, *)
    @available(tvOS, unavailable)
    nonisolated public func navigationDocument<D, I>(_ document: D, preview: SharePreview<I, Never>) -> some View where D : Transferable, I : Transferable


    /// Configures the view's document for purposes of navigation.
    ///
    /// In iOS, iPadOS, this populates the title menu with a header
    /// previewing the document. In macOS, this populates a proxy icon.
    ///
    /// Refer to the <doc:Configure-Your-Apps-Navigation-Titles> article
    /// for more information on navigation document modifiers.
    ///
    /// - Parameters:
    ///   - document: The transferable content associated to the
    ///     navigation title.
    ///   - preview: The preview of the document to use when sharing.
    @available(iOS 16.0, macOS 13.0, watchOS 9.0, *)
    @available(tvOS, unavailable)
    nonisolated public func navigationDocument<D, I1, I2>(_ document: D, preview: SharePreview<I1, I2>) -> some View where D : Transferable, I1 : Transferable, I2 : Transferable

}

extension View {

    /// Configures the view's document for purposes of navigation.
    ///
    /// In iOS, iPadOS, this populates the title menu with a header
    /// previewing the document. In macOS, this populates a proxy icon.
    ///
    /// Refer to the <doc:Configure-Your-Apps-Navigation-Titles> article
    /// for more information on navigation document modifiers.
    ///
    /// - Parameters:
    ///   - document: The URL content associated to the
    ///     navigation title.
    ///   - preview: The preview of the document to use when sharing.
    @available(iOS 16.0, macOS 13.0, watchOS 9.0, tvOS 16.0, *)
    nonisolated public func navigationDocument(_ url: URL) -> some View

}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension View {

    /// Uses the string you specify to identify the view.
    ///
    /// Use this value for testing. It isn't visible to the user.
    ///
    /// - Parameters:
    ///   - identifier: The accessibility identifier to apply.
    ///   - isEnabled: If true the accessibility identifier is applied;
    ///     otherwise the accessibility identifier is unchanged.
    nonisolated public func accessibilityIdentifier(_ identifier: String, isEnabled: Bool) -> ModifiedContent<Self, AccessibilityAttachmentModifier>
}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension ModifiedContent where Modifier == AccessibilityAttachmentModifier {

    /// Uses the string you specify to identify the view.
    ///
    /// Use this value for testing. It isn't visible to the user.
    ///
    /// - Parameters:
    ///   - identifier: The accessibility identifier to apply.
    ///   - isEnabled: If true the accessibility identifier is applied;
    ///     otherwise the accessibility identifier is unchanged.
    nonisolated public func accessibilityIdentifier(_ identifier: String, isEnabled: Bool) -> ModifiedContent<Content, Modifier>
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension View {

    /// Uses the string you specify to identify the view.
    ///
    /// Use this value for testing. It isn't visible to the user.
    nonisolated public func accessibilityIdentifier(_ identifier: String) -> ModifiedContent<Self, AccessibilityAttachmentModifier>
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ModifiedContent where Modifier == AccessibilityAttachmentModifier {

    /// Uses the string you specify to identify the view.
    ///
    /// Use this value for testing. It isn't visible to the user.
    nonisolated public func accessibilityIdentifier(_ identifier: String) -> ModifiedContent<Content, Modifier>
}

@available(iOS 15.0, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension View {

    /// Sets the vertical spacing between two adjacent rows in a List.
    ///
    /// The following example creates a List with 10 pts of spacing between each
    /// row:
    ///
    ///     List {
    ///         Text("Blue")
    ///         Text("Red")
    ///     }
    ///     .listRowSpacing(10.0)
    ///
    /// - Parameter spacing: The spacing value to use. A value of `nil` uses
    ///   the default spacing.
    @inlinable nonisolated public func listRowSpacing(_ spacing: CGFloat?) -> some View

}

extension View {

    /// Remove a toolbar item present by default
    ///
    /// Use this modifier to remove toolbar items other `View`s add
    /// by default. For example, to remove the sidebar toggle toolbar
    /// item provided by `NavigationSplitView`:
    ///
    ///     NavigationSplitView {
    ///         SidebarView()
    ///             .toolbar(removing: .sidebarToggle)
    ///     } detail: {
    ///         DetailView()
    ///     }
    ///
    /// - Parameters:
    ///   - defaultItemKind: The kind of default item to remove
    @available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
    nonisolated public func toolbar(removing defaultItemKind: ToolbarDefaultItemKind?) -> some View

}

@available(iOS 13.0, macOS 10.15, watchOS 6.0, tvOS 14.0, *)
extension View {

    /// Adds an action to perform when this view recognizes a long press
    /// gesture.
    ///
    /// - Parameters:
    ///     - minimumDuration: The minimum duration of the long press that must
    ///     elapse before the gesture succeeds.
    ///     - maximumDistance: The maximum distance that the fingers or cursor
    ///     performing the long press can move before the gesture fails.
    ///     - action: The action to perform when a long press is recognized.
    ///     - onPressingChanged:  A closure to run when the pressing state of the
    ///     gesture changes, passing the current state as a parameter.
    @available(tvOS, unavailable)
    nonisolated public func onLongPressGesture(minimumDuration: Double = 0.5, maximumDistance: CGFloat = 10, perform action: @escaping () -> Void, onPressingChanged: ((Bool) -> Void)? = nil) -> some View

}

@available(iOS 13.0, macOS 10.15, watchOS 6.0, tvOS 14.0, *)
extension View {

    /// Adds an action to perform when this view recognizes a long press
    /// gesture.
    @available(iOS, deprecated: 100000.0, renamed: "onLongPressGesture(minimumDuration:maximumDuration:perform:onPressingChanged:)")
    @available(macOS, deprecated: 100000.0, renamed: "onLongPressGesture(minimumDuration:maximumDuration:perform:onPressingChanged:)")
    @available(tvOS, unavailable)
    @available(watchOS, deprecated: 100000.0, renamed: "onLongPressGesture(minimumDuration:maximumDuration:perform:onPressingChanged:)")
    @available(visionOS, deprecated: 100000.0, renamed: "onLongPressGesture(minimumDuration:maximumDuration:perform:onPressingChanged:)")
    nonisolated public func onLongPressGesture(minimumDuration: Double = 0.5, maximumDistance: CGFloat = 10, pressing: ((Bool) -> Void)? = nil, perform action: @escaping () -> Void) -> some View

}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension View {

    /// Presents a confirmation dialog when a given condition is true, using a
    /// localized string key for the title.
    ///
    /// In the example below, a button conditionally presents a confirmation
    /// dialog depending upon the value of a bound Boolean variable. When the
    /// Boolean value is set to `true`, the system displays a confirmation
    /// dialog with a cancel action and a destructive action.
    ///
    ///     struct ConfirmEraseItems: View {
    ///         @State private var isShowingDialog = false
    ///         var body: some View {
    ///             Button("Empty Trash") {
    ///                 isShowingDialog = true
    ///             }
    ///             .confirmationDialog(
    ///                 "Permanently erase the items in the Trash?",
    ///                 isPresented: $isShowingDialog
    ///             ) {
    ///                 Button("Empty Trash", role: .destructive) {
    ///                     // Handle empty trash action.
    ///                 }
    ///             }
    ///         }
    ///     }
    ///
    /// All actions in a confirmation dialog will dismiss the dialog after the
    /// action runs. The default button will be shown with greater prominence.
    /// You can influence the default button by assigning it the
    /// ``KeyboardShortcut/defaultAction`` keyboard shortcut.
    ///
    /// The system may reorder the buttons based on their role and prominence.
    ///
    /// Dialogs include a standard dismiss action by default. If you provide a
    /// button with a role of ``ButtonRole/cancel``, that button takes the place
    /// of the default dismiss action. You don't have to dismiss the
    /// presentation with the cancel button's action.
    ///
    /// > Note: In regular size classes in iOS, the system renders confirmation
    /// dialogs as a popover that the user dismisses by tapping anywhere outside
    /// the popover, rather than displaying the standard dismiss action.
    ///
    /// On iOS, tvOS, and watchOS, confirmation dialogs only support controls
    /// with labels that are ``Text``. Passing any other type of view results in
    /// the content being omitted.
    ///
    /// This modifier creates a ``Text`` view for the title on your behalf, and
    /// treats the localized key similar to
    /// ``Text/init(_:tableName:bundle:comment:)``. See ``Text`` for more
    /// information about localizing strings.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the localized string that describes the title
    ///     of the dialog.
    ///   - isPresented: A binding to a Boolean value that determines whether to
    ///     present the dialog. When the user presses or taps the dialog's
    ///     default action button, the system sets this value to `false`,
    ///     dismissing the dialog.
    ///   - titleVisibility: The visibility of the dialog's title. The default
    ///     value is ``Visibility/automatic``.
    ///   - actions: A view builder returning the dialog's actions.
    nonisolated public func confirmationDialog<A>(_ titleKey: LocalizedStringKey, isPresented: Binding<Bool>, titleVisibility: Visibility = .automatic, @ViewBuilder actions: () -> A) -> some View where A : View


    /// Presents a confirmation dialog when a given condition is true, using a
    /// string variable as a title.
    ///
    /// In the example below, a button conditionally presents a confirmation
    /// dialog depending upon the value of a bound Boolean variable. When the
    /// Boolean value is set to `true`, the system displays a confirmation
    /// dialog with a cancel action and a destructive action.
    ///
    ///     struct ConfirmEraseItems: View {
    ///         @State private var isShowingDialog = false
    ///         var title: String
    ///         var body: some View {
    ///             Button("Empty Trash") {
    ///                 isShowingDialog = true
    ///             }
    ///             .confirmationDialog(
    ///                 title,
    ///                 isPresented: $isShowingDialog
    ///             ) {
    ///                 Button("Empty Trash", role: .destructive) {
    ///                     // Handle empty trash action.
    ///                 }
    ///                 Button("Cancel", role: .cancel) {
    ///                     isShowingDialog = false
    ///                 }
    ///             }
    ///         }
    ///     }
    ///
    /// All actions in a confirmation dialog will dismiss the dialog after the
    /// action runs. The default button will be shown with greater prominence.
    /// You can influence the default button by assigning it the
    /// ``KeyboardShortcut/defaultAction`` keyboard shortcut.
    ///
    /// The system may reorder the buttons based on their role and prominence.
    ///
    /// Dialogs include a standard dismiss action by default. If you provide a
    /// button with a role of ``ButtonRole/cancel``, that button takes the place
    /// of the default dismiss action. You don't have to dismiss the
    /// presentation with the cancel button's action.
    ///
    /// > Note: In regular size classes in iOS, the system renders confirmation
    /// dialogs as a popover that the user dismisses by tapping anywhere outside
    /// the popover, rather than displaying the standard dismiss action.
    ///
    /// - Parameters:
    ///   - title: A text string used as the title of the dialog.
    ///   - isPresented: A binding to a Boolean value that determines whether to
    ///     present the dialog. When the user presses or taps the dialog's
    ///     default action button, the system sets this value to `false`,
    ///     dismissing the dialog.
    ///   - titleVisibility: The visibility of the dialog's title. The default
    ///     value is ``Visibility/automatic``.
    ///   - actions: A view builder returning the dialog's actions.
    nonisolated public func confirmationDialog<S, A>(_ title: S, isPresented: Binding<Bool>, titleVisibility: Visibility = .automatic, @ViewBuilder actions: () -> A) -> some View where S : StringProtocol, A : View


    /// Presents a confirmation dialog when a given condition is true, using a
    /// text view for the title.
    ///
    /// In the example below, a button conditionally presents a confirmation
    /// dialog depending upon the value of a bound Boolean variable. When the
    /// Boolean value is set to `true`, the system displays a confirmation
    /// dialog with a cancel action and a destructive action.
    ///
    ///     struct ConfirmEraseItems: View {
    ///         @State private var isShowingDialog = false
    ///         var body: some View {
    ///             Button("Empty Trash") {
    ///                 isShowingDialog = true
    ///             }
    ///             .confirmationDialog(
    ///                 Text("Permanently erase the items in the trash?"),
    ///                 isPresented: $isShowingDialog
    ///             ) {
    ///                 Button("Empty Trash", role: .destructive) {
    ///                     // Handle empty trash action.
    ///                 }
    ///             }
    ///         }
    ///     }
    ///
    /// All actions in a confirmation dialog will dismiss the dialog after the
    /// action runs. The default button will be shown with greater prominence.
    /// You can influence the default button by assigning it the
    /// ``KeyboardShortcut/defaultAction`` keyboard shortcut.
    ///
    /// The system may reorder the buttons based on their role and prominence.
    ///
    /// Dialogs include a standard dismiss action by default. If you provide a
    /// button with a role of ``ButtonRole/cancel``, that button takes the place
    /// of the default dismiss action. You don't have to dismiss the
    /// presentation with the cancel button's action.
    ///
    /// > Note: In regular size classes in iOS, the system renders confirmation
    /// dialogs as a popover that the user dismisses by tapping anywhere outside
    /// the popover, rather than displaying the standard dismiss action.
    ///
    /// - Parameters:
    ///   - title: the title of the dialog.
    ///   - isPresented: A binding to a Boolean value that determines whether
    ///     to present the dialog. When the user presses or taps the dialog's
    ///     default action button, the system sets this value to `false`,
    ///     dismissing the dialog.
    ///   - titleVisibility: The visibility of the dialog's title. The default
    ///     value is ``Visibility/automatic``.
    ///   - actions: A view builder returning the dialog's actions.
    nonisolated public func confirmationDialog<A>(_ title: Text, isPresented: Binding<Bool>, titleVisibility: Visibility = .automatic, @ViewBuilder actions: () -> A) -> some View where A : View

}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension View {

    /// Presents a confirmation dialog with a message when a given condition is
    /// true, using a localized string key for the title.
    ///
    /// In the example below, a button conditionally presents a confirmation
    /// dialog depending upon the value of a bound Boolean variable. When the
    /// Boolean value is set to `true`, the system displays a confirmation
    /// dialog with a cancel action and a destructive action.
    ///
    ///     struct ConfirmEraseItems: View {
    ///         @State private var isShowingDialog = false
    ///         var body: some View {
    ///             Button("Empty Trash") {
    ///                 isShowingDialog = true
    ///             }
    ///             .confirmationDialog(
    ///                 "Permanently erase the items in the Trash?",
    ///                 isPresented: $isShowingDialog
    ///             ) {
    ///                 Button("Empty Trash", role: .destructive) {
    ///                     // Handle empty trash action.
    ///                 }
    ///             } message: {
    ///                 Text("You cannot undo this action.")
    ///             }
    ///         }
    ///     }
    ///
    /// All actions in a confirmation dialog will dismiss the dialog after the
    /// action runs. The default button will be shown with greater prominence.
    /// You can influence the default button by assigning it the
    /// ``KeyboardShortcut/defaultAction`` keyboard shortcut.
    ///
    /// The system may reorder the buttons based on their role and prominence.
    ///
    /// Dialogs include a standard dismiss action by default. If you provide a
    /// button with a role of ``ButtonRole/cancel``, that button takes the place
    /// of the default dismiss action. You don't have to dismiss the
    /// presentation with the cancel button's action.
    ///
    /// > Note: In regular size classes in iOS, the system renders confirmation
    /// dialogs as a popover that the user dismisses by tapping anywhere outside
    /// the popover, rather than displaying the standard dismiss action.
    ///
    /// On iOS, tvOS, and watchOS, confirmation dialogs only support controls
    /// with labels that are `Text`. Passing any other type of view results in
    /// the content being omitted.
    ///
    /// This modifier creates a ``Text`` view for the title on your behalf, and
    /// treats the localized key similar to
    /// ``Text/init(_:tableName:bundle:comment:)``. See ``Text`` for more
    /// information about localizing strings.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the localized string that describes the title
    ///     of the dialog.
    ///   - isPresented: A binding to a Boolean value that determines whether to
    ///     present the dialog. When the user presses or taps the dialog's
    ///     default action button, the system sets this value to `false`,
    ///     dismissing the dialog.
    ///   - titleVisibility: The visibility of the dialog's title. The default
    ///     value is ``Visibility/automatic``.
    ///   - actions: A view builder returning the dialog's actions.
    ///   - message: A view builder returning the message for the dialog.
    nonisolated public func confirmationDialog<A, M>(_ titleKey: LocalizedStringKey, isPresented: Binding<Bool>, titleVisibility: Visibility = .automatic, @ViewBuilder actions: () -> A, @ViewBuilder message: () -> M) -> some View where A : View, M : View


    /// Presents a confirmation dialog with a message when a given condition is
    /// true, using a string variable for the title.
    ///
    /// In the example below, a button conditionally presents a confirmation
    /// dialog depending upon the value of a bound Boolean variable. When the
    /// Boolean value is set to `true`, the system displays a confirmation
    /// dialog with a cancel action and a destructive action.
    ///
    ///     struct ConfirmEraseItems: View {
    ///         @State private var isShowingDialog = false
    ///         var title: String
    ///         var body: some View {
    ///             Button("Empty Trash") {
    ///                 isShowingDialog = true
    ///             }
    ///             .confirmationDialog(
    ///                 title,
    ///                 isPresented: $isShowingDialog
    ///             ) {
    ///                 Button("Empty Trash", role: .destructive) {
    ///                     // Handle empty trash action.
    ///                 }
    ///                 Button("Cancel", role: .cancel) {
    ///                     isShowingDialog = false
    ///                 }
    ///             } message: {
    ///                 Text("You cannot undo this action.")
    ///             }
    ///         }
    ///     }
    ///
    /// All actions in a confirmation dialog will dismiss the dialog after the
    /// action runs. The default button will be shown with greater prominence.
    /// You can influence the default button by assigning it the
    /// ``KeyboardShortcut/defaultAction`` keyboard shortcut.
    ///
    /// The system may reorder the buttons based on their role and prominence.
    ///
    /// Dialogs include a standard dismiss action by default. If you provide a
    /// button with a role of ``ButtonRole/cancel``, that button takes the place
    /// of the default dismiss action. You don't have to dismiss the
    /// presentation with the cancel button's action.
    ///
    /// > Note: In regular size classes in iOS, the system renders confirmation
    /// dialogs as a popover that the user dismisses by tapping anywhere outside
    /// the popover, rather than displaying the standard dismiss action.
    ///
    /// - Parameters:
    ///   - title: A text string used as the title of the dialog.
    ///   - isPresented: A binding to a Boolean value that determines whether to
    ///     present the dialog. When the user presses or taps the dialog's
    ///     default action button, the system sets this value to `false`,
    ///     dismissing the dialog.
    ///   - titleVisibility: The visibility of the dialog's title. The default
    ///     value is ``Visibility/automatic``.
    ///   - actions: A view builder returning the dialog's actions.
    ///   - message: A view builder returning the message for the dialog.
    nonisolated public func confirmationDialog<S, A, M>(_ title: S, isPresented: Binding<Bool>, titleVisibility: Visibility = .automatic, @ViewBuilder actions: () -> A, @ViewBuilder message: () -> M) -> some View where S : StringProtocol, A : View, M : View


    /// Presents a confirmation dialog with a message when a given condition is
    /// true, using a text view for the title.
    ///
    /// In the example below, a button conditionally presents a confirmation
    /// dialog depending upon the value of a bound Boolean variable. When the
    /// Boolean value is set to `true`, the system displays a confirmation
    /// dialog with a cancel action and a destructive action.
    ///
    ///     struct ConfirmEraseItems: View {
    ///         @State private var isShowingDialog = false
    ///         var body: some View {
    ///             Button("Empty Trash") {
    ///                 isShowingDialog = true
    ///             }
    ///             .confirmationDialog(
    ///                 Text("Permanently erase the items in the trash?"),
    ///                 isPresented: $isShowingDialog
    ///             ) {
    ///                 Button("Empty Trash", role: .destructive) {
    ///                     // Handle empty trash action.
    ///                 }
    ///             } message: {
    ///                 Text("You cannot undo this action.")
    ///             }
    ///         }
    ///     }
    ///
    /// All actions in a confirmation dialog will dismiss the dialog after the
    /// action runs. The default button will be shown with greater prominence.
    /// You can influence the default button by assigning it the
    /// ``KeyboardShortcut/defaultAction`` keyboard shortcut.
    ///
    /// The system may reorder the buttons based on their role and prominence.
    ///
    /// Dialogs include a standard dismiss action by default. If you provide a
    /// button with a role of ``ButtonRole/cancel``, that button takes the place
    /// of the default dismiss action. You don't have to dismiss the
    /// presentation with the cancel button's action.
    ///
    /// > Note: In regular size classes in iOS, the system renders confirmation
    /// dialogs as a popover that the user dismisses by tapping anywhere outside
    /// the popover, rather than displaying the standard dismiss action.
    ///
    /// - Parameters:
    ///   - title: the title of the dialog.
    ///   - isPresented: A binding to a Boolean value that determines whether
    ///     to present the dialog. When the user presses or taps the dialog's
    ///     default action button, the system sets this value to `false`,
    ///     dismissing the dialog.
    ///   - titleVisibility: The visibility of the dialog's title. The default
    ///     value is ``Visibility/automatic``.
    ///   - actions: A view builder returning the dialog's actions.
    ///   - message: A view builder returning the message for the dialog.
    nonisolated public func confirmationDialog<A, M>(_ title: Text, isPresented: Binding<Bool>, titleVisibility: Visibility = .automatic, @ViewBuilder actions: () -> A, @ViewBuilder message: () -> M) -> some View where A : View, M : View

}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension View {

    /// Presents a confirmation dialog using data to produce the dialog's
    /// content and a localized string key for the title.
    ///
    /// In order for the interface to appear, both `isPresented` must be `true`
    /// and `data` must not be `nil`. `data` should not change after the
    /// presentation occurs. Any changes which occur after the presentation
    /// occurs will be ignored.
    ///
    /// Use this method when you need to populate the fields of a confirmation
    /// dialog with content from a data source. The example below shows a custom
    /// data source, `FileDetails`, that provides data to populate the dialog:
    ///
    ///     struct FileDetails: Identifiable {
    ///         var id: String { name }
    ///         let name: String
    ///         let fileType: UTType
    ///     }
    ///     struct ConfirmFileImport: View {
    ///         @State private var isConfirming = false
    ///         @State private var dialogDetail: FileDetails?
    ///         var body: some View {
    ///             Button("Import File") {
    ///                 dialogDetail = FileDetails(
    ///                     name: "MyImageFile.png", fileType: .png)
    ///                 isConfirming = true
    ///             }
    ///             .confirmationDialog(
    ///                 "Are you sure you want to import this file?",
    ///                 isPresented: $isConfirming, presenting: dialogDetail
    ///             ) { detail in
    ///                 Button {
    ///                     // Handle import action.
    ///                 } label: {
    ///                     Text("""
    ///                     Import \(detail.name)
    ///                     File Type: \(detail.fileType.description)
    ///                     """)
    ///                 }
    ///                 Button("Cancel", role: .cancel) {
    ///                     dialogDetail = nil
    ///                 }
    ///             }
    ///         }
    ///     }
    ///
    /// This modifier creates a ``Text`` view for the title on your behalf, and
    /// treats the localized key similar to
    /// ``Text/init(_:tableName:bundle:comment:)``. See ``Text`` for more
    /// information about localizing strings.
    ///
    /// All actions in a confirmation dialog will dismiss the dialog after the
    /// action runs. The default button will be shown with greater prominence.
    /// You can influence the default button by assigning it the
    /// ``KeyboardShortcut/defaultAction`` keyboard shortcut.
    ///
    /// The system may reorder the buttons based on their role and prominence.
    ///
    /// Dialogs include a standard dismiss action by default. If you provide a
    /// button with a role of ``ButtonRole/cancel``, that button takes the place
    /// of the default dismiss action. You don't have to dismiss the
    /// presentation with the cancel button's action.
    ///
    /// > Note: In regular size classes in iOS, the system renders confirmation
    /// dialogs as a popover that the user dismisses by tapping anywhere outside
    /// the popover, rather than displaying the standard dismiss action.
    ///
    /// On iOS, tvOS, and watchOS, confirmation dialogs only support controls
    /// with labels that are `Text`. Passing any other type of view results in
    /// the content being omitted.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the localized string that describes the title
    ///     of the dialog.
    ///   - isPresented: A binding to a Boolean value that determines whether
    ///     to present the dialog. When the user presses or taps the dialog's
    ///     default action button, the system sets this value to `false`,
    ///     dismissing the dialog.
    ///   - titleVisibility: The visibility of the dialog's title. The default
    ///     value is ``Visibility/automatic``.
    ///   - data: An optional source of truth for the confirmation dialog. The
    ///     system passes the contents to the modifier's closures. You use this
    ///     data to populate the fields of a confirmation dialog that you create
    ///     that the system displays to the user.
    ///   - actions: A view builder returning the dialog's actions given the
    ///     currently available data.
    nonisolated public func confirmationDialog<A, T>(_ titleKey: LocalizedStringKey, isPresented: Binding<Bool>, titleVisibility: Visibility = .automatic, presenting data: T?, @ViewBuilder actions: (T) -> A) -> some View where A : View


    /// Presents a confirmation dialog using data to produce the dialog's
    /// content and a string variable for the title.
    ///
    /// In order for the interface to appear, both `isPresented` must be `true`
    /// and `data` must not be `nil`. `data` should not change after the
    /// presentation occurs. Any changes which occur after the presentation
    /// occurs will be ignored.
    ///
    /// Use this method when you need to populate the fields of a confirmation
    /// dialog with content from a data source. The example below shows a custom
    /// data source, `FileDetails`, that provides data to populate the dialog:
    ///
    ///     struct FileDetails: Identifiable {
    ///         var id: String { name }
    ///         let name: String
    ///         let fileType: UTType
    ///     }
    ///     struct ConfirmFileImport: View {
    ///         var title: String
    ///         @State private var isConfirming = false
    ///         @State private var dialogDetail: FileDetails?
    ///         var body: some View {
    ///             Button("Import File") {
    ///                 dialogDetail = FileDetails(
    ///                     name: "MyImageFile.png", fileType: .png)
    ///                 isConfirming = true
    ///             }
    ///             .confirmationDialog(
    ///                 title, isPresented: $isConfirming,
    ///                 presenting: dialogDetail
    ///             ) { detail in
    ///                 Button {
    ///                     // Handle import action.
    ///                 } label: {
    ///                     Text("""
    ///                     Import \(detail.name)
    ///                     File Type: \(detail.fileType.description)
    ///                     """)
    ///                 }
    ///                 Button("Cancel", role: .cancel) {
    ///                     dialogDetail = nil
    ///                 }
    ///             }
    ///         }
    ///     }
    ///
    /// All actions in a confirmation dialog will dismiss the dialog after the
    /// action runs. The default button will be shown with greater prominence.
    /// You can influence the default button by assigning it the
    /// ``KeyboardShortcut/defaultAction`` keyboard shortcut.
    ///
    /// The system may reorder the buttons based on their role and prominence.
    ///
    /// Dialogs include a standard dismiss action by default. If you provide a
    /// button with a role of ``ButtonRole/cancel``, that button takes the place
    /// of the default dismiss action. You don't have to dismiss the
    /// presentation with the cancel button's action.
    ///
    /// > Note: In regular size classes in iOS, the system renders confirmation
    /// dialogs as a popover that the user dismisses by tapping anywhere outside
    /// the popover, rather than displaying the standard dismiss action.
    ///
    /// On iOS, tvOS, and watchOS, confirmation dialogs only support controls
    /// with labels that are `Text`. Passing any other type of view results in
    /// the content being omitted.
    ///
    /// - Parameters:
    ///   - title: A text string used as the title of the dialog.
    ///   - isPresented: A binding to a Boolean value that determines whether
    ///     to present the dialog. When the user presses or taps the dialog's
    ///     default action button, the system sets this value to `false`,
    ///     dismissing the dialog.
    ///   - titleVisibility: The visibility of the dialog's title. The default
    ///     value is ``Visibility/automatic``.
    ///   - data: An optional source of truth for the confirmation dialog. The
    ///     system passes the contents to the modifier's closures. You use this
    ///     data to populate the fields of a confirmation dialog that you create
    ///     that the system displays to the user.
    ///   - actions: A view builder returning the dialog's actions given the
    ///     currently available data.
    nonisolated public func confirmationDialog<S, A, T>(_ title: S, isPresented: Binding<Bool>, titleVisibility: Visibility = .automatic, presenting data: T?, @ViewBuilder actions: (T) -> A) -> some View where S : StringProtocol, A : View


    /// Presents a confirmation dialog using data to produce the dialog's
    /// content and a text view for the title.
    ///
    /// In order for the interface to appear, both `isPresented` must be `true`
    /// and `data` must not be `nil`. `data` should not change after the
    /// presentation occurs. Any changes which occur after the presentation
    /// occurs will be ignored.
    ///
    /// Use this method when you need to populate the fields of a confirmation
    /// dialog with content from a data source. The example below shows a custom
    /// data source, `FileDetails`, that provides data to populate the dialog:
    ///
    ///     struct FileDetails: Identifiable {
    ///         var id: String { name }
    ///         let name: String
    ///         let fileType: UTType
    ///     }
    ///     struct ConfirmFileImport: View {
    ///         @State private var isConfirming = false
    ///         @State private var dialogDetail: FileDetails?
    ///         var body: some View {
    ///             Button("Import File") {
    ///                 dialogDetail = FileDetails(
    ///                     name: "MyImageFile.png", fileType: .png)
    ///                 isConfirming = true
    ///             }
    ///             .confirmationDialog(
    ///                 Text("Import New File?"),
    ///                 isPresented: $isConfirming, presenting: dialogDetail
    ///             ) { detail in
    ///                 Button {
    ///                     // Handle import action.
    ///                 } label: {
    ///                     Text("""
    ///                     Import \(detail.name)
    ///                     File Type: \(detail.fileType.description)
    ///                     """)
    ///                 }
    ///                 Button("Cancel", role: .cancel) {
    ///                     dialogDetail = nil
    ///                 }
    ///             }
    ///         }
    ///     }
    ///
    /// All actions in a confirmation dialog will dismiss the dialog after the
    /// action runs. The default button will be shown with greater prominence.
    /// You can influence the default button by assigning it the
    /// ``KeyboardShortcut/defaultAction`` keyboard shortcut.
    ///
    /// The system may reorder the buttons based on their role and prominence.
    ///
    /// Dialogs include a standard dismiss action by default. If you provide a
    /// button with a role of ``ButtonRole/cancel``, that button takes the place
    /// of the default dismiss action. You don't have to dismiss the
    /// presentation with the cancel button's action.
    ///
    /// > Note: In regular size classes in iOS, the system renders confirmation
    /// dialogs as a popover that the user dismisses by tapping anywhere outside
    /// the popover, rather than displaying the standard dismiss action.
    ///
    /// On iOS, tvOS, and watchOS, confirmation dialogs only support controls
    /// with labels that are `Text`. Passing any other type of view results in
    /// the content being omitted.
    ///
    /// - Parameters:
    ///   - title: the title of the dialog.
    ///   - isPresented: A binding to a Boolean value that determines whether
    ///     to present the dialog. When the user presses or taps the dialog's
    ///     default action button, the system sets this value to `false`,
    ///     dismissing the dialog.
    ///   - titleVisibility: The visibility of the dialog's title. The default
    ///     value is ``Visibility/automatic``.
    ///   - data: An optional source of truth for the confirmation dialog. The
    ///     system passes the contents to the modifier's closures. You use this
    ///     data to populate the fields of a confirmation dialog that you create
    ///     that the system displays to the user.
    ///   - actions: A view builder returning the dialog's actions given the
    ///     currently available data.
    nonisolated public func confirmationDialog<A, T>(_ title: Text, isPresented: Binding<Bool>, titleVisibility: Visibility = .automatic, presenting data: T?, @ViewBuilder actions: (T) -> A) -> some View where A : View

}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension View {

    /// Presents a confirmation dialog with a message using data to produce the
    /// dialog's content and a localized string key for the title.
    ///
    /// In order for the interface to appear, both `isPresented` must be `true`
    /// and `data` must not be `nil`. `data` should not change after the
    /// presentation occurs. Any changes which occur after the presentation
    /// occurs will be ignored.
    ///
    /// Use this method when you need to populate the fields of a confirmation
    /// dialog with content from a data source. The example below shows a custom
    /// data source, `FileDetails`, that provides data to populate the dialog:
    ///
    ///     struct FileDetails: Identifiable {
    ///         var id: String { name }
    ///         let name: String
    ///         let fileType: UTType
    ///     }
    ///     struct ConfirmFileImport: View {
    ///         @State private var isConfirming = false
    ///         @State private var dialogDetail: FileDetails?
    ///         var body: some View {
    ///             Button("Import File") {
    ///                 dialogDetail = FileDetails(
    ///                     name: "MyImageFile.png", fileType: .png)
    ///                 isConfirming = true
    ///             }
    ///             .confirmationDialog(
    ///                 "Are you sure you want to import this file?",
    ///                 isPresented: $isConfirming, presenting: dialogDetail
    ///             ) { detail in
    ///                 Button {
    ///                     // Handle import action.
    ///                 } label: {
    ///                     Text("Import \(detail.name)")
    ///                 }
    ///                 Button("Cancel", role: .cancel) {
    ///                     dialogDetail = nil
    ///                 }
    ///             } message: { detail in
    ///                 Text(
    ///                     """
    ///                     This will add \(detail.name).\(detail.fileType) \
    ///                     to your library.
    ///                     """)
    ///             }
    ///         }
    ///     }
    ///
    /// This modifier creates a ``Text`` view for the title on your behalf, and
    /// treats the localized key similar to
    /// ``Text/init(_:tableName:bundle:comment:)``. See ``Text`` for more
    /// information about localizing strings.
    ///
    /// All actions in a confirmation dialog will dismiss the dialog after the
    /// action runs. The default button will be shown with greater prominence.
    /// You can influence the default button by assigning it the
    /// ``KeyboardShortcut/defaultAction`` keyboard shortcut.
    ///
    /// The system may reorder the buttons based on their role and prominence.
    ///
    /// Dialogs include a standard dismiss action by default. If you provide a
    /// button with a role of ``ButtonRole/cancel``, that button takes the place
    /// of the default dismiss action. You don't have to dismiss the
    /// presentation with the cancel button's action.
    ///
    /// > Note: In regular size classes in iOS, the system renders confirmation
    /// dialogs as a popover that the user dismisses by tapping anywhere outside
    /// the popover, rather than displaying the standard dismiss action.
    ///
    /// On iOS, tvOS, and watchOS, confirmation dialogs only support controls
    /// with labels that are `Text`. Passing any other type of view results in
    /// the content being omitted.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the localized string that describes the title
    ///     of the dialog.
    ///   - isPresented: A binding to a Boolean value that determines whether
    ///     to present the dialog. When the user presses or taps the dialog's
    ///     default action button, the system sets this value to `false`,
    ///     dismissing the dialog.
    ///   - titleVisibility: The visibility of the dialog's title. The default
    ///     value is ``Visibility/automatic``.
    ///   - data: An optional source of truth for the confirmation dialog. The
    ///     system passes the contents to the modifier's closures. You use this
    ///     data to populate the fields of a confirmation dialog that you create
    ///     that the system displays to the user.
    ///   - actions: A view builder returning the dialog's actions given the
    ///     currently available data.
    ///   - message: A view builder returning the message for the dialog given
    ///     the currently available data.
    nonisolated public func confirmationDialog<A, M, T>(_ titleKey: LocalizedStringKey, isPresented: Binding<Bool>, titleVisibility: Visibility = .automatic, presenting data: T?, @ViewBuilder actions: (T) -> A, @ViewBuilder message: (T) -> M) -> some View where A : View, M : View


    /// Presents a confirmation dialog with a message using data to produce the
    /// dialog's content and a string variable for the title.
    ///
    /// In order for the interface to appear, both `isPresented` must be `true`
    /// and `data` must not be `nil`. `data` should not change after the
    /// presentation occurs. Any changes which occur after the presentation
    /// occurs will be ignored.
    ///
    /// Use this method when you need to populate the fields of a confirmation
    /// dialog with content from a data source. The example below shows a custom
    /// data source, `FileDetails`, that provides data to populate the dialog:
    ///
    ///     struct FileDetails: Identifiable {
    ///         var id: String { name }
    ///         let name: String
    ///         let fileType: UTType
    ///     }
    ///     struct ConfirmFileImport: View {
    ///         var title: String
    ///         @State private var isConfirming = false
    ///         @State private var dialogDetail: FileDetails?
    ///         var body: some View {
    ///             Button("Import File") {
    ///                 dialogDetail = FileDetails(
    ///                     name: "MyImageFile.png", fileType: .png)
    ///                 isConfirming = true
    ///             }
    ///             .confirmationDialog(
    ///                 title, isPresented: $isConfirming,
    ///                 presenting: dialogDetail
    ///             ) { detail in
    ///                 Button {
    ///                     // Handle import action.
    ///                 } label: {
    ///                     Text("Import \(detail.name)")
    ///                 }
    ///                 Button("Cancel", role: .cancel) {
    ///                     dialogDetail = nil
    ///                 }
    ///             } message: { detail in
    ///                 Text(
    ///                     """
    ///                     This will add \(detail.name).\(detail.fileType) \
    ///                     to your library.
    ///                     """)
    ///             }
    ///         }
    ///     }
    ///
    /// All actions in a confirmation dialog will dismiss the dialog after the
    /// action runs. The default button will be shown with greater prominence.
    /// You can influence the default button by assigning it the
    /// ``KeyboardShortcut/defaultAction`` keyboard shortcut.
    ///
    /// The system may reorder the buttons based on their role and prominence.
    ///
    /// Dialogs include a standard dismiss action by default. If you provide a
    /// button with a role of ``ButtonRole/cancel``, that button takes the place
    /// of the default dismiss action. You don't have to dismiss the
    /// presentation with the cancel button's action.
    ///
    /// > Note: In regular size classes in iOS, the system renders confirmation
    /// dialogs as a popover that the user dismisses by tapping anywhere outside
    /// the popover, rather than displaying the standard dismiss action.
    ///
    /// On iOS, tvOS, and watchOS, confirmation dialogs only support controls
    /// with labels that are `Text`. Passing any other type of view results in
    /// the content being omitted.
    ///
    /// - Parameters:
    ///   - title: A text string used as the title of the dialog.
    ///   - isPresented: A binding to a Boolean value that determines whether
    ///     to present the dialog. When the user presses or taps the dialog's
    ///     default action button, the system sets this value to `false`,
    ///     dismissing the dialog.
    ///   - titleVisibility: The visibility of the dialog's title. The default
    ///     value is ``Visibility/automatic``.
    ///   - data: An optional source of truth for the confirmation dialog. The
    ///     system passes the contents to the modifier's closures. You use this
    ///     data to populate the fields of a confirmation dialog that you create
    ///     that the system displays to the user.
    ///   - actions: A view builder returning the dialog's actions given the
    ///     currently available data.
    ///   - message: A view builder returning the message for the dialog given
    ///     the currently available data.
    nonisolated public func confirmationDialog<S, A, M, T>(_ title: S, isPresented: Binding<Bool>, titleVisibility: Visibility = .automatic, presenting data: T?, @ViewBuilder actions: (T) -> A, @ViewBuilder message: (T) -> M) -> some View where S : StringProtocol, A : View, M : View


    /// Presents a confirmation dialog with a message using data to produce the
    /// dialog's content and a text view for the message.
    ///
    /// In order for the interface to appear, both `isPresented` must be `true`
    /// and `data` must not be `nil`. `data` should not change after the
    /// presentation occurs. Any changes which occur after the presentation
    /// occurs will be ignored.
    ///
    /// Use this method when you need to populate the fields of a confirmation
    /// dialog with content from a data source. The example below shows a custom
    /// data source, `FileDetails`, that provides data to populate the dialog:
    ///
    ///     struct FileDetails: Identifiable {
    ///         var id: String { name }
    ///         let name: String
    ///         let fileType: UTType
    ///     }
    ///     struct ConfirmFileImport: View {
    ///         @State private var isConfirming = false
    ///         @State private var dialogDetail: FileDetails?
    ///         var body: some View {
    ///             Button("Import File") {
    ///                 dialogDetail = FileDetails(
    ///                     name: "MyImageFile.png", fileType: .png)
    ///                 isConfirming = true
    ///             }
    ///             .confirmationDialog(
    ///                 Text("Import New File?"),
    ///                 isPresented: $isConfirming, presenting: dialogDetail
    ///             ) { detail in
    ///                 Button {
    ///                     // Handle import action.
    ///                 } label: {
    ///                     Text("Import \(detail.name)")
    ///                 }
    ///                 Button("Cancel", role: .cancel) {
    ///                     dialogDetail = nil
    ///                 }
    ///             } message: { detail in
    ///                 Text(
    ///                     """
    ///                     This will add \(detail.name).\(detail.fileType) \
    ///                     to your library.
    ///                     """)
    ///             }
    ///         }
    ///     }
    ///
    /// All actions in a confirmation dialog will dismiss the dialog after the
    /// action runs. The default button will be shown with greater prominence.
    /// You can influence the default button by assigning it the
    /// ``KeyboardShortcut/defaultAction`` keyboard shortcut.
    ///
    /// The system may reorder the buttons based on their role and prominence.
    ///
    /// Dialogs include a standard dismiss action by default. If you provide a
    /// button with a role of ``ButtonRole/cancel``, that button takes the place
    /// of the default dismiss action. You don't have to dismiss the
    /// presentation with the cancel button's action.
    ///
    /// > Note: In regular size classes in iOS, the system renders confirmation
    /// dialogs as a popover that the user dismisses by tapping anywhere outside
    /// the popover, rather than displaying the standard dismiss action.
    ///
    /// On iOS, tvOS, and watchOS, confirmation dialogs only support controls
    /// with labels that are `Text`. Passing any other type of view results in
    /// the content being omitted.
    ///
    /// - Parameters:
    ///   - title: the title of the dialog.
    ///   - isPresented: A binding to a Boolean value that determines whether
    ///     to present the dialog. When the user presses or taps the dialog's
    ///     default action button, the system sets this value to `false`,
    ///     dismissing the dialog.
    ///   - titleVisibility: The visibility of the dialog's title. The default
    ///     value is ``Visibility/automatic``.
    ///   - data: An optional source of truth for the confirmation dialog. The
    ///     system passes the contents to the modifier's closures. You use this
    ///     data to populate the fields of a confirmation dialog that you create
    ///     that the system displays to the user.
    ///   - actions: A view builder returning the dialog's actions given the
    ///     currently available data.
    ///   - message: A view builder returning the message for the dialog given
    ///     the currently available data.
    nonisolated public func confirmationDialog<A, M, T>(_ title: Text, isPresented: Binding<Bool>, titleVisibility: Visibility = .automatic, presenting data: T?, @ViewBuilder actions: (T) -> A, @ViewBuilder message: (T) -> M) -> some View where A : View, M : View

}

@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension View {

    /// Tells a view that acts as a cell in a grid to span the specified
    /// number of columns.
    ///
    /// By default, each view that you put into the content closure of a
    /// ``GridRow`` corresponds to exactly one column of the grid. Apply the
    /// `gridCellColumns(_:)` modifier to a view that you want to span more
    /// than one column, as in the following example of a typical macOS
    /// configuration view:
    ///
    ///     Grid(alignment: .leadingFirstTextBaseline) {
    ///         GridRow {
    ///             Text("Regular font:")
    ///                 .gridColumnAlignment(.trailing)
    ///             Text("Helvetica 12")
    ///             Button("Select...") { }
    ///         }
    ///         GridRow {
    ///             Text("Fixed-width font:")
    ///             Text("Menlo Regular 11")
    ///             Button("Select...") { }
    ///         }
    ///         GridRow {
    ///             Color.clear
    ///                 .gridCellUnsizedAxes([.vertical, .horizontal])
    ///             Toggle("Use fixed-width font for new documents", isOn: $isOn)
    ///                 .gridCellColumns(2) // Span two columns.
    ///         }
    ///     }
    ///
    /// The ``Toggle`` in the example above spans the column that contains
    /// the font names and the column that contains the buttons:
    ///
    /// ![A screenshot of a configuration view, arranged in a grid. The grid
    /// has three colums and three rows. Scanning from top to bottom, the
    /// left-most column contains a cell with the text Regular font, a cell with
    /// the text Fixed-width font, and a blank cell. The middle row contains
    /// a cell with the text Helvetica 12, a cell with the text Menlo Regular
    /// 11, and a cell with a labeled checkbox. The label says Use fixed-width
    /// font for new documents. The label spans its own cell and the cell to
    /// its right. The right-most column contains two cells with buttons
    /// labeled Select. The last column's bottom cell is merged with the cell
    /// from the middle columnn that holds the labeled
    /// checkbox.](View-gridCellColumns-1-macOS)
    ///
    /// > Important: When you tell a cell to span multiple columns, the grid
    /// changes the merged cell to use anchor alignment, rather than the
    /// usual alignment guides. For information about the behavior of
    /// anchor alignment, see ``View/gridCellAnchor(_:)``.
    ///
    /// As a convenience you can cause a view to span all of the ``Grid``
    /// columns by placing the view directly in the content closure of the
    /// ``Grid``, outside of a ``GridRow``, and omitting the modifier. To do
    /// the opposite and include more than one view in a cell, group the views
    /// using an appropriate layout container, like an ``HStack``, so that
    /// they act as a single view.
    ///
    /// - Parameters:
    ///   - count: The number of columns that the view should consume
    ///     when placed in a grid row.
    ///
    /// - Returns: A view that occupies the specified number of columns in a
    ///   grid row.
    @inlinable nonisolated public func gridCellColumns(_ count: Int) -> some View


    /// Specifies a custom alignment anchor for a view that acts as a grid cell.
    ///
    /// Grids, like stacks and other layout containers, perform most alignment
    /// operations using alignment guides. The grid moves the contents of each
    /// cell in a row in the y direction until the specified
    /// ``VerticalAlignment`` guide of each view in the row aligns with the same
    /// guide of all the other views in the row. Similarly, the grid aligns the
    /// ``HorizontalAlignment`` guides of views in a column by adjusting views
    /// in the x direction. See the guide types for more information about
    /// typical SwiftUI alignment operations.
    ///
    /// When you use the `gridCellAnchor(_:)` modifier on a
    /// view in a grid, the grid changes to an anchor-based alignment strategy
    /// for the associated cell. With anchor alignment, the grid projects a
    /// ``UnitPoint`` that you specify onto both the view and the cell, and
    /// aligns the two projections. For example, consider the following grid:
    ///
    ///     Grid(horizontalSpacing: 1, verticalSpacing: 1) {
    ///         GridRow {
    ///             Color.red.frame(width: 60, height: 60)
    ///             Color.red.frame(width: 60, height: 60)
    ///         }
    ///         GridRow {
    ///             Color.red.frame(width: 60, height: 60)
    ///             Color.blue.frame(width: 10, height: 10)
    ///                 .gridCellAnchor(UnitPoint(x: 0.25, y: 0.75))
    ///         }
    ///     }
    ///
    /// The grid creates red reference squares in the first row and column to
    /// establish row and column sizes. Without the anchor modifier, the blue
    /// marker in the remaining cell would appear at the center of its cell,
    /// because of the grid's default ``Alignment/center`` alignment. With
    /// the anchor modifier shown in the code above, the grid aligns the one
    /// quarter point of the marker with the one quarter point of its cell in
    /// the x direction, as measured from the origin at the top left of the
    /// cell. The grid also aligns the three quarters point of the marker
    /// with the three quarters point of the cell in the y direction:
    ///
    /// ![A screenshot of a grid with two rows and two columns. The cells in
    /// the top row and left-most column are each completely filled with a red
    /// rectangle. The lower-right cell contains a small blue square that's
    /// horizontally placed about one quarter of the way from the left to the
    /// right, and about three quarters of the way from the top to the
    /// bottom of the cell it occupies.](View-gridCellAnchor-1-iOS)
    ///
    /// ``UnitPoint`` defines many convenience points that correspond to the
    /// typical alignment guides, which you can use as well. For example, you
    /// can use ``UnitPoint/topTrailing`` to align the top and trailing edges
    /// of a view in a cell with the top and trailing edges of the cell:
    ///
    ///     Color.blue.frame(width: 10, height: 10)
    ///         .gridCellAnchor(.topTrailing)
    ///
    /// ![A screenshot of a grid with two rows and two columns. The cells in
    /// the top row and left-most column are each completely filled with a red
    /// rectangle. The lower-right cell contains a small blue square that's
    /// horizontally aligned with the trailing edge, and vertically aligned
    /// with the top edge of the cell.](View-gridCellAnchor-2-iOS)
    ///
    /// Applying the anchor-based alignment strategy to a single cell
    /// doesn't affect the alignment strategy that the grid uses on other cells.
    ///
    /// ### Anchor alignment for merged cells
    ///
    /// If you use the ``View/gridCellColumns(_:)`` modifier to cause
    /// a cell to span more than one column, or if you place a view in a grid
    /// outside of a row so that the view spans the entire grid, the grid
    /// automatically converts its vertical and horizontal alignment guides
    /// to the unit point equivalent for the merged cell, and uses an
    /// anchor-based approach for that cell. For example, the following grid
    /// places the marker at the center of the merged cell by converting the
    /// grid's default ``Alignment/center`` alignment guide to a
    /// ``UnitPoint/center`` anchor for the blue marker in the merged cell:
    ///
    ///     Grid(alignment: .center, horizontalSpacing: 1, verticalSpacing: 1) {
    ///         GridRow {
    ///             Color.red.frame(width: 60, height: 60)
    ///             Color.red.frame(width: 60, height: 60)
    ///             Color.red.frame(width: 60, height: 60)
    ///         }
    ///         GridRow {
    ///             Color.red.frame(width: 60, height: 60)
    ///             Color.blue.frame(width: 10, height: 10)
    ///                 .gridCellColumns(2)
    ///         }
    ///     }
    ///
    /// The grid makes this conversion in part to avoid ambiguity. Each column
    /// has its own horizontal guide, and it isn't clear which of these
    /// a cell that spans multiple columns should align with. Further, in
    /// the example above, neither of the center alignment guides for the
    /// second or third column would provide the expected behavior, which is
    /// to center the marker in the merged cell. Anchor alignment provides
    /// this behavior:
    ///
    /// ![A screenshot of a grid with two rows and three columns. The cells in
    /// the top row and left-most column are each completely filled with a red
    /// rectangle. The other two cells are meged into a single cell that
    /// contains a small blue square that's centered in the merged
    /// cell.](View-gridCellAnchor-3-iOS)
    ///
    /// - Parameters:
    ///   - anchor: The unit point that defines how to align the view
    ///     within the bounds of its grid cell.
    ///
    /// - Returns: A view that uses the specified anchor point to align its
    ///   content.
    @inlinable nonisolated public func gridCellAnchor(_ anchor: UnitPoint) -> some View


    /// Overrides the default horizontal alignment of the grid column that
    /// the view appears in.
    ///
    /// You set a default alignment for the cells in a grid in both vertical
    /// and horizontal dimensions when you create the grid with the
    /// ``Grid/init(alignment:horizontalSpacing:verticalSpacing:content:)``
    /// initializer. However, you can use the `gridColumnAlignment(_:)` modifier
    /// to override the horizontal alignment of a column within the grid. The
    /// following example sets a grid's alignment to
    /// ``Alignment/leadingFirstTextBaseline``, and then sets the first column
    /// to use ``HorizontalAlignment/trailing`` alignment:
    ///
    ///     Grid(alignment: .leadingFirstTextBaseline) {
    ///         GridRow {
    ///             Text("Regular font:")
    ///                 .gridColumnAlignment(.trailing) // Align the entire first column.
    ///             Text("Helvetica 12")
    ///             Button("Select...") { }
    ///         }
    ///         GridRow {
    ///             Text("Fixed-width font:")
    ///             Text("Menlo Regular 11")
    ///             Button("Select...") { }
    ///         }
    ///         GridRow {
    ///             Color.clear
    ///                 .gridCellUnsizedAxes([.vertical, .horizontal])
    ///             Toggle("Use fixed-width font for new documents", isOn: $isOn)
    ///                 .gridCellColumns(2)
    ///         }
    ///     }
    ///
    /// This creates the layout of a typical macOS configuration
    /// view, with the trailing edge of the first column flush with the
    /// leading edge of the second column:
    ///
    /// ![A screenshot of a configuration view, arranged in a grid. The grid
    /// has three colums and three rows. Scanning from top to bottom, the
    /// left-most column contains a cell with the text Regular font, a cell with
    /// the text Fixed-width font, and a blank cell. The middle row contains
    /// a cell with the text Helvetica 12, a cell with the text Menlo Regular
    /// 11, and a cell with a labeled checkbox. The label says Use fixed-width
    /// font for new documents. The label spans its own cell and the cell to
    /// its right. The right-most column contains two cells with buttons
    /// labeled Select. The last column's bottom cell is merged with the cell
    /// from the middle columnn that holds the labeled
    /// checkbox.](View-gridColumnAlignment-1-macOS)
    ///
    /// Add the modifier to only one cell in a column. The grid
    /// automatically aligns all cells in that column the same way.
    /// You get undefined behavior if you apply different alignments to
    /// different cells in the same column.
    ///
    /// To override row alignment, see ``GridRow/init(alignment:content:)``. To
    /// override alignment for a single cell, see ``View/gridCellAnchor(_:)``.
    ///
    /// - Parameters:
    ///   - guide: The ``HorizontalAlignment`` guide to use for the grid
    ///     column that the view appears in.
    ///
    /// - Returns: A view that uses the specified horizontal alignment, and
    ///   that causes all cells in the same column of a grid to use the
    ///   same alignment.
    @inlinable nonisolated public func gridColumnAlignment(_ guide: HorizontalAlignment) -> some View


    /// Asks grid layouts not to offer the view extra size in the specified
    /// axes.
    ///
    /// Use this modifier to prevent a flexible view from taking more space
    /// on the specified axes than the other cells in a row or column require.
    /// For example, consider the following ``Grid`` that places a ``Divider``
    /// between two rows of content:
    ///
    ///     Grid {
    ///         GridRow {
    ///             Text("Hello")
    ///             Image(systemName: "globe")
    ///         }
    ///         Divider()
    ///         GridRow {
    ///             Image(systemName: "hand.wave")
    ///             Text("World")
    ///         }
    ///     }
    ///
    /// The text and images all have ideal widths for their content. However,
    /// because a divider takes as much space as its parent offers, the grid
    /// fills the width of the display, expanding all the other cells to match:
    ///
    /// ![A screenshot of items arranged in a grid. The upper-left
    /// cell in the grid contains the word hello. The upper-right contains
    /// an image of a globe. The lower-left contains an image of a waving hand.
    /// The lower-right contains the word world. A dividing line that spans
    /// the width of the grid separates the upper and lower elements. The grid's
    /// rows have minimal vertical spacing, but it's columns have a lot of
    /// horizontal spacing, with column content centered
    /// horizontally.](View-gridCellUnsizedAxes-1-iOS)
    ///
    /// You can prevent the grid from giving the divider more width than
    /// the other cells require by adding the modifier with the
    /// ``Axis/horizontal`` parameter:
    ///
    ///     Divider()
    ///         .gridCellUnsizedAxes(.horizontal)
    ///
    /// This restores the grid to the width that it would have without the
    /// divider:
    ///
    /// ![A screenshot of items arranged in a grid. The upper-left
    /// position in the grid contains the word hello. The upper-right contains
    /// an image of a globe. The lower-left contains an image of a waving hand.
    /// The lower-right contains the word world. A dividing line that spans
    /// the width of the grid separates the upper and lower elements. The grid's
    /// rows and columns have minimal vertical or horizontal
    /// spacing.](View-gridCellUnsizedAxes-2-iOS)
    ///
    /// - Parameters:
    ///   - axes: The dimensions in which the grid shouldn't offer the view a
    ///     share of any available space. This prevents a flexible view like a
    ///     ``Spacer``, ``Divider``, or ``Color`` from defining the size of
    ///     a row or column.
    ///
    /// - Returns: A view that doesn't ask an enclosing grid for extra size
    ///   in one or more axes.
    @inlinable nonisolated public func gridCellUnsizedAxes(_ axes: Axis.Set) -> some View

}

@available(iOS 17.5, macOS 14.5, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
@available(visionOS, unavailable)
extension EnvironmentValues {

    /// The action that the user prefers to perform after double-tapping their
    /// Apple Pencil, as selected in the Settings app.
    ///
    /// You can read this value by creating a property with the ``Environment``
    /// property wrapper and using it inside the action closure of the
    /// ``View/onPencilDoubleTap(perform:)`` view modifier as an indication of
    /// what to do after the user double-taps their Apple Pencil:
    ///
    /// ```
    /// @Environment(\.preferredPencilDoubleTapAction) private var preferredAction
    ///
    /// var body: some View {
    ///     MyDrawingCanvas()
    ///         .onPencilDoubleTap { value in
    ///             switch preferredAction {
    ///                 ...
    ///             }
    ///         }
    /// }
    /// ```
    ///
    /// In macOS, this value cannot be changed by users and is always set to
    /// ``PencilPreferredAction/switchEraser``.
    public var preferredPencilDoubleTapAction: PencilPreferredAction { get }
}

@available(iOS 17.5, macOS 14.5, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
@available(visionOS, unavailable)
extension EnvironmentValues {

    /// The action that the user prefers to perform when squeezing their Apple
    /// Pencil, as selected in the Settings app.
    ///
    /// You can read this value by creating a property with the ``Environment``
    /// property wrapper and using it inside the action closure of the
    /// ``View/onPencilSqueeze(perform:)`` view modifier as an indication of
    /// what to do when the user squeezes their Apple Pencil:
    ///
    /// ```
    /// @Environment(\.preferredPencilSqueezeAction) private var preferredAction
    ///
    /// var body: some View {
    ///     MyDrawingCanvas()
    ///         .onPencilSqueeze { phase in
    ///             switch (phase, preferredAction) {
    ///                 ...
    ///             }
    ///         }
    /// }
    /// ```
    ///
    /// In macOS, this value cannot be changed by users and is always set to
    /// ``PencilPreferredAction/showContextualPalette``.
    public var preferredPencilSqueezeAction: PencilPreferredAction { get }
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension View {

    /// Populates the toolbar or navigation bar with the views you provide.
    ///
    /// Use this modifier to add content to the toolbar. The toolbar modifier
    /// expects a collection of toolbar items that you can provide either by
    /// supplying a collection of views with each view wrapped in a
    /// ``ToolbarItem``, or by providing a collection of views as a
    /// ``ToolbarItemGroup``. The example below adds views to using a toolbar
    /// item group to support text editing features:
    ///
    ///     struct StructToolbarItemGroupView: View {
    ///         @State private var text = ""
    ///         @State private var bold = false
    ///         @State private var italic = false
    ///         @State private var fontSize = 12.0
    ///
    ///         var displayFont: Font {
    ///             let font = Font.system(size: CGFloat(fontSize),
    ///                                    weight: bold == true ? .bold : .regular)
    ///             return italic == true ? font.italic() : font
    ///         }
    ///
    ///         var body: some View {
    ///             TextEditor(text: $text)
    ///                 .font(displayFont)
    ///                 .toolbar {
    ///                     ToolbarItemGroup {
    ///                         Slider(
    ///                             value: $fontSize,
    ///                             in: 8...120,
    ///                             minimumValueLabel:
    ///                                 Text("A").font(.system(size: 8)),
    ///                             maximumValueLabel:
    ///                                 Text("A").font(.system(size: 16))
    ///                         ) {
    ///                             Text("Font Size (\(Int(fontSize)))")
    ///                         }
    ///                         .frame(width: 150)
    ///                         Toggle(isOn: $bold) {
    ///                             Image(systemName: "bold")
    ///                         }
    ///                         Toggle(isOn: $italic) {
    ///                             Image(systemName: "italic")
    ///                         }
    ///                     }
    ///                 }
    ///                 .navigationTitle("My Note")
    ///         }
    ///     }
    ///
    /// ![A window showing a font size selector, and toggles for bold, italic.
    ///   and underlined text styling installed in the toolbar to
    ///   support text editing in
    ///   macOS.](SwiftUI-View-Styling-ToolbarContent.png)
    ///
    /// - Parameter content: The views representing the content of the toolbar.
    nonisolated public func toolbar<Content>(@ViewBuilder content: () -> Content) -> some View where Content : View


    /// Populates the toolbar or navigation bar with the specified items.
    ///
    /// Use this method to populate a toolbar with a collection of views that
    /// you provide to a toolbar view builder.
    ///
    /// The toolbar modifier expects a collection of toolbar items which you can
    /// provide either by supplying a collection of views with each view
    /// wrapped in a ``ToolbarItem``, or by providing a collection of views as
    /// a ``ToolbarItemGroup``. The example below uses a collection of
    /// ``ToolbarItem`` views to create a macOS toolbar that supports text
    /// editing features:
    ///
    ///     struct StructToolbarItemGroupView: View {
    ///         @State private var text = ""
    ///         @State private var bold = false
    ///         @State private var italic = false
    ///         @State private var fontSize = 12.0
    ///
    ///         var displayFont: Font {
    ///             let font = Font.system(size: CGFloat(fontSize),
    ///                                    weight: bold == true ? .bold : .regular)
    ///             return italic == true ? font.italic() : font
    ///         }
    ///
    ///         var body: some View {
    ///             TextEditor(text: $text)
    ///                 .font(displayFont)
    ///                 .toolbar {
    ///                     ToolbarItemGroup {
    ///                         Slider(
    ///                             value: $fontSize,
    ///                             in: 8...120,
    ///                             minimumValueLabel:
    ///                                 Text("A").font(.system(size: 8)),
    ///                             maximumValueLabel:
    ///                                 Text("A").font(.system(size: 16))
    ///                         ) {
    ///                             Text("Font Size (\(Int(fontSize)))")
    ///                         }
    ///                         .frame(width: 150)
    ///                         Toggle(isOn: $bold) {
    ///                             Image(systemName: "bold")
    ///                         }
    ///                         Toggle(isOn: $italic) {
    ///                             Image(systemName: "italic")
    ///                         }
    ///                     }
    ///                 }
    ///                 .navigationTitle("My Note")
    ///         }
    ///     }
    ///
    /// ![A window showing a font size selector, and toggles for bold, italic.
    ///   and underlined text styling installed in the toolbar to
    ///   support text editing in
    ///   macOS.](SwiftUI-View-Styling-ToolbarContent.png)
    ///
    /// Although it's not mandatory, wrapping a related group of toolbar
    /// items together in a ``ToolbarItemGroup`` provides a one-to-one mapping
    /// between controls and toolbar items which results in the correct layout
    /// and spacing on each platform.
    /// For design guidance on toolbars, see
    /// <doc://com.apple.documentation/design/human-interface-guidelines/toolbars>
    /// in the Human Interface Guidelines.
    ///
    /// - Parameter content: The items representing the content of the toolbar.
    nonisolated public func toolbar<Content>(@ToolbarContentBuilder content: () -> Content) -> some View where Content : ToolbarContent


    /// Populates the toolbar or navigation bar with the specified items,
    /// allowing for user customization.
    ///
    /// Use this modifier when you want to allow the user to customize the
    /// components and layout of elements in the toolbar. The toolbar modifier
    /// expects a collection of toolbar items which you can provide either by
    /// supplying a collection of views with each view wrapped in a
    /// ``ToolbarItem``.
    ///
    /// > Note: Customizable toolbars will be displayed on both macOS and iOS,
    ///   but only apps running on iPadOS 16.0 and later will support
    ///   user customization.
    ///
    /// The example below creates a view that represents each
    /// ``ToolbarItem`` along with an ID that uniquely identifies the toolbar
    /// item to the customization editor:
    ///
    ///     struct ToolsEditorView: View {
    ///         @State private var text = ""
    ///         @State private var bold = false
    ///         @State private var italic = false
    ///         @State private var fontSize = 12.0
    ///
    ///         var displayFont: Font {
    ///             let font = Font.system(
    ///                size: CGFloat(fontSize),
    ///                  weight: bold == true ? .bold : .regular)
    ///             return italic == true ? font.italic() : font
    ///         }
    ///
    ///         var body: some View {
    ///             TextEditor(text: $text)
    ///                 .font(displayFont)
    ///                 .toolbar(id: "editingtools") {
    ///                     ToolbarItem(
    ///                         id: "sizeSelector", placement: .secondaryAction
    ///                     ) {
    ///                         Slider(
    ///                             value: $fontSize,
    ///                             in: 8...120,
    ///                             minimumValueLabel:
    ///                                 Text("A").font(.system(size: 8)),
    ///                             maximumValueLabel:
    ///                                 Text("A").font(.system(size: 16))
    ///                         ) {
    ///                             Text("Font Size (\(Int(fontSize)))")
    ///                         }
    ///                         .frame(width: 150)
    ///                     }
    ///                     ToolbarItem(
    ///                         id: "bold", placement: .secondaryAction
    ///                     ) {
    ///                         Toggle(isOn: $bold) {
    ///                             Image(systemName: "bold")
    ///                         }
    ///                     }
    ///                     ToolbarItem(
    ///                         id: "italic", placement: .secondaryAction
    ///                     ) {
    ///                         Toggle(isOn: $italic) {
    ///                             Image(systemName: "italic")
    ///                         }
    ///                     }
    ///                 }
    ///                 .navigationTitle("My Note")
    ///         }
    ///     }
    ///
    /// ![A window showing the macOS toolbar customization
    ///   editor.](SwiftUI-View-Styling-ToolbarCustomization.png)
    ///
    /// > Note: Only ``ToolbarItemPlacement/secondaryAction`` items support
    ///   customization in iPadOS. Other items follow the normal
    ///   placement rules and can't be customized by the user.
    ///
    /// In macOS you can enable menu support for toolbar customization by
    /// adding a ``ToolbarCommands`` instance to a scene using the
    /// ``Scene/commands(content:)`` scene modifier:
    ///
    ///     @main
    ///     struct ToolbarContent_macOSApp: App {
    ///         var body: some Scene {
    ///             WindowGroup {
    ///                 ToolsEditorView()
    ///                     .frame(maxWidth: .infinity, maxHeight: .infinity)
    ///             }
    ///             .commands {
    ///                 ToolbarCommands()
    ///             }
    ///         }
    ///     }
    ///
    /// When you add the toolbar commands, the system adds a menu item to
    /// your app's main menu to provide toolbar customization support.
    /// This is in addition to the ability to Control-click on the
    /// toolbar to open the toolbar customization editor.
    ///
    /// ![A screenshot of the toolbar editor support for the macOS view
    /// menu.](SwiftUI-View-Styling-ToolbarCustomizationMenu.png)
    ///
    /// - Parameters:
    ///   - id: A unique identifier for this toolbar.
    ///   - content: The content representing the content of the toolbar.
    nonisolated public func toolbar<Content>(id: String, @ToolbarContentBuilder content: () -> Content) -> some View where Content : CustomizableToolbarContent

}

@available(iOS 16.0, macOS 13.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension Optional : Commands where Wrapped : Commands {

    /// The type of commands that represents the body of this command hierarchy.
    ///
    /// When you create custom commands, Swift infers this type from your
    /// implementation of the required ``SwiftUI/Commands/body-swift.property``
    /// property.
    @available(iOS 16.0, macOS 13.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias Body = Never
}

extension EdgeInsets {

    /// Create edge insets from the equivalent NSDirectionalEdgeInsets.
    @available(iOS 14.0, macOS 11.0, tvOS 14.0, *)
    @available(watchOS, unavailable)
    public init(_ nsEdgeInsets: NSDirectionalEdgeInsets)
}

extension NSDirectionalEdgeInsets {

    /// Create edge insets from the equivalent EdgeInsets.
    @available(iOS 14.0, macOS 11.0, tvOS 14.0, *)
    @available(watchOS, unavailable)
    public init(_ edgeInsets: EdgeInsets)
}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension EnvironmentValues {

    /// The current system user authentication enablement status.
    ///
    /// Use this value to determine whether the system will issue additional device-owner
    /// authentication challenges before revealing this piece of user interface
    /// from under a system-installed shield.
    ///
    /// Your app can respond to changes in this value to take appropriate action,
    /// like installing or uninstalling a bespoke UI shield for sensitive content.
    public var isUserAuthenticationEnabled: Bool
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension View {

    /// Configures the view's title for purposes of navigation.
    ///
    /// A view's navigation title is used to visually display
    /// the current navigation state of an interface.
    /// On iOS and watchOS, when a view is navigated to inside
    /// of a navigation view, that view's title is displayed
    /// in the navigation bar. On iPadOS, the primary destination's
    /// navigation title is reflected as the window's title in the
    /// App Switcher. Similarly on macOS, the primary destination's title
    /// is used as the window title in the titlebar, Windows menu
    /// and Mission Control.
    ///
    /// Refer to the <doc:Configure-Your-Apps-Navigation-Titles> article
    /// for more information on navigation title modifiers.
    ///
    /// - Parameter title: The title to display.
    nonisolated public func navigationTitle(_ title: Text) -> some View


    /// Configures the view's title for purposes of navigation,
    /// using a localized string.
    ///
    /// A view's navigation title is used to visually display
    /// the current navigation state of an interface.
    /// On iOS and watchOS, when a view is navigated to inside
    /// of a navigation view, that view's title is displayed
    /// in the navigation bar. On iPadOS, the primary destination's
    /// navigation title is reflected as the window's title in the
    /// App Switcher. Similarly on macOS, the primary destination's title
    /// is used as the window title in the titlebar, Windows menu
    /// and Mission Control.
    ///
    /// Refer to the <doc:Configure-Your-Apps-Navigation-Titles> article
    /// for more information on navigation title modifiers.
    ///
    /// - Parameter titleKey: The key to a localized string to display.
    nonisolated public func navigationTitle(_ titleKey: LocalizedStringKey) -> some View


    /// Configures the view's title for purposes of navigation, using a string.
    ///
    /// A view's navigation title is used to visually display
    /// the current navigation state of an interface.
    /// On iOS and watchOS, when a view is navigated to inside
    /// of a navigation view, that view's title is displayed
    /// in the navigation bar. On iPadOS, the primary destination's
    /// navigation title is reflected as the window's title in the
    /// App Switcher. Similarly on macOS, the primary destination's title
    /// is used as the window title in the titlebar, Windows menu
    /// and Mission Control.
    ///
    /// Refer to the <doc:Configure-Your-Apps-Navigation-Titles> article
    /// for more information on navigation title modifiers.
    ///
    /// - Parameter title: The string to display.
    nonisolated public func navigationTitle<S>(_ title: S) -> some View where S : StringProtocol

}

extension View {

    /// Configures the view's title for purposes of navigation, using a string
    /// binding.
    ///
    /// In iOS, iPadOS, and macOS, this allows editing the navigation title
    /// when the title is displayed in the toolbar.
    ///
    /// Refer to the <doc:Configure-Your-Apps-Navigation-Titles> article
    /// for more information on navigation title modifiers.
    ///
    /// - Parameter title: The text of the title.
    @available(iOS 16.0, macOS 13.0, watchOS 9.0, tvOS 16.0, *)
    nonisolated public func navigationTitle(_ title: Binding<String>) -> some View

}

@available(iOS 14.0, watchOS 8.0, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
extension View {

    /// Configures the title display mode for this view.
    ///
    /// - Parameter displayMode: The style to use for displaying the title.
    nonisolated public func navigationBarTitleDisplayMode(_ displayMode: NavigationBarItem.TitleDisplayMode) -> some View

}

extension View {

    /// Sets the screen edge from which you want your gesture to take
    /// precedence over the system gesture.
    ///
    /// The following code defers the vertical screen edges system gestures
    /// of a given canvas.
    ///
    ///     struct DeferredView: View {
    ///         var body: some View {
    ///             Canvas()
    ///                 .defersSystemGestures(on: .vertical)
    ///         }
    ///     }
    ///
    /// - Parameter edges: A value that indicates the screen edge from which
    ///   you want your gesture to take precedence over the system gesture.
    @available(iOS 16.0, *)
    @available(macOS, unavailable)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    @available(visionOS, unavailable)
    nonisolated public func defersSystemGestures(on edges: Edge.Set) -> some View

}

@available(iOS, introduced: 13.0, deprecated: 100000.0, message: "Use Color(uiColor:) when converting a UIColor, or create a standard Color directly")
@available(macOS, unavailable)
@available(tvOS, introduced: 13.0, deprecated: 100000.0, message: "Use Color(uiColor:) when converting a UIColor, or create a standard Color directly")
@available(watchOS, introduced: 6.0, deprecated: 100000.0, message: "Use Color(uiColor:) when converting a UIColor, or create a standard Color directly")
@available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Use Color(uiColor:) when converting a UIColor, or create a standard Color directly")
extension Color {

    /// Creates a color from a UIKit color.
    ///
    /// Use this method to create a SwiftUI color from a
    /// <doc://com.apple.documentation/documentation/UIKit/UIColor> instance.
    /// The new color preserves the adaptability of the original.
    /// For example, you can create a rectangle using
    /// <doc://com.apple.documentation/documentation/UIKit/UIColor/3173132-link>
    /// to see how the shade adjusts to match the user's system settings:
    ///
    ///     struct Box: View {
    ///         var body: some View {
    ///             Color(UIColor.link)
    ///                 .frame(width: 200, height: 100)
    ///         }
    ///     }
    ///
    /// The `Box` view defined above automatically changes its
    /// appearance when the user turns on Dark Mode. With the light and dark
    /// appearances placed side by side, you can see the subtle difference
    /// in shades:
    ///
    /// ![A side by side comparison of light and dark appearance screenshots of
    ///   rectangles rendered with the link color. The light variant appears on
    ///   the left, and the dark variant on the right.](Color-init-3)
    ///
    /// > Note: Use this initializer only if you need to convert an existing
    /// <doc://com.apple.documentation/documentation/UIKit/UIColor> to a
    /// SwiftUI color. Otherwise, create a SwiftUI ``Color`` using an
    /// initializer like ``init(_:red:green:blue:opacity:)``, or use a system
    /// color like ``ShapeStyle/blue``.
    ///
    /// - Parameter color: A
    ///   <doc://com.apple.documentation/documentation/UIKit/UIColor> instance
    ///   from which to create a color.
    public init(_ color: UIColor)
}

@available(iOS 15.0, tvOS 15.0, watchOS 8.0, *)
@available(macOS, unavailable)
extension Color {

    /// Creates a color from a UIKit color.
    ///
    /// Use this method to create a SwiftUI color from a
    /// <doc://com.apple.documentation/documentation/UIKit/UIColor> instance.
    /// The new color preserves the adaptability of the original.
    /// For example, you can create a rectangle using
    /// <doc://com.apple.documentation/documentation/UIKit/UIColor/3173132-link>
    /// to see how the shade adjusts to match the user's system settings:
    ///
    ///     struct Box: View {
    ///         var body: some View {
    ///             Color(uiColor: .link)
    ///                 .frame(width: 200, height: 100)
    ///         }
    ///     }
    ///
    /// The `Box` view defined above automatically changes its
    /// appearance when the user turns on Dark Mode. With the light and dark
    /// appearances placed side by side, you can see the subtle difference
    /// in shades:
    ///
    /// ![A side by side comparison of light and dark appearance screenshots of
    ///   rectangles rendered with the link color. The light variant appears on
    ///   the left, and the dark variant on the right.](Color-init-3)
    ///
    /// > Note: Use this initializer only if you need to convert an existing
    /// <doc://com.apple.documentation/documentation/UIKit/UIColor> to a
    /// SwiftUI color. Otherwise, create a SwiftUI ``Color`` using an
    /// initializer like ``init(_:red:green:blue:opacity:)``, or use a system
    /// color like ``ShapeStyle/blue``.
    ///
    /// - Parameter color: A
    ///   <doc://com.apple.documentation/documentation/UIKit/UIColor> instance
    ///   from which to create a color.
    public init(uiColor: UIColor)
}

extension UIColor {

    @available(iOS 14.0, tvOS 14.0, watchOS 7.0, *)
    @available(macOS, unavailable)
    public convenience init(_ color: Color)
}

extension ColorScheme {

    /// Creates a color scheme from its user interface style equivalent.
    @available(iOS 14.0, tvOS 14.0, *)
    @available(macOS, unavailable)
    @available(watchOS, unavailable)
    public init?(_ uiUserInterfaceStyle: UIUserInterfaceStyle)
}

extension UIUserInterfaceStyle {

    /// Creates a user interface style from its ColorScheme equivalent.
    @available(iOS 14.0, tvOS 14.0, *)
    @available(macOS, unavailable)
    @available(watchOS, unavailable)
    public init(_ colorScheme: ColorScheme?)
}

extension ColorSchemeContrast {

    /// Creates a contrast from its accessibility contrast equivalent.
    @available(iOS 14.0, tvOS 14.0, *)
    @available(macOS, unavailable)
    @available(watchOS, unavailable)
    public init?(_ uiAccessibilityContrast: UIAccessibilityContrast)
}

extension UIAccessibilityContrast {

    /// Create a contrast from its ColorSchemeContrast equivalent.
    @available(iOS 14.0, tvOS 14.0, *)
    @available(macOS, unavailable)
    @available(watchOS, unavailable)
    public init(_ colorSchemeContrast: ColorSchemeContrast?)
}

extension ContentSizeCategory {

    /// Create a size category from its UIContentSizeCategory equivalent.
    @available(iOS 14.0, tvOS 14.0, *)
    @available(macOS, unavailable)
    @available(watchOS, unavailable)
    public init?(_ uiSizeCategory: UIContentSizeCategory)
}

@available(iOS 15.0, tvOS 15.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension DynamicTypeSize {

    /// Create a Dynamic Type size from its `UIContentSizeCategory` equivalent.
    public init?(_ uiSizeCategory: UIContentSizeCategory)
}

extension UIContentSizeCategory {

    /// Create a size category from its `ContentSizeCategory` equivalent.
    @available(iOS 14.0, tvOS 14.0, *)
    @available(macOS, unavailable)
    @available(watchOS, unavailable)
    public init(_ sizeCategory: ContentSizeCategory?)

    @available(iOS 15.0, tvOS 15.0, *)
    @available(macOS, unavailable)
    @available(watchOS, unavailable)
    public init(_ dynamicTypeSize: DynamicTypeSize?)
}

extension LayoutDirection {

    /// Create a direction from its UITraitEnvironmentLayoutDirection equivalent.
    @available(iOS 14.0, tvOS 14.0, *)
    @available(macOS, unavailable)
    @available(watchOS, unavailable)
    public init?(_ uiLayoutDirection: UITraitEnvironmentLayoutDirection)
}

extension UITraitEnvironmentLayoutDirection {

    /// Create a direction from its LayoutDirection equivalent.
    @available(iOS 14.0, tvOS 14.0, *)
    @available(macOS, unavailable)
    @available(watchOS, unavailable)
    public init(_ layoutDirection: LayoutDirection)
}

extension LegibilityWeight {

    /// Creates a legibility weight from its UILegibilityWeight equivalent.
    @available(iOS 14.0, tvOS 14.0, *)
    @available(macOS, unavailable)
    @available(watchOS, unavailable)
    public init?(_ uiLegibilityWeight: UILegibilityWeight)
}

extension UILegibilityWeight {

    /// Creates a legibility weight from its LegibilityWeight equivalent.
    @available(iOS 14.0, tvOS 14.0, *)
    @available(macOS, unavailable)
    @available(watchOS, unavailable)
    public init(_ legibilityWeight: LegibilityWeight?)
}

extension UserInterfaceSizeClass {

    /// Creates a SwiftUI size class from the specified UIKit size class.
    @available(iOS 14.0, *)
    @available(macOS, unavailable)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public init?(_ uiUserInterfaceSizeClass: UIUserInterfaceSizeClass)
}

extension UIUserInterfaceSizeClass {

    /// Creates a UIKit size class from the specified SwiftUI size class.
    @available(iOS 14.0, *)
    @available(macOS, unavailable)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public init(_ sizeClass: UserInterfaceSizeClass?)
}

extension Preview {

    /// Creates a preview of a SwiftUI view.
    ///
    /// Preview macros expand into a declaration that calls this initializer.
    /// Don't use this initializer directly. Instead use one of the macros, like
    /// <doc://com.apple.documentation/documentation/SwiftUI/Preview(_:body:)>.
    ///
    /// - Parameters:
    ///   - name: An optional display name for the preview.
    ///   - traits: An optional list of
    ///     <doc://com.apple.documentation/documentation/developertoolssupport/previewtrait>
    ///     instances that customize the appearance of the preview.
    ///   - body: A view builder that produces a SwiftUI view to preview.
    @available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
    @MainActor public init(_ name: String? = nil, traits: PreviewTrait<Preview.ViewTraits>..., body: @escaping @MainActor () -> any View)
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// Sets a value for the specified preference key, the value is a
    /// function of the key's current value and a geometry value tied
    /// to the current coordinate space, allowing readers of the value
    /// to convert the geometry to their local coordinates.
    ///
    /// - Parameters:
    ///   - key: the preference key type.
    ///   - value: the geometry value in the current coordinate space.
    ///   - transform: the function to produce the preference value.
    ///
    /// - Returns: a new version of the view that writes the preference.
    @inlinable nonisolated public func transformAnchorPreference<A, K>(key _: K.Type = K.self, value: Anchor<A>.Source, transform: @escaping (inout K.Value, Anchor<A>) -> Void) -> some View where K : PreferenceKey

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// Defines the content shape for hit testing.
    ///
    /// - Parameters:
    ///   - shape: The hit testing shape for the view.
    ///   - eoFill: A Boolean that indicates whether the shape is interpreted
    ///     with the even-odd winding number rule.
    ///
    /// - Returns: A view that uses the given shape for hit testing.
    @inlinable nonisolated public func contentShape<S>(_ shape: S, eoFill: Bool = false) -> some View where S : Shape

}

@available(iOS 16.0, macOS 12.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension Never {

    /// The type of value of rows presented by this column content.
    public typealias TableRowValue = Never
}

@available(iOS 16.0, macOS 12.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension Never : TableRowContent {

    /// The type of content representing the body of this table row content.
    public typealias TableRowBody = Never

    /// The composition of content that comprise the table row content.
    @MainActor @preconcurrency public var tableRowBody: Never { get }
}

extension View {

    /// Sets the text content type for this view, which the system uses to
    /// offer suggestions while the user enters text on an iOS or tvOS device.
    ///
    /// Use this method to set the content type for input text.
    /// For example, you can configure a ``TextField`` for the entry of email
    /// addresses:
    ///
    ///     TextField("Enter your email", text: $emailAddress)
    ///         .textContentType(.emailAddress)
    ///
    /// - Parameter textContentType: One of the content types available in the
    ///   <doc://com.apple.documentation/documentation/UIKit/UITextContentType>
    ///   structure that identify the semantic meaning expected for a text-entry
    ///   area. These include support for email addresses, location names, URLs,
    ///   and telephone numbers, to name just a few.
    @available(iOS 13.0, tvOS 13.0, *)
    @available(macOS, unavailable)
    @available(watchOS, unavailable)
    @inlinable nonisolated public func textContentType(_ textContentType: UITextContentType?) -> some View

}

extension View {

    /// Configure the title menu of a toolbar.
    ///
    /// A title menu represent common functionality that can be done on the
    /// content represented by your app's toolbar or navigation title. This
    /// menu may be populated from your app's commands like
    /// ``CommandGroupPlacement/saveItem`` or
    /// ``CommandGroupPlacement/printItem``.
    ///
    ///     ContentView()
    ///         .toolbar {
    ///             ToolbarTitleMenu()
    ///         }
    ///
    /// You can provide your own set of actions to override this behavior.
    ///
    ///     ContentView()
    ///         .toolbarTitleMenu {
    ///             DuplicateButton()
    ///             PrintButton()
    ///         }
    ///
    /// In iOS and iPadOS, this will construct a menu that can be presented by
    /// tapping the navigation title in the app's navigation bar.
    ///
    /// - Parameter content: The content associated to the toolbar title menu.
    @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
    nonisolated public func toolbarTitleMenu<C>(@ViewBuilder content: () -> C) -> some View where C : View

}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension View {

    /// Replaces one or more accessibility elements for this view with new
    /// accessibility elements.
    ///
    /// You can make controls accessible by using a custom style. For example, a custom
    /// ``ToggleStyle`` that you create inherits the accessibility features of ``Toggle``
    /// automatically. When you can't use the parent view's accessibility elements, use the
    /// `accessibilityRepresentation(representation:)`
    /// modifier instead. This modifier replaces default accessibility elements with different accessibility
    /// elements that you provide. You use synthetic, non-visual accessibility elements to represent
    /// what the view displays.
    ///
    /// The example below makes a custom adjustable control accessible by explicitly
    /// defining the representation of its step increments using a ``Slider``:
    ///
    ///     var body: some View {
    ///         VStack {
    ///             SliderTrack(...) // Custom slider implementation.
    ///         }
    ///         .accessibilityRepresentation {
    ///             Slider(value: $value, in: 0...100) {
    ///                 Text("Label")
    ///             }
    ///         }
    ///     }
    ///
    /// SwiftUI hides the view that you provide in the `representation` closure
    /// and makes it non-interactive. The framework uses it only to
    /// generate accessibility elements.
    ///
    /// - Parameter representation: A hidden view that the accessibility
    ///   system uses to generate accessibility elements.
    ///
    nonisolated public func accessibilityRepresentation<V>(@ViewBuilder representation: () -> V) -> some View where V : View


    /// Replaces the existing accessibility element's children with one or
    /// more new synthetic accessibility elements.
    ///
    /// Use this modifier to replace an existing element's children with one
    /// or more new synthetic accessibility elements you provide. This allows
    /// for synthetic, non-visual accessibility elements to be set as children
    /// of a visual accessibility element.
    ///
    /// SwiftUI creates an accessibility container implicitly when needed.
    /// If an accessibility element already exists, the framework converts it
    /// into an accessibility container.
    ///
    /// In the  example below, a ``Canvas`` displays a graph of vertical bars that don't have any
    /// inherent accessibility elements. You make the view accessible by adding
    /// the ``accessibilityChildren(children:)`` modifier with views whose accessibility
    /// elements represent the values of each bar drawn in the canvas:
    ///
    ///     var body: some View {
    ///         Canvas { context, size in
    ///             // Draw Graph
    ///             for data in dataSet {
    ///                 let path = Path(
    ///                     roundedRect: CGRect(
    ///                         x: (size.width / CGFloat(dataSet.count))
    ///                         * CGFloat(data.week),
    ///                         y: 0,
    ///                         width: size.width / CGFloat(dataSet.count),
    ///                         height: CGFloat(data.lines),
    ///                     cornerRadius: 5)
    ///                 context.fill(path, with: .color(.blue))
    ///             }
    ///             // Draw Axis and Labels
    ///             ...
    ///         }
    ///         .accessibilityLabel("Lines of Code per Week")
    ///         .accessibilityChildren {
    ///             HStack {
    ///                 ForEach(dataSet) { data in
    ///                     RoundedRectangle(cornerRadius: 5)
    ///                         .accessibilityLabel("Week \(data.week)")
    ///                         .accessibilityValue("\(data.lines) lines")
    ///                 }
    ///             }
    ///         }
    ///     }
    ///
    /// SwiftUI hides any views that you provide with the `children` parameter,
    /// then the framework uses the views to generate the accessibility elements.
    ///
    /// - Parameter children: A ``ViewBuilder`` that represents the replacement
    ///   child views the framework uses to generate accessibility elements.
    nonisolated public func accessibilityChildren<V>(@ViewBuilder children: () -> V) -> some View where V : View

}

extension EnvironmentValues {

    /// A Boolean that indicates whether the quick actions feature is enabled.
    ///
    /// The system uses quick actions to provide users with a
    /// fast alternative interaction method. Quick actions can be
    /// presented to users with a textual banner at the top of their
    /// screen and/or an outline around a view that is already on screen.
    @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
    public var accessibilityQuickActionsEnabled: Bool { get }
}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, *)
@available(watchOS, unavailable)
extension View {

    /// Performs an action if the user presses a key on a hardware keyboard
    /// while the view has focus.
    ///
    /// SwiftUI performs the action for key-down and key-repeat events.
    ///
    /// - Parameters:
    ///   - key: The key to match against incoming hardware keyboard events.
    ///   - action: The action to perform. Return `.handled` to consume the
    ///     event and prevent further dispatch, or `.ignored` to allow dispatch
    ///     to continue.
    /// - Returns: A modified view that binds hardware keyboard input
    ///   when focused.
    nonisolated public func onKeyPress(_ key: KeyEquivalent, action: @escaping () -> KeyPress.Result) -> some View


    /// Performs an action if the user presses a key on a hardware keyboard
    /// while the view has focus.
    ///
    /// SwiftUI performs the action for the specified event phases.
    ///
    /// - Parameters:
    ///   - key: The key to match against incoming hardware keyboard events.
    ///   - phases: The key-press phases to match (`.down`, `.up`,
    ///     and `.repeat`).
    ///   - action: The action to perform. The action receives a value
    ///     describing the matched key event. Return `.handled` to consume the
    ///     event and prevent further dispatch, or `.ignored` to allow dispatch
    ///     to continue.
    /// - Returns: A modified view that binds hardware keyboard input
    ///   when focused.
    nonisolated public func onKeyPress(_ key: KeyEquivalent, phases: KeyPress.Phases, action: @escaping (KeyPress) -> KeyPress.Result) -> some View


    /// Performs an action if the user presses one or more keys on a hardware
    /// keyboard while the view has focus.
    ///
    /// - Parameters:
    ///   - keys: A set of keys to match against incoming hardware
    ///     keyboard events.
    ///   - phases: The key-press phases to match (`.down`, `.repeat`, and
    ///     `.up`). The default value is `[.down, .repeat]`.
    ///   - action: The action to perform. The action receives a value
    ///     describing the matched key event. Return `.handled` to consume the
    ///     event and prevent further dispatch, or `.ignored` to allow dispatch
    ///     to continue.
    /// - Returns: A modified view that binds keyboard input when focused.
    nonisolated public func onKeyPress(keys: Set<KeyEquivalent>, phases: KeyPress.Phases = [.down, .repeat], action: @escaping (KeyPress) -> KeyPress.Result) -> some View


    /// Performs an action if the user presses one or more keys on a hardware
    /// keyboard while the view has focus.
    ///
    /// - Parameters:
    ///   - characters: The set of characters to match against incoming
    ///     hardware keyboard events.
    ///   - phases: The key-press phases to match (`.down`, `.repeat`, and
    ///     `.up`). The default value is `[.down, .repeat]`.
    ///   - action: The action to perform. The action receives a value
    ///     describing the matched key event. Return `.handled` to consume the
    ///     event and prevent further dispatch, or `.ignored` to allow dispatch
    ///     to continue.
    /// - Returns: A modified view that binds hardware keyboard input
    ///   when focused.
    nonisolated public func onKeyPress(characters: CharacterSet, phases: KeyPress.Phases = [.down, .repeat], action: @escaping (KeyPress) -> KeyPress.Result) -> some View


    /// Performs an action if the user presses any key on a hardware keyboard
    /// while the view has focus.
    ///
    /// - Parameters:
    ///   - phases: The key-press phases to match (`.down`, `.repeat`, and
    ///     `.up`). The default value is `[.down, .repeat]`.
    ///   - action: The action to perform. The action receives a value
    ///     describing the matched key event. Return `.handled` to consume the
    ///     event and prevent further dispatch, or `.ignored` to allow dispatch
    ///     to continue.
    /// - Returns: A modified view that binds hardware keyboard input
    ///   when focused.
    nonisolated public func onKeyPress(phases: KeyPress.Phases = [.down, .repeat], action: @escaping (KeyPress) -> KeyPress.Result) -> some View

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// Hides this view unconditionally.
    ///
    /// Hidden views are invisible and can't receive or respond to interactions.
    /// However, they do remain in the view hierarchy and affect layout. Use
    /// this modifier if you want to include a view for layout purposes, but
    /// don't want it to display.
    ///
    ///     HStack {
    ///         Image(systemName: "a.circle.fill")
    ///         Image(systemName: "b.circle.fill")
    ///         Image(systemName: "c.circle.fill")
    ///             .hidden()
    ///         Image(systemName: "d.circle.fill")
    ///     }
    ///
    /// The third circle takes up space, because it's still present, but
    /// SwiftUI doesn't draw it onscreen.
    ///
    /// ![A row of circles with the letters A, B, and D, with a gap where
    ///   the circle with the letter C should be.](SwiftUI-View-hidden-1.png)
    ///
    /// If you want to conditionally include a view in the view hierarchy, use
    /// an `if` statement instead:
    ///
    ///     VStack {
    ///         HStack {
    ///             Image(systemName: "a.circle.fill")
    ///             Image(systemName: "b.circle.fill")
    ///             if !isHidden {
    ///                 Image(systemName: "c.circle.fill")
    ///             }
    ///             Image(systemName: "d.circle.fill")
    ///         }
    ///         Toggle("Hide", isOn: $isHidden)
    ///     }
    ///
    /// Depending on the current value of the `isHidden` state variable in the
    /// example above, controlled by the ``Toggle`` instance, SwiftUI draws
    /// the circle or completely omits it from the layout.
    ///
    /// ![Two side by side groups of items, each composed of a toggle beneath
    ///   a row of circles with letters in them. The toggle on the left
    ///   is off and has four equally spaced circles above it: A, B, C, and D.
    ///   The toggle on the right is on and has three equally spaced circles
    ///   above it: A, B, and D.](SwiftUI-View-hidden-2.png)
    ///
    /// - Returns: A hidden view.
    @inlinable nonisolated public func hidden() -> some View

}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension View {

    /// Adds a descriptor to a View that represents a chart to make
    /// the chart's contents accessible to all users.
    ///
    /// Use this method to provide information about your chart view
    /// to allow VoiceOver and other assistive technology users to
    /// perceive and interact with your chart and its data.
    ///
    /// This may be applied to any View that represents a chart,
    /// including Image and custom-rendered chart views.
    ///
    /// The `accessibilityChartDescriptor` modifier can be applied to -any-
    /// view representing a chart, the simplest case being just an image of
    /// a chart. The implementation details of the view aren't important,
    /// only the fact that it represents a chart, and that the provided
    /// chart descriptor accurately describes the content of the chart.
    ///
    /// - Parameter chartDescriptor: The ``AXChartDescriptorRepresentable``
    ///  used to describe your chart and its data.
    ///
    /// Example usage:
    ///
    /// First define your `AXChartDescriptorRepresentable` type.
    ///
    ///     struct MyChartDescriptorRepresentable:
    ///     AXChartDescriptorRepresentable {
    ///         func makeChartDescriptor() -> AXChartDescriptor {
    ///             // Build and return your `AXChartDescriptor` here.
    ///         }
    ///
    ///         func updateChartDescriptor(_ descriptor: AXChartDescriptor) {
    ///             // Update your chart descriptor with any new values, or
    ///             // don't override if your chart doesn't have changing
    ///             // values.
    ///         }
    ///     }
    ///
    /// Then use the `accessibilityChartDescriptor` modifier to provide an
    /// instance of your `AXChartDescriptorRepresentable` type to the view
    /// representing your chart:
    ///
    ///     SomeChartView()
    ///         .accessibilityChartDescriptor(MyChartDescriptorRepresentable())
    nonisolated public func accessibilityChartDescriptor<R>(_ representable: R) -> some View where R : AXChartDescriptorRepresentable

}

extension View {

    /// Configures the search toolbar presentation behavior for any
    /// searchable modifiers within this view.
    ///
    /// By default on iOS, a toolbar may hide parts of its content when
    /// presenting search to focus on searching. You can override
    /// this behavior by providing a value of
    /// ``SearchPresentationToolbarBehavior/avoidHidingContent``
    /// to this modifer.
    ///
    ///     @State private var searchText = ""
    ///
    ///     List {
    ///         // ... content
    ///     }
    ///     .searchable(text: $searchText)
    ///     .searchPresentationToolbarBehavior(.avoidHidingContent)
    ///
    @available(iOS 17.1, macOS 14.1, tvOS 17.1, watchOS 10.1, *)
    nonisolated public func searchPresentationToolbarBehavior(_ behavior: SearchPresentationToolbarBehavior) -> some View

}

extension View {

    /// Configures the dictation behavior for any search fields configured
    /// by the searchable modifier.
    ///
    /// By default, search fields on visionOS will automatically start
    /// dictation when looking at the dictation button in the search field.
    /// You can change this behavior by providing a value of
    /// ``TextInputDictationBehavior/preventDictation`` to this modifier.
    ///
    /// See the ``TextInputDictationBehavior`` type for more information
    /// on the available dictation behaviors.
    @available(iOS 17.0, visionOS 1.0, *)
    @available(macOS, unavailable)
    @available(watchOS, unavailable)
    @available(tvOS, unavailable)
    nonisolated public func searchDictationBehavior(_ dictationBehavior: TextInputDictationBehavior) -> some View

}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension View {

    /// Add additional accessibility information to the view.
    ///
    /// Use this method to add information you want accessibility users to be
    /// able to access about this element, beyond the basics of label, value,
    /// and hint. For example, `accessibilityCustomContent` can be used to add
    /// information about the orientation of a photograph, or the number of
    /// people found in the picture.
    ///
    /// - Parameter key: Key used to specify the identifier and label of the
    ///   of the additional accessibility information entry.
    /// - Parameter value: Text value for the additional accessibility
    ///   information. For example: "landscape." A value of `nil` will remove
    ///   any entry of additional information added earlier for any `key` with
    ///   the same identifier.
    /// - Note: Repeated calls of `accessibilityCustomContent` with `key`s
    ///   having different identifiers will create new entries of
    ///   additional information.
    ///   Calling `accessibilityAdditionalContent` repeatedly with `key`s
    ///   having matching identifiers will replace the previous entry.
    nonisolated public func accessibilityCustomContent(_ key: AccessibilityCustomContentKey, _ value: Text?, importance: AXCustomContent.Importance = .default) -> ModifiedContent<Self, AccessibilityAttachmentModifier>

    /// Add additional accessibility information to the view.
    ///
    /// Use this method to add information you want accessibility users to be
    /// able to access about this element, beyond the basics of label, value,
    /// and hint. For example, `accessibilityCustomContent` can be used to add
    /// information about the orientation of a photograph, or the number of
    /// people found in the picture.
    ///
    /// - Parameter key: Key used to specify the identifier and label of the
    ///   of the additional accessibility information entry.
    /// - Parameter valueKey: Text value for the additional accessibility
    ///   information. For example: "landscape." A value of `nil` will remove
    ///   any entry of additional information added earlier for any `key` with
    ///   the same identifier.
    /// - Parameter importance: Importance of the accessibility information.
    ///   High-importance information gets read out immediately, while
    ///   default-importance information must be explicitly asked for by the
    ///   user.
    /// - Note: Repeated calls of `accessibilityCustomContent` with `key`s
    ///   having different identifiers will create new entries of
    ///   additional information.
    ///   Calling `accessibilityAdditionalContent` repeatedly with `key`s
    ///   having matching identifiers will replace the previous entry.
    nonisolated public func accessibilityCustomContent(_ key: AccessibilityCustomContentKey, _ valueKey: LocalizedStringKey, importance: AXCustomContent.Importance = .default) -> ModifiedContent<Self, AccessibilityAttachmentModifier>

    /// Add additional accessibility information to the view.
    ///
    /// Use this method to add information you want accessibility users to be
    /// able to access about this element, beyond the basics of label, value,
    /// and hint. For example, `accessibilityCustomContent` can be used to add
    /// information about the orientation of a photograph, or the number of
    /// people found in the picture.
    ///
    /// - Parameter key: Key used to specify the identifier and label of the
    ///   of the additional accessibility information entry.
    /// - Parameter value: Text value for the additional accessibility
    ///   information. For example: "landscape." A value of `nil` will remove
    ///   any entry of additional information added earlier for any `key` with
    ///   the same identifier.
    /// - Parameter importance: Importance of the accessibility information.
    ///   High-importance information gets read out immediately, while
    ///   default-importance information must be explicitly asked for by the
    ///   user.
    /// - Note: Repeated calls of `accessibilityCustomContent` with `key`s
    ///   having different identifiers will create new entries of
    ///   additional information.
    ///   Calling `accessibilityAdditionalContent` repeatedly with `key`s
    ///   having matching identifiers will replace the previous entry.
    nonisolated public func accessibilityCustomContent<V>(_ key: AccessibilityCustomContentKey, _ value: V, importance: AXCustomContent.Importance = .default) -> ModifiedContent<Self, AccessibilityAttachmentModifier> where V : StringProtocol
}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension View {

    /// Add additional accessibility information to the view.
    ///
    /// Use this method to add information you want accessibility users to be
    /// able to access about this element, beyond the basics of label, value,
    /// and hint. For example: `accessibilityCustomContent` can be used to add
    /// information about the orientation of a photograph, or the number of
    /// people found in the picture.
    ///
    /// - Parameter label: Localized text describing to the user what
    ///   is contained in this additional information entry. For example:
    ///   "orientation".
    /// - Parameter value: Text value for the additional accessibility
    ///   information. For example: "landscape."
    /// - Parameter importance: Importance of the accessibility information.
    ///   High-importance information gets read out immediately, while
    ///   default-importance information must be explicitly asked for by the
    ///   user.
    /// - Note: Repeated calls of `accessibilityCustomContent` with different
    ///   labels will create new entries of additional information. Calling
    ///   `accessibilityAdditionalContent` repeatedly with the same label will
    ///   instead replace the previous value and importance.
    nonisolated public func accessibilityCustomContent(_ label: Text, _ value: Text, importance: AXCustomContent.Importance = .default) -> ModifiedContent<Self, AccessibilityAttachmentModifier>

    /// Add additional accessibility information to the view.
    ///
    /// Use this method to add information you want accessibility users to be
    /// able to access about this element, beyond the basics of label, value,
    /// and hint. For example: `accessibilityCustomContent` can be used to add
    /// information about the orientation of a photograph, or the number of
    /// people found in the picture.
    ///
    /// - Parameter label: Localized text describing to the user what
    ///   is contained in this additional information entry. For example:
    ///   "orientation".
    /// - Parameter value: Text value for the additional accessibility
    ///   information. For example: "landscape."
    /// - Parameter importance: Importance of the accessibility information.
    ///   High-importance information gets read out immediately, while
    ///   default-importance information must be explicitly asked for by the
    ///   user.
    /// - Note: Repeated calls of `accessibilityCustomContent` with different
    ///   labels will create new entries of additional information. Calling
    ///   `accessibilityAdditionalContent` repeatedly with the same label will
    ///   instead replace the previous value and importance.
    nonisolated public func accessibilityCustomContent(_ labelKey: LocalizedStringKey, _ value: Text, importance: AXCustomContent.Importance = .default) -> ModifiedContent<Self, AccessibilityAttachmentModifier>

    /// Add additional accessibility information to the view.
    ///
    /// Use this method to add information you want accessibility users to be
    /// able to access about this element, beyond the basics of label, value,
    /// and hint. For example, `accessibilityCustomContent` can be used to add
    /// information about the orientation of a photograph, or the number of
    /// people found in the picture.
    ///
    /// - Parameter labelKey: Localized text describing to the user what
    ///   is contained in this additional information entry. For example:
    ///   "orientation".
    /// - Parameter value: Text value for the additional accessibility
    ///   information. For example: "landscape."
    /// - Parameter importance: Importance of the accessibility information.
    ///   High-importance information gets read out immediately, while
    ///   default-importance information must be explicitly asked for by the
    ///   user.
    /// - Note: Repeated calls of `accessibilityCustomContent` with different
    ///   labels will create new entries of additional information. Calling
    ///   `accessibilityAdditionalContent` repeatedly with the same label will
    ///   instead replace the previous value and importance.
    nonisolated public func accessibilityCustomContent(_ labelKey: LocalizedStringKey, _ valueKey: LocalizedStringKey, importance: AXCustomContent.Importance = .default) -> ModifiedContent<Self, AccessibilityAttachmentModifier>

    /// Add additional accessibility information to the view.
    ///
    /// Use this method to add information you want accessibility users to be
    /// able to access about this element, beyond the basics of label, value,
    /// and hint. For example, `accessibilityCustomContent` can be used to add
    /// information about the orientation of a photograph, or the number of
    /// people found in the picture.
    ///
    /// - Parameter labelKey: Localized text describing to the user what
    ///   is contained in this additional information entry. For example:
    ///   "orientation".
    /// - Parameter value: Text value for the additional accessibility
    ///   information. For example: "landscape."
    /// - Parameter importance: Importance of the accessibility information.
    ///   High-importance information gets read out immediately, while
    ///   default-importance information must be explicitly asked for by the
    ///   user.
    /// - Note: Repeated calls of `accessibilityCustomContent` with different
    ///   labels will create new entries of additional information. Calling
    ///   `accessibilityAdditionalContent` repeatedly with the same label will
    ///   instead replace the previous value and importance.
    nonisolated public func accessibilityCustomContent<V>(_ labelKey: LocalizedStringKey, _ value: V, importance: AXCustomContent.Importance = .default) -> ModifiedContent<Self, AccessibilityAttachmentModifier> where V : StringProtocol
}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension ModifiedContent where Modifier == AccessibilityAttachmentModifier {

    /// Add additional accessibility information to the view.
    ///
    /// Use this method to add information you want accessibility users to be
    /// able to access about this element, beyond the basics of label, value,
    /// and hint. For example, `accessibilityCustomContent` can be used to add
    /// information about the orientation of a photograph, or the number of
    /// people found in the picture.
    ///
    /// - Parameter key: Key used to specify the identifier and label of the
    ///   of the additional accessibility information entry.
    /// - Parameter value: Text value for the additional accessibility
    ///   information. For example: "landscape." A value of `nil` will remove
    ///   any entry of additional information added earlier for any `key` with
    ///   the same identifier.
    /// - Note: Repeated calls of `accessibilityCustomContent` with `key`s
    ///   having different identifiers will create new entries of
    ///   additional information.
    ///   Calling `accessibilityAdditionalContent` repeatedly with `key`s
    ///   having matching identifiers will replace the previous entry.
    nonisolated public func accessibilityCustomContent(_ key: AccessibilityCustomContentKey, _ value: Text?, importance: AXCustomContent.Importance = .default) -> ModifiedContent<Content, Modifier>

    /// Add additional accessibility information to the view.
    ///
    /// Use this method to add information you want accessibility users to be
    /// able to access about this element, beyond the basics of label, value,
    /// and hint. For example, `accessibilityCustomContent` can be used to add
    /// information about the orientation of a photograph, or the number of
    /// people found in the picture.
    ///
    /// - Parameter key: Key used to specify the identifier and label of the
    ///   of the additional accessibility information entry.
    /// - Parameter valueKey: Text value for the additional accessibility
    ///   information. For example: "landscape." A value of `nil` will remove
    ///   any entry of additional information added earlier for any `key` with
    ///   the same identifier.
    /// - Parameter importance: Importance of the accessibility information.
    ///   High-importance information gets read out immediately, while
    ///   default-importance information must be explicitly asked for by the
    ///   user.
    /// - Note: Repeated calls of `accessibilityCustomContent` with `key`s
    ///   having different identifiers will create new entries of
    ///   additional information.
    ///   Calling `accessibilityAdditionalContent` repeatedly with `key`s
    ///   having matching identifiers will replace the previous entry.
    nonisolated public func accessibilityCustomContent(_ key: AccessibilityCustomContentKey, _ valueKey: LocalizedStringKey, importance: AXCustomContent.Importance = .default) -> ModifiedContent<Content, Modifier>

    /// Add additional accessibility information to the view.
    ///
    /// Use this method to add information you want accessibility users to be
    /// able to access about this element, beyond the basics of label, value,
    /// and hint. For example, `accessibilityCustomContent` can be used to add
    /// information about the orientation of a photograph, or the number of
    /// people found in the picture.
    ///
    /// - Parameter key: Key used to specify the identifier and label of the
    ///   of the additional accessibility information entry.
    /// - Parameter value: Text value for the additional accessibility
    ///   information. For example: "landscape." A value of `nil` will remove
    ///   any entry of additional information added earlier for any `key` with
    ///   the same identifier.
    /// - Parameter importance: Importance of the accessibility information.
    ///   High-importance information gets read out immediately, while
    ///   default-importance information must be explicitly asked for by the
    ///   user.
    /// - Note: Repeated calls of `accessibilityCustomContent` with `key`s
    ///   having different identifiers will create new entries of
    ///   additional information.
    ///   Calling `accessibilityAdditionalContent` repeatedly with `key`s
    ///   having matching identifiers will replace the previous entry.
    nonisolated public func accessibilityCustomContent<V>(_ key: AccessibilityCustomContentKey, _ value: V, importance: AXCustomContent.Importance = .default) -> ModifiedContent<Content, Modifier> where V : StringProtocol

    /// Add additional accessibility information to the view.
    ///
    /// Use this method to add information you want accessibility users to be
    /// able to access about this element, beyond the basics of label, value,
    /// and hint. For example: `accessibilityCustomContent` can be used to add
    /// information about the orientation of a photograph, or the number of
    /// people found in the picture.
    ///
    /// - Parameter label: Localized text describing to the user what
    ///   is contained in this additional information entry. For example:
    ///   "orientation".
    /// - Parameter value: Text value for the additional accessibility
    ///   information. For example: "landscape."
    /// - Parameter importance: Importance of the accessibility information.
    ///   High-importance information gets read out immediately, while
    ///   default-importance information must be explicitly asked for by the
    ///   user.
    /// - Note: Repeated calls of `accessibilityCustomContent` with different
    ///   labels will create new entries of additional information. Calling
    ///   `accessibilityAdditionalContent` repeatedly with the same label will
    ///   instead replace the previous value and importance.
    nonisolated public func accessibilityCustomContent(_ label: Text, _ value: Text, importance: AXCustomContent.Importance = .default) -> ModifiedContent<Content, Modifier>

    /// Add additional accessibility information to the view.
    ///
    /// Use this method to add information you want accessibility users to be
    /// able to access about this element, beyond the basics of label, value,
    /// and hint. For example: `accessibilityCustomContent` can be used to add
    /// information about the orientation of a photograph, or the number of
    /// people found in the picture.
    ///
    /// - Parameter label: Localized text describing to the user what
    ///   is contained in this additional information entry. For example:
    ///   "orientation".
    /// - Parameter value: Text value for the additional accessibility
    ///   information. For example: "landscape."
    /// - Parameter importance: Importance of the accessibility information.
    ///   High-importance information gets read out immediately, while
    ///   default-importance information must be explicitly asked for by the
    ///   user.
    /// - Note: Repeated calls of `accessibilityCustomContent` with different
    ///   labels will create new entries of additional information. Calling
    ///   `accessibilityAdditionalContent` repeatedly with the same label will
    ///   instead replace the previous value and importance.
    nonisolated public func accessibilityCustomContent(_ labelKey: LocalizedStringKey, _ value: Text, importance: AXCustomContent.Importance = .default) -> ModifiedContent<Content, Modifier>

    /// Add additional accessibility information to the view.
    ///
    /// Use this method to add information you want accessibility users to be
    /// able to access about this element, beyond the basics of label, value,
    /// and hint. For example, `accessibilityCustomContent` can be used to add
    /// information about the orientation of a photograph, or the number of
    /// people found in the picture.
    ///
    /// - Parameter labelKey: Localized text describing to the user what
    ///   is contained in this additional information entry. For example:
    ///   "orientation".
    /// - Parameter value: Text value for the additional accessibility
    ///   information. For example: "landscape."
    /// - Parameter importance: Importance of the accessibility information.
    ///   High-importance information gets read out immediately, while
    ///   default-importance information must be explicitly asked for by the
    ///   user.
    /// - Note: Repeated calls of `accessibilityCustomContent` with different
    ///   labels will create new entries of additional information. Calling
    ///   `accessibilityAdditionalContent` repeatedly with the same label will
    ///   instead replace the previous value and importance.
    nonisolated public func accessibilityCustomContent(_ labelKey: LocalizedStringKey, _ valueKey: LocalizedStringKey, importance: AXCustomContent.Importance = .default) -> ModifiedContent<Content, Modifier>

    /// Add additional accessibility information to the view.
    ///
    /// Use this method to add information you want accessibility users to be
    /// able to access about this element, beyond the basics of label, value,
    /// and hint. For example, `accessibilityCustomContent` can be used to add
    /// information about the orientation of a photograph, or the number of
    /// people found in the picture.
    ///
    /// - Parameter labelKey: Localized text describing to the user what
    ///   is contained in this additional information entry. For example:
    ///   "orientation".
    /// - Parameter value: Text value for the additional accessibility
    ///   information. For example: "landscape."
    /// - Parameter importance: Importance of the accessibility information.
    ///   High-importance information gets read out immediately, while
    ///   default-importance information must be explicitly asked for by the
    ///   user.
    /// - Note: Repeated calls of `accessibilityCustomContent` with different
    ///   labels will create new entries of additional information. Calling
    ///   `accessibilityAdditionalContent` repeatedly with the same label will
    ///   instead replace the previous value and importance.
    nonisolated public func accessibilityCustomContent<V>(_ labelKey: LocalizedStringKey, _ value: V, importance: AXCustomContent.Importance = .default) -> ModifiedContent<Content, Modifier> where V : StringProtocol
}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension View {

    /// Sets the direction of a selection or cursor relative to a text character.
    ///
    /// Use this modifier when you need to handle line breaks in a specific way,
    /// alter cursor movement or deal with bidirectional text (text that
    /// contains both LTR and RTL scripts, like English and Arabic combined).
    ///
    /// Selection affinity also determines whether, for example, the insertion
    /// point appears after the last character on a line or before the first
    /// character on the following line in cases where text wraps across line boundaries.
    ///
    /// Given the scenario `hello|`, where `|` represents the cursor & ``
    /// represents "hello" in Arabic, the ambiguity arises because:
    ///
    /// - If the cursor is associated with the end of the English word, it would be
    ///   as if you're continuing to type in English (LTR).
    /// - If the cursor is associated with the beginning of the Arabic word, it would
    ///   also be as if you're continuing to type in Arabic (RTL).
    ///
    /// This modifier helps resolve this ambiguity by determining the
    /// direction or association of the cursor relative to the surrounding text.
    ///
    /// The following example shows how you would specify a specific selection
    /// affinity on the given hierarchy:
    ///
    ///     struct SuggestionTextEditor: View {
    ///         @State var text: String = ""
    ///         @State var selection: TextSelection? = nil
    ///
    ///         var body: some View {
    ///             VStack {
    ///                 TextEditor(text: $text, selection: $selection)
    ///                 // A helper view that offers live suggestions based on selection.
    ///                 SuggestionsView(
    ///                     substrings: getSubstrings(text: text, indices: selection?.indices))
    ///             }
    ///             .textSelectionAffinity(.upstream)
    ///         }
    ///
    ///         private func getSubstrings(
    ///             text: String, indices: TextSelection.Indices?
    ///         ) -> [Substring] {
    ///             // Resolve substrings representing the current selection...
    ///         }
    ///     }
    ///
    ///     struct SuggestionsView: View { ... }
    ///
    /// - Parameter affinity: The text selection affinity strategy to apply.
    ///
    /// - Returns: A view that uses the specified selection affinity strategy.
    nonisolated public func textSelectionAffinity(_ affinity: TextSelectionAffinity) -> some View

}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension EnvironmentValues {

    /// A representation of the direction or association of a selection or cursor
    /// relative to a text character. This concept becomes much more prominent
    /// when dealing with bidirectional text (text that contains both LTR and RTL
    /// scripts, like English and Arabic combined).
    ///
    /// You can configure the selection affinity on a given hierarchy by using
    /// the ``View/textSelectionAffinity(_:)`` modifier.
    public var textSelectionAffinity: TextSelectionAffinity
}

@available(iOS 15.0, macOS 12.0, tvOS 17.0, *)
@available(watchOS, unavailable)
extension EnvironmentValues {

    /// The menu indicator visibility to apply to controls within a view.
    ///
    /// - Note: On tvOS, the standard button styles do not include a menu
    ///         indicator, so this modifier will have no effect when using a
    ///         built-in button style. You can implement an indicator in your
    ///         own ``ButtonStyle`` implementation by checking the value of this
    ///         environment value.
    public var menuIndicatorVisibility: Visibility
}

@available(iOS 15.0, macOS 12.0, tvOS 17.0, *)
@available(watchOS, unavailable)
extension View {

    /// Sets the menu indicator visibility for controls within this view.
    ///
    /// Use this modifier to override the default menu indicator
    /// visibility for controls in this view. For example, the code below
    /// creates a menu without an indicator:
    ///
    ///     Menu {
    ///         ForEach(history , id: \.self) { historyItem in
    ///             Button(historyItem.title) {
    ///                 self.openURL(historyItem.url)
    ///             }
    ///         }
    ///     } label: {
    ///         Label("Back", systemImage: "chevron.backward")
    ///             .labelStyle(.iconOnly)
    ///     } primaryAction: {
    ///         if let last = history.last {
    ///             self.openURL(last.url)
    ///         }
    ///     }
    ///     .menuIndicator(.hidden)
    ///
    /// - Note: On tvOS, the standard button styles do not include a menu
    ///         indicator, so this modifier will have no effect when using a
    ///         built-in button style. You can implement an indicator in your
    ///         own ``ButtonStyle`` implementation by checking the value of the
    ///         `menuIndicatorVisibility` environment value.
    ///
    /// - Parameter visibility: The menu indicator visibility to apply.
    @inlinable nonisolated public func menuIndicator(_ visibility: Visibility) -> some View

}

@available(iOS 16.0, macOS 12.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension Group : TableColumnContent where Content : TableColumnContent {

    /// The type of value of rows presented by this column content.
    public typealias TableRowValue = Content.TableRowValue

    /// The type of sort comparator associated with this table column content.
    public typealias TableColumnSortComparator = Content.TableColumnSortComparator

    /// The type of content representing the body of this table column content.
    public typealias TableColumnBody = Never

    /// Creates a group of table columns.
    ///
    /// - Parameter content: A ``SwiftUI/TableColumnBuilder`` that produces the
    ///   columns to group.
    @inlinable nonisolated public init<R, C>(@TableColumnBuilder<R, C> content: () -> Content) where R == Content.TableRowValue, C == Content.TableColumnSortComparator
}

extension View {

    /// Modifies this view by injecting a value that you provide for use by
    /// other views whose state depends on the focused view hierarchy.
    ///
    /// - Parameters:
    ///   - keyPath: The key path to associate `value` with when adding
    ///     it to the existing table of exported focus values.
    ///   - value: The focus value to export.
    /// - Returns: A modified representation of this view.
    @available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
    nonisolated public func focusedValue<Value>(_ keyPath: WritableKeyPath<FocusedValues, Value?>, _ value: Value) -> some View


    /// Creates a new view that exposes the provided value to other views whose
    /// state depends on the focused view hierarchy.
    ///
    /// Use this method instead of ``View/focusedSceneValue(_:_:)`` when your
    /// scene includes multiple focusable views with their own associated
    /// values, and you need an app- or scene-scoped element like a command or
    /// toolbar item that operates on the value associated with whichever view
    /// currently has focus. Each focusable view can supply its own value:
    ///
    ///
    ///
    /// - Parameters:
    ///   - keyPath: The key path to associate `value` with when adding
    ///     it to the existing table of exported focus values.
    ///   - value: The focus value to export, or `nil` if no value is
    ///     currently available.
    /// - Returns: A modified representation of this view.
    @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
    nonisolated public func focusedValue<Value>(_ keyPath: WritableKeyPath<FocusedValues, Value?>, _ value: Value?) -> some View


    /// Modifies this view by injecting a value that you provide for use by
    /// other views whose state depends on the focused scene.
    ///
    /// Use this method instead of ``View/focusedValue(_:_:)`` for values that
    /// must be visible regardless of where focus is located in the active
    /// scene. For example, if an app needs a command for moving focus to a
    /// particular text field in the sidebar, it could use this modifier to
    /// publish a button action that's visible to command views as long as the
    /// scene is active, and regardless of where focus happens to be in it.
    ///
    ///     struct Sidebar: View {
    ///         @FocusState var isFiltering: Bool
    ///
    ///         var body: some View {
    ///             VStack {
    ///                 TextField(...)
    ///                     .focused(when: $isFiltering)
    ///                     .focusedSceneValue(\.filterAction) {
    ///                         isFiltering = true
    ///                     }
    ///             }
    ///         }
    ///     }
    ///
    ///     struct NavigationCommands: Commands {
    ///         @FocusedValue(\.filterAction) var filterAction
    ///
    ///         var body: some Commands {
    ///             CommandMenu("Navigate") {
    ///                 Button("Filter in Sidebar") {
    ///                     filterAction?()
    ///                 }
    ///             }
    ///             .disabled(filterAction == nil)
    ///         }
    ///     }
    ///
    ///     struct FilterActionKey: FocusedValuesKey {
    ///         typealias Value = () -> Void
    ///     }
    ///
    ///     extension FocusedValues {
    ///         var filterAction: (() -> Void)? {
    ///             get { self[FilterActionKey.self] }
    ///             set { self[FilterActionKey.self] = newValue }
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - keyPath: The key path to associate `value` with when adding
    ///     it to the existing table of published focus values.
    ///   - value: The focus value to publish.
    /// - Returns: A modified representation of this view.
    @available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
    nonisolated public func focusedSceneValue<T>(_ keyPath: WritableKeyPath<FocusedValues, T?>, _ value: T) -> some View


    /// Creates a new view that exposes the provided value to other views whose
    /// state depends on the active scene.
    ///
    /// Use this method instead of ``View/focusedValue(_:_:)`` for values that
    /// must be visible regardless of where focus is located in the active
    /// scene. For example, if an app needs a command for moving focus to a
    /// particular text field in the sidebar, it could use this modifier to
    /// publish a button action that's visible to command views as long as the
    /// scene is active, and regardless of where focus happens to be in it.
    ///
    ///     struct Sidebar: View {
    ///         @FocusState var isFiltering: Bool
    ///
    ///         var body: some View {
    ///             VStack {
    ///                 TextField(...)
    ///                     .focused(when: $isFiltering)
    ///                     .focusedSceneValue(\.filterAction) {
    ///                         isFiltering = true
    ///                     }
    ///             }
    ///         }
    ///     }
    ///
    ///     struct NavigationCommands: Commands {
    ///         @FocusedValue(\.filterAction) var filterAction
    ///
    ///         var body: some Commands {
    ///             CommandMenu("Navigate") {
    ///                 Button("Filter in Sidebar") {
    ///                     filterAction?()
    ///                 }
    ///             }
    ///             .disabled(filterAction == nil)
    ///         }
    ///     }
    ///
    ///     struct FilterActionKey: FocusedValuesKey {
    ///         typealias Value = () -> Void
    ///     }
    ///
    ///     extension FocusedValues {
    ///         var filterAction: (() -> Void)? {
    ///             get { self[FilterActionKey.self] }
    ///             set { self[FilterActionKey.self] = newValue }
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - keyPath: The key path to associate `value` with when adding
    ///     it to the existing table of published focus values.
    ///   - value: The focus value to publish, or `nil` if no value is
    ///     currently available.
    /// - Returns: A modified representation of this view.
    @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
    nonisolated public func focusedSceneValue<T>(_ keyPath: WritableKeyPath<FocusedValues, T?>, _ value: T?) -> some View

}

extension EnvironmentValues {

    /// Accesses the environment value associated with a custom key.
    ///
    /// Create custom environment values by defining a key
    /// that conforms to the ``EnvironmentKey`` protocol, and then using that
    /// key with the subscript operator of the ``EnvironmentValues`` structure
    /// to get and set a value for that key:
    ///
    ///     private struct MyEnvironmentKey: EnvironmentKey {
    ///         static let defaultValue: String = "Default value"
    ///     }
    ///
    ///     extension EnvironmentValues {
    ///         var myCustomValue: String {
    ///             get { self[MyEnvironmentKey.self] }
    ///             set { self[MyEnvironmentKey.self] = newValue }
    ///         }
    ///     }
    ///
    /// You use custom environment values the same way you use system-provided
    /// values, setting a value with the ``View/environment(_:_:)`` view
    /// modifier, and reading values with the ``Environment`` property wrapper.
    /// You can also provide a dedicated view modifier as a convenience for
    /// setting the value:
    ///
    ///     extension View {
    ///         func myCustomValue(_ myCustomValue: String) -> some View {
    ///             environment(\.myCustomValue, myCustomValue)
    ///         }
    ///     }
    ///
    @available(iOS 17.0, tvOS 17.0, *)
    @available(macOS, unavailable)
    @available(watchOS, unavailable)
    public subscript<K>(key: K.Type) -> K.Value where K : UITraitBridgedEnvironmentKey
}

@available(iOS 16.0, macOS 12.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension View {

    /// Sets the style for tables within this view.
    nonisolated public func tableStyle<S>(_ style: S) -> some View where S : TableStyle

}

@available(iOS 16.0, macOS 13.0, watchOS 7.0, *)
@available(tvOS, unavailable)
extension View {

    /// Sets the style for gauges within this view.
    nonisolated public func gaugeStyle<S>(_ style: S) -> some View where S : GaugeStyle

}

@available(iOS 17.0, macOS 14.0, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
extension View {

    /// Controls the visibility of a `Table`'s column header views.
    ///
    /// By default, `Table` will display a global header view with the labels
    /// of each table column. This area is also where users can sort, resize,
    /// and rearrange the columns. For simple cases that don't require those
    /// features, this header can be hidden.
    ///
    /// This will not affect the header of any `Section`s in a table.
    ///
    ///     Table(article.authors) {
    ///         TableColumn("Name", value: \.name)
    ///         TableColumn("Title", value: \.title)
    ///     }
    ///     .tableColumnHeaders(.hidden)
    ///
    /// - Parameter visibility: A value of `visible` will show table columns,
    ///   `hidden` will remove them, and `automatic` will defer to default
    ///   behavior.
    nonisolated public func tableColumnHeaders(_ visibility: Visibility) -> some View

}

extension View {

    /// Configures the toolbar title display mode for this view.
    ///
    /// Use this modifier to override the default toolbar title display
    /// mode.
    ///
    ///     NavigationStack {
    ///         ContentView()
    ///             .toolbarTitleDisplayMode(.inlineLarge)
    ///     }
    ///
    /// See ``ToolbarTitleDisplayMode`` for more information on the
    /// different kinds of display modes. This modifier has no effect
    /// on macOS.
    @available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
    nonisolated public func toolbarTitleDisplayMode(_ mode: ToolbarTitleDisplayMode) -> some View

}

@available(iOS 15.0, macOS 12.0, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
extension View {

    /// Generates a badge for the view from an integer value.
    ///
    /// Use a badge to convey optional, supplementary information about a
    /// view. Keep the contents of the badge as short as possible. Badges
    /// appear only in list rows, tab bars, and menus.
    ///
    /// The following example shows a ``List`` with the value of `recentItems.count`
    /// represented by a badge on one of the rows:
    ///
    ///     List {
    ///         Text("Recents")
    ///             .badge(recentItems.count)
    ///         Text("Favorites")
    ///     }
    ///
    /// ![A table with two rows, titled Recents and Favorites. The first row
    /// shows the number 10 at the trailing side of the row
    ///  cell.](View-badge-1)
    ///
    /// - Parameter count: An integer value to display in the badge.
    ///   Set the value to zero to hide the badge.
    nonisolated public func badge(_ count: Int) -> some View


    /// Generates a badge for the view from a text view.
    ///
    /// Use a badge to convey optional, supplementary information about a
    /// view. Keep the contents of the badge as short as possible. Badges
    /// appear only in list rows, tab bars, and menus.
    ///
    /// Use this initializer when you want to style a ``Text`` view for use as a
    /// badge. The following example customizes the badge with the
    /// ``Text/monospacedDigit()``, ``Text/foregroundColor(_:)``, and
    /// ``Text/bold()`` modifiers.
    ///
    ///     var body: some View {
    ///         let badgeView = Text("\(recentItems.count)")
    ///             .monospacedDigit()
    ///             .foregroundColor(.red)
    ///             .bold()
    ///
    ///         List {
    ///             Text("Recents")
    ///                 .badge(badgeView)
    ///             Text("Favorites")
    ///         }
    ///     }
    ///
    /// ![A table with two rows, titled Recents and Favorites. The first row
    /// shows the number 21 at the side of the row cell. The number badge
    /// appears in bold red text with monospaced digits.](View-badge-2)
    ///
    /// Styling the text view has no effect when the badge appears in
    /// a ``TabView``.
    ///
    /// - Parameter label: An optional ``Text`` view to display as a badge.
    ///   Set the value to `nil` to hide the badge.
    nonisolated public func badge(_ label: Text?) -> some View


    /// Generates a badge for the view from a localized string key.
    ///
    /// Use a badge to convey optional, supplementary information about a
    /// view. Keep the contents of the badge as short as possible. Badges
    /// appear only in list rows, tab bars, and menus.
    ///
    /// This modifier creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:tableName:bundle:comment:)``. For
    /// more information about localizing strings, see ``Text``. The following
    /// example shows a list with a "Default" badge on one of its rows.
    ///
    ///     NavigationView {
    ///         List(servers) { server in
    ///             Text(server.name)
    ///                 .badge(server.isDefault ? "Default" : nil)
    ///         }
    ///         .navigationTitle("Servers")
    ///     }
    ///
    /// ![A table with the navigation title Servers and four rows: North 1,
    /// North 2, East 1, and South 1. The North 2 row shows a badge with the
    /// text Default on its trailing side.](View-badge-3)
    ///
    /// - Parameter key: An optional string key to display as a badge.
    ///   Set the value to `nil` to hide the badge.
    nonisolated public func badge(_ key: LocalizedStringKey?) -> some View


    /// Generates a badge for the view from a string.
    ///
    /// Use a badge to convey optional, supplementary information about a
    /// view. Keep the contents of the badge as short as possible. Badges
    /// appear only in list rows, tab bars, and menus.
    ///
    /// This modifier creates a ``Text`` view on your behalf, and treats the
    /// localized key similar to ``Text/init(_:)-9d1g4``. The following
    /// example shows a list with a "Default" badge on one of its rows.
    ///
    ///     NavigationView {
    ///         List(servers) { server in
    ///             Text(server.name)
    ///                 .badge(server.defaultString())
    ///         }
    ///         .navigationTitle("Servers")
    ///     }
    ///
    /// ![A table with the navigation title Servers and four rows: North 1,
    /// North 2, East 1, and South 1. The North 2 row shows a badge with the
    /// text Default on its trailing side.](View-badge-3)
    ///
    /// - Parameter label: An optional string to display as a badge.
    ///   Set the value to `nil` to hide the badge.
    nonisolated public func badge<S>(_ label: S?) -> some View where S : StringProtocol

}

@available(iOS 15.0, macOS 12.0, tvOS 17.0, *)
@available(watchOS, unavailable)
extension View {

    /// Sets the style for control groups within this view.
    ///
    /// - Parameter style: The style to apply to controls within this view.
    nonisolated public func controlGroupStyle<S>(_ style: S) -> some View where S : ControlGroupStyle

}

@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension View {

    /// Defines a keyboard shortcut and assigns it to the modified control.
    ///
    /// Pressing the control's shortcut while the control is anywhere in the
    /// frontmost window or scene, or anywhere in the macOS main menu, is
    /// equivalent to direct interaction with the control to perform its primary
    /// action.
    ///
    /// The target of a keyboard shortcut is resolved in a leading-to-trailing,
    /// depth-first traversal of one or more view hierarchies. On macOS, the
    /// system looks in the key window first, then the main window, and then the
    /// command groups; on other platforms, the system looks in the active
    /// scene, and then the command groups.
    ///
    /// If multiple controls are associated with the same shortcut, the first
    /// one found is used.
    ///
    /// The default localization configuration is set to ``KeyboardShortcut/Localization-swift.struct/automatic``.
    nonisolated public func keyboardShortcut(_ key: KeyEquivalent, modifiers: EventModifiers = .command) -> some View


    /// Assigns a keyboard shortcut to the modified control.
    ///
    /// Pressing the control's shortcut while the control is anywhere in the
    /// frontmost window or scene, or anywhere in the macOS main menu, is
    /// equivalent to direct interaction with the control to perform its primary
    /// action.
    ///
    /// The target of a keyboard shortcut is resolved in a leading-to-trailing
    /// traversal of one or more view hierarchies. On macOS, the system looks in
    /// the key window first, then the main window, and then the command groups;
    /// on other platforms, the system looks in the active scene, and then the
    /// command groups.
    ///
    /// If multiple controls are associated with the same shortcut, the first
    /// one found is used.
    nonisolated public func keyboardShortcut(_ shortcut: KeyboardShortcut) -> some View


    /// Assigns an optional keyboard shortcut to the modified control.
    ///
    /// Pressing the control's shortcut while the control is anywhere in the
    /// frontmost window or scene, or anywhere in the macOS main menu, is
    /// equivalent to direct interaction with the control to perform its primary
    /// action.
    ///
    /// The target of a keyboard shortcut is resolved in a leading-to-trailing
    /// traversal of one or more view hierarchies. On macOS, the system looks in
    /// the key window first, then the main window, and then the command groups;
    /// on other platforms, the system looks in the active scene, and then the
    /// command groups.
    ///
    /// If multiple controls are associated with the same shortcut, the first
    /// one found is used. If the provided shortcut is `nil`, the modifier will
    /// have no effect.
    @available(iOS 15.4, macOS 12.3, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    nonisolated public func keyboardShortcut(_ shortcut: KeyboardShortcut?) -> some View

}

@available(iOS 15.0, macOS 12.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension View {

    /// Defines a keyboard shortcut and assigns it to the modified control.
    ///
    /// Pressing the control's shortcut while the control is anywhere in the
    /// frontmost window or scene, or anywhere in the macOS main menu, is
    /// equivalent to direct interaction with the control to perform its primary
    /// action.
    ///
    /// The target of a keyboard shortcut is resolved in a leading-to-trailing,
    /// depth-first traversal of one or more view hierarchies. On macOS, the
    /// system looks in the key window first, then the main window, and then the
    /// command groups; on other platforms, the system looks in the active
    /// scene, and then the command groups.
    ///
    /// If multiple controls are associated with the same shortcut, the first
    /// one found is used.
    ///
    /// ### Localization
    ///
    /// Provide a `localization` value to specify how this shortcut
    /// should be localized.
    /// Given that `key` is always defined in relation to the US-English
    /// keyboard layout, it might be hard to reach on different international
    /// layouts. For example the shortcut `[` works well for the
    /// US layout but is hard to reach for German users, where
    /// `[` is available by pressing `5`, making users type `5`.
    /// The automatic keyboard shortcut remapping re-assigns the shortcut to
    /// an appropriate replacement, `` in this case.
    ///
    /// Certain shortcuts carry information about directionality. For instance,
    /// `[` can reveal a previous view. Following the layout direction of
    /// the UI, this shortcut will be automatically mirrored to `]`.
    /// However, this does not apply to items such as "Align Left `{`",
    /// which will be "left" independently of the layout direction.
    /// When the shortcut shouldn't follow the directionality of the UI, but rather
    /// be the same in both right-to-left and left-to-right directions, using
    /// ``KeyboardShortcut/Localization-swift.struct/withoutMirroring``
    /// will prevent the system from flipping it.
    ///
    ///     var body: some Commands {
    ///         CommandMenu("Card") {
    ///             Button("Align Left") { ... }
    ///                 .keyboardShortcut("{",
    ///                      modifiers: .option,
    ///                      localization: .withoutMirroring)
    ///             Button("Align Right") { ... }
    ///                 .keyboardShortcut("}",
    ///                      modifiers: .option,
    ///                      localization: .withoutMirroring)
    ///         }
    ///     }
    ///
    /// Lastly, providing the option
    /// ``KeyboardShortcut/Localization-swift.struct/custom``
    /// disables
    /// the automatic localization for this shortcut to tell the system that
    /// internationalization is taken care of in a different way.
    nonisolated public func keyboardShortcut(_ key: KeyEquivalent, modifiers: EventModifiers = .command, localization: KeyboardShortcut.Localization) -> some View

}

@available(iOS 15.0, macOS 12.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension EnvironmentValues {

    /// The keyboard shortcut that buttons in this environment will be triggered
    /// with.
    ///
    /// This is particularly useful in button styles when a button's appearance
    /// depends on the shortcut associated with it. On macOS, for example, when
    /// a button is bound to the Return key, it is typically drawn with a
    /// special emphasis. This happens automatically when using the built-in
    /// button styles, and can be implemented manually in custom styles using
    /// this environment key:
    ///
    ///     private struct MyButtonStyle: ButtonStyle {
    ///         @Environment(\.keyboardShortcut)
    ///         private var shortcut: KeyboardShortcut?
    ///
    ///         func makeBody(configuration: Configuration) -> some View {
    ///             let labelFont = Font.body
    ///                 .weight(shortcut == .defaultAction ? .bold : .regular)
    ///             configuration.label
    ///                 .font(labelFont)
    ///         }
    ///     }
    ///
    /// If no keyboard shortcut has been applied to the view or its ancestor,
    /// then the environment value will be `nil`.
    public var keyboardShortcut: KeyboardShortcut? { get }
}

extension View {

    /// Sets whether to disable autocorrection for this view.
    ///
    /// Use this method when the effect of autocorrection would
    /// make it more difficult for the user to input information. The entry of
    /// proper names and street addresses are examples where autocorrection can
    /// negatively affect the user's ability complete a data entry task.
    ///
    /// The example below configures a ``TextField`` with the default
    /// keyboard. Disabling autocorrection allows the user to enter arbitrary
    /// text without the autocorrection system offering suggestions or
    /// attempting to override their input.
    ///
    ///     TextField("1234 Main St.", text: $address)
    ///         .keyboardType(.default)
    ///         .autocorrectionDisabled(true)
    ///
    /// - Parameter disable: A Boolean value that indicates whether
    ///   autocorrection is disabled for this view. The default value is `true`.
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 8.0, *)
    nonisolated public func autocorrectionDisabled(_ disable: Bool = true) -> some View

}

extension EnvironmentValues {

    /// A Boolean value that determines whether the view hierarchy has
    /// auto-correction enabled.
    ///
    /// The default value is `false`.
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 8.0, *)
    public var autocorrectionDisabled: Bool
}

extension View {

    /// Sets whether to disable autocorrection for this view.
    ///
    /// Use `disableAutocorrection(_:)` when the effect of autocorrection would
    /// make it more difficult for the user to input information. The entry of
    /// proper names and street addresses are examples where autocorrection can
    /// negatively affect the user's ability complete a data entry task.
    ///
    /// In the example below configures a ``TextField`` with the `.default`
    /// keyboard. Disabling autocorrection allows the user to enter arbitrary
    /// text without the autocorrection system offering suggestions or
    /// attempting to override their input.
    ///
    ///     TextField("1234 Main St.", text: $address)
    ///         .keyboardType(.default)
    ///         .disableAutocorrection(true)
    ///
    /// - Parameter enabled: A Boolean value that indicates whether
    ///   autocorrection is disabled for this view.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, renamed: "autocorrectionDisabled(_:)")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, renamed: "autocorrectionDisabled(_:)")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, renamed: "autocorrectionDisabled(_:)")
    @available(watchOS, introduced: 8.0, deprecated: 100000.0, renamed: "autocorrectionDisabled(_:)")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, renamed: "autocorrectionDisabled(_:)")
    nonisolated public func disableAutocorrection(_ disable: Bool?) -> some View

}

extension EnvironmentValues {

    /// A Boolean value that determines whether the view hierarchy has
    /// auto-correction enabled.
    ///
    /// When the value is `nil`, SwiftUI uses the system default. The default
    /// value is `nil`.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, renamed: "autocorrectionDisabled")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, renamed: "autocorrectionDisabled")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, renamed: "autocorrectionDisabled")
    @available(watchOS, introduced: 8.0, deprecated: 100000.0, renamed: "autocorrectionDisabled")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, renamed: "autocorrectionDisabled")
    public var disableAutocorrection: Bool?
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension GeometryEffect {

    /// Returns an effect that produces the same geometry transform as this
    /// effect, but only applies the transform while rendering its view.
    ///
    /// Use this method to disable layout changes during transitions. The view
    /// ignores the transform returned by this method while the view is
    /// performing its layout calculations.
    @inlinable public func ignoredByLayout() -> _IgnoredByLayoutEffect<Self>
}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension View {

    /// Modifies this view by binding its accessibility element's focus state to
    /// the given state value.
    ///
    /// - Parameters:
    ///   - binding: The state binding to register. When accessibility focus moves to the
    ///     accessibility element of the modified view, SwiftUI sets the bound value to the corresponding
    ///     match value. If you set the state value programmatically to the matching value, then
    ///     accessibility focus moves to the accessibility element of the modified view. SwiftUI sets
    ///     the value to `nil` if accessibility focus leaves the accessibility element associated with the
    ///     modified view, and programmatically setting the value to `nil` dismisses focus automatically.
    ///   - value: The value to match against when determining whether the
    ///     binding should change.
    /// - Returns: The modified view.
    nonisolated public func accessibilityFocused<Value>(_ binding: AccessibilityFocusState<Value>.Binding, equals value: Value) -> some View where Value : Hashable


    /// Modifies this view by binding its accessibility element's focus state
    /// to the given boolean state value.
    ///
    /// - Parameter condition: The accessibility focus state to bind. When
    ///     accessibility focus moves to the accessibility element of the
    ///     modified view, the focus value is set to `true`.
    ///     If the value is set to `true` programmatically, then accessibility
    ///     focus will move to accessibility element of the modified view.
    ///     The value will be set to `false` if accessibility focus leaves
    ///     the accessibility element of the modified view,
    ///     and accessibility focus will be dismissed automatically if the
    ///     value is set to `false` programmatically.
    ///
    /// - Returns: The modified view.
    nonisolated public func accessibilityFocused(_ condition: AccessibilityFocusState<Bool>.Binding) -> some View

}

@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Optional : ToolbarContent where Wrapped : ToolbarContent {

    @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
    public typealias Body = Never
}

@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Optional : CustomizableToolbarContent where Wrapped : CustomizableToolbarContent {
}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension EnvironmentValues {

    /// The label style to apply to controls within a toolbar.
    ///
    /// The default is `nil` for items outside the window toolbar.
    public var toolbarLabelStyle: ToolbarLabelStyle? { get }
}

@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension View {

    /// Sets the style for group boxes within this view.
    ///
    /// - Parameter style: The style to apply to boxes within this view.
    nonisolated public func groupBoxStyle<S>(_ style: S) -> some View where S : GroupBoxStyle

}

/// Adds custom actions to a section.
///
/// On iOS, the actions are displayed as items after the content
/// of the section. On macOS, the actions are displayed
/// when a user hovers over the section.
///
/// The following example adds an 'Add' button to
/// the 'Categories' section.
///
///     List {
///         Label("Home", systemImage: "house")
///         Label("Alerts", systemImage: "bell")
///
///         Section("Categories") {
///             Label("Climate", systemImage: "fan")
///             Label("Lights", systemImage: "lightbulb")
///         }
///         .sectionActions {
///             Button("Add Category", systemImage: "plus") { }
///         }
///     }
///
@available(iOS 18.0, macOS 15.0, visionOS 2.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension View {

    nonisolated public func sectionActions<Content>(@ViewBuilder content: () -> Content) -> some View where Content : View

}

@available(iOS 16.0, macOS 12.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension ForEach : TableRowContent where Content : TableRowContent {

    /// The type of value represented by this table row content.
    public typealias TableRowValue = Content.TableRowValue

    /// The type of content representing the body of this table row content.
    public typealias TableRowBody = Never

    /// Creates an instance that uniquely identifies and creates table rows
    /// across updates based on the identity of the underlying data.
    ///
    /// - Parameters:
    ///   - data: The identified data that the ``ForEach`` instance uses to
    ///     create table rows dynamically.
    ///   - content: The table row builder that creates rows dynamically.
    nonisolated public init<V>(_ data: Data, @TableRowBuilder<V> content: @escaping (Data.Element) -> Content) where ID == Data.Element.ID, V == Content.TableRowValue, Data.Element : Identifiable

    /// Creates an instance that uniquely identifies and creates table rows
    /// across updates based on the provided key path to the underlying data's
    /// identifier.
    ///
    /// - Parameters:
    ///   - data: The data that the ``ForEach`` instance uses to create table
    ///     rows dynamically.
    ///   - id: The key path to the provided data's identifier.
    ///   - content: The table row builder that creates rows dynamically.
    nonisolated public init<V>(_ data: Data, id: KeyPath<Data.Element, ID>, @TableRowBuilder<V> content: @escaping (Data.Element) -> Content) where V == Content.TableRowValue

    /// Creates an instance that uniquely identifies and creates table rows
    /// across updates based on the identity of the underlying data.
    ///
    /// The following example creates a `Person` type that conforms to
    /// <doc://com.apple.documentation/documentation/Swift/Identifiable>, and an
    /// array of this type called `people`. A `ForEach` instance iterates over
    /// the array, producing new ``TableRow`` instances implicitly.
    ///
    ///     private struct Person: Identifiable {
    ///         var id = UUID()
    ///         var name: String
    ///     }
    ///
    ///     @State private var people: [Person] = /* ... */
    ///
    ///     Table(of: Person.self) {
    ///         TableColumn("ID", value: \.id.uuidString)
    ///         TableColumn("Name", value: \.name)
    ///     } rows: {
    ///         Section("Team") {
    ///             /* This is equivalent to the line below:
    ///             ForEach(people) { TableRow($0) }
    ///             */
    ///             ForEach(people)
    ///         }
    ///     }
    ///
    /// - Parameter data: The identified data that the ``ForEach`` instance uses
    ///     to create table rows dynamically.
    nonisolated public init(_ data: Data) where ID == Data.Element.ID, Content == TableRow<Data.Element>, Data.Element : Identifiable

    /// Creates an instance that computes table rows on demand over a given
    /// constant range.
    ///
    /// The instance only reads the initial value of the provided `data` and
    /// doesn't need to identify rows across updates. To compute rows on
    /// demand over a dynamic range, use ``ForEach/init(_:id:content:)``.
    ///
    /// - Parameters:
    ///   - data: A constant range.
    ///   - content: The table row builder that creates rows dynamically.
    nonisolated public init<V>(_ data: Range<Int>, @TableRowBuilder<V> content: @escaping (Int) -> Content) where Data == Range<Int>, ID == Int, V == Content.TableRowValue
}

@available(iOS 16.0, macOS 12.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension ForEach : DynamicTableRowContent where Content : TableRowContent {
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension EnvironmentValues {

    public var managedObjectContext: NSManagedObjectContext
}

@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension View {

    /// Sets the available detents for the enclosing sheet.
    ///
    /// By default, sheets support the ``PresentationDetent/large`` detent.
    ///
    ///     struct ContentView: View {
    ///         @State private var showSettings = false
    ///
    ///         var body: some View {
    ///             Button("View Settings") {
    ///                 showSettings = true
    ///             }
    ///             .sheet(isPresented: $showSettings) {
    ///                 SettingsView()
    ///                     .presentationDetents([.medium, .large])
    ///             }
    ///         }
    ///     }
    ///
    /// - Parameter detents: A set of supported detents for the sheet.
    ///   If you provide more that one detent, people can drag the sheet
    ///   to resize it.
    nonisolated public func presentationDetents(_ detents: Set<PresentationDetent>) -> some View


    /// Sets the available detents for the enclosing sheet, giving you
    /// programmatic control of the currently selected detent.
    ///
    /// By default, sheets support the ``PresentationDetent/large`` detent.
    ///
    ///     struct ContentView: View {
    ///         @State private var showSettings = false
    ///         @State private var settingsDetent = PresentationDetent.medium
    ///
    ///         var body: some View {
    ///             Button("View Settings") {
    ///                 showSettings = true
    ///             }
    ///             .sheet(isPresented: $showSettings) {
    ///                 SettingsView()
    ///                     .presentationDetents(
    ///                         [.medium, .large],
    ///                         selection: $settingsDetent
    ///                      )
    ///             }
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - detents: A set of supported detents for the sheet.
    ///     If you provide more that one detent, people can drag the sheet
    ///     to resize it.
    ///   - selection: A ``Binding`` to the currently selected detent.
    ///     Ensure that the value matches one of the detents that you
    ///     provide for the `detents` parameter.
    nonisolated public func presentationDetents(_ detents: Set<PresentationDetent>, selection: Binding<PresentationDetent>) -> some View


    /// Sets the visibility of the drag indicator on top of a sheet.
    ///
    /// You can show a drag indicator when it isn't apparent that a
    /// sheet can resize or when the sheet can't dismiss interactively.
    ///
    ///     struct ContentView: View {
    ///         @State private var showSettings = false
    ///
    ///         var body: some View {
    ///             Button("View Settings") {
    ///                 showSettings = true
    ///             }
    ///             .sheet(isPresented: $showSettings) {
    ///                 SettingsView()
    ///                     .presentationDetents([.medium, .large])
    ///                     .presentationDragIndicator(.visible)
    ///             }
    ///         }
    ///     }
    ///
    /// - Parameter visibility: The preferred visibility of the drag indicator.
    nonisolated public func presentationDragIndicator(_ visibility: Visibility) -> some View

}

@available(iOS 16.4, macOS 13.3, tvOS 16.4, watchOS 9.4, *)
extension View {

    /// Controls whether people can interact with the view behind a
    /// presentation.
    ///
    /// On many platforms, SwiftUI automatically disables the view behind a
    /// sheet that you present, so that people can't interact with the backing
    /// view until they dismiss the sheet. Use this modifier if you want to
    /// enable interaction.
    ///
    /// The following example enables people to interact with the view behind
    /// the sheet when the sheet is at the smallest detent, but not at the other
    /// detents:
    ///
    ///     struct ContentView: View {
    ///         @State private var showSettings = false
    ///
    ///         var body: some View {
    ///             Button("View Settings") {
    ///                 showSettings = true
    ///             }
    ///             .sheet(isPresented: $showSettings) {
    ///                 SettingsView()
    ///                     .presentationDetents(
    ///                         [.height(120), .medium, .large])
    ///                     .presentationBackgroundInteraction(
    ///                         .enabled(upThrough: .height(120)))
    ///             }
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - interaction: A specification of how people can interact with the
    ///     view behind a presentation.
    nonisolated public func presentationBackgroundInteraction(_ interaction: PresentationBackgroundInteraction) -> some View


    /// Specifies how to adapt a presentation to compact size classes.
    ///
    /// Some presentations adapt their appearance depending on the context. For
    /// example, a sheet presentation over a vertically-compact view uses a
    /// full-screen-cover appearance by default. Use this modifier to indicate
    /// a custom adaptation preference. For example, the following code
    /// uses a presentation adaptation value of ``PresentationAdaptation/none``
    /// to request that the system not adapt the sheet in compact size classes:
    ///
    ///     struct ContentView: View {
    ///         @State private var showSettings = false
    ///
    ///         var body: some View {
    ///             Button("View Settings") {
    ///                 showSettings = true
    ///             }
    ///             .sheet(isPresented: $showSettings) {
    ///                 SettingsView()
    ///                     .presentationDetents([.medium, .large])
    ///                     .presentationCompactAdaptation(.none)
    ///             }
    ///         }
    ///     }
    ///
    /// If you want to specify different adaptations for each dimension,
    /// use the ``View/presentationCompactAdaptation(horizontal:vertical:)``
    /// method instead.
    ///
    /// - Parameter adaptation: The adaptation to use in either a horizontally
    ///   or vertically compact size class.
    nonisolated public func presentationCompactAdaptation(_ adaptation: PresentationAdaptation) -> some View


    /// Specifies how to adapt a presentation to horizontally and vertically
    /// compact size classes.
    ///
    /// Some presentations adapt their appearance depending on the context. For
    /// example, a popover presentation over a horizontally-compact view uses a
    /// sheet appearance by default. Use this modifier to indicate a custom
    /// adaptation preference.
    ///
    ///     struct ContentView: View {
    ///         @State private var showInfo = false
    ///
    ///         var body: some View {
    ///             Button("View Info") {
    ///                 showInfo = true
    ///             }
    ///             .popover(isPresented: $showInfo) {
    ///                 InfoView()
    ///                     .presentationCompactAdaptation(
    ///                         horizontal: .popover,
    ///                         vertical: .sheet)
    ///             }
    ///         }
    ///     }
    ///
    /// If you want to specify the same adaptation for both dimensions,
    /// use the ``View/presentationCompactAdaptation(_:)`` method instead.
    ///
    /// - Parameters:
    ///   - horizontalAdaptation: The adaptation to use in a horizontally
    ///     compact size class.
    ///   - verticalAdaptation: The adaptation to use in a vertically compact
    ///     size class. In a size class that is both horizontally and vertically
    ///     compact, SwiftUI uses the `verticalAdaptation` value.
    nonisolated public func presentationCompactAdaptation(horizontal horizontalAdaptation: PresentationAdaptation, vertical verticalAdaptation: PresentationAdaptation) -> some View


    /// Requests that the presentation have a specific corner radius.
    ///
    /// Use this modifier to change the corner radius of a presentation.
    ///
    ///     struct ContentView: View {
    ///         @State private var showSettings = false
    ///
    ///         var body: some View {
    ///             Button("View Settings") {
    ///                 showSettings = true
    ///             }
    ///             .sheet(isPresented: $showSettings) {
    ///                 SettingsView()
    ///                     .presentationDetents([.medium, .large])
    ///                     .presentationCornerRadius(21)
    ///             }
    ///         }
    ///     }
    ///
    /// - Parameter cornerRadius: The corner radius, or `nil` to use the system
    ///   default.
    nonisolated public func presentationCornerRadius(_ cornerRadius: CGFloat?) -> some View


    /// Configures the behavior of swipe gestures on a presentation.
    ///
    /// By default, when a person swipes up on a scroll view in a resizable
    /// presentation, the presentation grows to the next detent. A scroll view
    /// embedded in the presentation only scrolls after the presentation
    /// reaches its largest size. Use this modifier to control which action
    /// takes precedence.
    ///
    /// For example, you can request that swipe gestures scroll content first,
    /// resizing the sheet only after hitting the end of the scroll view, by
    /// passing the ``PresentationContentInteraction/scrolls`` value to this
    /// modifier:
    ///
    ///     struct ContentView: View {
    ///         @State private var showSettings = false
    ///
    ///         var body: some View {
    ///             Button("View Settings") {
    ///                 showSettings = true
    ///             }
    ///             .sheet(isPresented: $showSettings) {
    ///                 SettingsView()
    ///                     .presentationDetents([.medium, .large])
    ///                     .presentationContentInteraction(.scrolls)
    ///             }
    ///         }
    ///     }
    ///
    /// People can always resize your presentation using the drag indicator.
    ///
    /// - Parameter behavior: The requested behavior.
    nonisolated public func presentationContentInteraction(_ behavior: PresentationContentInteraction) -> some View

}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension View {

    /// Sets whether buttons in this view should repeatedly trigger their
    /// actions on prolonged interactions.
    ///
    /// Apply this to buttons that increment or decrement a value or perform
    /// some other inherently iterative operation. Interactions such as
    /// pressing-and-holding on the button, holding the button's keyboard
    /// shortcut, or holding down the space key while the button is focused will
    /// trigger this repeat behavior.
    ///
    ///     Button {
    ///         playbackSpeed.advance(by: 1)
    ///     } label: {
    ///         Label("Speed up", systemImage: "hare")
    ///     }
    ///     .buttonRepeatBehavior(.enabled)
    ///
    /// This affects all system button styles, as well as automatically
    /// affects custom `ButtonStyle` conforming types. This does not
    /// automatically apply to custom `PrimitiveButtonStyle` conforming types,
    /// and the ``EnvironmentValues.buttonRepeatBehavior`` value should be used
    /// to adjust their custom gestures as appropriate.
    ///
    /// - Parameter behavior: A value of `enabled` means that buttons should
    ///   enable repeating behavior and a value of `disabled` means that buttons
    ///   should disallow repeating behavior.
    nonisolated public func buttonRepeatBehavior(_ behavior: ButtonRepeatBehavior) -> some View

}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension EnvironmentValues {

    /// Whether buttons with this associated environment should repeatedly
    /// trigger their actions on prolonged interactions.
    ///
    /// A value of `enabled` means that buttons will be able to repeatedly
    /// trigger their action, and `disabled` means they should not. A value of
    /// `automatic` means that buttons will defer to default behavior.
    public var buttonRepeatBehavior: ButtonRepeatBehavior { get }
}

@available(iOS 16.0, macOS 13.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension View {

    /// Adds an item-based context menu to a view.
    ///
    /// You can add an item-based context menu to a container that supports
    /// selection, like a ``List`` or a ``Table``. In the closure that you
    /// use to define the menu, you receive a collection of items that
    /// depends on the selection state of the container and the location where
    /// the person clicks or taps to activate the menu. The collection contains:
    ///
    /// * The selected item or items, when people initiate the context menu
    ///   from any selected item.
    /// * Nothing, if people tap or click to activate the context menu from
    ///   an empty part of the container. This is true even when one or more
    ///   items is currently selected.
    ///
    /// You can vary the menu contents according to the number of selected
    /// items. For example, the following code has a list that defines an
    /// empty area menu, a single item menu, and a multi-item menu:
    ///
    ///     struct ContextMenuItemExample: View {
    ///         var items: [Item]
    ///         @State private var selection = Set<Item.ID>()
    ///
    ///         var body: some View {
    ///             List(selection: $selection) {
    ///                 ForEach(items) { item in
    ///                     Text(item.name)
    ///                 }
    ///             }
    ///             .contextMenu(forSelectionType: Item.ID.self) { items in
    ///                 if items.isEmpty { // Empty area menu.
    ///                     Button("New Item") { }
    ///
    ///                 } else if items.count == 1 { // Single item menu.
    ///                     Button("Copy") { }
    ///                     Button("Delete", role: .destructive) { }
    ///
    ///                 } else { // Multi-item menu.
    ///                     Button("Copy") { }
    ///                     Button("New Folder With Selection") { }
    ///                     Button("Delete Selected", role: .destructive) { }
    ///                 }
    ///             }
    ///         }
    ///     }
    ///
    /// The above example assumes that the `Item` type conforms to the
    /// <doc://com.apple.documentation/documentation/Swift/Identifiable>
    /// protocol, and relies on the associated `ID` type for both selection
    /// and context menu presentation.
    ///
    /// If you add the modifier to a view hierarchy that doesn't have a
    /// container that supports selection, the context menu never activates.
    /// To add a context menu that doesn't depend on selection behavior, use
    /// ``View/contextMenu(menuItems:)``. To add a context menu to a specific
    /// row in a table, use ``TableRowContent/contextMenu(menuItems:)``.
    ///
    /// ### Add a primary action
    ///
    /// Optionally, you can add a custom primary action to the context menu. In
    /// macOS, a single click on a row in a selectable container selects that
    /// row, and a double click performs the primary action. In iOS and iPadOS,
    /// tapping on the row activates the primary action. To select a row
    /// without performing an action, either enter edit mode or hold
    /// shift or command on a keyboard while tapping the row.
    ///
    /// For example, you can modify the context menu from the previous example
    /// so that double clicking the row on macOS opens a new window for
    /// selected items. Get the ``OpenWindowAction`` from the environment:
    ///
    ///     @Environment(\.openWindow) private var openWindow
    ///
    /// Then call ``EnvironmentValues/openWindow`` from inside the
    /// `primaryAction` closure for each item:
    ///
    ///     .contextMenu(forSelectionType: Item.ID.self) { items in
    ///         // ...
    ///     } primaryAction: { items in
    ///         for item in items {
    ///             openWindow(value: item)
    ///         }
    ///     }
    ///
    /// The open window action depends on the declaration of a ``WindowGroup``
    /// scene in your ``App`` that responds to the `Item` type:
    ///
    ///     WindowGroup("Item Detail", for: Item.self) { $item in
    ///         // ...
    ///     }
    ///
    /// - Parameters:
    ///   - itemType: The identifier type of the items. Ensure that this
    ///     matches the container's selection type.
    ///   - menu: A closure that produces the menu. A single parameter to the
    ///     closure contains the set of items to act on. An empty set indicates
    ///     menu activation over the empty area of the selectable container,
    ///     while a non-empty set indicates menu activation over selected items.
    ///     Use controls like ``Button``, ``Picker``, and ``Toggle`` to define
    ///     the menu items. You can also create submenus using ``Menu``, or
    ///     group items with ``Section``. You can deactivate the context menu
    ///     by returning nothing from the closure.
    ///   - primaryAction: A closure that defines the action to perform in
    ///     response to the primary interaction. A single parameter to the
    ///     closure contains the set of items to act on.
    ///
    /// - Returns: A view that can display an item-based context menu.
    nonisolated public func contextMenu<I, M>(forSelectionType itemType: I.Type = I.self, @ViewBuilder menu: @escaping (Set<I>) -> M, primaryAction: ((Set<I>) -> Void)? = nil) -> some View where I : Hashable, M : View

}

@available(iOS 18.0, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@available(visionOS, unavailable)
extension View {

    /// Attaches a ``UIGestureRecognizerRepresentable`` to the view.
    ///
    /// - Parameter representable: The ``UIGestureRecognizerRepresentable``
    ///   that creates and manages a gesture recognizer.
    ///
    /// - Returns: A view with a ``UIGestureRecognizerRepresentable`` attached.
    nonisolated public func gesture(_ representable: some UIGestureRecognizerRepresentable) -> some View

}

@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension Group : Commands where Content : Commands {

    /// Creates a group of commands.
    ///
    /// - Parameter content: A ``SwiftUI/CommandsBuilder`` that produces the
    /// commands to group.
    @inlinable nonisolated public init(@CommandsBuilder content: () -> Content)
}

@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension View {

    /// Presents a system interface for allowing the user to move an existing
    /// file to a new location.
    ///
    /// - Note: This interface provides security-scoped URLs.
    ///   Call the ``startAccessingSecurityScopedResource`` method to access or bookmark
    ///   the URLs, and the ``stopAccessingSecurityScopedResource`` method
    ///   to release the access.
    ///
    /// In order for the interface to appear, both `isPresented` must be `true`
    /// and `file` must not be `nil`. When the operation is finished,
    /// `isPresented` will be set to `false` before `onCompletion` is called. If
    /// the user cancels the operation, `isPresented` will be set to `false` and
    /// `onCompletion` will not be called.
    ///
    /// - Parameters:
    ///   - isPresented: A binding to whether the interface should be shown.
    ///   - file: The `URL` of the file to be moved.
    ///   - onCompletion: A callback that will be invoked when the operation has
    ///     has succeeded or failed. To access the received URLs, call `startAccessingSecurityScopedResource`.
    ///     When the access is no longer required, call `stopAccessingSecurityScopedResource`.
    ///   - result: A `Result` indicating whether the operation succeeded or
    ///     failed.
    nonisolated public func fileMover(isPresented: Binding<Bool>, file: URL?, onCompletion: @escaping (_ result: Result<URL, any Error>) -> Void) -> some View


    /// Presents a system interface for allowing the user to move a collection
    /// of existing files to a new location.
    ///
    /// - Note: This interface provides security-scoped URLs.
    ///   Call the ``startAccessingSecurityScopedResource`` method to access or bookmark
    ///   the URLs, and the ``stopAccessingSecurityScopedResource`` method
    ///   to release the access.
    ///
    /// In order for the interface to appear, both `isPresented` must be `true`
    /// and `files` must not be empty. When the operation is finished,
    /// `isPresented` will be set to `false` before `onCompletion` is called. If
    /// the user cancels the operation, `isPresented` will be set to `false` and
    /// `onCompletion` will not be called.
    ///
    /// - Parameters:
    ///   - isPresented: A binding to whether the interface should be shown.
    ///   - files: A collection of `URL`s for the files to be moved.
    ///   - onCompletion: A callback that will be invoked when the operation has
    ///     has succeeded or failed. To access the received URLs, call `startAccessingSecurityScopedResource`.
    ///     When the access is no longer required, call `stopAccessingSecurityScopedResource`.
    ///   - result: A `Result` indicating whether the operation succeeded or
    ///     failed.
    nonisolated public func fileMover<C>(isPresented: Binding<Bool>, files: C, onCompletion: @escaping (_ result: Result<[URL], any Error>) -> Void) -> some View where C : Collection, C.Element == URL

}

@available(iOS 17.0, macOS 14.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension View {

    /// Presents a system dialog for allowing the user to move
    /// an existing file to a new location.
    ///
    /// - Note: This dialog provides security-scoped URLs.
    ///   Call the ``startAccessingSecurityScopedResource`` method to access or bookmark
    ///   the URLs, and the ``stopAccessingSecurityScopedResource`` method
    ///   to release the access.
    ///
    /// For example, a button that allows the user to move a file might look like this:
    ///
    ///       struct MoveFileButton: View {
    ///           @State private var showFileMover = false
    ///           var file: URL
    ///           var onCompletion: (URL) -> Void
    ///           var onCancellation: (() -> Void)?
    ///
    ///           var body: some View {
    ///               Button {
    ///                   showFileMover = true
    ///               } label: {
    ///                   Label("Choose destination", systemImage: "folder.circle")
    ///               }
    ///               .fileMover(isPresented: $showFileMover, file: file) { result in
    ///                   switch result {
    ///                   case .success(let url):
    ///                       guard url.startAccessingSecurityScopedResource() else {
    ///                           return
    ///                       }
    ///                       onCompletion(url)
    ///                       url.stopAccessingSecurityScopedResource()
    ///                   case .failure(let error):
    ///                       print(error)
    ///                       // handle error
    ///                   }
    ///               } onCancellation: {
    ///                   onCancellation?()
    ///               }
    ///           }
    ///       }
    ///
    /// - Parameters:
    ///   - isPresented: A binding to whether the dialog should be shown.
    ///   - file: The URL of the file to be moved.
    ///   - onCompletion: A callback that will be invoked when the operation has
    ///     succeeded or failed. The `result` indicates whether
    ///     the operation succeeded or failed. To access the received URLs, call
    ///     `startAccessingSecurityScopedResource`.
    ///     When the access is no longer required, call `stopAccessingSecurityScopedResource`.
    ///   - onCancellation: A callback that will be invoked
    ///     if the user cancels the operation.
    nonisolated public func fileMover(isPresented: Binding<Bool>, file: URL?, onCompletion: @escaping (Result<URL, any Error>) -> Void, onCancellation: @escaping () -> Void) -> some View


    /// Presents a system dialog for allowing the user to move
    /// a collection of existing files to a new location.
    ///
    /// - Note: This dialog provides security-scoped URLs.
    ///   Call the ``startAccessingSecurityScopedResource`` method to access or bookmark
    ///   the URLs, and the ``stopAccessingSecurityScopedResource`` method
    ///   to release the access.
    ///
    /// For example, a button that allows the user to move files might look like this:
    ///
    ///       struct MoveFilesButton: View {
    ///           @Binding var files: [URL]
    ///           @State private var showFileMover = false
    ///           var onCompletion: (URL) -> Void
    ///           var onCancellation: (() -> Void)?
    ///
    ///           var body: some View {
    ///               Button {
    ///                   showFileMover = true
    ///               } label: {
    ///                   Label("Choose destination", systemImage: "folder.circle")
    ///               }
    ///               .fileMover(isPresented: $showFileMover, files: files) { result in
    ///                   switch result {
    ///                   case .success(let urls):
    ///                       urls.forEach { url in
    ///                           guard url.startAccessingSecurityScopedResource() else {
    ///                               return
    ///                           }
    ///                           onCompletion(url)
    ///                           url.stopAccessingSecurityScopedResource()
    ///                       }
    ///                   case .failure(let error):
    ///                       print(error)
    ///                       // handle error
    ///                   }
    ///               } onCancellation: {
    ///                   onCancellation?()
    ///               }
    ///           }
    ///       }
    ///
    /// - Parameters:
    ///   - isPresented: A binding to whether the dialog should be shown.
    ///   - files: A collection of URLs for the files to be moved.
    ///   - onCompletion: A callback that will be invoked when the operation has
    ///     succeeded or failed. The `result` indicates whether
    ///     the operation succeeded or failed.
    ///     To access the received URLs, call `startAccessingSecurityScopedResource`.
    ///     When the access is no longer required, call `stopAccessingSecurityScopedResource`.
    ///   - onCancellation: A callback that will be invoked
    ///     if the user cancels the operation.
    nonisolated public func fileMover<C>(isPresented: Binding<Bool>, files: C, onCompletion: @escaping (Result<[URL], any Error>) -> Void, onCancellation: @escaping () -> Void) -> some View where C : Collection, C.Element == URL

}

@available(iOS 16.0, macOS 12.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension Group : TableRowContent where Content : TableRowContent {

    /// The type of value represented by this table row content.
    public typealias TableRowValue = Content.TableRowValue

    /// The type of content representing the body of this table row content.
    public typealias TableRowBody = Never

    /// Creates a group of table rows.
    ///
    /// - Parameter content: A ``SwiftUI/TableRowBuilder`` that produces the
    ///   rows to group.
    @inlinable nonisolated public init<R>(@TableRowBuilder<R> content: () -> Content) where R == Content.TableRowValue
}

extension View {

    /// Associates a binding to a scroll position with a scroll view within this
    /// view.
    ///
    /// Use this modifier to control where a scroll view is positioned. You
    /// can use the ``ScrollPosition`` type to scroll in a variety of ways:
    ///   - scroll to a view with a provided identity
    ///   - scroll to a concrete offset
    ///   - scroll to an edge
    ///
    /// You can create a scroll position with a specified view identity type
    ///
    ///     @State private var position
    ///         = ScrollPosition(idType: MyItem.ID.self)
    ///
    /// SwiftUI will use that along with the views in the scroll view's
    /// scroll target layout to programmatically scroll to those views and to
    /// update the ``ScrollPosition/viewID`` property as the user scrolls.
    /// Use the ``View/scrollTargetLayout()`` modifier to configure
    /// which the layout that contains your scroll targets.
    ///
    /// When scrolling to a view with an identifier, SwiftUI will update
    /// the position with the value of the top-most view scrolled within
    /// the visible region of the scroll view.
    ///
    /// In the following example, the position binding will update to reflect
    /// the top-most ItemView as the scroll view scrolls.
    ///
    ///     @Binding var items: [MyItem]
    ///     @State private var position: ScrollPosition
    ///         = .init(idType: MyItem.ID.self)
    ///
    ///     ScrollView {
    ///         LazyVStack {
    ///             ForEach(items) { item in
    ///                 ItemView(item)
    ///             }
    ///         }
    ///         .scrollTargetLayout()
    ///     }
    ///     .scrollPosition($scrolledID)
    ///
    /// You can then query the currently scrolled id by using the
    /// ``ScrollPosition/viewID(type:)``.
    ///
    ///     let viewID: MyItem.ID = position.viewID(type: MyItem.ID.self)
    ///
    /// While most use cases will use view identity based scrolling, you
    /// can also use the scroll position type to scroll to offsets or edges.
    /// For example, you can create a button that scrolls to the bottom of
    /// the scroll view by specifying an edge.
    ///
    ///     Button("Scroll to bottom") {
    ///         position.scrollTo(edge: .bottom)
    ///     }
    ///
    /// When configuring a scroll position, SwiftUI will attempt to keep that
    /// position stable. For an edge, that means keeping a top aligned
    /// scroll view scrolled to the top if the content size changes.
    /// For a point, SwiftUI won't attempt to keep that exact offset scrolled
    /// when the content size changes nor will it update to a new offset
    /// when that changes.
    ///
    /// For view identity positions, SwiftUI will attempt to keep the view with
    /// the identity specified in the provided binding visible when events occur
    /// that might cause it to be scrolled out of view by the system.
    /// Some examples of these include:
    ///   - The data backing the content of a scroll view is re-ordered.
    ///   - The size of the scroll view changes, like when a window is resized
    ///     on macOS or during a rotation on iOS.
    ///   - The scroll view initially lays out it content defaulting to
    ///     the top most view, but the binding has a different view's identity.
    ///
    /// You can provide an anchor to a view identity based position to:
    ///   - Influence which view the system chooses as the view whose
    ///     identity value will update the providing binding as the scroll
    ///     view scrolls.
    ///   - Control the alignment of the view when scrolling to a view
    ///     when writing a new binding value.
    ///
    /// In the example below, the bottom most view will be chosen to update the
    /// position binding with.
    ///
    ///     ScrollView {
    ///         LazyVStack {
    ///             ForEach(items) { item in
    ///                 ItemView(item)
    ///             }
    ///         }
    ///         .scrollTargetLayout()
    ///     }
    ///     .scrollPosition($scrolledID, anchor: .bottom)
    ///
    /// For example, providing a value of ``UnitPoint/bottom`` will prefer
    /// to have the bottom-most view chosen and prefer to scroll to views
    /// aligned to the bottom.
    @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
    nonisolated public func scrollPosition(_ position: Binding<ScrollPosition>, anchor: UnitPoint? = nil) -> some View

}

extension View {

    /// Associates a binding to be updated when a scroll view within this
    /// view scrolls.
    ///
    /// Use this modifier along with the ``View/scrollTargetLayout()``
    /// modifier to know the identity of the view that is actively scrolled.
    /// As the scroll view scrolls, the binding will be updated with the
    /// identity of the leading-most / top-most view.
    ///
    /// Use the ``View/scrollTargetLayout()`` modifier to configure
    /// which the layout that contains your scroll targets. In the following
    /// example, the top-most ItemView will update with the scrolledID
    /// binding as the scroll view scrolls.
    ///
    ///     @Binding var items: [Item]
    ///     @Binding var scrolledID: Item.ID?
    ///
    ///     ScrollView {
    ///         LazyVStack {
    ///             ForEach(items) { item in
    ///                 ItemView(item)
    ///             }
    ///         }
    ///         .scrollTargetLayout()
    ///     }
    ///     .scrollPosition(id: $scrolledID)
    ///
    /// You can write to the binding to scroll to the view with
    /// the provided identity.
    ///
    ///     @Binding var items: [Item]
    ///     @Binding var scrolledID: Item.ID?
    ///
    ///     ScrollView {
    ///         // ...
    ///     }
    ///     .scrollPosition(id: $scrolledID)
    ///     .toolbar {
    ///         Button("Scroll to Top") {
    ///             scrolledID = items.first
    ///         }
    ///     }
    ///
    /// SwiftUI will attempt to keep the view with the identity specified
    /// in the provided binding visible when events occur that might cause it
    /// to be scrolled out of view by the system. Some examples of these
    /// include:
    ///   - The data backing the content of a scroll view is re-ordered.
    ///   - The size of the scroll view changes, like when a window is resized
    ///     on macOS or during a rotation on iOS.
    ///   - The scroll view initially lays out it content defaulting to
    ///     the top most view, but the binding has a different view's identity.
    ///
    /// You can provide an anchor to this modifier to both:
    ///   - Influence which view the system chooses as the view whose
    ///     identity value will update the providing binding as the scroll
    ///     view scrolls.
    ///   - Control the alignment of the view when scrolling to a view
    ///     when writing a new binding value.
    ///
    /// For example, providing a value of ``UnitPoint/bottom`` will prefer
    /// to have the bottom-most view chosen and prefer to scroll to views
    /// aligned to the bottom.
    ///
    /// If no anchor has been provided, SwiftUI will scroll the minimal amount
    /// when using the scroll position to programmatically scroll to a view.
    @available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
    nonisolated public func scrollPosition(id: Binding<(some Hashable)?>, anchor: UnitPoint? = nil) -> some View

}

@available(iOS 18.0, macOS 15.0, visionOS 2.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension View {

    /// Specifies the customizations to apply to the sidebar representation
    /// of the tab view.
    ///
    /// Only the ``TabViewStyle/sidebarAdaptable`` style supports
    /// supports customization. Specifying a non-nil ``TabViewCustomization``
    /// object using this modifier enables customization.
    ///
    /// By default, if a person hasn't made customizations, tabs appear
    /// according to the default builder visibilities and sections appear in
    /// the order you declare in the tab view's tab builder.
    ///
    /// You can change the default visibility by using the
    /// ``TabContent/defaultVisibility(_:for:)`` with a
    /// ``AdaptableTabBarPlacement/sidebar`` placement.
    ///
    /// You can change the default section order by changing the order
    /// in the builder. If there's an existing persisted customization,
    /// reset the order by calling
    /// ``TabViewCustomization/resetSectionOrder(for:)``
    /// when you change the order.
    ///
    /// All tabs and tab sections that support customization need to have
    /// a customization ID. You can mark a tab as being non-customizable
    /// by specifying a ``TabCustomizationBehavior/disabled`` behavior
    /// in all adaptable tab bar placements
    /// using ``TabContent/customizationBehavior(_:for:)-2u727``.
    ///
    /// On macOS, a default interaction is provided for reordering sections but
    /// not for controlling the visibility of individual tabs. A custom
    /// experience should be provided if desired by setting the visibility of
    /// the tab on the customization.
    ///
    /// The following code example uses `@AppStorage` to automatically persist
    /// any visibility or section order customizations a person makes.
    ///
    ///     @AppStorage
    ///     private var customization: TabViewCustomization
    ///
    ///     TabView {
    ///         Tab("Home", systemImage: "house") {
    ///             MyHomeView()
    ///         }
    ///         .customizationID("com.myApp.home")
    ///
    ///         Tab("Reports", systemImage: "chart.bar") {
    ///             MyReportsView()
    ///         }
    ///         .customizationID("com.myApp.reports")
    ///
    ///         TabSection("Categories") {
    ///             Tab("Climate", systemImage: "fan") {
    ///                 ClimateView()
    ///             }
    ///             .customizationID("com.myApp.climate")
    ///
    ///             Tab("Lights", systemImage: "lightbulb") {
    ///                 LightsView()
    ///             }
    ///             .customizationID("com.myApp.lights")
    ///         }
    ///         .customizationID("com.myApp.browse")
    ///     }
    ///     .tabViewStyle(.sidebarAdaptable)
    ///     .tabViewCustomization($customization)
    ///
    /// - Parameters:
    ///   - customization: The customization object to store
    ///     user customization in.
    nonisolated public func tabViewCustomization(_ customization: Binding<TabViewCustomization>?) -> some View

}

extension View {

    /// Specifies if the view is focusable.
    ///
    /// - Parameter isFocusable: A Boolean value that indicates whether this
    ///   view is focusable.
    ///
    /// - Returns: A view that sets whether a view is focusable.
    @available(iOS 17.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
    nonisolated public func focusable(_ isFocusable: Bool = true) -> some View


    /// Specifies if the view is focusable, and if so, what focus-driven
    /// interactions it supports.
    ///
    /// By default, SwiftUI enables all possible focus interactions. However, on
    /// macOS and iOS it is conventional for button-like views to only accept
    /// focus when the user has enabled keyboard navigation system-wide in the
    /// Settings app. Clients can reproduce this behavior with custom views by
    /// only supporting `.activate` interactions.
    ///
    ///     MyTapGestureView(...)
    ///         .focusable(interactions: .activate)
    ///
    /// - Note: The focus interactions allowed for custom views changed in
    ///   macOS 14previously, custom views could only become focused with
    ///   keyboard navigation enabled system-wide. Clients built using older
    ///   SDKs will continue to see the older focus behavior, while custom views
    ///   in clients built using macOS 14 or later will always be focusable
    ///   unless the client requests otherwise by specifying a restricted set of
    ///   focus interactions.
    ///
    /// - Parameters:
    ///   - isFocusable: `true` if the view should participate in focus;
    ///     `false` otherwise. The default value is `true`.
    ///   - interactions: The types of focus interactions supported by the view.
    ///     The default value is `.automatic`.
    /// - Returns: A view that sets whether its child is focusable.
    @available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
    nonisolated public func focusable(_ isFocusable: Bool = true, interactions: FocusInteractions) -> some View


    /// Adds a condition that controls whether this view can display focus
    /// effects, such as a default focus ring or hover effect.
    ///
    /// The higher views in a view hierarchy can override the value you set on
    /// this view. In the following example, the button does not display a focus
    /// effect because the outer `focusEffectDisabled(_:)` modifier overrides
    /// the inner one:
    ///
    ///     HStack {
    ///         Button("Press") {}
    ///             .focusEffectDisabled(false)
    ///     }
    ///     .focusEffectDisabled(true)
    ///
    /// - Parameter disabled: A Boolean value that determines whether this view
    ///   can display focus effects.
    /// - Returns: A view that controls whether focus effects can be displayed
    ///   in this view.
    @available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
    nonisolated public func focusEffectDisabled(_ disabled: Bool = true) -> some View

}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension EnvironmentValues {

    /// A Boolean value that indicates whether the view associated with this
    /// environment allows focus effects to be displayed.
    ///
    /// The default value is `true`.
    @available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
    public var isFocusEffectEnabled: Bool
}

extension EnvironmentValues {

    /// Returns whether the nearest focusable ancestor has focus.
    ///
    /// If there is no focusable ancestor, the value is `false`.
    @available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
    public var isFocused: Bool { get }
}

extension View {

    /// Controls the visibility of labels of any controls contained within this
    /// view.
    ///
    /// Use this modifier when you want to omit a label from one or more
    /// labeled content in your user interface. For example, the first ``Toggle``
    /// in the following example hides its label:
    ///
    ///     VStack {
    ///         Toggle(isOn: $toggle1) {
    ///             Text("Toggle 1")
    ///         }
    ///         .labelsVisibility(.hidden)
    ///
    ///         Toggle(isOn: $toggle2) {
    ///             Text("Toggle 2")
    ///         }
    ///     }
    ///
    /// The ``VStack`` in the example above centers the first toggle's control
    /// element in the available space, while it centers the second toggle's
    /// combined label and control element:
    ///
    /// ![A screenshot showing a view with two toggle controls where one label
    ///   is visible and the other label is hidden.](View-labelsHidden-1.png)
    ///
    /// Always provide a label for controls, even when you hide the label,
    /// because SwiftUI uses labels for other purposes, including accessibility.
    ///
    /// On iOS, a `Picker` within a `Menu` hides its label by default. You can use
    /// this modifier to explicitly show the label in that context:
    ///
    ///     Menu {
    ///         Picker("Flavor", selection: $selectedFlavor) {
    ///             Text("Chocolate").tag(Flavor.chocolate)
    ///             Text("Vanilla").tag(Flavor.vanilla)
    ///             Text("Strawberry").tag(Flavor.strawberry)
    ///         }
    ///         .labelsVisibility(.visible)
    ///     }
    ///
    /// > Note: This modifier doesn't work for all labels. It applies to
    ///   ``LabeledContent`` elements, including controls like ``Picker`` and
    ///   ``Toggle``, but not to controls like a bordered button where the label
    ///   is inside the button's border.
    @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
    nonisolated public func labelsVisibility(_ visibility: Visibility) -> some View

}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension EnvironmentValues {

    /// The labels visibility set by ``View/labelsVisibility(_:)``.
    ///
    /// Read this environment value from within a view to obtain the preferred
    /// visibility for labels within the hierarchy. If you would like to
    /// dynamically hide the label of your custom view, make sure to include an
    /// accessibility label via the ``View/accessibilityLabel(content:)``
    /// modifier as illustrated below:
    ///
    ///     @Environment(\.labelsVisibility)
    ///     private var labelsVisibility
    ///
    ///     var body: some View {
    ///         VStack {
    ///             QuizCardView()
    ///             if labelsVisibility != .hidden {
    ///                 label
    ///             }
    ///         }
    ///         .accessibilityLabel {
    ///             label
    ///         }
    ///     }
    ///
    ///     private var label: some View {
    ///         Text("Quiz Card")
    ///     }
    public var labelsVisibility: Visibility
}

extension View {

    /// Configures the semantic role for the content populating the toolbar.
    ///
    /// Use this modifier to configure the semantic role for content
    /// populating your app's toolbar. SwiftUI uses this role when
    /// rendering the content of your app's toolbar.
    ///
    ///     ContentView()
    ///         .navigationTitle("Browser")
    ///         .toolbarRole(.browser)
    ///         .toolbar {
    ///             ToolbarItem(placement: .primaryAction) {
    ///                 AddButton()
    ///             }
    ///          }
    ///
    /// - Parameter role: The role of the toolbar.
    @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
    nonisolated public func toolbarRole(_ role: ToolbarRole) -> some View

}

@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension View {

    /// Presents a system interface for exporting a document that's stored in
    /// a value type, like a structure, to a file on disk.
    ///
    /// In order for the interface to appear, both `isPresented` must be `true`
    /// and `document` must not be `nil`. When the operation is finished,
    /// `isPresented` will be set to `false` before `onCompletion` is called. If
    /// the user cancels the operation, `isPresented` will be set to `false` and
    /// `onCompletion` will not be called.
    ///
    /// The `contentType` provided must be included within the document type's
    /// `writableContentTypes`, otherwise the first valid writable content type
    /// will be used instead.
    ///
    /// - Parameters:
    ///   - isPresented: A binding to whether the interface should be shown.
    ///   - document: The in-memory document to export.
    ///   - contentType: The content type to use for the exported file.
    ///   - defaultFilename: If provided, the default name to use for the
    ///     exported file, which will the user will have an opportunity to edit
    ///     prior to the export.
    ///   - onCompletion: A callback that will be invoked when the operation has
    ///     has succeeded or failed.
    ///   - result: A `Result` indicating whether the operation succeeded or
    ///     failed.
    nonisolated public func fileExporter<D>(isPresented: Binding<Bool>, document: D?, contentType: UTType, defaultFilename: String? = nil, onCompletion: @escaping (_ result: Result<URL, any Error>) -> Void) -> some View where D : FileDocument


    /// Presents a system interface for exporting a collection of value type
    /// documents to files on disk.
    ///
    /// In order for the interface to appear, both `isPresented` must be `true`
    /// and `documents` must not be empty. When the operation is finished,
    /// `isPresented` will be set to `false` before `onCompletion` is called. If
    /// the user cancels the operation, `isPresented` will be set to `false` and
    /// `onCompletion` will not be called.
    ///
    /// The `contentType` provided must be included within the document type's
    /// `writableContentTypes`, otherwise the first valid writable content type
    /// will be used instead.
    ///
    /// - Parameters:
    ///   - isPresented: A binding to whether the interface should be shown.
    ///   - documents: The collection of in-memory documents to export.
    ///   - contentType: The content type to use for the exported file.
    ///   - onCompletion: A callback that will be invoked when the operation has
    ///     has succeeded or failed.
    ///   - result: A `Result` indicating whether the operation succeeded or
    ///     failed.
    nonisolated public func fileExporter<C>(isPresented: Binding<Bool>, documents: C, contentType: UTType, onCompletion: @escaping (_ result: Result<[URL], any Error>) -> Void) -> some View where C : Collection, C.Element : FileDocument


    /// Presents a system interface for exporting a document that's stored in
    /// a reference type, like a class, to a file on disk.
    ///
    /// In order for the interface to appear, both `isPresented` must be `true`
    /// and `document` must not be `nil`. When the operation is finished,
    /// `isPresented` will be set to `false` before `onCompletion` is called. If
    /// the user cancels the operation, `isPresented` will be set to `false` and
    /// `onCompletion` will not be called.
    ///
    /// The `contentType` provided must be included within the document type's
    /// `writableContentTypes`, otherwise the first valid writable content type
    /// will be used instead.
    ///
    /// - Parameters:
    ///   - isPresented: A binding to whether the interface should be shown.
    ///   - document: The in-memory document to export.
    ///   - contentType: The content type to use for the exported file.
    ///   - defaultFilename: If provided, the default name to use for the
    ///     exported file, which will the user will have an opportunity to edit
    ///     prior to the export.
    ///   - onCompletion: A callback that will be invoked when the operation has
    ///     has succeeded or failed.
    ///   - result: A `Result` indicating whether the operation succeeded or
    ///     failed.
    nonisolated public func fileExporter<D>(isPresented: Binding<Bool>, document: D?, contentType: UTType, defaultFilename: String? = nil, onCompletion: @escaping (_ result: Result<URL, any Error>) -> Void) -> some View where D : ReferenceFileDocument


    /// Presents a system interface for exporting a collection of reference type
    /// documents to files on disk.
    ///
    /// In order for the interface to appear, both `isPresented` must be `true`
    /// and `documents` must not be empty. When the operation is finished,
    /// `isPresented` will be set to `false` before `onCompletion` is called. If
    /// the user cancels the operation, `isPresented` will be set to `false` and
    /// `onCompletion` will not be called.
    ///
    /// The `contentType` provided must be included within the document type's
    /// `writableContentTypes`, otherwise the first valid writable content type
    /// will be used instead.
    ///
    /// - Parameters:
    ///   - isPresented: A binding to whether the interface should be shown.
    ///   - documents: The collection of in-memory documents to export.
    ///   - contentType: The content type to use for the exported file.
    ///   - onCompletion: A callback that will be invoked when the operation has
    ///     has succeeded or failed.
    ///   - result: A `Result` indicating whether the operation succeeded or
    ///     failed.
    nonisolated public func fileExporter<C>(isPresented: Binding<Bool>, documents: C, contentType: UTType, onCompletion: @escaping (_ result: Result<[URL], any Error>) -> Void) -> some View where C : Collection, C.Element : ReferenceFileDocument

}

@available(iOS 17.0, macOS 14.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension View {

    /// Presents a system interface allowing the user to export
    /// a `Transferable` item to file on disk.
    ///
    /// In order for the interface to appear `isPresented` must be set to `true`.
    /// When the operation is finished,
    /// `isPresented` will be set to `false` before `onCompletion` is called. If
    /// the user cancels the operation, `isPresented` will be set to `false` and
    /// `onCompletion` will not be called.
    ///
    /// - Parameters:
    ///   - isPresented: A binding to whether the interface should be shown.
    ///   - item: The item to be saved on disk.
    ///   - contentTypes: The optional content types to use for the exported file.
    ///     If empty, SwiftUI uses the content types from the `transferRepresentation`
    ///     property provided for `Transferable` conformance.
    ///   - onCompletion: A callback that will be invoked when the operation
    ///     has succeeded or failed.
    ///   - onCancellation: A callback that will be invoked
    ///     if the operation was cancelled.
    nonisolated public func fileExporter<T>(isPresented: Binding<Bool>, item: T?, contentTypes: [UTType] = [], defaultFilename: String? = nil, onCompletion: @escaping (Result<URL, any Error>) -> Void, onCancellation: @escaping () -> Void = { }) -> some View where T : Transferable


    /// Presents a system interface allowing the user to export
    /// a collection of items to files on disk.
    ///
    /// In order for the interface to appear `isPresented` must be set to `true`.
    /// When the operation is finished,
    /// `isPresented` will be set to `false` before `onCompletion` is called. If
    /// the user cancels the operation, `isPresented` will be set to `false` and
    /// `onCompletion` will not be called.
    ///
    /// - Parameters:
    ///   - isPresented: A binding to whether the interface should be shown.
    ///   - items: Collection of values to be saved on disk.
    ///   - contentTypes: The content types to use for the exported file.
    ///     If empty, SwiftUI uses the content types from the `transferRepresentation`
    ///     property provided for `Transferable` conformance.
    ///   - allowsOtherContentTypes: A Boolean value that indicates if the users
    ///     are allowed to save the files with a different file extension than
    ///     specified by the `contentType` property.
    ///   - onCompletion: A callback that will be invoked when the operation has
    ///     has succeeded or failed.
    ///   - onCancellation: A callback that will be invoked
    ///     if the operation was cancelled.
    nonisolated public func fileExporter<C, T>(isPresented: Binding<Bool>, items: C, contentTypes: [UTType] = [], onCompletion: @escaping (Result<[URL], any Error>) -> Void, onCancellation: @escaping () -> Void = { }) -> some View where C : Collection, T : Transferable, T == C.Element


    /// Presents a system interface for allowing the user to export a
    /// `FileDocument` to a file on disk.
    ///
    /// In order for the interface to appear, `isPresented` must be `true`. When
    /// the operation is finished, `isPresented` will be set to `false` before
    /// `onCompletion` is called. If the user cancels the operation,
    /// `isPresented` will be set to `false` and `onCancellation` will be
    /// called.
    ///
    /// - Parameters:
    ///   - isPresented: A binding to whether the interface should be shown.
    ///   - document: The in-memory document to export.
    ///   - contentTypes: The list of supported content types which can
    ///     be exported. If not provided, `FileDocument.writableContentTypes`
    ///     are used.
    ///   - defaultFilename: If provided, the default name to use
    ///     for the exported file, which will the user will have
    ///     an opportunity to edit prior to the export.
    ///   - onCompletion: A callback that will be invoked when the operation has
    ///     succeeded or failed. The `result` indicates whether
    ///     the operation succeeded or failed.
    ///   - onCancellation: A callback that will be invoked
    ///     if the user cancels the operation.
    nonisolated public func fileExporter<D>(isPresented: Binding<Bool>, document: D?, contentTypes: [UTType] = [], defaultFilename: String? = nil, onCompletion: @escaping (Result<URL, any Error>) -> Void, onCancellation: @escaping () -> Void = {}) -> some View where D : FileDocument


    /// Presents a system dialog for allowing the user to export a
    /// `ReferenceFileDocument` to a file on disk.
    ///
    /// In order for the dialog to appear, `isPresented` must be `true`. When
    /// the operation is finished, `isPresented` will be set to `false` before
    /// `onCompletion` is called. If the user cancels the operation,
    /// `isPresented` will be set to `false` and `onCancellation` will be
    /// called.
    ///
    /// - Parameters:
    ///   - isPresented: A binding to whether the dialog should be shown.
    ///   - document: The in-memory document to export.
    ///   - contentTypes: The list of supported content types which can
    ///     be exported. If not provided, `ReferenceFileDocument.writableContentTypes`
    ///     are used.
    ///   - defaultFilename: If provided, the default name to use
    ///     for the exported file, which will the user will have
    ///     an opportunity to edit prior to the export.
    ///   - onCompletion: A callback that will be invoked when the operation has
    ///     succeeded or failed. The `result` indicates whether
    ///     the operation succeeded or failed.
    ///   - onCancellation: A callback that will be invoked
    ///     if the user cancels the operation.
    nonisolated public func fileExporter<D>(isPresented: Binding<Bool>, document: D?, contentTypes: [UTType] = [], defaultFilename: String? = nil, onCompletion: @escaping (Result<URL, any Error>) -> Void, onCancellation: @escaping () -> Void = {}) -> some View where D : ReferenceFileDocument


    /// Presents a system dialog for allowing the user to export a
    /// collection of documents that conform to `FileDocument`
    /// to files on disk.
    ///
    /// In order for the dialog to appear, `isPresented` must be `true`. When
    /// the operation is finished, `isPresented` will be set to `false` before
    /// `onCompletion` is called. If the user cancels the operation,
    /// `isPresented` will be set to `false` and `onCancellation` will be
    /// called.
    ///
    /// - Parameters:
    ///   - isPresented: A binding to whether the dialog should be shown.
    ///   - documents: The in-memory documents to export.
    ///   - contentTypes: The list of supported content types which can
    ///     be exported. If not provided, `FileDocument.writableContentTypes`
    ///     are used.
    ///   - onCompletion: A callback that will be invoked when the operation has
    ///     succeeded or failed. The `result` indicates whether
    ///     the operation succeeded or failed.
    ///   - onCancellation: A callback that will be invoked
    ///     if the user cancels the operation.
    nonisolated public func fileExporter<C>(isPresented: Binding<Bool>, documents: C, contentTypes: [UTType] = [], onCompletion: @escaping (Result<[URL], any Error>) -> Void, onCancellation: @escaping () -> Void = {}) -> some View where C : Collection, C.Element : FileDocument


    /// Presents a system dialog for allowing the user to export a
    /// collection of documents that conform to `ReferenceFileDocument`
    /// to files on disk.
    ///
    /// In order for the dialog to appear, `isPresented` must be `true`. When
    /// the operation is finished, `isPresented` will be set to `false` before
    /// `onCompletion` is called. If the user cancels the operation,
    /// `isPresented` will be set to `false` and `onCancellation` will be
    /// called.
    ///
    /// - Parameters:
    ///   - isPresented: A binding to whether the dialog should be shown.
    ///   - documents: The in-memory documents to export.
    ///   - contentTypes: The list of supported content types which can
    ///     be exported. If not provided, `ReferenceFileDocument.writableContentTypes`
    ///     are used.
    ///   - onCompletion: A callback that will be invoked when the operation has
    ///     succeeded or failed. The `result` indicates whether
    ///     the operation succeeded or failed.
    ///   - onCancellation: A callback that will be invoked
    ///     if the user cancels the operation.
    nonisolated public func fileExporter<C>(isPresented: Binding<Bool>, documents: C, contentTypes: [UTType] = [], onCompletion: @escaping (Result<[URL], any Error>) -> Void, onCancellation: @escaping () -> Void = {}) -> some View where C : Collection, C.Element : ReferenceFileDocument

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension View {

    /// Adds the given traits to the view.
    nonisolated public func accessibilityAddTraits(_ traits: AccessibilityTraits) -> ModifiedContent<Self, AccessibilityAttachmentModifier>

    /// Removes the given traits from this view.
    nonisolated public func accessibilityRemoveTraits(_ traits: AccessibilityTraits) -> ModifiedContent<Self, AccessibilityAttachmentModifier>
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ModifiedContent where Modifier == AccessibilityAttachmentModifier {

    /// Adds the given traits to the view.
    nonisolated public func accessibilityAddTraits(_ traits: AccessibilityTraits) -> ModifiedContent<Content, Modifier>

    /// Removes the given traits from this view.
    nonisolated public func accessibilityRemoveTraits(_ traits: AccessibilityTraits) -> ModifiedContent<Content, Modifier>
}

extension View {

    /// Adds the given traits to the view.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityAddTraits(_:)")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, renamed: "accessibilityAddTraits(_:)")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityAddTraits(_:)")
    @available(watchOS, introduced: 6, deprecated: 100000.0, renamed: "accessibilityAddTraits(_:)")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, renamed: "accessibilityAddTraits(_:)")
    nonisolated public func accessibility(addTraits traits: AccessibilityTraits) -> ModifiedContent<Self, AccessibilityAttachmentModifier>

    /// Removes the given traits from this view.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityRemoveTraits(_:)")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, renamed: "accessibilityRemoveTraits(_:)")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityRemoveTraits(_:)")
    @available(watchOS, introduced: 6, deprecated: 100000.0, renamed: "accessibilityRemoveTraits(_:)")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, renamed: "accessibilityRemoveTraits(_:)")
    nonisolated public func accessibility(removeTraits traits: AccessibilityTraits) -> ModifiedContent<Self, AccessibilityAttachmentModifier>
}

extension ModifiedContent where Modifier == AccessibilityAttachmentModifier {

    /// Adds the given traits to the view.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityAddTraits(_:)")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, renamed: "accessibilityAddTraits(_:)")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityAddTraits(_:)")
    @available(watchOS, introduced: 6, deprecated: 100000.0, renamed: "accessibilityAddTraits(_:)")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, renamed: "accessibilityAddTraits(_:)")
    nonisolated public func accessibility(addTraits traits: AccessibilityTraits) -> ModifiedContent<Content, Modifier>

    /// Removes the given traits from this view.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityRemoveTraits(_:)")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, renamed: "accessibilityRemoveTraits(_:)")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityRemoveTraits(_:)")
    @available(watchOS, introduced: 6, deprecated: 100000.0, renamed: "accessibilityRemoveTraits(_:)")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, renamed: "accessibilityRemoveTraits(_:)")
    nonisolated public func accessibility(removeTraits traits: AccessibilityTraits) -> ModifiedContent<Content, Modifier>
}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension View {

    /// Sets a particular container value of a view.
    ///
    /// Use this modifier to set one of the writable properties of the
    /// ``ContainerValues`` structure, including custom values that you
    /// create.
    ///
    /// Like preferences, container values are able to be read by views above
    /// the view they're set on. Unlike preferences, however, container values
    /// don't have merging behavior because they don't escape their closest
    /// container. In the following example, the container value is set
    /// on the contained view, but is dropped when it reaches the containing
    ///  ``VStack``.
    ///
    ///     VStack {
    ///         Text("A").containerValue(\.myCustomValue, 1) // myCustomValue = 1
    ///         Text("B").containerValue(\.myCustomValue, 2) // myCustomValue = 2
    ///         // container values are unaffected by views that aren't containers:
    ///         Text("C")
    ///             .containerValue(\.myCustomValue, 3)
    ///             .padding() // myCustomValue = 3
    ///     } // myCustomValue = it's default value, values do not escape the container
    ///
    /// Even if a stack has only one child, container values still wouldn't
    /// be lifted to the `VStack`. Container values don't escape a container
    /// even if the container has only one child.
    ///
    /// - Parameters:
    ///   - keyPath: A key path that indicates the property of the
    ///     ``ContainerValues`` structure to update.
    ///   - value: The new value to set for the item specified by `keyPath`.
    ///
    /// - Returns: A view that has the given value set in its containerValues.
    nonisolated public func containerValue<V>(_ keyPath: WritableKeyPath<ContainerValues, V>, _ value: V) -> some View

}

@available(iOS 17.0, macOS 14.0, visionOS 1.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension EnvironmentValues {

    /// A window dismissal action stored in a view's environment.
    ///
    /// Use the `dismissWindow` environment value to get an
    /// ``DismissWindowAction`` instance for a given ``Environment``. Then call
    /// the instance to dismiss a window. You call the instance directly because
    /// it defines a ``DismissWindowAction/callAsFunction(id:)`` method that
    /// Swift calls when you call the instance.
    ///
    /// For example, you can define a button that dismisses an auxiliary window:
    ///
    ///     @main
    ///     struct MyApp: App {
    ///         var body: some Scene {
    ///             WindowGroup {
    ///                 ContentView()
    ///             }
    ///             #if os(macOS)
    ///             Window("Auxiliary", id: "auxiliary") {
    ///                 AuxiliaryContentView()
    ///             }
    ///             #endif
    ///         }
    ///     }
    ///
    ///     struct DismissWindowButton: View {
    ///         @Environment(\.dismissWindow) private var dismissWindow
    ///
    ///         var body: some View {
    ///             Button("Close Auxiliary Window") {
    ///                 dismissWindow(id: "auxiliary")
    ///             }
    ///         }
    ///     }
    ///
    /// If the window was opened with ``EnvironmentValues/pushWindow``, the
    /// presenting window will reappear when this action is performed.
    public var dismissWindow: DismissWindowAction { get }
}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension View {

    /// Conditionally prevents interactive dismissal of presentations like
    /// popovers, sheets, and inspectors.
    ///
    /// Users can dismiss certain kinds of presentations using built-in
    /// gestures. In particular, a user can dismiss a sheet by dragging it down,
    /// or a popover by clicking or tapping outside of the presented view. Use
    /// the `interactiveDismissDisabled(_:)` modifier to conditionally prevent
    /// this kind of dismissal. You typically do this to prevent the user from
    /// dismissing a presentation before providing needed data or completing
    /// a required action.
    ///
    /// For instance, suppose you have a view that displays a licensing
    /// agreement that the user must acknowledge before continuing:
    ///
    ///     struct TermsOfService: View {
    ///         @Binding var areTermsAccepted: Bool
    ///         @Environment(\.dismiss) private var dismiss
    ///
    ///         var body: some View {
    ///             Form {
    ///                 Text("License Agreement")
    ///                     .font(.title)
    ///                 Text("Terms and conditions go here.")
    ///                 Button("Accept") {
    ///                     areTermsAccepted = true
    ///                     dismiss()
    ///                 }
    ///             }
    ///         }
    ///     }
    ///
    /// If you present this view in a sheet, the user can dismiss it by either
    /// tapping the button --- which calls ``EnvironmentValues/dismiss``
    /// from its `action` closure --- or by dragging the sheet down. To
    /// ensure that the user accepts the terms by tapping the button,
    /// disable interactive dismissal, conditioned on the `areTermsAccepted`
    /// property:
    ///
    ///     struct ContentView: View {
    ///         @State private var isSheetPresented = false
    ///         @State private var areTermsAccepted = false
    ///
    ///         var body: some View {
    ///             Button("Use Service") {
    ///                 isSheetPresented = true
    ///             }
    ///             .sheet(isPresented: $isSheetPresented) {
    ///                 TermsOfService()
    ///                     .interactiveDismissDisabled(!areTermsAccepted)
    ///             }
    ///         }
    ///     }
    ///
    /// You can apply the modifier to any view in the sheet's view hierarchy,
    /// including to the sheet's top level view, as the example demonstrates,
    /// or to any child view, like the ``Form`` or the Accept ``Button``.
    ///
    /// The modifier has no effect on programmatic dismissal, which you can
    /// invoke by updating the ``Binding`` that controls the presentation, or
    /// by calling the environment's ``EnvironmentValues/dismiss`` action.
    /// On macOS, disabling interactive dismissal in a popover makes the popover
    /// nontransient.
    ///
    /// - Parameter isDisabled: A Boolean value that indicates whether to
    ///   prevent nonprogrammatic dismissal of the containing view hierarchy
    ///   when presented in a sheet or popover.
    nonisolated public func interactiveDismissDisabled(_ isDisabled: Bool = true) -> some View

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// Creates a new accessibility element, or modifies the
    /// ``AccessibilityChildBehavior`` of the existing accessibility element.
    ///
    /// See also:
    /// - ``AccessibilityChildBehavior/ignore``
    /// - ``AccessibilityChildBehavior/combine``
    /// - ``AccessibilityChildBehavior/contain``
    ///
    /// - Parameters:
    ///     -   children: The behavior to use when creating or
    ///     transforming an accessibility element.
    ///     The default is ``AccessibilityChildBehavior/ignore``
    nonisolated public func accessibilityElement(children: AccessibilityChildBehavior = .ignore) -> some View

}

@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension View {

    /// Sets a style for labeled content.
    nonisolated public func labeledContentStyle<S>(_ style: S) -> some View where S : LabeledContentStyle

}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
@available(visionOS, unavailable)
extension ShapeStyle where Self == WindowBackgroundShapeStyle {

    /// A style appropriate for elements that should match the background
    /// of their containing window.
    ///
    /// On macOS, this has a unique appearance compared to the default
    /// `ShapeStyle.background`. It matches the default background of a
    /// window: a wallpaper-tinted light gray in the light appearance and a
    /// wallpaper-tinted dark gray in the dark appearance.
    ///
    /// On visionOS, the default glass window background can only be created
    /// using `glassBackgroundEffect`.
    ///
    /// For information about how to use shape styles, see ``ShapeStyle``.
    public static var windowBackground: WindowBackgroundShapeStyle { get }
}

extension View {

    /// Adds an action to perform when this view recognizes a tap gesture,
    /// and provides the action with the location of the interaction.
    ///
    /// Use this method to perform the specified `action` when the user clicks
    /// or taps on the modified view `count` times. The action closure receives
    /// the location of the interaction.
    ///
    /// > Note: If you create a control that's functionally equivalent
    /// to a ``Button``, use ``ButtonStyle`` to create a customized button
    /// instead.
    ///
    /// The following code adds a tap gesture to a ``Circle`` that toggles the color
    /// of the circle based on the tap location.
    ///
    ///     struct TapGestureExample: View {
    ///         @State private var location: CGPoint = .zero
    ///
    ///         var body: some View {
    ///             Circle()
    ///                 .fill(self.location.y > 50 ? Color.blue : Color.red)
    ///                 .frame(width: 100, height: 100, alignment: .center)
    ///                 .onTapGesture { location in
    ///                     self.location = location
    ///                 }
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///    - count: The number of taps or clicks required to trigger the action
    ///      closure provided in `action`. Defaults to `1`.
    ///    - coordinateSpace: The coordinate space in which to receive
    ///      location values. Defaults to ``CoordinateSpace/local``.
    ///    - action: The action to perform. This closure receives an input
    ///      that indicates where the interaction occurred.
    @available(iOS, introduced: 16.0, deprecated: 100000.0, message: "use overload that accepts a CoordinateSpaceProtocol instead")
    @available(macOS, introduced: 13.0, deprecated: 100000.0, message: "use overload that accepts a CoordinateSpaceProtocol instead")
    @available(watchOS, introduced: 9.0, deprecated: 100000.0, message: "use overload that accepts a CoordinateSpaceProtocol instead")
    @available(tvOS, unavailable)
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "use overload that accepts a CoordinateSpaceProtocol instead")
    nonisolated public func onTapGesture(count: Int = 1, coordinateSpace: CoordinateSpace = .local, perform action: @escaping (CGPoint) -> Void) -> some View

}

extension View {

    /// Adds an action to perform when this view recognizes a tap gesture,
    /// and provides the action with the location of the interaction.
    ///
    /// Use this method to perform the specified `action` when the user clicks
    /// or taps on the modified view `count` times. The action closure receives
    /// the location of the interaction.
    ///
    /// > Note: If you create a control that's functionally equivalent
    /// to a ``Button``, use ``ButtonStyle`` to create a customized button
    /// instead.
    ///
    /// The following code adds a tap gesture to a ``Circle`` that toggles the color
    /// of the circle based on the tap location.
    ///
    ///     struct TapGestureExample: View {
    ///         @State private var location: CGPoint = .zero
    ///
    ///         var body: some View {
    ///             Circle()
    ///                 .fill(self.location.y > 50 ? Color.blue : Color.red)
    ///                 .frame(width: 100, height: 100, alignment: .center)
    ///                 .onTapGesture { location in
    ///                     self.location = location
    ///                 }
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///    - count: The number of taps or clicks required to trigger the action
    ///      closure provided in `action`. Defaults to `1`.
    ///    - coordinateSpace: The coordinate space in which to receive
    ///      location values. Defaults to ``CoordinateSpace/local``.
    ///    - action: The action to perform. This closure receives an input
    ///      that indicates where the interaction occurred.
    @available(iOS 17.0, macOS 14.0, watchOS 10.0, *)
    @available(tvOS, unavailable)
    nonisolated public func onTapGesture(count: Int = 1, coordinateSpace: some CoordinateSpaceProtocol = .local, perform action: @escaping (CGPoint) -> Void) -> some View

}

extension View {

    /// Sets a tag that you use for tracking interactivity.
    ///
    /// The following example tracks the scrolling activity of a ``List``:
    ///
    ///     List {
    ///         Section("Today") {
    ///             ForEach(messageStore.today) { message in
    ///                 Text(message.title)
    ///             }
    ///         }
    ///     }
    ///     .interactionActivityTrackingTag("MessagesList")
    ///
    /// The resolved activity tracking tag is additive, so using the
    /// modifier across the view hierarchy builds the tag from top to
    /// bottom. The example below shows a hierarchical usage of this
    /// modifier with the resulting tag `Home-Feed`:
    ///
    ///     var body: some View {
    ///         Home()
    ///             .interactionActivityTrackingTag("Home")
    ///     }
    ///
    ///     struct Home: View {
    ///         var body: some View {
    ///             List {
    ///                 Text("A List Item")
    ///                 Text("A Second List Item")
    ///                 Text("A Third List Item")
    ///             }
    ///             .interactionActivityTrackingTag("Feed")
    ///         }
    ///     }
    ///
    /// - Parameter tag: The tag used to track user interactions
    ///   hosted by this view as activities.
    ///
    /// - Returns: A view that uses a tracking tag.
    @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
    nonisolated public func interactionActivityTrackingTag(_ tag: String) -> some View

}

@available(iOS 16.4, macOS 13.3, tvOS 16.4, watchOS 9.4, *)
extension View {

    /// Sets the presentation background of the enclosing sheet using a shape
    /// style.
    ///
    /// The following example uses the ``Material/thick`` material as the sheet
    /// background:
    ///
    ///     struct ContentView: View {
    ///         @State private var showSettings = false
    ///
    ///         var body: some View {
    ///             Button("View Settings") {
    ///                 showSettings = true
    ///             }
    ///             .sheet(isPresented: $showSettings) {
    ///                 SettingsView()
    ///                     .presentationBackground(.thickMaterial)
    ///             }
    ///         }
    ///     }
    ///
    /// The `presentationBackground(_:)` modifier differs from the
    /// ``View/background(_:ignoresSafeAreaEdges:)`` modifier in several key
    /// ways. A presentation background:
    ///
    /// * Automatically fills the entire presentation.
    /// * Allows views behind the presentation to show through translucent
    ///   styles.
    ///
    /// - Parameter style: The shape style to use as the presentation
    ///   background.
    nonisolated public func presentationBackground<S>(_ style: S) -> some View where S : ShapeStyle


    /// Sets the presentation background of the enclosing sheet to a custom
    /// view.
    ///
    /// The following example uses a yellow view as the sheet background:
    ///
    ///     struct ContentView: View {
    ///         @State private var showSettings = false
    ///
    ///         var body: some View {
    ///             Button("View Settings") {
    ///                 showSettings = true
    ///             }
    ///             .sheet(isPresented: $showSettings) {
    ///                 SettingsView()
    ///                     .presentationBackground {
    ///                         Color.yellow
    ///                     }
    ///             }
    ///         }
    ///     }
    ///
    /// The `presentationBackground(alignment:content:)` modifier differs from
    /// the ``View/background(alignment:content:)`` modifier in several key
    /// ways. A presentation background:
    ///
    /// * Automatically fills the entire presentation.
    /// * Allows views behind the presentation to show through translucent
    ///   areas of the `content`.
    ///
    /// - Parameters:
    ///   - alignment: The alignment that the modifier uses to position the
    ///     implicit ``ZStack`` that groups the background views. The default is
    ///     ``Alignment/center``.
    ///   - content: The view to use as the background of the presentation.
    nonisolated public func presentationBackground<V>(alignment: Alignment = .center, @ViewBuilder content: () -> V) -> some View where V : View

}

extension View {

    /// Sets the rename action in the environment to update focus state.
    ///
    /// Use this modifier in conjunction with the ``RenameButton`` to implement
    /// standard rename interactions. A rename button receives its action
    /// from the environment. Use this modifier to customize the action
    /// provided to the rename button.
    ///
    ///     struct RowView: View {
    ///         @State private var text = ""
    ///         @FocusState private var isFocused: Bool
    ///
    ///         var body: some View {
    ///             TextField(text: $item.name) {
    ///                 Text("Prompt")
    ///             }
    ///             .focused($isFocused)
    ///             .contextMenu {
    ///                 RenameButton()
    ///                 // ... your own custom actions
    ///             }
    ///             .renameAction($isFocused)
    ///     }
    ///
    /// When someone taps the rename button in the context menu, the rename
    /// action focuses the text field by setting the `isFocused`
    /// property to true.
    ///
    /// - Parameter isFocused: The focus binding to update when
    ///   activating the rename action.
    ///
    /// - Returns: A view that has the specified rename action.
    @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
    nonisolated public func renameAction(_ isFocused: FocusState<Bool>.Binding) -> some View


    /// Sets a closure to run for the rename action.
    ///
    /// Use this modifier in conjunction with the ``RenameButton`` to implement
    /// standard rename interactions. A rename button receives its action
    /// from the environment. Use this modifier to customize the action
    /// provided to the rename button.
    ///
    ///     struct RowView: View {
    ///         @State private var text = ""
    ///         @FocusState private var isFocused: Bool
    ///
    ///         var body: some View {
    ///             TextField(text: $item.name) {
    ///                 Text("Prompt")
    ///             }
    ///             .focused($isFocused)
    ///             .contextMenu {
    ///                 RenameButton()
    ///                 // ... your own custom actions
    ///             }
    ///             .renameAction { isFocused = true }
    ///     }
    ///
    /// When the user taps the rename button in the context menu, the rename
    /// action focuses the text field by setting the `isFocused`
    /// property to true.
    ///
    /// - Parameter action: A closure to run when renaming.
    ///
    /// - Returns: A view that has the specified rename action.
    @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
    nonisolated public func renameAction(_ action: @escaping () -> Void) -> some View

}

extension EnvironmentValues {

    /// An action that activates the standard rename interaction.
    ///
    /// Use the ``View/renameAction(_:)`` modifier to configure the rename
    /// action in the environment.
    @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
    public var rename: RenameAction? { get }
}

@available(iOS 17.0, macOS 14.0, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
extension View {

    /// Specifies the prominence of badges created by this view.
    ///
    /// Badges can be used for different kinds of information, from the
    /// passive number of items in a container to the number of required
    /// actions. The prominence of badges in Lists can be adjusted to reflect
    /// this and be made to draw more or less attention to themselves.
    ///
    /// Badges will default to `standard` prominence unless specified.
    ///
    /// The following example shows a ``List`` displaying a list of folders
    /// with an informational badge with lower prominence, showing the number
    /// of items in the folder.
    ///
    ///     List(folders) { folder in
    ///         Text(folder.name)
    ///             .badge(folder.numberOfItems)
    ///     }
    ///     .badgeProminence(.decreased)
    ///
    /// - Parameter prominence: The prominence to apply to badges.
    @inlinable nonisolated public func badgeProminence(_ prominence: BadgeProminence) -> some View

}

@available(iOS 17.0, macOS 14.0, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
extension EnvironmentValues {

    /// The prominence to apply to badges associated with this environment.
    ///
    /// The default is ``BadgeProminence/standard``.
    public var badgeProminence: BadgeProminence
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension View {

    /// Adds an accessibility zoom action to the view. Actions allow
    /// assistive technologies, such as VoiceOver, to interact with the
    /// view by invoking the action.
    ///
    /// For example, this is how a zoom action is used to transform the scale
    /// of a shape which has a `MagnificationGesture`.
    ///
    ///     var body: some View {
    ///         Circle()
    ///             .scaleEffect(magnifyBy)
    ///             .gesture(magnification)
    ///             .accessibilityLabel("Circle Magnifier")
    ///             .accessibilityZoomAction { action in
    ///                 switch action.direction {
    ///                 case .zoomIn:
    ///                     magnifyBy += 0.5
    ///                 case .zoomOut:
    ///                      magnifyBy -= 0.5
    ///                 }
    ///             }
    ///     }
    ///
    nonisolated public func accessibilityZoomAction(_ handler: @escaping (AccessibilityZoomGestureAction) -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension ModifiedContent where Modifier == AccessibilityAttachmentModifier {

    /// Adds an accessibility zoom action to the view. Actions allow
    /// assistive technologies, such as VoiceOver, to interact with the
    /// view by invoking the action.
    ///
    /// For example, this is how a zoom action is used to transform the scale
    /// of a shape which has a `MagnificationGesture`.
    ///
    ///     var body: some View {
    ///         Circle()
    ///             .scaleEffect(magnifyBy)
    ///             .gesture(magnification)
    ///             .accessibilityLabel("Circle Magnifier")
    ///             .accessibilityZoomAction { action in
    ///                 switch action.direction {
    ///                 case .zoomIn:
    ///                     magnifyBy += 0.5
    ///                 case .zoomOut:
    ///                      magnifyBy -= 0.5
    ///                 }
    ///             }
    ///     }
    ///
    nonisolated public func accessibilityZoomAction(_ handler: @escaping (AccessibilityZoomGestureAction) -> Void) -> ModifiedContent<Content, Modifier>
}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension View {

    /// The activation point for an element is the location
    /// assistive technologies use to initiate gestures.
    ///
    /// Use this modifier to ensure that the activation point for a
    /// small element remains accurate even if you present a larger
    /// version of the element to VoiceOver.
    ///
    /// If an activation point is not provided, an activation point
    /// will be derived from one of the accessibility elements
    /// decedents or from the center of the accessibility frame.
    ///
    /// - Parameters:
    ///   - activationPoint: The accessibility activation point to apply.
    ///   - isEnabled: If true the accessibility activation point is applied;
    ///     otherwise the accessibility activation point is unchanged.
    nonisolated public func accessibilityActivationPoint(_ activationPoint: CGPoint, isEnabled: Bool) -> ModifiedContent<Self, AccessibilityAttachmentModifier>

    /// The activation point for an element is the location
    /// assistive technologies use to initiate gestures.
    ///
    /// Use this modifier to ensure that the activation point for a
    /// small element remains accurate even if you present a larger
    /// version of the element to VoiceOver.
    ///
    /// If an activation point is not provided, an activation point
    /// will be derived from one of the accessibility elements
    /// decedents or from the center of the accessibility frame.
    ///
    /// - Parameters:
    ///   - activationPoint: The accessibility activation point to apply.
    ///   - isEnabled: If true the accessibility activation point is applied;
    ///     otherwise the accessibility activation point is unchanged.
    nonisolated public func accessibilityActivationPoint(_ activationPoint: UnitPoint, isEnabled: Bool) -> ModifiedContent<Self, AccessibilityAttachmentModifier>
}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension ModifiedContent where Modifier == AccessibilityAttachmentModifier {

    /// The activation point for an element is the location
    /// assistive technologies use to initiate gestures.
    ///
    /// Use this modifier to ensure that the activation point for a
    /// small element remains accurate even if you present a larger
    /// version of the element to VoiceOver.
    ///
    /// If an activation point is not provided, an activation point
    /// will be derived from one of the accessibility elements
    /// decedents or from the center of the accessibility frame.
    ///
    /// - Parameters:
    ///   - activationPoint: The accessibility activation point to apply.
    ///   - isEnabled: If true the accessibility activation point is applied;
    ///     otherwise the accessibility activation point is unchanged.
    nonisolated public func accessibilityActivationPoint(_ activationPoint: CGPoint, isEnabled: Bool) -> ModifiedContent<Content, Modifier>

    /// The activation point for an element is the location
    /// assistive technologies use to initiate gestures.
    ///
    /// Use this modifier to ensure that the activation point for a
    /// small element remains accurate even if you present a larger
    /// version of the element to VoiceOver.
    ///
    /// If an activation point is not provided, an activation point
    /// will be derived from one of the accessibility elements
    /// decedents or from the center of the accessibility frame.
    ///
    /// - Parameters:
    ///   - activationPoint: The accessibility activation point to apply.
    ///   - isEnabled: If true the accessibility activation point is applied;
    ///     otherwise the accessibility activation point is unchanged.
    nonisolated public func accessibilityActivationPoint(_ activationPoint: UnitPoint, isEnabled: Bool) -> ModifiedContent<Content, Modifier>
}

@available(iOS 18.0, macOS 15.0, visionOS 2.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension View {

    /// The point an assistive technology should use to begin a drag interaction.
    ///
    /// Use this modifier when you need to provide a description to users
    /// when prompted begin a drag interaction.
    ///
    ///     struct FileView: View {
    ///         var filename: String
    ///
    ///         var body: some View {
    ///             FileIcon(filename: filename)
    ///                 .accessibilityDragPoint(
    ///                     .center, description: Text("Move \(filename)"))
    ///         }
    ///     }
    ///
    /// By default, if an accessible view or its subtree has drag and/or drop
    /// interactions, they will be automatically exposed by assistive
    /// technologies. However, if there is more than one such interaction, each
    /// drag or drop should have a description to disambiguate it and give a
    /// good user experience.
    ///
    /// - Note: An accessibility element can have multiple points
    ///         for a drag, provided they have different descriptions.
    ///
    /// - Parameters:
    ///   - point: The point the assitive technology will begin a drag
    ///     interaction.
    ///   - description: The description of the drag interaction.
    ///   - isEnabled: If true the accessibility drag point is applied;
    ///     otherwise the accessibility drag point is unchanged.
    nonisolated public func accessibilityDragPoint(_ point: UnitPoint, description: Text, isEnabled: Bool) -> ModifiedContent<Self, AccessibilityAttachmentModifier>

    /// The point an assistive technology should use to begin a drag interaction.
    ///
    /// Use this modifier when you need to provide a description to users
    /// when prompted begin a drag interaction.
    ///
    ///     struct FileView: View {
    ///         var filename: String
    ///
    ///         var body: some View {
    ///             FileIcon(filename: filename)
    ///                 .accessibilityDragPoint(
    ///                     .center, description: Text("Move \(filename)"))
    ///         }
    ///     }
    ///
    /// By default, if an accessible view or its subtree has drag and/or drop
    /// interactions, they will be automatically exposed by assistive
    /// technologies. However, if there is more than one such interaction, each
    /// drag or drop should have a description to disambiguate it and give a
    /// good user experience.
    ///
    /// - Note: An accessibility element can have multiple points
    ///         for a drag, provided they have different descriptions.
    ///
    /// - Parameters:
    ///   - point: The point the assitive technology will begin a drag
    ///     interaction.
    ///   - description: The description of the drag interaction.
    ///   - isEnabled: If true the accessibility drag point is applied;
    ///     otherwise the accessibility drag point is unchanged.
    nonisolated public func accessibilityDragPoint(_ point: UnitPoint, description: LocalizedStringKey, isEnabled: Bool) -> ModifiedContent<Self, AccessibilityAttachmentModifier>

    /// The point an assistive technology should use to begin a drag interaction.
    ///
    /// Use this modifier when you need to provide a description to users
    /// when prompted begin a drag interaction.
    ///
    ///     struct FileView: View {
    ///         var filename: String
    ///
    ///         var body: some View {
    ///             FileIcon(filename: filename)
    ///                 .accessibilityDragPoint(
    ///                     .center, description: Text("Move \(filename)"))
    ///         }
    ///     }
    ///
    /// By default, if an accessible view or its subtree has drag and/or drop
    /// interactions, they will be automatically exposed by assistive
    /// technologies. However, if there is more than one such interaction, each
    /// drag or drop should have a description to disambiguate it and give a
    /// good user experience.
    ///
    /// - Note: An accessibility element can have multiple points
    ///         for a drag, provided they have different descriptions.
    ///
    /// - Parameters:
    ///   - point: The point the assitive technology will begin a drag
    ///     interaction.
    ///   - description: The description of the drag interaction.
    ///   - isEnabled: If true the accessibility drag point is applied;
    ///     otherwise the accessibility drag point is unchanged.
    nonisolated public func accessibilityDragPoint<S>(_ point: UnitPoint, description: S, isEnabled: Bool) -> ModifiedContent<Self, AccessibilityAttachmentModifier> where S : StringProtocol

    /// The point an assistive technology should use to end a drag interaction.
    ///
    /// Use this modifier when you need to provide a description to users
    /// when prompted end a drag interaction.
    ///
    ///     struct FolderView: View {
    ///         var folderName: String
    ///
    ///         var body: some View {
    ///             FolderIcon(folderName: folderName)
    ///                 .accessibilityDropPoint(
    ///                     .center, description: Text("Move to \(folderName)"))
    ///         }
    ///     }
    ///
    /// By default, if an accessible view or its subtree has drag and/or drop
    /// interactions, they will be automatically exposed by assistive
    /// technologies. However, if there is more than one such interaction, each
    /// drag or drop should have a description to disambiguate it and give a
    /// good user experience.
    ///
    /// - Note: An accessibility element can have multiple points
    ///         for a drop, provided they have different descriptions.
    /// - Parameters:
    ///   - point: The point the assitive technology will perform a drop
    ///     interaction.
    ///   - description: The description of the drop interaction.
    ///   - isEnabled: If true the accessibility drop point is applied;
    ///     otherwise the accessibility drop point is unchanged.
    nonisolated public func accessibilityDropPoint(_ point: UnitPoint, description: Text, isEnabled: Bool) -> ModifiedContent<Self, AccessibilityAttachmentModifier>

    /// The point an assistive technology should use to end a drag interaction.
    ///
    /// Use this modifier when you need to provide a description to users
    /// when prompted end a drag interaction.
    ///
    ///     struct FolderView: View {
    ///         var folderName: String
    ///
    ///         var body: some View {
    ///             FolderIcon(folderName: folderName)
    ///                 .accessibilityDropPoint(
    ///                     .center, description: Text("Move to \(folderName)"))
    ///         }
    ///     }
    ///
    /// By default, if an accessible view or its subtree has drag and/or drop
    /// interactions, they will be automatically exposed by assistive
    /// technologies. However, if there is more than one such interaction, each
    /// drag or drop should have a description to disambiguate it and give a
    /// good user experience.
    ///
    /// - Note: An accessibility element can have multiple points
    ///         for a drop, provided they have different descriptions.
    /// - Parameters:
    ///   - point: The point the assitive technology will perform a drop
    ///     interaction.
    ///   - description: The description of the drop interaction.
    ///   - isEnabled: If true the accessibility drop point is applied;
    ///     otherwise the accessibility drop point is unchanged.
    nonisolated public func accessibilityDropPoint(_ point: UnitPoint, description: LocalizedStringKey, isEnabled: Bool) -> ModifiedContent<Self, AccessibilityAttachmentModifier>

    /// The point an assistive technology should use to end a drag interaction.
    ///
    /// Use this modifier when you need to provide a description to users
    /// when prompted end a drag interaction.
    ///
    ///     struct FolderView: View {
    ///         var folderName: String
    ///
    ///         var body: some View {
    ///             FolderIcon(folderName: folderName)
    ///                 .accessibilityDropPoint(
    ///                     .center, description: Text("Move to \(folderName)"))
    ///         }
    ///     }
    ///
    /// By default, if an accessible view or its subtree has drag and/or drop
    /// interactions, they will be automatically exposed by assistive
    /// technologies. However, if there is more than one such interaction, each
    /// drag or drop should have a description to disambiguate it and give a
    /// good user experience.
    ///
    /// - Note: An accessibility element can have multiple points
    ///         for a drop, provided they have different descriptions.
    /// - Parameters:
    ///   - point: The point the assitive technology will perform a drop
    ///     interaction.
    ///   - description: The description of the drop interaction.
    ///   - isEnabled: If true the accessibility drop point is applied;
    ///     otherwise the accessibility drop point is unchanged.
    nonisolated public func accessibilityDropPoint<S>(_ point: UnitPoint, description: S, isEnabled: Bool) -> ModifiedContent<Self, AccessibilityAttachmentModifier> where S : StringProtocol
}

@available(iOS 18.0, macOS 15.0, visionOS 2.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension ModifiedContent where Modifier == AccessibilityAttachmentModifier {

    /// The point an assistive technology should use to begin a drag interaction.
    ///
    /// Use this modifier when you need to provide a description to users
    /// when prompted begin a drag interaction.
    ///
    ///     struct FileView: View {
    ///         var filename: String
    ///
    ///         var body: some View {
    ///             FileIcon(filename: filename)
    ///                 .accessibilityDragPoint(
    ///                     .center, description: Text("Move \(filename)"))
    ///         }
    ///     }
    ///
    /// By default, if an accessible view or its subtree has drag and/or drop
    /// interactions, they will be automatically exposed by assistive
    /// technologies. However, if there is more than one such interaction, each
    /// drag or drop should have a description to disambiguate it and give a
    /// good user experience.
    ///
    /// - Note: An accessibility element can have multiple points
    ///         for a drag, provided they have different descriptions.
    ///
    /// - Parameters:
    ///   - point: The point the assitive technology will begin a drag
    ///     interaction.
    ///   - description: The description of the drag interaction.
    ///   - isEnabled: If true the accessibility drag point is applied;
    ///     otherwise the accessibility drag point is unchanged.
    nonisolated public func accessibilityDragPoint(_ point: UnitPoint, description: Text, isEnabled: Bool) -> ModifiedContent<Content, Modifier>

    /// The point an assistive technology should use to begin a drag interaction.
    ///
    /// Use this modifier when you need to provide a description to users
    /// when prompted begin a drag interaction.
    ///
    ///     struct FileView: View {
    ///         var filename: String
    ///
    ///         var body: some View {
    ///             FileIcon(filename: filename)
    ///                 .accessibilityDragPoint(
    ///                     .center, description: Text("Move \(filename)"))
    ///         }
    ///     }
    ///
    /// By default, if an accessible view or its subtree has drag and/or drop
    /// interactions, they will be automatically exposed by assistive
    /// technologies. However, if there is more than one such interaction, each
    /// drag or drop should have a description to disambiguate it and give a
    /// good user experience.
    ///
    /// - Note: An accessibility element can have multiple points
    ///         for a drag, provided they have different descriptions.
    ///
    /// - Parameters:
    ///   - point: The point the assitive technology will begin a drag
    ///     interaction.
    ///   - description: The description of the drag interaction.
    ///   - isEnabled: If true the accessibility drag point is applied;
    ///     otherwise the accessibility drag point is unchanged.
    nonisolated public func accessibilityDragPoint(_ point: UnitPoint, description: LocalizedStringKey, isEnabled: Bool) -> ModifiedContent<Content, Modifier>

    /// The point an assistive technology should use to begin a drag interaction.
    ///
    /// Use this modifier when you need to provide a description to users
    /// when prompted begin a drag interaction.
    ///
    ///     struct FileView: View {
    ///         var filename: String
    ///
    ///         var body: some View {
    ///             FileIcon(filename: filename)
    ///                 .accessibilityDragPoint(
    ///                     .center, description: Text("Move \(filename)"))
    ///         }
    ///     }
    ///
    /// By default, if an accessible view or its subtree has drag and/or drop
    /// interactions, they will be automatically exposed by assistive
    /// technologies. However, if there is more than one such interaction, each
    /// drag or drop should have a description to disambiguate it and give a
    /// good user experience.
    ///
    /// - Note: An accessibility element can have multiple points
    ///         for a drag, provided they have different descriptions.
    ///
    /// - Parameters:
    ///   - point: The point the assitive technology will begin a drag
    ///     interaction.
    ///   - description: The description of the drag interaction.
    ///   - isEnabled: If true the accessibility drag point is applied;
    ///     otherwise the accessibility drag point is unchanged.
    nonisolated public func accessibilityDragPoint<S>(_ point: UnitPoint, description: S, isEnabled: Bool) -> ModifiedContent<Content, Modifier> where S : StringProtocol

    /// The point an assistive technology should use to end a drag interaction.
    ///
    /// Use this modifier when you need to provide a description to users
    /// when prompted end a drag interaction.
    ///
    ///     struct FolderView: View {
    ///         var folderName: String
    ///
    ///         var body: some View {
    ///             FolderIcon(folderName: folderName)
    ///                 .accessibilityDropPoint(
    ///                     .center, description: Text("Move to \(folderName)"))
    ///         }
    ///     }
    ///
    /// By default, if an accessible view or its subtree has drag and/or drop
    /// interactions, they will be automatically exposed by assistive
    /// technologies. However, if there is more than one such interaction, each
    /// drag or drop should have a description to disambiguate it and give a
    /// good user experience.
    ///
    /// - Note: An accessibility element can have multiple points
    ///         for a drop, provided they have different descriptions.
    /// - Parameters:
    ///   - point: The point the assitive technology will perform a drop
    ///     interaction.
    ///   - description: The description of the drop interaction.
    ///   - isEnabled: If true the accessibility drop point is applied;
    ///     otherwise the accessibility drop point is unchanged.
    nonisolated public func accessibilityDropPoint(_ point: UnitPoint, description: Text, isEnabled: Bool) -> ModifiedContent<Content, Modifier>

    /// The point an assistive technology should use to end a drag interaction.
    ///
    /// Use this modifier when you need to provide a description to users
    /// when prompted end a drag interaction.
    ///
    ///     struct FolderView: View {
    ///         var folderName: String
    ///
    ///         var body: some View {
    ///             FolderIcon(folderName: folderName)
    ///                 .accessibilityDropPoint(
    ///                     .center, description: Text("Move to \(folderName)"))
    ///         }
    ///     }
    ///
    /// By default, if an accessible view or its subtree has drag and/or drop
    /// interactions, they will be automatically exposed by assistive
    /// technologies. However, if there is more than one such interaction, each
    /// drag or drop should have a description to disambiguate it and give a
    /// good user experience.
    ///
    /// - Note: An accessibility element can have multiple points
    ///         for a drop, provided they have different descriptions.
    /// - Parameters:
    ///   - point: The point the assitive technology will perform a drop
    ///     interaction.
    ///   - description: The description of the drop interaction.
    ///   - isEnabled: If true the accessibility drop point is applied;
    ///     otherwise the accessibility drop point is unchanged.
    nonisolated public func accessibilityDropPoint(_ point: UnitPoint, description: LocalizedStringKey, isEnabled: Bool) -> ModifiedContent<Content, Modifier>

    /// The point an assistive technology should use to end a drag interaction.
    ///
    /// Use this modifier when you need to provide a description to users
    /// when prompted end a drag interaction.
    ///
    ///     struct FolderView: View {
    ///         var folderName: String
    ///
    ///         var body: some View {
    ///             FolderIcon(folderName: folderName)
    ///                 .accessibilityDropPoint(
    ///                     .center, description: Text("Move to \(folderName)"))
    ///         }
    ///     }
    ///
    /// By default, if an accessible view or its subtree has drag and/or drop
    /// interactions, they will be automatically exposed by assistive
    /// technologies. However, if there is more than one such interaction, each
    /// drag or drop should have a description to disambiguate it and give a
    /// good user experience.
    ///
    /// - Note: An accessibility element can have multiple points
    ///         for a drop, provided they have different descriptions.
    /// - Parameters:
    ///   - point: The point the assitive technology will perform a drop
    ///     interaction.
    ///   - description: The description of the drop interaction.
    ///   - isEnabled: If true the accessibility drop point is applied;
    ///     otherwise the accessibility drop point is unchanged.
    nonisolated public func accessibilityDropPoint<S>(_ point: UnitPoint, description: S, isEnabled: Bool) -> ModifiedContent<Content, Modifier> where S : StringProtocol
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension View {

    /// The activation point for an element is the location
    /// assistive technologies use to initiate gestures.
    ///
    /// Use this modifier to ensure that the activation point for a
    /// small element remains accurate even if you present a larger
    /// version of the element to VoiceOver.
    ///
    /// If an activation point is not provided, an activation point
    /// will be derrived from one of the accessibility elements
    /// decendents or from the center of the accessibility frame.
    nonisolated public func accessibilityActivationPoint(_ activationPoint: CGPoint) -> ModifiedContent<Self, AccessibilityAttachmentModifier>

    /// The activation point for an element is the location
    /// assistive technologies use to initiate gestures.
    ///
    /// Use this modifier to ensure that the activation point for a
    /// small element remains accurate even if you present a larger
    /// version of the element to VoiceOver.
    ///
    /// If an activation point is not provided, an activation point
    /// will be derrived from one of the accessibility elements
    /// decendents or from the center of the accessibility frame.
    nonisolated public func accessibilityActivationPoint(_ activationPoint: UnitPoint) -> ModifiedContent<Self, AccessibilityAttachmentModifier>
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ModifiedContent where Modifier == AccessibilityAttachmentModifier {

    /// The activation point for an element is the location
    /// assistive technologies use to initiate gestures.
    ///
    /// Use this modifier to ensure that the activation point for a
    /// small element remains accurate even if you present a larger
    /// version of the element to VoiceOver.
    ///
    /// If an activation point is not provided, an activation point
    /// will be derrived from one of the accessibility elements
    /// decendents or from the center of the accessibility frame.
    nonisolated public func accessibilityActivationPoint(_ activationPoint: CGPoint) -> ModifiedContent<Content, Modifier>

    /// The activation point for an element is the location
    /// assistive technologies use to initiate gestures.
    ///
    /// Use this modifier to ensure that the activation point for a
    /// small element remains accurate even if you present a larger
    /// version of the element to VoiceOver.
    ///
    /// If an activation point is not provided, an activation point
    /// will be derrived from one of the accessibility elements
    /// decendents or from the center of the accessibility frame.
    nonisolated public func accessibilityActivationPoint(_ activationPoint: UnitPoint) -> ModifiedContent<Content, Modifier>
}

@available(iOS 16.0, macOS 13.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension View {

    /// The point an assistive technology should use to begin a drag interaction.
    ///
    /// Use this modifier when you need to provide a description to users
    /// when prompted begin a drag interaction.
    ///
    ///     struct FileView: View {
    ///         var filename: String
    ///
    ///         var body: some View {
    ///             FileIcon(filename: filename)
    ///                 .accessibilityDragPoint(.center, description: Text("Move \(filename)"))
    ///         }
    ///     }
    ///
    /// By default, if an accessible view or its subtree has drag and/or drop
    /// interactions, they will be automatically exposed by assistive technologies.
    /// However, if there is more than one such interaction, each drag or drop
    /// should have a description to disambiguate it and give a good user experience.
    ///
    /// - Note: An accessibility element can have multiple points
    ///         for a drag, provided they have different descriptions.
    nonisolated public func accessibilityDragPoint(_ point: UnitPoint, description: Text) -> ModifiedContent<Self, AccessibilityAttachmentModifier>

    /// The point an assistive technology should use to begin a drag interaction.
    ///
    /// Use this modifier when you need to provide a description to users
    /// when prompted begin a drag interaction.
    ///
    ///     struct FileView: View {
    ///         var filename: String
    ///
    ///         var body: some View {
    ///             FileIcon(filename: filename)
    ///                 .accessibilityDragPoint(.center, description: "Move \(filename)")
    ///         }
    ///     }
    ///
    /// By default, if an accessible view or its subtree has drag and/or drop
    /// interactions, they will be automatically exposed by assistive technologies.
    /// However, if there is more than one such interaction, each drag or drop
    /// should have a description to disambiguate it and give a good user experience.
    ///
    /// - Note: An accessibility element can have multiple points
    ///         for a drag, provided they have different descriptions.
    nonisolated public func accessibilityDragPoint(_ point: UnitPoint, description: LocalizedStringKey) -> ModifiedContent<Self, AccessibilityAttachmentModifier>

    /// The point an assistive technology should use to begin a drag interaction.
    ///
    /// Use this modifier when you need to provide a description to users
    /// when prompted begin a drag interaction.
    ///
    ///     struct FileView: View {
    ///         var filename: String
    ///
    ///         var body: some View {
    ///             FileIcon(filename: filename)
    ///                 .accessibilityDragPoint(.center, description: "Move \(filename)")
    ///         }
    ///     }
    ///
    /// By default, if an accessible view or its subtree has drag and/or drop
    /// interactions, they will be automatically exposed by assistive technologies.
    /// However, if there is more than one such interaction, each drag or drop
    /// should have a description to disambiguate it and give a good user experience.
    ///
    /// - Note: An accessibility element can have multiple points
    ///         for a drag, provided they have different descriptions.
    nonisolated public func accessibilityDragPoint<S>(_ point: UnitPoint, description: S) -> ModifiedContent<Self, AccessibilityAttachmentModifier> where S : StringProtocol

    /// The point an assistive technology should use to end a drag interaction.
    ///
    /// Use this modifier when you need to provide a description to users
    /// when prompted end a drag interaction.
    ///
    ///     struct FolderView: View {
    ///         var folderName: String
    ///
    ///         var body: some View {
    ///             FolderIcon(folderName: folderName)
    ///                 .accessibilityDropPoint(.center, description: Text("Move to \(folderName)"))
    ///         }
    ///     }
    ///
    /// By default, if an accessible view or its subtree has drag and/or drop
    /// interactions, they will be automatically exposed by assistive technologies.
    /// However, if there is more than one such interaction, each drag or drop
    /// should have a description to disambiguate it and give a good user experience.
    ///
    /// - Note: An accessibility element can have multiple points
    ///         for a drop, provided they have different descriptions.
    nonisolated public func accessibilityDropPoint(_ point: UnitPoint, description: Text) -> ModifiedContent<Self, AccessibilityAttachmentModifier>

    /// The point an assistive technology should use to end a drag interaction.
    ///
    /// Use this modifier when you need to provide a description to users
    /// when prompted end a drag interaction.
    ///
    ///     struct FolderView: View {
    ///         var folderName: String
    ///
    ///         var body: some View {
    ///             FolderIcon(folderName: folderName)
    ///                 .accessibilityDropPoint(.center, description: "Move to \(folderName)")
    ///         }
    ///     }
    ///
    /// By default, if an accessible view or its subtree has drag and/or drop
    /// interactions, they will be automatically exposed by assistive technologies.
    /// However, if there is more than one such interaction, each drag or drop
    /// should have a description to disambiguate it and give a good user experience.
    ///
    /// - Note: An accessibility element can have multiple points
    ///         for a drop, provided they have different descriptions.
    nonisolated public func accessibilityDropPoint(_ point: UnitPoint, description: LocalizedStringKey) -> ModifiedContent<Self, AccessibilityAttachmentModifier>

    /// The point an assistive technology should use to end a drag interaction.
    ///
    /// Use this modifier when you need to provide a description to users
    /// when prompted end a drag interaction.
    ///
    ///     struct FolderView: View {
    ///         var folderName: String
    ///
    ///         var body: some View {
    ///             FolderIcon(folderName: folderName)
    ///                 .accessibilityDropPoint(.center, description: "Move to \(folderName)")
    ///         }
    ///     }
    ///
    /// By default, if an accessible view or its subtree has drag and/or drop
    /// interactions, they will be automatically exposed by assistive technologies.
    /// However, if there is more than one such interaction, each drag or drop
    /// should have a description to disambiguate it and give a good user experience.
    ///
    /// - Note: An accessibility element can have multiple points
    ///         for a drop, provided they have different descriptions.
    nonisolated public func accessibilityDropPoint<S>(_ point: UnitPoint, description: S) -> ModifiedContent<Self, AccessibilityAttachmentModifier> where S : StringProtocol
}

@available(iOS 16.0, macOS 13.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension ModifiedContent where Modifier == AccessibilityAttachmentModifier {

    /// The point an assistive technology should use to begin a drag interaction.
    ///
    /// Use this modifier when you need to provide a description to users
    /// when prompted begin a drag interaction.
    ///
    ///     struct FileView: View {
    ///         var filename: String
    ///
    ///         var body: some View {
    ///             FileIcon(filename: filename)
    ///                 .accessibilityDragPoint(.center, description: Text("Move \(filename)"))
    ///         }
    ///     }
    ///
    /// By default, if an accessible view or its subtree has drag and/or drop
    /// interactions, they will be automatically exposed by assistive technologies.
    /// However, if there is more than one such interaction, each drag or drop
    /// should have a description to disambiguate it and give a good user experience.
    ///
    /// - Note: An accessibility element can have multiple points
    ///         for a drag, provided they have different descriptions.
    nonisolated public func accessibilityDragPoint(_ point: UnitPoint, description: Text) -> ModifiedContent<Content, Modifier>

    /// The point an assistive technology should use to begin a drag interaction.
    ///
    /// Use this modifier when you need to provide a description to users
    /// when prompted begin a drag interaction.
    ///
    ///     struct FileView: View {
    ///         var filename: String
    ///
    ///         var body: some View {
    ///             FileIcon(filename: filename)
    ///                 .accessibilityDragPoint(.center, description: "Move \(filename)")
    ///         }
    ///     }
    ///
    /// By default, if an accessible view or its subtree has drag and/or drop
    /// interactions, they will be automatically exposed by assistive technologies.
    /// However, if there is more than one such interaction, each drag or drop
    /// should have a description to disambiguate it and give a good user experience.
    ///
    /// - Note: An accessibility element can have multiple points
    ///         for a drag, provided they have different descriptions.
    nonisolated public func accessibilityDragPoint(_ point: UnitPoint, description: LocalizedStringKey) -> ModifiedContent<Content, Modifier>

    /// The point an assistive technology should use to begin a drag interaction.
    ///
    /// Use this modifier when you need to provide a description to users
    /// when prompted begin a drag interaction.
    ///
    ///     struct FileView: View {
    ///         var filename: String
    ///
    ///         var body: some View {
    ///             FileIcon(filename: filename)
    ///                 .accessibilityDragPoint(.center, description: "Move \(filename)")
    ///         }
    ///     }
    ///
    /// By default, if an accessible view or its subtree has drag and/or drop
    /// interactions, they will be automatically exposed by assistive technologies.
    /// However, if there is more than one such interaction, each drag or drop
    /// should have a description to disambiguate it and give a good user experience.
    ///
    /// - Note: An accessibility element can have multiple points
    ///         for a drag, provided they have different descriptions.
    nonisolated public func accessibilityDragPoint<S>(_ point: UnitPoint, description: S) -> ModifiedContent<Content, Modifier> where S : StringProtocol

    /// The point an assistive technology should use to end a drag interaction.
    ///
    /// Use this modifier when you need to provide a description to users
    /// when prompted end a drag interaction.
    ///
    ///     struct FolderView: View {
    ///         var folderName: String
    ///
    ///         var body: some View {
    ///             FolderIcon(folderName: folderName)
    ///                 .accessibilityDropPoint(.center, description: Text("Move to \(folderName)"))
    ///         }
    ///     }
    ///
    /// By default, if an accessible view or its subtree has drag and/or drop
    /// interactions, they will be automatically exposed by assistive technologies.
    /// However, if there is more than one such interaction, each drag or drop
    /// should have a description to disambiguate it and give a good user experience.
    ///
    /// - Note: An accessibility element can have multiple points
    ///         for a drop, provided they have different descriptions.
    nonisolated public func accessibilityDropPoint(_ point: UnitPoint, description: Text) -> ModifiedContent<Content, Modifier>

    /// The point an assistive technology should use to end a drag interaction.
    ///
    /// Use this modifier when you need to provide a description to users
    /// when prompted end a drag interaction.
    ///
    ///     struct FolderView: View {
    ///         var folderName: String
    ///
    ///         var body: some View {
    ///             FolderIcon(folderName: folderName)
    ///                 .accessibilityDropPoint(.center, description: "Move to \(folderName)")
    ///         }
    ///     }
    ///
    /// By default, if an accessible view or its subtree has drag and/or drop
    /// interactions, they will be automatically exposed by assistive technologies.
    /// However, if there is more than one such interaction, each drag or drop
    /// should have a description to disambiguate it and give a good user experience.
    ///
    /// - Note: An accessibility element can have multiple points
    ///         for a drop, provided they have different descriptions.
    nonisolated public func accessibilityDropPoint(_ point: UnitPoint, description: LocalizedStringKey) -> ModifiedContent<Content, Modifier>

    /// The point an assistive technology should use to end a drag interaction.
    ///
    /// Use this modifier when you need to provide a description to users
    /// when prompted end a drag interaction.
    ///
    ///     struct FolderView: View {
    ///         var folderName: String
    ///
    ///         var body: some View {
    ///             FolderIcon(folderName: folderName)
    ///                 .accessibilityDropPoint(.center, description: "Move to \(folderName)")
    ///         }
    ///     }
    ///
    /// By default, if an accessible view or its subtree has drag and/or drop
    /// interactions, they will be automatically exposed by assistive technologies.
    /// However, if there is more than one such interaction, each drag or drop
    /// should have a description to disambiguate it and give a good user experience.
    ///
    /// - Note: An accessibility element can have multiple points
    ///         for a drop, provided they have different descriptions.
    nonisolated public func accessibilityDropPoint<S>(_ point: UnitPoint, description: S) -> ModifiedContent<Content, Modifier> where S : StringProtocol
}

@available(iOS 18.0, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@available(visionOS, unavailable)
extension View {

    /// Specifies the default placement for the tabs in a tab view using the
    /// adaptable sidebar style.
    ///
    /// This modifier is only effective on iPadOS in the
    /// ``TabViewStyle/sidebarAdaptable`` style. In any other configuration,
    /// the system ignores it.
    ///
    /// The following example shows a ``TabView`` with three tabs, where
    /// the tab view displays the sidebar representation when the app
    /// initially launches.
    ///
    ///     TabView(selection: $selection) {
    ///         Tab("Home", systemImage: "house", value: MyTab.home) {
    ///             MyHomeView()
    ///         }
    ///
    ///         Tab("Downloads", systemImage: "square.and.arrow.down.fill",
    ///             value: MyTab.downloads
    ///         ) {
    ///             MyDownloadsView()
    ///         }
    ///
    ///         Tab("Browse", systemImage: "list.bullet", value: MyTab.browse) {
    ///             MyBrowseView()
    ///         }
    ///     }
    ///     .tabViewStyle(.sidebarAdaptable)
    ///     .defaultAdaptableTabBarPlacement(.sidebar)
    ///
    /// - Parameters:
    ///   - defaultPlacement: The default arrangement for the tab view.
    nonisolated public func defaultAdaptableTabBarPlacement(_ defaultPlacement: AdaptableTabBarPlacement = .automatic) -> some View

}

@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension View {

    /// Creates a new view that exposes the provided object to other views whose
    /// whose state depends on the focused view hierarchy.
    ///
    /// Use this method instead of ``View/focusedSceneObject(_:)`` when your
    /// scene includes multiple focusable views with their own associated data,
    /// and you need an app- or scene-scoped element like a command or toolbar
    /// item that operates on the data associated with whichever view currently
    /// has focus. Each focusable view can supply its own object:
    ///
    ///     struct MessageView: View {
    ///         @StateObject private var message = Message(...)
    ///
    ///         var body: some View {
    ///             TextField(...)
    ///                 .focusedObject(message)
    ///         }
    ///     }
    ///
    /// Interested views can then use the ``FocusedObject`` property wrapper to
    /// observe and update the focused view's object. In this example, an app
    /// command updates the focused view's data, and is automatically disabled
    /// when focus is in an unrelated part of the scene:
    ///
    ///     struct MessageCommands: Commands {
    ///         @FocusedObject private var message: Message?
    ///
    ///         var body: some Commands {
    ///             CommandGroup(after: .pasteboard) {
    ///                 Button("Add Duck to Message") {
    ///                     message?.text.append(" ")
    ///                 }
    ///                 .keyboardShortcut("d")
    ///                 .disabled(message == nil)
    ///             }
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - object: The observable object to associate with focus.
    /// - Returns: A view that supplies an observable object when in focus.
    @inlinable nonisolated public func focusedObject<T>(_ object: T) -> some View where T : ObservableObject


    /// Creates a new view that exposes the provided object to other views whose
    /// state depends on the focused view hierarchy.
    ///
    /// Use this method instead of ``View/focusedSceneObject(_:)`` when your
    /// scene includes multiple focusable views with their own associated data,
    /// and you need an app- or scene-scoped element like a command or toolbar
    /// item that operates on the data associated with whichever view currently
    /// has focus. Each focusable view can supply its own object:
    ///
    ///     struct MessageView: View {
    ///         @StateObject private var message = Message(...)
    ///
    ///         var body: some View {
    ///             TextField(...)
    ///                 .focusedObject(message)
    ///         }
    ///     }
    ///
    /// Interested views can then use the ``FocusedObject`` property wrapper to
    /// observe and update the focused view's object. In this example, an app
    /// command updates the focused view's data, and is automatically disabled
    /// when focus is in an unrelated part of the scene:
    ///
    ///     struct MessageCommands: Commands {
    ///         @FocusedObject private var message: Message?
    ///
    ///         var body: some Commands {
    ///             CommandGroup(after: .pasteboard) {
    ///                 Button("Add Duck to Message") {
    ///                     message?.text.append(" ")
    ///                 }
    ///                 .keyboardShortcut("d")
    ///                 .disabled(message == nil)
    ///             }
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - object: The observable object to associate with focus, or `nil` if
    ///     no object is currently available.
    /// - Returns: A view that supplies an observable object when in focus.
    @inlinable nonisolated public func focusedObject<T>(_ object: T?) -> some View where T : ObservableObject


    /// Creates a new view that exposes the provided object to other views whose
    /// whose state depends on the active scene.
    ///
    /// Use this method instead of ``View/focusedObject(_:)`` for observable
    /// objects that must be visible regardless of where focus is located in the
    /// active scene. This is sometimes needed for things like main menu and
    /// discoverability HUD commands that observe and update data from the
    /// active scene but aren't concerned with what the user is actually focused
    /// on. The scene's root view can supply the scene's state object:
    ///
    ///     struct RootView: View {
    ///         @StateObject private var sceneData = SceneData()
    ///
    ///         var body: some View {
    ///             NavigationSplitView {
    ///                 ...
    ///             }
    ///             .focusedSceneObject(sceneData)
    ///         }
    ///     }
    ///
    /// Interested views can then use the ``FocusedObject`` property wrapper to
    /// observe and update the active scene's state object. In this example, an
    /// app command updates the active scene's data, and is enabled as long as
    /// any scene is active.
    ///
    ///     struct MessageCommands: Commands {
    ///         @FocusedObject private var sceneData: SceneData?
    ///
    ///         var body: some Commands {
    ///             CommandGroup(after: .newItem) {
    ///                 Button("New Message") {
    ///                     sceneData?.addMessage()
    ///                 }
    ///                 .keyboardShortcut("n", modifiers: [.option, .command])
    ///                 .disabled(sceneData == nil)
    ///             }
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - object: The observable object to associate with the scene.
    /// - Returns: A view that supplies an observable object while the scene
    ///   is active.
    @inlinable nonisolated public func focusedSceneObject<T>(_ object: T) -> some View where T : ObservableObject


    /// Creates a new view that exposes the provided object to other views whose
    /// whose state depends on the active scene.
    ///
    /// Use this method instead of ``View/focusedObject(_:)`` for observable
    /// objects that must be visible regardless of where focus is located in the
    /// active scene. This is sometimes needed for things like main menu and
    /// discoverability HUD commands that observe and update data from the
    /// active scene but aren't concerned with what the user is actually focused
    /// on. The scene's root view can supply the scene's state object:
    ///
    ///     struct RootView: View {
    ///         @StateObject private var sceneData = SceneData()
    ///
    ///         var body: some View {
    ///             NavigationSplitView {
    ///                 ...
    ///             }
    ///             .focusedSceneObject(sceneData)
    ///         }
    ///     }
    ///
    /// Interested views can then use the ``FocusedObject`` property wrapper to
    /// observe and update the active scene's state object. In this example, an
    /// app command updates the active scene's data, and is enabled as long as
    /// any scene is active.
    ///
    ///     struct MessageCommands: Commands {
    ///         @FocusedObject private var sceneData: SceneData?
    ///
    ///         var body: some Commands {
    ///             CommandGroup(after: .newItem) {
    ///                 Button("New Message") {
    ///                     sceneData?.addMessage()
    ///                 }
    ///                 .keyboardShortcut("n", modifiers: [.option, .command])
    ///                 .disabled(sceneData == nil)
    ///             }
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - object: The observable object to associate with the scene, or `nil`
    ///     if no object is currently available.
    /// - Returns: A view that supplies an observable object while the scene
    ///   is active.
    @inlinable nonisolated public func focusedSceneObject<T>(_ object: T?) -> some View where T : ObservableObject

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Anchor.Source where Value == CGRect {

    /// Returns an anchor source rect defined by `r` in the current view.
    public static func rect(_ r: CGRect) -> Anchor<Value>.Source

    /// An anchor source rect defined as the entire bounding rect of the current
    /// view.
    public static var bounds: Anchor<CGRect>.Source { get }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// Adds an accessibility action to the view. Actions allow assistive technologies,
    /// such as the VoiceOver, to interact with the view by invoking the action.
    ///
    /// For example, this is how a `.default` action to compose
    /// a new email could be added to a view.
    ///
    ///     var body: some View {
    ///         ContentView()
    ///             .accessibilityAction {
    ///                 // Handle action
    ///             }
    ///     }
    ///
    nonisolated public func accessibilityAction(_ actionKind: AccessibilityActionKind = .default, _ handler: @escaping () -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>

    /// Adds an accessibility action to the view. Actions allow assistive technologies,
    /// such as the VoiceOver, to interact with the view by invoking the action.
    ///
    /// For example, this is how a custom action to compose
    /// a new email could be added to a view.
    ///
    ///     var body: some View {
    ///         ContentView()
    ///             .accessibilityAction(named: Text("New Message")) {
    ///                 // Handle action
    ///             }
    ///     }
    ///
    nonisolated public func accessibilityAction(named name: Text, _ handler: @escaping () -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension ModifiedContent where Modifier == AccessibilityAttachmentModifier {

    /// Adds an accessibility action to the view. Actions allow assistive technologies,
    /// such as the VoiceOver, to interact with the view by invoking the action.
    ///
    /// For example, this is how a `.default` action to compose
    /// a new email could be added to a view.
    ///
    ///     var body: some View {
    ///         ContentView()
    ///             .accessibilityAction {
    ///                 // Handle action
    ///             }
    ///     }
    ///
    nonisolated public func accessibilityAction(_ actionKind: AccessibilityActionKind = .default, _ handler: @escaping () -> Void) -> ModifiedContent<Content, Modifier>

    /// Adds an accessibility action to the view. Actions allow assistive technologies,
    /// such as the VoiceOver, to interact with the view by invoking the action.
    ///
    /// For example, this is how a custom action to compose
    /// a new email could be added to a view.
    ///
    ///     var body: some View {
    ///         ContentView()
    ///             .accessibilityAction(named: Text("New Message")) {
    ///                 // Handle action
    ///             }
    ///     }
    ///
    nonisolated public func accessibilityAction(named name: Text, _ handler: @escaping () -> Void) -> ModifiedContent<Content, Modifier>
}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension View {

    /// Adds an accessibility action to the view. Actions allow assistive technologies,
    /// such as the VoiceOver, to interact with the view by invoking the action.
    ///
    /// For example, this is how a custom action to compose
    /// a new email could be added to a view.
    ///
    ///     var body: some View {
    ///         ContentView()
    ///             .accessibilityAction {
    ///                 // Handle action
    ///             } label: {
    ///                 Label("New Message", systemImage: "plus")
    ///             }
    ///     }
    ///
    nonisolated public func accessibilityAction<Label>(action: @escaping () -> Void, @ViewBuilder label: () -> Label) -> some View where Label : View

}

@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension View {

    /// Adds multiple accessibility actions to the view.
    ///
    /// Actions allow assistive technologies,
    /// such as the VoiceOver, to interact with the view by invoking the action.
    /// For example, this is how a dynamic number of custom action could
    /// be added to a view.
    ///
    ///     var isDraft: Bool
    ///
    ///     var body: some View {
    ///         ContentView()
    ///             .accessibilityActions {
    ///                 ForEach(actions) { action in
    ///                     Button {
    ///                         action()
    ///                     } label: {
    ///                         Text(action.title)
    ///                     }
    ///                 }
    ///
    ///                 if isDraft {
    ///                     Button {
    ///                         // Handle Delete
    ///                     } label: {
    ///                         Text("Delete")
    ///                     }
    ///                 }
    ///             }
    ///
    nonisolated public func accessibilityActions<Content>(@ViewBuilder _ content: () -> Content) -> some View where Content : View

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension View {

    /// Adds an accessibility action to the view. Actions allow assistive technologies,
    /// such as the VoiceOver, to interact with the view by invoking the action.
    ///
    /// For example, this is how a custom action to compose
    /// a new email could be added to a view.
    ///
    ///     var body: some View {
    ///         ContentView()
    ///             .accessibilityAction(named: "New Message") {
    ///                 // Handle action
    ///             }
    ///     }
    ///
    nonisolated public func accessibilityAction(named nameKey: LocalizedStringKey, _ handler: @escaping () -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier>

    /// Adds an accessibility action to the view. Actions allow assistive technologies,
    /// such as the VoiceOver, to interact with the view by invoking the action.
    ///
    /// For example, this is how a custom action to compose
    /// a new email could be added to a view.
    ///
    ///     var body: some View {
    ///         ContentView()
    ///             .accessibilityAction(named: "New Message") {
    ///                 // Handle action
    ///             }
    ///     }
    ///
    nonisolated public func accessibilityAction<S>(named name: S, _ handler: @escaping () -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier> where S : StringProtocol
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ModifiedContent where Modifier == AccessibilityAttachmentModifier {

    /// Adds an accessibility action to the view. Actions allow assistive technologies,
    /// such as the VoiceOver, to interact with the view by invoking the action.
    ///
    /// For example, this is how a custom action to compose
    /// a new email could be added to a view.
    ///
    ///     var body: some View {
    ///         ContentView()
    ///             .accessibilityAction(named: "New Message") {
    ///                 // Handle action
    ///             }
    ///     }
    ///
    nonisolated public func accessibilityAction(named nameKey: LocalizedStringKey, _ handler: @escaping () -> Void) -> ModifiedContent<Content, Modifier>

    /// Adds an accessibility action to the view. Actions allow assistive technologies,
    /// such as the VoiceOver, to interact with the view by invoking the action.
    ///
    /// For example, this is how a custom action to compose
    /// a new email could be added to a view.
    ///
    ///     var body: some View {
    ///         ContentView()
    ///             .accessibilityAction(named: "New Message") {
    ///                 // Handle action
    ///             }
    ///     }
    ///
    nonisolated public func accessibilityAction<S>(named name: S, _ handler: @escaping () -> Void) -> ModifiedContent<Content, Modifier> where S : StringProtocol
}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Group {

    /// Constructs a group from the sections of the given view.
    ///
    /// Sections are constructed lazily, on demand, so access only as much
    /// of this collection as is necessary to create the resulting content.
    ///
    ///     struct SectionedStack<Content: View>: View {
    ///         var content: Content
    ///
    ///         init(@ViewBuilder content: () -> Content) {
    ///             self.content = content()
    ///         }
    ///
    ///         var body: some View {
    ///             VStack {
    ///                 Group(sections: content) { sections in
    ///                     ForEach(sections) { section in
    ///                         SectionChrome {
    ///                             section.content
    ///                         } header: {
    ///                             section.header
    ///                         } footer: {
    ///                             section.footer
    ///                         }
    ///                     }
    ///                 }
    ///             }
    ///         }
    ///     }
    ///
    /// This can then be used by creating a `SectionedStack` with it's
    /// view builder-based initializer.
    ///
    ///     SectionedStack {
    ///         Section("Header A") {
    ///             Text("Hello")
    ///             Text("World")
    ///         } footer: {
    ///             Text("Footer A")
    ///         }
    ///         Section("Header B") {
    ///             Text("Foo")
    ///             Text("Bar")
    ///         } footer: {
    ///             Text("Footer B")
    ///         }
    ///     }
    ///
    /// Any content of the given view which is not explicitly specified as a
    /// section is grouped with its sibling content to form implicit sections,
    /// meaning the minimum number of sections in a `SectionCollection` is one.
    /// For example in the following `SectionedStack`, there is one explicit
    /// section, and two implicit sections containing the content before,
    /// and after the explicit section:
    ///
    ///     SectionedStack {
    ///         Text("First implicit section")
    ///         Section("Explicit section") {
    ///             Text("Content")
    ///         }
    ///         Text("Second implicit section")
    ///     }
    ///
    /// - Parameters:
    ///   - view: The view to extract the sections of.
    ///   - content: A closure that constructs a view from the collection of
    ///     sections.
    public init<Base, Result>(sections view: Base, @ViewBuilder transform: @escaping (SectionCollection) -> Result) where Content == GroupSectionsOfContent<Base, Result>, Base : View, Result : View
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension View {

    /// Adds help text to a view using a localized string that you provide.
    ///
    /// Adding help to a view configures the view's accessibility hint and
    /// its help tag (also called a _tooltip_) in macOS or visionOS.
    /// For more information on using help tags, see
    /// <doc://com.apple.documentation/design/human-interface-guidelines/offering-help>
    /// in the Human Interface Guidelines.
    ///
    ///     Button(action: composeMessage) {
    ///         Image(systemName: "square.and.pencil")
    ///     }
    ///     .help("Compose a new message")
    ///
    /// - Parameter textKey: The key for the localized text to use as help.
    nonisolated public func help(_ textKey: LocalizedStringKey) -> some View


    /// Adds help text to a view using a text view that you provide.
    ///
    /// Adding help to a view configures the view's accessibility hint and
    /// its help tag (also called a _tooltip_) in macOS or visionOS.
    /// For more information on using help tags, see
    /// <doc://com.apple.documentation/design/human-interface-guidelines/offering-help>
    /// in the Human Interface Guidelines.
    ///
    ///     Slider("Opacity", value: $selectedShape.opacity)
    ///         .help(Text("Adjust the opacity of the selected \(selectedShape.name)"))
    ///
    /// - Parameter text: The ``Text`` view to use as help.
    nonisolated public func help(_ text: Text) -> some View


    /// Adds help text to a view using a string that you provide.
    ///
    /// Adding help to a view configures the view's accessibility hint and
    /// its help tag (also called a _tooltip_) in macOS or visionOS.
    /// For more information on using help tags, see
    /// <doc://com.apple.documentation/design/human-interface-guidelines/offering-help>
    /// in the Human Interface Guidelines.
    ///
    ///     Image(systemName: "pin.circle")
    ///         .foregroundColor(pointOfInterest.tintColor)
    ///         .help(pointOfInterest.name)
    ///
    /// - Parameter text: The text to use as help.
    nonisolated public func help<S>(_ text: S) -> some View where S : StringProtocol

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// Places a custom background view behind a list row item.
    ///
    /// Use `listRowBackground(_:)` to place a custom background view behind a
    /// list row item.
    ///
    /// In the example below, the `Flavor` enumeration provides content for list
    /// items. The SwiftUI ``ForEach`` structure computes views for each element
    /// of the `Flavor` enumeration and extracts the raw value of each of its
    /// elements using the resulting text to create each list row item. The
    /// `listRowBackground(_:)` modifier then places the view you supply behind
    /// each of the list row items:
    ///
    ///     struct ContentView: View {
    ///         enum Flavor: String, CaseIterable, Identifiable {
    ///             var id: String { self.rawValue }
    ///             case vanilla, chocolate, strawberry
    ///         }
    ///
    ///         var body: some View {
    ///             List {
    ///                 ForEach(Flavor.allCases) {
    ///                     Text($0.rawValue)
    ///                         .listRowBackground(Ellipse()
    ///                                             .background(Color.clear)
    ///                                             .foregroundColor(.purple)
    ///                                             .opacity(0.3)
    ///                         )
    ///                 }
    ///             }
    ///         }
    ///     }
    ///
    /// ![A screenshot showing the placement of an image as the background to
    ///   each row in a list.](SwiftUI-View-listRowBackground.png)
    ///
    /// - Parameter view: The ``View`` to use as the background behind the list
    ///   row view.
    ///
    /// - Returns: A list row view with `view` as its background view.
    @inlinable nonisolated public func listRowBackground<V>(_ view: V?) -> some View where V : View

}

@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension AppearsActiveKey : UITraitBridgedEnvironmentKey {
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension View {

    /// Sets the style for labels within this view.
    ///
    /// Use this modifier to set a specific style for all labels within a view:
    ///
    ///     VStack {
    ///         Label("Fire", systemImage: "flame.fill")
    ///         Label("Lightning", systemImage: "bolt.fill")
    ///     }
    ///     .labelStyle(MyCustomLabelStyle())
    ///
    nonisolated public func labelStyle<S>(_ style: S) -> some View where S : LabelStyle

}

@available(iOS 13.4, macOS 10.15, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension View {

    /// Activates this view as the source of a drag and drop operation.
    ///
    /// Applying the `onDrag(_:)` modifier adds the appropriate gestures for
    /// drag and drop to this view. When a drag operation begins, a rendering of
    /// this view is generated and used as the preview image.
    ///
    /// To customize the default preview, apply a
    /// ``View/contentShape(_:_:eoFill:)`` with a
    /// ``ContentShapeKinds/dragPreview`` kind. For example, you can change the
    /// preview's corner radius or use a nested view as the preview.
    ///
    /// If you want to show a different preview, you can use
    /// ``View/onDrag(_:preview:)``.
    ///
    /// - Parameter data: A closure that returns a single
    /// <doc://com.apple.documentation/documentation/Foundation/NSItemProvider> that
    /// represents the draggable data from this view.
    ///
    /// - Returns: A view that activates this view as the source of a drag and
    ///   drop operation, beginning with user gesture input.
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    nonisolated public func onDrag(_ data: @escaping () -> NSItemProvider) -> some View

}

@available(iOS 15.0, macOS 12.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension View {

    /// Activates this view as the source of a drag and drop operation.
    ///
    /// Applying the `onDrag(_:preview:)` modifier adds the appropriate gestures
    /// for drag and drop to this view. When a drag operation begins,
    /// a rendering of `preview` is generated and used as the preview image.
    ///
    /// To customize the lift preview, shown while the system transitions
    /// to show your custom `preview`, apply a ``View/contentShape(_:_:eoFill:)``
    /// with a ``ContentShapeKinds/dragPreview`` kind. For example, you can
    /// change the preview's corner radius or use a nested view as the preview.
    ///
    /// - Parameter data: A closure that returns a single
    /// <doc://com.apple.documentation/documentation/Foundation/NSItemProvider>
    /// that represents the draggable data from this view.
    /// - Parameter preview: A ``View`` to use as the source for the dragging
    ///   preview, once the drag operation has begun. The preview is centered over
    ///   the source view.
    ///
    /// - Returns: A view that activates this view as the source of a drag-and-
    ///   drop operation, beginning with user gesture input.
    nonisolated public func onDrag<V>(_ data: @escaping () -> NSItemProvider, @ViewBuilder preview: () -> V) -> some View where V : View

}

@available(iOS 16.0, macOS 13.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension View {

    /// Activates this view as the source of a drag and drop operation.
    ///
    /// Applying the `draggable(_:)` modifier adds the appropriate gestures for
    /// drag and drop to this view. When a drag operation begins, a rendering of
    /// this view is generated and used as the preview image.
    ///
    /// To customize the default preview, apply a
    /// ``View/contentShape(_:_:eoFill:)`` with a
    /// ``ContentShapeKinds/dragPreview`` kind. For example, you can change the
    /// preview's corner radius or use a nested view as the preview.
    ///
    /// - Parameter payload: A closure that returns a single
    /// instance or a value conforming to <doc://com.apple.documentation/documentation/coretransferable/transferable> that
    /// represents the draggable data from this view.
    ///
    /// - Returns: A view that activates this view as the source of a drag and
    ///   drop operation, beginning with user gesture input.
    nonisolated public func draggable<T>(_ payload: @autoclosure @escaping () -> T) -> some View where T : Transferable


    /// Activates this view as the source of a drag and drop operation.
    ///
    /// Applying the `draggable(_:preview:)` modifier adds the appropriate gestures
    /// for drag and drop to this view. When a drag operation begins,
    /// a rendering of `preview` is generated and used as the preview image.
    ///
    ///     var title: String
    ///     var body: some View {
    ///         Color.pink
    ///             .frame(width: 400, height: 400)
    ///             .draggable(title) {
    ///                  Text("Drop me")
    ///              }
    ///     }
    ///
    /// To customize the lift preview, shown while the system transitions
    /// to show your custom `preview`, apply a ``View/contentShape(_:_:eoFill:)``
    /// with a ``ContentShapeKinds/dragPreview`` kind. For example, you can
    /// change the preview's corner radius or use a nested view as the preview.
    ///
    /// - Parameter payload: A closure that returns a single
    /// class instance or a value conforming to `Transferable` that
    /// represents the draggable data from this view.
    /// - Parameter preview: A ``View`` to use as the source for the dragging
    /// preview, once the drag operation has begun. The preview is centered over
    /// the source view.
    ///
    /// - Returns: A view that activates this view as the source of a drag and
    ///   drop operation, beginning with user gesture input.
    nonisolated public func draggable<V, T>(_ payload: @autoclosure @escaping () -> T, @ViewBuilder preview: () -> V) -> some View where V : View, T : Transferable

}

@available(iOS 13.0, macOS 10.15, watchOS 10.0, *)
@available(tvOS, unavailable)
extension View {

    /// Sets the style for date pickers within this view.
    nonisolated public func datePickerStyle<S>(_ style: S) -> some View where S : DatePickerStyle

}

@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension Never : Commands {
}

